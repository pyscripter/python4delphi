<?xml version="1.0" encoding="UTF-8"?>
<docs>
  <class unit="FMX.ListBox" name="TListBoxItem">
    <docstr>A TListBoxItem is an item that is used in list box components.
The items in list boxes and combo boxes are of type TListBoxItem. To add an item to a list box or combo box, double-click the component or right-click the component and choose Add Item.</docstr>
    <members>
      <procedure name="ChangeOrder">
        <docstr>Notification method called after the creation order is changed.
FMX.ListBox.TListBoxItem.ChangeOrder inherits from FMX.Types.TFmxObject.ChangeOrder. All content below this line refers to FMX.Types.TFmxObject.ChangeOrder.
Notification method called after the creation order is changed. ChangeOrder is a virtual method to be implemented in subclasses to allow for changing the creation order of this FMX object.</docstr>
      </procedure>
      <function name="ListBox">
        <docstr>Returns the list box object that contains the item.
ListBox gets the list box parent of the item. If the parent of the item is not a TListBox, the method returns nil.</docstr>
      </function>
      <function name="ComboBox">
        <docstr>Returns the combo box object that contains the item.
ComboBox gets the combo box parent of the item. If the parent of the item is not a TComboBox, the method returns nil.</docstr>
      </function>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.ListBox.TListBoxItem.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.ListBox.TListBoxItem.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.ListBox.TListBoxItem.FreeStyle inherits from FMX.Controls.TTextControl.FreeStyle. All content below this line refers to FMX.Controls.TTextControl.FreeStyle.
Frees the style of TStyledControl.
FreeStyle frees some TTextControl-specific style resources like TextObject and TextSettings, then calls the inherited TStyledControl.FreeStyle.</docstr>
      </procedure>
      <function name="EnterChildren">
        <docstr>Checks whether the input is taken by the control or by its parent.
FMX.ListBox.TListBoxItem.EnterChildren inherits from FMX.Controls.TControl.EnterChildren. All content below this line refers to FMX.Controls.TControl.EnterChildren.
Checks whether the input is taken by the control or by its parent.
EnterChildren returns True if the input is taken directly by the control&apos;s parent, and False otherwise. 
Usually, EnterChildren returns False. If the control is an item such as TListBoxItem, a TTreeViewItem, or TMenuItem, EnterChildren returns True.</docstr>
      </function>
      <procedure name="DragOver">
        <docstr>OnDragOver event dispatcher. 
FMX.ListBox.TListBoxItem.DragOver inherits from FMX.Controls.TControl.DragOver. All content below this line refers to FMX.Controls.TControl.DragOver.
OnDragOver event dispatcher. 
Data specifies the dragged object.
Point specifies the current point of the  mouse cursor within the client area of the control.
Operation is the operation parameter (None, Move, Copy, Link) that specifies the action to perform when an item is dragged over the object.  

None is the default. No action takes place, it does not display any name.
Move - the word Move is displayed once an item is dragged over the object.
Copy - the word Copy is displayed once an item is dragged over the object.
Link - the word Link is displayed once an item is dragged over the object.
A control calls DragOver when a dragged object is over the control area.
Override the protected DragOver method to provide other responses when a dragged object is over the control area.</docstr>
      </procedure>
      <procedure name="DragEnd">
        <docstr>OnDragEnd event dispatcher. 
FMX.ListBox.TListBoxItem.DragEnd inherits from FMX.Controls.TControl.DragEnd. All content below this line refers to FMX.Controls.TControl.DragEnd.
OnDragEnd event dispatcher. 
A control calls DragEnd when a dragging session ends.
Override the protected DragEnd method to provide other responses when the dragging session ends.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.ListBox.TListBoxItem.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <function name="GetHeight">
        <docstr>Getter function for the Height property.
FMX.ListBox.TListBoxItem.GetHeight inherits from FMX.Controls.TControl.GetHeight. All content below this line refers to FMX.Controls.TControl.GetHeight.
Getter function for the Height property.</docstr>
      </function>
      <function name="GetWidth">
        <docstr>Getter function for the Width property.
FMX.ListBox.TListBoxItem.GetWidth inherits from FMX.Controls.TControl.GetWidth. All content below this line refers to FMX.Controls.TControl.GetWidth.
Getter function for the Width property.</docstr>
      </function>
      <procedure name="SetHeight">
        <docstr>Setter function for the Height property.
FMX.ListBox.TListBoxItem.SetHeight inherits from FMX.Controls.TControl.SetHeight. All content below this line refers to FMX.Controls.TControl.SetHeight.
Setter function for the Height property. Value specifies the new value of the Height property.</docstr>
      </procedure>
      <function name="DoSetSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SelectBackground">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnBitmapChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="StyledSettingsStored">
        <docstr>Retrieves whether any of the default values of font properties that are stored in the StyledSettings property is changed.
FMX.ListBox.TListBoxItem.StyledSettingsStored inherits from FMX.Controls.TTextControl.StyledSettingsStored. All content below this line refers to FMX.Controls.TTextControl.StyledSettingsStored.
Retrieves whether any of the default values of font properties that are stored in the StyledSettings property is changed.
StyledSettingsStored retrieves whether StyledSettings needs to be stored in the .fmx form file, keeping the description of the FMX form.
StyledSettingsStored returns True if StyledSettings &lt;&gt; DefaultStyledSettings. The DefaultStyledSettings property is set during the style loading in the ApplyStyle method. See also AllStyledSettings.</docstr>
      </function>
      <property name="Align">
        <docstr>Specifies the alignment options (top, left, client, and so on) of this control. 
Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale.</docstr>
      </property>
      <property name="RotationAngle">
        <docstr>Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
To set the rotation center, use RotationCenter.</docstr>
      </property>
      <property name="RotationCenter">
        <docstr>Specifies the position of the pivot point of the control.
The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
To set the rotation angle, use RotationAngle.</docstr>
      </property>
      <function name="GetTextSettingsClass">
        <docstr>Returns the class type that instance represents the used text settings.
FMX.ListBox.TListBoxItem.GetTextSettingsClass inherits from FMX.Controls.TTextControl.GetTextSettingsClass. All content below this line refers to FMX.Controls.TTextControl.GetTextSettingsClass.
Returns the class type that instance represents the used text settings.
GetTextSettingsClass returns the TTextSettingsInfo.TCustomTextSettingsClass (or its descendant)  class reference. An instance of such class provides the DefaultTextSettings,   TextSettings, StyledSettings, ResultingTextSettings, and other properties handling the text representation settings of a control. 
You can override the method in descendant classes to modify the default behavior.
Typical implementations of GetTextSettingsClass returns the class declaring properties like the Font, FontColor, HorzAlign, and WordWrap. Some of these properties can be declared as published to be editable in the Object Inspector.

 See Also
FMX.Controls.TTextSettingsInfo
FMX.Controls.TTextSettingsInfo.TCustomTextSettingsClass
FMX.Controls.TTextSettingsInfo.DefaultTextSettings
FMX.Controls.TTextSettingsInfo.TextSettings
FMX.Controls.TTextSettingsInfo.StyledSettings
FMX.Controls.TTextSettingsInfo.ResultingTextSettings</docstr>
      </function>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.ListBox.TListBoxItem.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <function name="DoGetDefaultStyleLookupName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ImagesChanged">
        <docstr>Should be called when the component needs to redraw the image.
ImagesChanged should be called
when you change the Images reference to the TCustomImageList object or 
the object itself or when you change the ImageIndex property.</docstr>
      </procedure>
      <function name="ImageIndexStored">
        <docstr>Returns True when the ImageIndex property needs to be stored in the fmx-file.</docstr>
      </function>
      <procedure name="SetVisible">
        <docstr>Setter for the Visible property.
This method also unselects any items that are not visible.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.ListBox.TListBoxItem.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.ListBox.TListBoxItem.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="Data">
        <docstr>Stores a Tvalue, which is a data structure that can store different kinds of data types.
FMX.ListBox.TListBoxItem.Data inherits from FMX.Types.TFmxObject.Data. All content below this line refers to FMX.Types.TFmxObject.Data.
Stores a Tvalue, which is a data structure that can store different kinds of data types.
Data has no predefined meaning. Although Data is used for LiveBinding, any succesor override this behavior. Then, the behaviour of Data is based on the type of its value.

Note: Do not use this member. It is for internal use only.</docstr>
      </property>
      <function name="GetParentComponent">
        <docstr>Returns the containing component.
Returns the containing component.
FMX.ListBox.TListBoxItem.GetParentComponent inherits from System.Classes.TComponent.GetParentComponent. All content below this line refers to System.Classes.TComponent.GetParentComponent.
Returns the containing component.
GetParentComponent returns a reference to the component that contains the current component, or nil if there is no container. Use HasParent to determine whether a component has a containing component. 
For example, a button on a panel on a form returns the panel, the panel returns the form, and the form returns nil.</docstr>
      </function>
      <procedure name="ApplyTriggerEffect">
        <docstr>Applies the specified mouse trigger effect to all the children of this FMX object that are of type TEffect.
FMX.ListBox.TListBoxItem.ApplyTriggerEffect inherits from FMX.Controls.TControl.ApplyTriggerEffect. All content below this line refers to FMX.Controls.TControl.ApplyTriggerEffect.
Applies the specified mouse trigger effect to all the children of this FMX object that are of type TEffect.
ApplyTriggerEffect iterates through all the children of this FMX object and, if one of them is of type TEffect, applies the mouse trigger given through the ATrigger parameter (which can be &apos;IsMouseOver&apos;, &apos;IsMouseOver&apos;, &apos;IsDragOver&apos;, and so on).
AInstance specifies the instance of the FMX object to which the trigger effect is applied.</docstr>
      </procedure>
      <procedure name="SetIsSelectedInternal">
        <docstr>Processes the selection of an item.
Sets the value of the IsSelected property, triggers the selection animation and calls the ItemStateChanged method of the listbox selection controller.
The UserChange specifies whether the selection is initiated by an user action (as opposed to by a code call).</docstr>
      </procedure>
      <property name="Images">
        <docstr>Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
If the TCustomImageList list is empty, then Images is nil/null.
Call ImagesChanged when Images is changed.</docstr>
      </property>
      <property name="Selectable">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="IsChecked">
        <docstr>Specifies whether the check box associated with the item is checked.</docstr>
      </property>
      <property name="IsSelected">
        <docstr>Specifies whether the item is selected.
If IsSelected is True, the item appears as selected inside its parent component.</docstr>
      </property>
      <property name="ItemData">
        <docstr>Specifies various data that can be attached to a TListBoxItem in order to be shown in the list box.
Use the ItemData property in order to attach various data to a list box item. This data can then be displayed in the list box.

ItemData has four sub-properties:

Accessory - lets you add to the selected list box item one of the following items:
Checkmark icon 
Detail icon 
More icon 
No icon (this is the default)
Bitmap - lets you add a bitmap image to your item.
Detail - lets you add an additional text that describes your list box item.
Text - allows you to change the text displayed on your list box item.

In the picture above, two list box items are present in the list:

The first one has a bitmap image, additional text description and no accessory icon.
The second one has a bitmap image, additional text description and the Detail accessory icon.</docstr>
      </property>
      <property name="ImageIndex">
        <docstr>Defines the zero-based index enumerating images in the Images list of images.
If you use a non-existing ImageIndex value to access an image in the Images list, then no image is retrieved and no exception is raised. The usual default value is -1. Call ImagesChanged when ImageIndex is changed.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.ListBox" name="TCustomListBox">
    <docstr>A TCustomListBox is the base class for list box components.
Inherits from TCustomListBox to create a control that represents a specialized list box.

List Box Events
TCustomListBox has events that are generic to the list box control, and other events that are specific to the items:

Events that are generic to the list box control: Events such as OnClick, OnDblClick, OnEnter, and OnMouseDown are inherited events, and they refer to the event that occurs in the list box control.
Events that are specific to the items of the list box: Events such as OnItemClick, OnChange, OnChangeCheck, OnCompare, and OnDragChange are specific to the list box item, and they refer to events that occur in the items of the list box.
Therefore it is important to see, for example, the difference between OnClick that occurs when the list box is clicked, and OnItemClick that occurs when a list box item is clicked.
See the full list of TCustomListBox events in FMX.ListBox.TCustomListBox_Events.</docstr>
    <members>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.ListBox.TCustomListBox.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="GetData">
        <docstr>Gets the text of the selected item.
GetData returns the text of the item that is selected in the list box or an empty string, if no item is selected.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Sets the text of the selected item.
If no item is selected, nothing happens.</docstr>
      </procedure>
      <function name="CanObserve">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.</docstr>
      </function>
      <procedure name="DoChangeCheck">
        <docstr>Generates an OnChangeCheck event.
DoChangeCheck is executed internally when the check box associated with one of the items in the list changes its state. Check boxes are visible when the ShowCheckboxes property is set to True.</docstr>
      </procedure>
      <function name="CompareItems">
        <docstr>Compares the given items.
CompareItems compares the text of the given TListBoxItem items.
It also generates an OnCompare event.</docstr>
      </function>
      <procedure name="DoChange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SortItems">
        <docstr>Sorts the items in the list box.</docstr>
      </procedure>
      <procedure name="SetItemIndex">
        <docstr>Sets the index of the selected item in the list.
SetItemIndex is the protected setter method for the ItemIndex property.</docstr>
      </procedure>
      <function name="GetItemIndex">
        <docstr>Returns the index of the currently selected item.</docstr>
      </function>
      <procedure name="MouseDown">
        <docstr>Internally executed while a mouse button is pressed over the surface of this scroll box.
FMX.ListBox.TCustomListBox.MouseDown inherits from FMX.Layouts.TCustomScrollBox.MouseDown. All content below this line refers to FMX.Layouts.TCustomScrollBox.MouseDown.
Internally executed while a mouse button is pressed over the surface of this scroll box.
You can call MouseDown programmatically in applications to simulate a mouse button down event over this scroll box.
The Button parameter specifies the mouse button that has just been pressed (for instance, TMouseButton.mbLeft).
The Shift parameter specifies the keyboard state (for instance the CTRL key pressed at the same time with the mouse click).
The X and Y parameters specify the position of the mouse cursor on the screen.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>Internally executed while the mouse is moved over the surface of this scroll box.
FMX.ListBox.TCustomListBox.MouseMove inherits from FMX.Layouts.TCustomScrollBox.MouseMove. All content below this line refers to FMX.Layouts.TCustomScrollBox.MouseMove.
Internally executed while the mouse is moved over the surface of this scroll box.
You can call MouseMove programmatically in applications to simulate a mouse move event over this scroll box.
The Shift parameter specifies the keyboard state (for instance, the CTRL key pressed at the same time with the mouse click).
The X and Y parameters specify the position of the mouse cursor on the screen.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>Internally executed while a mouse button is released over the surface of this scroll box.
FMX.ListBox.TCustomListBox.MouseUp inherits from FMX.Layouts.TCustomScrollBox.MouseUp. All content below this line refers to FMX.Layouts.TCustomScrollBox.MouseUp.
Internally executed while a mouse button is released over the surface of this scroll box.
You can call MouseUp programmatically in applications to simulate a mouse button up event over this scroll box.
The Button parameter specifies the mouse button that has just been released (for instance, TMouseButton.mbLeft).
The Shift parameter specifies the keyboard state (for instance, the CTRL key pressed at the same time with the mouse click).
The X and Y parameters specify the position of the mouse cursor on the screen.</docstr>
      </procedure>
      <procedure name="MouseClick">
        <docstr>Calls Click and starts the animation by calling StartTriggerAnimation.
FMX.ListBox.TCustomListBox.MouseClick inherits from FMX.Controls.TControl.MouseClick. All content below this line refers to FMX.Controls.TControl.MouseClick.
Calls Click and starts the animation by calling StartTriggerAnimation.
MouseClick receives the following parameters: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys -- SHIFT, CTRL, ALT, and CMD (only for Mac) -- were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
 See Also
FMX.Controls.TControl.Click
FMX.Controls.TControl.OnClick
FMX.Controls.TControl.OnMouseLeave
FMX.Controls.TControl.OnMouseEnter
FMX.Controls.TControl.OnMouseMove
FMX.Controls.TControl.OnMouseDown
FMX.Controls.TControl.OnMouseWheel
System.Classes.TShiftState
System.UITypes.TMouseButton
FMX.Ani.TAnimator.StartTriggerAnimation</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Provides a response when a key is pressed down while the control has the keyboard focus. 
FMX.ListBox.TCustomListBox.KeyDown inherits from FMX.Controls.TControl.KeyDown. All content below this line refers to FMX.Controls.TControl.KeyDown.
Provides a response when a key is pressed down while the control has the keyboard focus. 
If the pressed key is the Applications key (Key = vkApps), then KeyDown shows the context menu of the control. Otherwise, KeyDown calls the OnKeyDown event handler if one is assigned. 
TCommonCustomForm and descendant of TControl classes--like TCustomGrid--call KeyDown from their methods handling key pressing. They decode the message parameters into the key code, character code, and shift state. They pass them into the called KeyDown method in the Key, KeyChar, and Shift parameters, respectively:  



Parameters

Descriptions



Key



Is the scan code of the pressed keyboard key or $0.
If a pressed key combination can be a shortcut, then Key &lt;&gt; 0 is a virtual key and KeyChar = #0. 
Physical scan codes of the same key can differ under different platforms (Windows or iOS).
Platform-specific units (for example FMX.Platform.Mac.pas) should translate native scan codes to corresponding Windows codes defined in the UITypes unit.  For example, 

vkReturn = $0D;  {  13 } corresponds to the RETURN keyboard key.
vkF2     = $71;  { 113 } corresponds to the F2 keyboard key.



KeyChar



Is the pressed character (digit) or #0.
If a pressed key combination can be treated as a printable character or digit, then Key = 0 and KeyChar contains a pressed symbol according to the current keyboard&apos;s input language, keyboard mode (CAPS LOCK and NUM LOCK keys), keyboard Shift state, and IME state. Editors can use this symbol to add into a text being edited. 




Shift



Indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the specified key was pressed with the control in focus.


If the control has successfully processed the pressed key combination and no additional processing is required, then KeyDown assigns Key = 0 and KeyChar = #0.  
Override the protected KeyDown method to provide other responses when a key is down while the control has keyboard input focus.
See TCommonCustomForm.KeyDown for more information about parameters.</docstr>
      </procedure>
      <procedure name="DragOver">
        <docstr>OnDragOver event dispatcher. 
FMX.ListBox.TCustomListBox.DragOver inherits from FMX.Controls.TControl.DragOver. All content below this line refers to FMX.Controls.TControl.DragOver.
OnDragOver event dispatcher. 
Data specifies the dragged object.
Point specifies the current point of the  mouse cursor within the client area of the control.
Operation is the operation parameter (None, Move, Copy, Link) that specifies the action to perform when an item is dragged over the object.  

None is the default. No action takes place, it does not display any name.
Move - the word Move is displayed once an item is dragged over the object.
Copy - the word Copy is displayed once an item is dragged over the object.
Link - the word Link is displayed once an item is dragged over the object.
A control calls DragOver when a dragged object is over the control area.
Override the protected DragOver method to provide other responses when a dragged object is over the control area.</docstr>
      </procedure>
      <procedure name="DragDrop">
        <docstr>OnDragDrop event dispatcher. 
FMX.ListBox.TCustomListBox.DragDrop inherits from FMX.Controls.TControl.DragDrop. All content below this line refers to FMX.Controls.TControl.DragDrop.
OnDragDrop event dispatcher. 
Data specifies the dragged object.
Point specifies the current point of the mouse cursor, within the client area of the control.
A control calls DragDrop when a dragged object is dropped on the control area.
Override the protected DragDrop method to provide other responses when a dragged object is dropped on the control area.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.ListBox.TCustomListBox.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.ListBox.TCustomListBox.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.ListBox.TCustomListBox.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <procedure name="DoEnter">
        <docstr>Responds when receiving input focus.
FMX.ListBox.TCustomListBox.DoEnter inherits from FMX.Controls.TStyledControl.DoEnter. All content below this line refers to FMX.Controls.TStyledControl.DoEnter.
Responds when receiving input focus.
DoEnter is called automatically when the control receives the input focus.</docstr>
      </procedure>
      <procedure name="DoExit">
        <docstr>OnExit event dispatcher.
FMX.ListBox.TCustomListBox.DoExit inherits from FMX.Controls.TControl.DoExit. All content below this line refers to FMX.Controls.TControl.DoExit.
OnExit event dispatcher.
DoExit is called automatically when the input focus moves from the current object.
DoExit repaints the control, starts the animation by calling StartTriggerAnimation, and applies effects by calling ApplyTriggerEffect. When a control receives focus, it is highlighted. The animations and effects applied by DoExit background the control.
Override the protected DoExit method to provide other responses when the focus moves from the current control.</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.ListBox.TCustomListBox.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoInsertObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetBorderHeight">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="CreateScrollContent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="DoCalcContentBounds">
        <docstr>Calculates the ContentBounds rectangle bounding all controls in the scrolling region.
FMX.ListBox.TCustomListBox.DoCalcContentBounds inherits from FMX.Layouts.TCustomScrollBox.DoCalcContentBounds. All content below this line refers to FMX.Layouts.TCustomScrollBox.DoCalcContentBounds.
Calculates the ContentBounds rectangle bounding all controls in the scrolling region.
DoRealign calls DoCalcContentBounds to calculate the ContentBounds rectangle. If the OnCalcContentBounds event handler is defined, then DoRealign calls this event handler and  passes into it the calculated content bounding rectangle for additional calculations.</docstr>
      </function>
      <procedure name="DoEndUpdate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ImagesChanged">
        <docstr>Should be called when the component needs to redraw the image.
ImagesChanged  should be called when you change the Images reference to the TCustomImageList object or the object itself.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.ListBox.TCustomListBox.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <procedure name="DoContentPaint">
        <docstr>Executes internally to render the content of the list box.</docstr>
      </procedure>
      <procedure name="Painting">
        <docstr>OnPainting event dispatcher. 
FMX.ListBox.TCustomListBox.Painting inherits from FMX.Controls.TControl.Painting. All content below this line refers to FMX.Controls.TControl.Painting.
OnPainting event dispatcher. 
Painting defines the drawing area of the control by intersecting Canvas with ClipRect if ClipChildren is True and dispatches the OnPainting event.
It is always called internally before DoPaint. 
The Painting method can be overridden by derived controls to establish control-specific rendering conditions.</docstr>
      </procedure>
      <procedure name="AfterPaint">
        <docstr>Restores Canvas properties after the painting process. 
FMX.ListBox.TCustomListBox.AfterPaint inherits from FMX.Controls.TControl.AfterPaint. All content below this line refers to FMX.Controls.TControl.AfterPaint.
Restores Canvas properties after the painting process. 
As implemented in TControl, AfterPaint does nothing.
TShape descendants of TControl override AfterPaint to restore Dash and  Thickness to default values.</docstr>
      </procedure>
      <procedure name="ViewportPositionChange">
        <docstr>Executed when the viewport position changes.
FMX.ListBox.TCustomListBox.ViewportPositionChange inherits from FMX.Layouts.TCustomScrollBox.ViewportPositionChange. All content below this line refers to FMX.Layouts.TCustomScrollBox.ViewportPositionChange.
Executed when the viewport position changes.
ViewportPositionChange receives the following parameters:

OldViewportPosition is the value that the ViewportPosition property had before it changed.
NewViewportPosition is the new value of the ViewportPosition property.
ContentSizeChanged indicates whether the size of the content of the viewport has changed as well (True) or not (False).
ViewportPositionChange calls the handler of the OnViewportPositionChange event.</docstr>
      </procedure>
      <procedure name="DoUpdateAniCalculations">
        <docstr>Sets the default inertial scrolling properties for the current platform.
FMX.ListBox.TCustomListBox.DoUpdateAniCalculations inherits from FMX.Layouts.TCustomScrollBox.DoUpdateAniCalculations. All content below this line refers to FMX.Layouts.TCustomScrollBox.DoUpdateAniCalculations.
Sets the default inertial scrolling properties for the current platform.
DoUpdateAniCalculations is called from UpdateAniCalculations to set the default values to the Animation, 
TouchTracking, BoundsAnimation, and AutoShowing properties of the inertial scrolling under the current platform. DoUpdateAniCalculations sets the properties of the TScrollCalculations object kept in the AniCalculations property.</docstr>
      </procedure>
      <function name="IsAddToContent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ContentAddObject">
        <docstr>Virtual method to be implemented in subclasses to provide further functionality when adding AObject to the scroll box.
FMX.ListBox.TCustomListBox.ContentAddObject inherits from FMX.Layouts.TCustomScrollBox.ContentAddObject. All content below this line refers to FMX.Layouts.TCustomScrollBox.ContentAddObject.
Virtual method to be implemented in subclasses to provide further functionality when adding AObject to the scroll box. In TScrollBox, ContentAddObject has no implementation.</docstr>
      </procedure>
      <procedure name="ContentInsertObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ContentBeforeRemoveObject">
        <docstr>Virtual method to be implemented in subclasses to provide further functionality right before removing AObject from the scroll box.
FMX.ListBox.TCustomListBox.ContentBeforeRemoveObject inherits from FMX.Layouts.TCustomScrollBox.ContentBeforeRemoveObject. All content below this line refers to FMX.Layouts.TCustomScrollBox.ContentBeforeRemoveObject.
Virtual method to be implemented in subclasses to provide further functionality right before removing AObject from the scroll box. In TScrollBox, ContentBeforeRemoveObject has no implementation.</docstr>
      </procedure>
      <procedure name="ContentRemoveObject">
        <docstr>Virtual method to be implemented in subclasses to provide further functionality right after removing AObject from the scroll box.
FMX.ListBox.TCustomListBox.ContentRemoveObject inherits from FMX.Layouts.TCustomScrollBox.ContentRemoveObject. All content below this line refers to FMX.Layouts.TCustomScrollBox.ContentRemoveObject.
Virtual method to be implemented in subclasses to provide further functionality right after removing AObject from the scroll box. In TScrollBox, ContentRemoveObject has no implementation.</docstr>
      </procedure>
      <function name="IsOpaque">
        <docstr>Indicates if the control should update effects when you scroll content.
FMX.ListBox.TCustomListBox.IsOpaque inherits from FMX.Layouts.TCustomScrollBox.IsOpaque. All content below this line refers to FMX.Layouts.TCustomScrollBox.IsOpaque.
Indicates if the control should update effects when you scroll content.
Its default value is False, meaning that the control does not update effects.
In the TFramedScrollBox and TFramedVertScrollBox classes IsOpaque returns True.</docstr>
      </function>
      <procedure name="UpdateVisibleItems">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="UpdateSelection">
        <docstr>Updates the items that are selected in the list box.</docstr>
      </procedure>
      <procedure name="UpdateGroups">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RealUpdateGroups">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="UpdateStickyHeader">
        <docstr>Updates the layout of the &quot;sticky&quot; item in a list box.
For example, a &quot;sticky&quot; item can be a TSearchBox. &quot;Sticky&quot; means that it always stays on the top of the list, similar to a header.
To add a search box as a &quot;sticky&quot; item, right-click on a TListBox control and select Add Item &gt; TSearchBox.</docstr>
      </procedure>
      <procedure name="SetGroupingKind">
        <docstr>The setter for the GroupingKind property.
Sets the value of the GroupingKind property and updates and repaints the content of the ListBox.</docstr>
      </procedure>
      <procedure name="DoRealign">
        <docstr>Performs the realignment of the children controls of the TScrollBox object within the object. 
FMX.ListBox.TCustomListBox.DoRealign inherits from FMX.Layouts.TCustomScrollBox.DoRealign. All content below this line refers to FMX.Layouts.TCustomScrollBox.DoRealign.
Performs the realignment of the children controls of the TScrollBox object within the object.  
It is called internally every time visual properties of TScrollBox are changed. 
The children are realigned taking into account their alignment properties, margins, and padding. 
DoRealign calls the inherited TControl.DoRealign and then executes the realignment during the inertial scrolling.</docstr>
      </procedure>
      <procedure name="DispatchStringsChangeEvent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Show">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="CanFocus">
        <docstr>Specifies whether the current control can receive focus. 
CanFocus is True if it can receive focus, and False otherwise.
If it is set to False, the control cannot be selected when using the TAB key.
A control can receive focus after it is created.</docstr>
      </property>
      <property name="CanParentFocus">
        <docstr>Specifies whether the parent of this control should be evaluated to receive focus.
CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise.</docstr>
      </property>
      <property name="Selection">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.ListBox.TCustomListBox.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <function name="GetFirstSelect">
        <docstr>Getter for the FirstSelectedItem property.</docstr>
      </function>
      <property name="AllowDrag">
        <docstr>Allows the dragging of items inside the list.
AllowDrag allows you to change the order of the list items by dragging them.</docstr>
      </property>
      <property name="AlternatingRowBackground">
        <docstr>Specifies whether consecutive items should have different backgrounds.
Set AlternatingRowBackground to True so that the background of items alternates.</docstr>
      </property>
      <property name="Columns">
        <docstr>Specifies the number of columns on which to display the items in the list box.
If Columns is set to 3, this is how the list box will display the items:</docstr>
      </property>
      <property name="ItemWidth">
        <docstr>Specifies the width of the items in the list box.
The default value is 0. If you set another value for ItemWidth, all the items will be re-dimensioned to that value and displayed on multiple columns.</docstr>
      </property>
      <property name="ItemHeight">
        <docstr>Specifies the height of the items from the list box.
Use ItemHeight to specify the height, in pixels, of the items in the list box.</docstr>
      </property>
      <property name="ListStyle">
        <docstr>Specifies how the items are displayed in the list box.
ListStyle specifies whether the items in the list box are displayed vertically or horizontally.
ListStyle can be set to Vertical or Horizontal.</docstr>
      </property>
      <property name="MultiSelectStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Sorted">
        <docstr>Specifies whether the list of items is sorted.</docstr>
      </property>
      <property name="ShowCheckboxes">
        <docstr>Displays a check box next to every item in the list box.</docstr>
      </property>
      <property name="FirstSelectedItem">
        <docstr>First item in the selection.
Returns nil if no item is selected.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs when the selection in the list box changes.
Write an OnChange event handler to take specific action immediately after a new item or items are selected in the list box.</docstr>
      </event>
      <event name="OnChangeCheck">
        <docstr>Occurs when the check box attached to a list item changes its state.
Write an OnChangeCheck event handler to take specific action after the check box attached to an item changes its state from selected to cleared or vice versa.
To make the check boxes attached to the list items visible, set the ShowCheckboxes property to True.</docstr>
      </event>
      <event name="OnCompare">
        <docstr>Occurs when two list items are compared.
Write an OnCompare event handler to create your own comparing criteria.</docstr>
      </event>
      <event name="OnDragChange">
        <docstr>Occurs after a drag-and-drop operation.
The OnDragChange event occurs after a drag-and-drop operation and allows you to make further changes to the list box.
If AllowDrag is set to True, you can write an event handler to specify the changes to the list box when a list box item is dragged inside the list.
See TOnListBoxDragChange for more details.</docstr>
      </event>
      <event name="OnStringsChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <property name="SelectionController">
        <docstr>The current selection controller.
The constructor initializes the MultiSelectStyle property which in turn defines the SelectionController. The default value of MultiSelectStyle is TMultiSelectStyle.None.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.ListBox.TCustomListBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.ListBox.TCustomListBox.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="Assign">
        <docstr>Assigns the Source object to the current object.
Assign copies the elements from Source to the current object, if Source is a TStrings object.</docstr>
      </procedure>
      <procedure name="Clear">
        <docstr>Deletes all the items from the list.
Clear removes the items from the list box and also frees the memory allocated for them. The items in the list box are stored as TListBoxItem objects.</docstr>
      </procedure>
      <function name="DragChange">
        <docstr>Generates an OnDragChange event.
DragChange is called automatically after a drag-and-drop operation.</docstr>
      </function>
      <procedure name="SelectAll">
        <docstr>Selects all the items in the list.
SelectAll works only if MultiSelect is set to True.</docstr>
      </procedure>
      <procedure name="ClearSelection">
        <docstr>Deselects all the selected items from the list box.
If no items are selected before calling ClearSelection, nothing happens.</docstr>
      </procedure>
      <procedure name="SelectRange">
        <docstr>Selects all the items between two given items.
SelectRange selects the items between Item1 and Item2 (including Item1 and Item2)  and deselects any other previously selected items.
SelectRange works only if MultiSelect is set to True.</docstr>
      </procedure>
      <procedure name="ScrollToItem">
        <docstr>Scrolls the content so that the Item is visible.</docstr>
      </procedure>
      <function name="FirstSelectedItemFrom">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="LastSelectedItemFrom">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="ItemByPoint">
        <docstr>Returns the item at the specified point.
Call ItemByPoint to get the item that contains in its bounds the point specified by X and Y.</docstr>
      </function>
      <function name="ItemByIndex">
        <docstr>Returns the item at the index specified by Idx.</docstr>
      </function>
      <procedure name="ItemsExchange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Sort">
        <docstr>Sorts components of the layout based on the comparison function Compare. 
FMX.ListBox.TCustomListBox.Sort inherits from FMX.Layouts.TCustomScrollBox.Sort. All content below this line refers to FMX.Layouts.TCustomScrollBox.Sort.
Sorts components of the layout based on the comparison function Compare. 
TFmxObjectSortCompare is declared as:

TFmxObjectSortCompare = function(item1, item2: TFmxObject): Integer;</docstr>
      </procedure>
      <procedure name="NotifyInflated">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="BorderHeight">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Count">
        <docstr>Determines the number of items in the list box.</docstr>
      </property>
      <property name="Selected">
        <docstr>Returns the item that is currently selected.
If no item is selected, it returns nil.
To obtain the index of the item that is currently selected, use the ItemIndex property.</docstr>
      </property>
      <property name="Items">
        <docstr>Specifies the items in the list box.
Use Items to get or set the list of items in the list box as strings.
Use the ListItems property to access an item by specifying its index. This property returns the item as a TListBoxItem object.

Adding Items
To add items as TListBoxItem at design-time, see ListBox Items Editor.
To add items as TStrings at design-time, see String List editor.</docstr>
      </property>
      <property name="ItemDown">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Images">
        <docstr>Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
If the TCustomImageList list is empty, then Images is nil/null.
Call ImagesChanged when Images is changed.</docstr>
      </property>
      <property name="ItemIndex">
        <docstr>Specifies the index of the currently selected item.
Gets or sets the index of the item that is selected in the list box.
The first item in the list has index 0, the second item has index 1, and so on. If no item is selected, the value of ItemIndex is -1.
To get the actual item that is selected, use the Selected property.</docstr>
      </property>
      <property name="GroupingKind">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FilterPredicate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="MultiSelect">
        <docstr>Specifies whether multiple items can be selected in the list.
If MultiSelect is set to True, you can select more than one item from the list, otherwise you are limited to one item.</docstr>
      </property>
      <property name="DefaultItemStyles">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <event name="OnItemClick">
        <docstr>Occurs immediately after clicking an item from the listbox.
Write an OnItemClick event handler to respond to clicking on an item from the listbox component.
The event handler for the OnItemClick event receives two arguments:

Sender: The TCustomListBox instance that holds the list box item that was clicked.
Item: The TListBoxItem instance that was clicked.
OnItemClick is an event of type TItemClickEvent.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.ListBox" name="TListBoxSeparatorItem">
    <docstr></docstr>
    <members>
      <function name="GetDefaultGroupHeaderStyle">
        <docstr>Gets default style for Group Header, which is used if TListBox.DefaultItemStyles.GroupHeaderStyle
            is empty</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.ListBox" name="TListBoxGroupHeader">
    <docstr></docstr>
    <members>
      <property name="CloneRef">
        <docstr>Reference to sticky TListBoxGroupHeader clone in Plain grouping mode</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.ListBox" name="TListBoxSelector">
    <docstr></docstr>
    <members>
      <field name="FListBox">
        <docstr>Reference to TListBox that hosts this controller</docstr>
      </field>
      <field name="FCurrent">
        <docstr>Index of currently selected item, -1 if none</docstr>
      </field>
      <field name="FFirst">
        <docstr>Index of first selected item, -1 if none</docstr>
      </field>
      <field name="FSelectionTimer">
        <docstr>Timer used for DelayedMouseDown</docstr>
      </field>
      <field name="FSelectionTimerTarget">
        <docstr>Item that&apos;s going to be acted upon if DelayedMouseDown is employed</docstr>
      </field>
      <field name="FInternalChange">
        <docstr>Flag used to prevent sending change notification</docstr>
      </field>
      <field name="FMouseSelectActive">
        <docstr>True during mouse selection</docstr>
      </field>
      <constructor name="Create">
        <docstr>Create a new instance of TSelectionController</docstr>
      </constructor>
      <function name="GetMultiSelectStyle">
        <docstr>Getter for MutliSelectStyle</docstr>
      </function>
      <procedure name="UpdateSelection">
        <docstr>Make host TListBox update selection visuals</docstr>
      </procedure>
      <procedure name="DelayedMouseDown">
        <docstr>Initiate a delayed mouse down action</docstr>
      </procedure>
      <procedure name="AbortDelayed">
        <docstr>Abort delayed mouse down action, if any</docstr>
      </procedure>
      <function name="GetFirst">
        <docstr>Get first item index, -1 if none</docstr>
      </function>
      <function name="GetCurrent">
        <docstr>Get current item index, -1 if none</docstr>
      </function>
      <function name="GetCurrentItem">
        <docstr>Get current TListBoxItem, nil if none selected</docstr>
      </function>
      <procedure name="ClearSelection">
        <docstr>Clear selection</docstr>
      </procedure>
      <procedure name="CopySelection">
        <docstr>Attempt to copy selection from another selector</docstr>
      </procedure>
      <procedure name="SelectAll">
        <docstr>Select everything</docstr>
      </procedure>
      <function name="SelectRange">
        <docstr>Select range between TListBoxItems Item1 and Item2</docstr>
      </function>
      <function name="SetSelected">
        <docstr>Mark TListBoxItem Item as Selected if Value is True, as not selected if Value is False.
           No notification. Return true if Item.Selected has been changed.</docstr>
      </function>
      <function name="SetCurrent">
        <docstr>Set item with index Index as current. Return True if the value of Current has been changed.</docstr>
      </function>
      <procedure name="ItemStateChanged">
        <docstr>Used to notify this TSelectionController when item state was changed externally. See DoItemStateChanged.</docstr>
      </procedure>
      <procedure name="MouseSelectStart">
        <docstr>Start mouse selection</docstr>
      </procedure>
      <procedure name="MouseSelectMove">
        <docstr>Handle mouse move during selection</docstr>
      </procedure>
      <procedure name="MouseSelectFinishing">
        <docstr>Before mouse selection is finished</docstr>
      </procedure>
      <procedure name="MouseSelectFinish">
        <docstr>Finish mouse selection</docstr>
      </procedure>
      <procedure name="KeyboardSelect">
        <docstr>Select using keyboard, e.g. by pressing space. KeyAction is one of: Move or Toggle</docstr>
      </procedure>
      <procedure name="UserSetIndex">
        <docstr>Invoked when item index is set programmatically by user</docstr>
      </procedure>
      <procedure name="Change">
        <docstr>Dispatch change notification</docstr>
      </procedure>
      <procedure name="DoMouseSelectStart">
        <docstr>MouseSelectStart implementation</docstr>
      </procedure>
      <procedure name="DoMouseSelectMove">
        <docstr>MouseSelectMove implementation</docstr>
      </procedure>
      <procedure name="DoMouseSelectFinishing">
        <docstr>MouseSelectFinishing implementation</docstr>
      </procedure>
      <procedure name="DoMouseSelectFinish">
        <docstr>MouseSelectFinish implementation</docstr>
      </procedure>
      <procedure name="DoKeyboardSelect">
        <docstr>KeyboardSelect implementation</docstr>
      </procedure>
      <procedure name="DoUserSetIndex">
        <docstr>UserSetIndex implementation</docstr>
      </procedure>
      <procedure name="DoItemStateChanged">
        <docstr>ItemStateChanged implementation</docstr>
      </procedure>
      <property name="MultiSelectStyle">
        <docstr>MultiSelectStyle that this selection controller implements</docstr>
      </property>
      <property name="MouseSelectActive">
        <docstr>True during mouse selection</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.ListBox" name="TListBoxSelectorFactory">
    <docstr></docstr>
    <members>
      <function name="CreateSelector">
        <docstr>Create TListBoxSelector for ListBox based on MultiSelectStyle</docstr>
      </function>
      <procedure name="RegisterSelector">
        <docstr>Register a selector that handles given MultiSelectStyle. Used during framework initialization</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.ListBox" name="TCustomComboBox">
    <docstr>A TCustomComboBox is the base class for combo box components.
Inherit from TCustomComboBox to create a control that represents a specialized combo box.</docstr>
    <members>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.ListBox.TCustomComboBox.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="DoOnValueChangedFromDropDownList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoChange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoPopup">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoClosePopup">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoClosePicker">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="CreateListBox">
        <docstr>Creates the list box associated with the combo box.
Call CreateListBox to instantiate the list box component of the current combo box. The list box is of type TComboListBox.</docstr>
      </function>
      <function name="CanObserve">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.</docstr>
      </function>
      <procedure name="GetChildren">
        <docstr>Enumerates all child components.
FMX.ListBox.TCustomComboBox.GetChildren inherits from System.Classes.TComponent.GetChildren. All content below this line refers to System.Classes.TComponent.GetChildren.
Enumerates all child components.
GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
GetChildren expects a TGetChildProc routine that receives all enumerated components. 
Root represents the owner of the components that will be enumerated.
This method does nothing in TComponent and is expected to be overridden in descendants.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.ListBox.TCustomComboBox.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.ListBox.TCustomComboBox.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="DoRealign">
        <docstr>Performs the alignment of a FireMonkey control.
FMX.ListBox.TCustomComboBox.DoRealign inherits from FMX.Controls.TControl.DoRealign. All content below this line refers to FMX.Controls.TControl.DoRealign.
Performs the alignment of a FireMonkey control.

 See Also
FMX.Types.AlignObjects</docstr>
      </procedure>
      <procedure name="DoContentPaint">
        <docstr>Renders the content of the combo box.
DoContentPaint paints the content of the combo box when it is not expanded.
DoContentPaint is used internally.</docstr>
      </procedure>
      <procedure name="DoExit">
        <docstr>OnExit event dispatcher.
FMX.ListBox.TCustomComboBox.DoExit inherits from FMX.Controls.TControl.DoExit. All content below this line refers to FMX.Controls.TControl.DoExit.
OnExit event dispatcher.
DoExit is called automatically when the input focus moves from the current object.
DoExit repaints the control, starts the animation by calling StartTriggerAnimation, and applies effects by calling ApplyTriggerEffect. When a control receives focus, it is highlighted. The animations and effects applied by DoExit background the control.
Override the protected DoExit method to provide other responses when the focus moves from the current control.</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.ListBox.TCustomComboBox.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoInsertObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.ListBox.TCustomComboBox.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.ListBox.TCustomComboBox.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseWheel">
        <docstr>OnMouseWheel event dispatcher. 
FMX.ListBox.TCustomComboBox.MouseWheel inherits from FMX.Controls.TControl.MouseWheel. All content below this line refers to FMX.Controls.TControl.MouseWheel.
OnMouseWheel event dispatcher. 
A control calls MouseWheel in response to any of mouse wheel messages, decoding the message parameters into the shift-key state, wheel rotation, and handle, which it passes in the Shift, WheelDelta, and Handled parameters, respectively:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
WheelDelta indicates the distance the wheel was rotated. WheelDelta is positive if the mouse was rotated upward, negative if the mouse was rotated downward.
Handled indicates whether the scroll bar was already moved, depending on the WheelDelta value. If one of the scrolls bars (vertical or horizontal) was already handled or it does not exist, MouseWheel tries to apply the rolling on the other scroll bar, if it exists.
Override the protected MouseWheel method to provide other responses when the mouse wheel is rotated while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Provides a response when a key is pressed down while the control has the keyboard focus. 
FMX.ListBox.TCustomComboBox.KeyDown inherits from FMX.Controls.TControl.KeyDown. All content below this line refers to FMX.Controls.TControl.KeyDown.
Provides a response when a key is pressed down while the control has the keyboard focus. 
If the pressed key is the Applications key (Key = vkApps), then KeyDown shows the context menu of the control. Otherwise, KeyDown calls the OnKeyDown event handler if one is assigned. 
TCommonCustomForm and descendant of TControl classes--like TCustomGrid--call KeyDown from their methods handling key pressing. They decode the message parameters into the key code, character code, and shift state. They pass them into the called KeyDown method in the Key, KeyChar, and Shift parameters, respectively:  



Parameters

Descriptions



Key



Is the scan code of the pressed keyboard key or $0.
If a pressed key combination can be a shortcut, then Key &lt;&gt; 0 is a virtual key and KeyChar = #0. 
Physical scan codes of the same key can differ under different platforms (Windows or iOS).
Platform-specific units (for example FMX.Platform.Mac.pas) should translate native scan codes to corresponding Windows codes defined in the UITypes unit.  For example, 

vkReturn = $0D;  {  13 } corresponds to the RETURN keyboard key.
vkF2     = $71;  { 113 } corresponds to the F2 keyboard key.



KeyChar



Is the pressed character (digit) or #0.
If a pressed key combination can be treated as a printable character or digit, then Key = 0 and KeyChar contains a pressed symbol according to the current keyboard&apos;s input language, keyboard mode (CAPS LOCK and NUM LOCK keys), keyboard Shift state, and IME state. Editors can use this symbol to add into a text being edited. 




Shift



Indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the specified key was pressed with the control in focus.


If the control has successfully processed the pressed key combination and no additional processing is required, then KeyDown assigns Key = 0 and KeyChar = #0.  
Override the protected KeyDown method to provide other responses when a key is down while the control has keyboard input focus.
See TCommonCustomForm.KeyDown for more information about parameters.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.ListBox.TCustomComboBox.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <procedure name="InitPicker">
        <docstr>Initializes a list picker. 
InitPicker initializes the list picker provided with the AListPicker parameter.</docstr>
      </procedure>
      <procedure name="RecalculatePopupSize">
        <docstr>Recalculates the pop-up size based on the items.</docstr>
      </procedure>
      <procedure name="ImagesChanged">
        <docstr>Should be called when the component needs to redraw the image.
ImagesChanged  should be called when you change the Images reference to the TCustomImageList object or the object itself.</docstr>
      </procedure>
      <property name="Popup">
        <docstr>Gets the pop-up window that is used as a holder for the drop-down list.</docstr>
      </property>
      <property name="CanFocus">
        <docstr>Specifies whether the current control can receive focus. 
CanFocus is True if it can receive focus, and False otherwise.
If it is set to False, the control cannot be selected when using the TAB key.
A control can receive focus after it is created.</docstr>
      </property>
      <property name="CanParentFocus">
        <docstr>Specifies whether the parent of this control should be evaluated to receive focus.
CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise.</docstr>
      </property>
      <property name="ItemHeight">
        <docstr>Specifies the height of the items from the drop-down list.
Use ItemHeight to specify the height, in pixels, of the items in the combo box list.</docstr>
      </property>
      <property name="ItemWidth">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="DropDownCount">
        <docstr>Specifies the maximum number of items displayed in the drop-down list.
By default, the drop-down list displays 8 items that are visible without requiring the user to scroll. To make the drop-down list smaller or larger, specify a number smaller or larger than eight as the DropDownCount value.
If the DropDownCount value is larger than the number of items, the drop-down list will be only large enough to display the existing items. If the DropDownCount value is smaller than the number of items, the drop-down list displays a scroll bar.</docstr>
      </property>
      <property name="Placement">
        <docstr>Specifies the position of the list box relative to the combo box button.
For example, if Placement is set to TPlacement.Right, the drop-down list is displayed to the right of the combo box.</docstr>
      </property>
      <property name="PlacementRectangle">
        <docstr>Specifies the position of the drop-down list of the combo box.
Use PlacementRectangle to specify the coordinates of the placement rectangle. The drop-down list will be displayed with the upper-left corner in the lower-left corner of the placement rectangle. The origin is considered to be the upper-left corner of the combo box button.</docstr>
      </property>
      <property name="DropDownKind">
        <docstr>Defines whether to use TCustomListPicker pickers providing platform-specific drop-down lists to select string items.
The TDropDownKind type is also used in the TComboEdit, 
TComboBox, and TPopupBox controls to define whether to use the TCustomListPicker picker to provide platform-specific controls to select string items from drop-down lists.</docstr>
      </property>
      <property name="ListBoxResource">
        <docstr>Specifies the name of the resource object to which the drop-down list of the combo box is linked.
Use ListBoxResource to specify the style for the drop-down list component of the combo box.</docstr>
      </property>
      <property name="Picker">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs when the selected item in the combo box changes.
Write an OnChange event handler to take specific action immediately after a new item is selected from the list.</docstr>
      </event>
      <event name="OnClosePopup">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnPopup">
        <docstr>Occurs just before the drop-drown list appears.
Write an OnPopup event handler to take specific action just before the drop-drown list appears.</docstr>
      </event>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.ListBox.TCustomComboBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.ListBox.TCustomComboBox.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="SetNewScene">
        <docstr>Sets a new Scene for the current control.
Sets a new Scene for the current control.
FMX.ListBox.TCustomComboBox.SetNewScene inherits from FMX.Controls.TControl.SetNewScene. All content below this line refers to FMX.Controls.TControl.SetNewScene.
Sets a new Scene for the current control.
AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
SetNewScene sets the same scene for the control&apos;s children.</docstr>
      </procedure>
      <procedure name="Clear">
        <docstr>Deletes all the items from the Items list.
Call Clear to empty the combo box at run time.</docstr>
      </procedure>
      <procedure name="DropDown">
        <docstr>Opens the list of items.
DropDown makes visible the list of items of the combo box.</docstr>
      </procedure>
      <procedure name="Sort">
        <docstr>Sorts the children in the children list using the specified sorting procedure.
FMX.ListBox.TCustomComboBox.Sort inherits from FMX.Types.TFmxObject.Sort. All content below this line refers to FMX.Types.TFmxObject.Sort.
Sorts the children in the children list using the specified sorting procedure.</docstr>
      </procedure>
      <property name="ListBox">
        <docstr>Gets the drop-down list component of the combo box.
The returned object is a TComboListBox.</docstr>
      </property>
      <property name="Count">
        <docstr>Returns the total number of items in the drop-down list associated with the combo box.</docstr>
      </property>
      <property name="Selected">
        <docstr>Gets the item that is currently selected in the combo box.
Selected returns the selected item in the combo box as a TListBoxItem instance.</docstr>
      </property>
      <property name="Items">
        <docstr>Specifies the items in the drop-down list.
Use Items to get or set the list of items in the drop-down as strings.
Use the ListItems property to access an item as a TListBoxItem object.</docstr>
      </property>
      <property name="Images">
        <docstr>Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
If the TCustomImageList list is empty, then Images is nil/null.
Call ImagesChanged when Images is changed.</docstr>
      </property>
      <property name="ItemIndex">
        <docstr>Specifies the index of the currently selected item.
Gets or sets the index of the item that is selected in the combo box.
The first item in the list has index 0, the second item has index 1, and so on. If no item is selected, the value of ItemIndex is -1.</docstr>
      </property>
      <property name="DroppedDown">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="IsPressed">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.ListBox" name="TComboBox">
    <docstr>A TComboBox is a button with a list box attached to it.
Click the button to display the list.
You can select an item from the list and it will appear as the button&apos;s text. You cannot type text directly into the combo box button.
To add items, right-click the combo box on the form and choose Add Item. This creates a new TListBoxItem object that appears in the Structure pane and can be edited individually.
You can also manage the items in the combo box by double-clicking the combo box control in the Form Designer. This opens the Items Designer dialog where you can add, delete, and change the order of the items.

Note: When a number of items in a control is more than can be concurrently shown in the TListBoxItem list box, then you can use the scroll bar to scroll the items shown in the list box. Notice that on Windows the scroll bar is shown by default. However, on OS X the scroll bar is not shown by default. On OS X, the scroll bar appears when you try to scroll items using the mouse wheel. To enforce the scroll bar to be shown by default, you can use the code like following:
ComboBox1.ListBox.AniCalculations.AutoShowing := false;
In Windows 8 style applications, you can create a Windows 8 style combo box by setting the value Native for the property DropDownKind.  For more information, see Creating a Metropolis UI ComboBox.</docstr>
  </class>
  <class unit="FMX.Bind.Navigator" name="TFMXBindNavigateAction">
    <docstr>Implements a standard LiveBindings action.
TFMXBindNavigateAction is the base class for all standard LiveBindings actions that are compatible with the bind navigator. The standard LiveBindings actions are listed in the following table.



Button

Purpose


Fmx.Bind.Navigator.TFMXBindNavigateFirst

Sets the current record to the first record in the data source, disables the First and Prior buttons, and enables the Next and Last buttons, if they are disabled.


Fmx.Bind.Navigator.TFMXBindNavigatePrior

Sets the current record to the previous record and enables the Last and Next buttons, if they are disabled.


Fmx.Bind.Navigator.TFMXBindNavigateNext

Sets the current record to the next record and enables the First and Prior buttons, if they are disabled.


Fmx.Bind.Navigator.TFMXBindNavigateLast

Sets the current record to the last record in the data source, disables the Last and Next buttons, and enables the First and Prior buttons, if they are disabled.


Fmx.Bind.Navigator.TFMXBindNavigateInsert

Inserts a new record before the current record and sets the data source into Insert and Edit states.


Fmx.Bind.Navigator.TFMXBindNavigateDelete

Deletes the current record and makes the next record the current record.


Fmx.Bind.Navigator.TFMXBindNavigateEdit

Puts the data source into Edit state so that the current record can be modified.


Fmx.Bind.Navigator.TFMXBindNavigatePost

Writes changes in the current record to the data source.


Fmx.Bind.Navigator.TFMXBindNavigateCancel

Cancels edits to the current record, restores the record display to its condition prior to editing, and turns off the Insert and Edit states, if they are active.


Fmx.Bind.Navigator.TFMXBindNavigateRefresh

Refreshes the buffered data in the associated data source.


Fmx.Bind.Navigator.TFMXBindNavigateApplyUpdates

Applies all pending updates to the data source.


Fmx.Bind.Navigator.TFMXBindNavigateCancelUpdates

Cancels all pending updates to the data source.

For more information on how to use standard LiveBindings actions, see the LiveBindings and Action Lists help topic.</docstr>
    <members>
      <property name="Controller">
        <docstr>Specifies the bind navigator controller that will execute the standard LiveBindings actions.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigateAction.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigateAction.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the instance of the contained action.
Fmx.Bind.Navigator.TFMXBindNavigateAction.Destroy inherits from System.Actions.TContainedAction.Destroy. All content below this line refers to System.Actions.TContainedAction.Destroy.
Destroys the instance of the contained action.
If the action is contained in an action list or action manager, Destroy removes the action from that list. Then it calls the inherited Destroy method.</docstr>
      </destructor>
      <function name="HandlesTarget">
        <docstr>Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
Fmx.Bind.Navigator.TFMXBindNavigateAction.HandlesTarget inherits from System.Classes.TBasicAction.HandlesTarget. All content below this line refers to System.Classes.TBasicAction.HandlesTarget.
Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise.</docstr>
      </function>
      <procedure name="ExecuteTarget">
        <docstr>Introduces an interface for invoking an action on a target client component or control.
Fmx.Bind.Navigator.TFMXBindNavigateAction.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
Introduces an interface for invoking an action on a target client component or control.
ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard.</docstr>
      </procedure>
      <procedure name="UpdateTarget">
        <docstr>Introduces an interface for a method of notifying a client when the action updates itself.
Fmx.Bind.Navigator.TFMXBindNavigateAction.UpdateTarget inherits from System.Classes.TBasicAction.UpdateTarget. All content below this line refers to System.Classes.TBasicAction.UpdateTarget.
Introduces an interface for a method of notifying a client when the action updates itself.
UpdateTarget does nothing in TBasicAction. UpdateTarget was introduced in TBasicAction so that descendants can override it to correspondingly update a target when the action updates.</docstr>
      </procedure>
      <property name="DataSource">
        <docstr>Specifies the linking bind source (binding datasource) that will be affected by standard LiveBindings actions (for instance, Delete, ApplyUpdates, CancelUpdates, and so on).</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Bind.Navigator" name="TFMXBindNavigateFirst">
    <docstr>Implements a standard First LiveBindings action.
The TFMXBindNavigateFirst class implements a standard LiveBindings action that is used to set the current record to the first record in the data source, to disable the First and Prior buttons, and to enable the Next and Last buttons, if they are disabled. For more information on how to use standard LiveBindings actions, see the LiveBindings and Action Lists help topic.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigateFirst.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Bind.Navigator" name="TFMXBindNavigatePrior">
    <docstr>Implements a standard Prior LiveBindings action.
The TFMXBindNavigatePrior class implements a standard LiveBindings action that is used to set the current record to the previous record and to enable the Last and Next buttons, if they are disabled. For more information on how to use standard LiveBindings actions, see the LiveBindings and Action Lists help topic.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigatePrior.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Bind.Navigator" name="TFMXBindNavigateNext">
    <docstr>Implements a standard Next LiveBindings action.
The TFMXBindNavigateNext class implements a standard LiveBindings action that is used to set the current record to the next record and to enable the First and Prior buttons, if they are disabled. For more information on how to use standard LiveBindings actions, see the LiveBindings and Action Lists help topic.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigateNext.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Bind.Navigator" name="TFMXBindNavigateLast">
    <docstr>Implements a standard Last LiveBindings action.
The TFMXBindNavigateLast class implements a standard LiveBindings action that is used to set the current record to the last record in the data source, to disable the Last and Next buttons, and to enable the First and Prior buttons, if they are disabled. For more information on how to use standard LiveBindings actions, see the LiveBindings and Action Lists help topic.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigateLast.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Bind.Navigator" name="TFMXBindNavigateInsert">
    <docstr>Implements a standard Insert LiveBindings action.
The TFMXBindNavigateInsert class implements a standard LiveBindings action that is used to insert a new record before the current record and to set the data source into Insert and Edit states. For more information on how to use standard LiveBindings actions, see the LiveBindings and Action Lists help topic.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigateInsert.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Bind.Navigator" name="TFMXBindNavigateDelete">
    <docstr>Implements a standard Delete LiveBindings action.
The TFMXBindNavigateDelete class implements a standard LiveBindings action that is used to delete the current record and to make the next record the current record. For more information on how to use standard LiveBindings actions, see the LiveBindings and Action Lists help topic.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigateDelete.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
      <procedure name="ExecuteTarget">
        <docstr>Introduces an interface for invoking an action on a target client component or control.
Fmx.Bind.Navigator.TFMXBindNavigateDelete.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
Introduces an interface for invoking an action on a target client component or control.
ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard.</docstr>
      </procedure>
      <property name="ConfirmDelete">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Bind.Navigator" name="TFMXBindNavigateEdit">
    <docstr>Implements a standard Edit LiveBindings action.
The TFMXBindNavigateEdit class implements a standard LiveBindings action that is used to put the data source into Edit state so that the current record can be modified. For more information on how to use standard LiveBindings actions, see the LiveBindings and Action Lists help topic.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigateEdit.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Bind.Navigator" name="TFMXBindNavigatePost">
    <docstr>Implements a standard Post LiveBindings action.
The TFMXBindNavigatePost class implements a standard LiveBindings action that is used to apply edits made in the current record to the data source. For more information on how to use standard LiveBindings actions, see the LiveBindings and Action Lists help topic.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigatePost.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Bind.Navigator" name="TFMXBindNavigateCancel">
    <docstr>Implements a standard Cancel LiveBindings action.
The TFMXBindNavigateCancel class implements a standard LiveBindings action that is used to cancel edits to the current record, to restore the record display to its condition prior to editing, and to turn off the Insert and Edit states, if they are active. For more information on how to use standard LiveBindings actions, see the LiveBindings and Action Lists help topic.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigateCancel.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Bind.Navigator" name="TFMXBindNavigateRefresh">
    <docstr>Implements a standard Refresh LiveBindings action.
The TFMXBindNavigateRefresh class implements a standard LiveBindings action that is used to refresh the current row only from the data source. For more information on how to use standard LiveBindings actions, see the LiveBindings and Action Lists help topic.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigateRefresh.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Bind.Navigator" name="TFMXBindNavigateApplyUpdates">
    <docstr>Implements a standard ApplyUpdates LiveBindings action.
The TFMXBindNavigateApplyUpdates class implements a standard LiveBindings action that is used to apply updates to the database with all changes that have been made to the data source. For more information on how to use standard LiveBindings actions, see the LiveBindings and Action Lists help topic.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigateApplyUpdates.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Bind.Navigator" name="TFMXBindNavigateCancelUpdates">
    <docstr>Implements a standard CancelUpdates LiveBindings action.
The TFMXBindNavigateCancelUpdates class implements a standard LiveBindings action that is used to discard all changes that have been made to the data source and restores the data source to the values originally retrieved from the database. For more information on how to use standard LiveBindings actions, see the LiveBindings and Action Lists help topic.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Fmx.Bind.Navigator.TFMXBindNavigateCancelUpdates.Create inherits from FMX.ActnList.TAction.Create. All content below this line refers to FMX.ActnList.TAction.Create.
Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Menus" name="TMenuItem">
    <docstr></docstr>
    <members>
      <function name="DoFilterControlText">
        <docstr>Filters the string contained in the Text property.
FMX.Menus.TMenuItem.DoFilterControlText inherits from FMX.Controls.TTextControl.DoFilterControlText. All content below this line refers to FMX.Controls.TTextControl.DoFilterControlText.
Filters the string contained in the Text property.
For example, you can use DoFilterControlText to filter the ampersand symbol of the accelerator key character.
If the control is registered as an accelerator key receiver, you can override this method to do your own filtering to the accelerator keys.

 See Also
FMX.Controls.TTextControl.Text
Specifying Accelerator Keys</docstr>
      </function>
      <function name="CanTriggerAcceleratorKey">
        <docstr>Determines whether the object reacts to the accelerator key or not.
FMX.Menus.TMenuItem.CanTriggerAcceleratorKey inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.CanTriggerAcceleratorKey. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.CanTriggerAcceleratorKey.
Determines whether the object reacts to the accelerator key or not.
Use CanTriggerAcceleratorKey for objects that are not intended to react to the accelerator key, for example: a hidden tab page or a hidden submenu. The object triggers the action if CanTriggerAcceleratorKey is True. Otherwise, the object cannot trigger the action.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey</docstr>
      </function>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.Menus.TMenuItem.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoInsertObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher.
In addition to FMX.Controls.TControl.MouseDown, if the left mouse button is clicked and the current TMenuItem object has a pop-up menu, MouseDown displays the pop-up menu.</docstr>
      </procedure>
      <procedure name="Click">
        <docstr>Responds to the click of the left mouse button.
In addition to FMX.Controls.TControl.Click, Click triggers an OnMouseLeave and, if the AutoCheck property is True, negates the IsChecked property.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Menus.TMenuItem.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="SetText">
        <docstr>Protected setter implementation for the Text property.
FMX.Menus.TMenuItem.SetText inherits from FMX.Controls.TTextControl.SetText. All content below this line refers to FMX.Controls.TTextControl.SetText.
Protected setter implementation for the Text property.
In descendants, override SetText to allow for further functionality when setting the text using the Text property.
Do not use SetText directly in applications. Use the Text property instead.</docstr>
      </procedure>
      <function name="EnterChildren">
        <docstr>Checks whether the input is taken by the control or by its parent.
FMX.Menus.TMenuItem.EnterChildren inherits from FMX.Controls.TControl.EnterChildren. All content below this line refers to FMX.Controls.TControl.EnterChildren.
Checks whether the input is taken by the control or by its parent.
EnterChildren returns True if the input is taken directly by the control&apos;s parent, and False otherwise. 
Usually, EnterChildren returns False. If the control is an item such as TListBoxItem, a TTreeViewItem, or TMenuItem, EnterChildren returns True.</docstr>
      </function>
      <procedure name="ActionChange">
        <docstr>Specifies the behavior of a TMenuItem menu item when Action changes. 
ActionChange calls the inherited TTextControl.ActionChange method and then, depending on the CheckDefaults value,  ActionChange uses properties of the Sender action to set new values to the  
IsChecked and GroupName properties of TMenuItem. 
Do not call ActionChange explicitly in an application. It is for internal use.</docstr>
      </procedure>
      <function name="GetVisibleItemsCount">
        <docstr>Determines the number of child TMenuItems that have the Visible property set to True.</docstr>
      </function>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.Menus.TMenuItem.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <procedure name="Move">
        <docstr>Realigns the parent of this TMenuItem.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.Menus.TMenuItem.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <procedure name="DoBitmapChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="CalcVisibleObjectsItemSize">
        <docstr>CalcVisibleObjectsItemSize determines the render size of this TMenuItem.</docstr>
      </function>
      <procedure name="ImagesChanged">
        <docstr>Should be called when the component needs to redraw the image.
ImagesChanged should be called
when you change the Images reference to the TCustomImageList object or 
the object itself or when you change the ImageIndex property.</docstr>
      </procedure>
      <function name="ImageIndexStored">
        <docstr>Returns True when the ImageIndex property needs to be stored in the fmx-file.</docstr>
      </function>
      <procedure name="SetParent">
        <docstr>Protected setter implementation for the Parent property.
FMX.Menus.TMenuItem.SetParent inherits from FMX.Types.TFmxObject.SetParent. All content below this line refers to FMX.Types.TFmxObject.SetParent.
Protected setter implementation for the Parent property.</docstr>
      </procedure>
      <procedure name="ParentChanged">
        <docstr>Executed right after the value of the Parent property changes.
FMX.Menus.TMenuItem.ParentChanged inherits from FMX.Controls.TControl.ParentChanged. All content below this line refers to FMX.Controls.TControl.ParentChanged.
Executed right after the value of the Parent property changes.
The control does not execute ParentChanged if you assign Parent the same value that it already has.

 See Also
FMX.Controls.TControl.AncestorParentChanged
FMX.Controls.TControl.ClipChildrenChanged
FMX.Controls.TControl.EffectEnabledChanged
FMX.Controls.TControl.EnabledChanged
FMX.Controls.TControl.HandleSizeChanged
FMX.Controls.TControl.HitTestChanged
FMX.Controls.TControl.PaddingChanged
FMX.Controls.TControl.VisibleChanged
FMX.Controls.TControl.AncestorVisibleChanged
FMX.Controls.TControl.ChildrenAlignChanged</docstr>
      </procedure>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.Menus.TMenuItem.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.Menus.TMenuItem.FreeStyle inherits from FMX.Controls.TTextControl.FreeStyle. All content below this line refers to FMX.Controls.TTextControl.FreeStyle.
Frees the style of TStyledControl.
FreeStyle frees some TTextControl-specific style resources like TextObject and TextSettings, then calls the inherited TStyledControl.FreeStyle.</docstr>
      </procedure>
      <function name="GetItemsCount">
        <docstr>Returns the number of the visible TMenuItems from the Children property.
GetItemsCount determines and returns the number of the TMenuItem objects from the Children property, for which the Visible property is True.</docstr>
      </function>
      <function name="GetItem">
        <docstr>Returns the specified TMenuItem child.
GetItem searches in the Children property for the TMenuItem object specified by the value of the AIndex parameter, and returns it.

Note: Only TMenuItem objects are taken into account when iterating through the Children property.</docstr>
      </function>
      <procedure name="SetVisible">
        <docstr>Setter function for the Visible property.
In addition to FMX.Controls.TControl.SetVisible, SetVisible realigns the children of the Parent property so that, if Visible is False, the TMenuItem object is not displayed.</docstr>
      </procedure>
      <procedure name="SetEnabled">
        <docstr>Modifies the value of the Enabled property of this TMenuItem.</docstr>
      </procedure>
      <procedure name="DialogKey">
        <docstr>Processes a dialog key.
DialogKey is called during the message preprocessing to handle dialog characters. If the pressed keys match the ShortCut property, an OnClick event is triggered.
Do not call DialogKey in an application. It is for internal use only.
DialogKey processes the dialog key messages for each of the control&apos;s children.</docstr>
      </procedure>
      <function name="IsMenuBarItem">
        <docstr>It determines if the item is child of TMenuBar control.
The appearance of these menu items differs from all the others. For example: the default style is menubaritemstyle.</docstr>
      </function>
      <property name="Handle">
        <docstr>Represents the FireMonkey-specific handle of the TMenuItem.</docstr>
      </property>
      <property name="ImageOffset">
        <docstr>It is the additional text offset to the right, which is determined by the width of the picture.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Menus.TMenuItem.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Menus.TMenuItem.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="Clear">
        <docstr>Clears this TMenuItem.
Clear removes all the children menu items of this menu item.</docstr>
      </procedure>
      <function name="CalcSize">
        <docstr>Calculates the size of a TMenuItem as a TPointF.
Use CalcSize to determine the size of a TMenuItem object as a TPointF.

Note: The Y value of the TPointF returned is 8 for a separator, and 23 for a regular TMenuItem.</docstr>
      </function>
      <function name="CalcRenderSize">
        <docstr>CalcRenderSize determines the render size of this TMenuItem as a TPointF.</docstr>
      </function>
      <function name="CanBeClicked">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="ParentMenuItem">
        <docstr>It returns the parent menu item.</docstr>
      </property>
      <property name="MainMenu">
        <docstr>It returns the main menu to which the menu item is attached.</docstr>
      </property>
      <procedure name="Popup">
        <docstr>Creates and displays the TMenuItem&apos;s pop-up menu.
Popup creates and displays a pop-up menu containing all the visible TMenuItem children of the current object.

Note: The TMenuItem children for which the Visible property is False are not displayed.</docstr>
      </procedure>
      <procedure name="NeedPopup">
        <docstr>Displays the pop-up menu of the current TMenuItem object, after a short delay.
Use NeedPopup to display the pop-up menu of the current TMenuItem object, after a short delay.</docstr>
      </procedure>
      <function name="HavePopup">
        <docstr>Decides whether the current TMenuItem needs a pop-up menu.
A TMenuItem object needs a pop-up menu if at least one of the object&apos;s children is a TMenuItem.</docstr>
      </function>
      <property name="View">
        <docstr>For internal use.
Do not use this property. It is for internal use.</docstr>
      </property>
      <property name="ItemsCount">
        <docstr>Represents the number of child TMenuItems of this menu item.</docstr>
      </property>
      <property name="IsSelected">
        <docstr>Specifies whether the TMenuItem is selected. IsSelected is True if the TMenuItem is selected, and False otherwise.</docstr>
      </property>
      <property name="IsSeparator">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Images">
        <docstr>Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
If the TCustomImageList list is empty, then Images is nil/null.
Call ImagesChanged when Images is changed.</docstr>
      </property>
      <property name="Bitmap">
        <docstr>A bitmap that is drawn on the TMenuItem menu item.
Use Bitmap to provide a custom image that appears next to the text of the TMenuItem.
Bitmap is an obsolete feature. We recommend to show images stored in a centralized collection of images. Such image is specified with the ImageIndex property from the image list specified with Images. If an image specified with ImageIndex and Images is not empty, the TMenuItem object shows this image. Otherwise, the TMenuItem object shows the image specified in  Bitmap.</docstr>
      </property>
      <property name="AutoCheck">
        <docstr>Controls whether the IsChecked property toggles when the TMenuItem is clicked.
Set the AutoCheck property to True if the toggling of the IsChecked property is desired when the  TMenuItem is clicked, and to False otherwise.</docstr>
      </property>
      <property name="GroupIndex">
        <docstr>Identifies the group of TMenuItems to which this TMenuItem belongs.
A group of TMenuItems represents a set of TMenuItem objects belonging to the same pop-up menu, out of which only one TMenuItem, having the RadioItem property set to True, can be selected.

Note: TMenuItems belonging to different pop-up menus (that do not have the same value for the Parent property) can be simultaneously selected, even if their RadioItem property is True.
Note: By default, all TMenuItems belonging to the same pop-up menu have the same value for the GroupIndex property.</docstr>
      </property>
      <property name="RadioItem">
        <docstr>Specifies whether the TMenuItem is mutually exclusive with other menu items in its group.
Use RadioItem to make the menu item behave like a radio button with a group of other menu items. The group of menu items is the set of all menu items in a pop-up menu that have the same value of GroupIndex. When RadioItem is True, only one menu item in the group that contains the menu item can be selected at a time. The single selected menu item in the group is indicated by a check mark beside its text.

Note: RadioItem does not work for the top-level items in a main menu.</docstr>
      </property>
      <property name="IsChecked">
        <docstr>Specifies whether a check mark is displayed beside the text of the TMenuItem.
Use IsChecked to allow the TMenuItem to work like a check box. The menu item appears selected if IsChecked is True, and cleared otherwise.

Note: If AutoCheck is False, the menu item remains cleared even if IsChecked is True.</docstr>
      </property>
      <property name="ShortCut">
        <docstr>Shortcut that opens the menu item.</docstr>
      </property>
      <property name="ImageIndex">
        <docstr>Defines the zero-based index enumerating images in the Images list of images.
If you use a non-existing ImageIndex value to access an image in the Images list, then no image is retrieved and no exception is raised. The usual default value is -1. Call ImagesChanged when ImageIndex is changed.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Menus" name="TPopupMenu">
    <docstr>Represents a pop-up menu.
Use TPopupMenu to describe a menu that appears only when the Popup procedure is called. TPopupMenu appears at the coordinates indicated by the parameters of the Popup procedure.
TPopupMenu is composed of TMenuItems. You can add menu items in several ways:

To add a menu item at design time, do any of the following:
Right-click the component and select Add Item from the context menu.
Double-click the component and click the Add Item button on the Items Designer.
Right-click the component, select Items Editor from the context menu, and then click the Add Item button.
To add a menu item at run time, use the AddObject procedure of TPopupMenu.</docstr>
    <members>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.Menus.TPopupMenu.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoInsertObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.Menus.TPopupMenu.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <procedure name="ImagesChanged">
        <docstr>Should be called when the component needs to redraw the image.
ImagesChanged  should be called when you change the Images reference to the TCustomImageList object or the object itself.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Menus.TPopupMenu.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Menus.TPopupMenu.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="Clear">
        <docstr>Clears this TPopupMenu.
Clear removes all the child menu items of this pop-up menu.</docstr>
      </procedure>
      <procedure name="CloseMenu">
        <docstr>TPopupMenu descendants may implement CloseMenu to define actions made when the pop-up menu closes.  
CloseMenu does nothing. It is meant to be implemented by TPopupMenu descendants to describe actions made when the pop-up menu closes.</docstr>
      </procedure>
      <procedure name="Popup">
        <docstr>Displays the pop-up menu onscreen.
Call Popup to bring up the pop-up menu. The menu appears at the screen coordinates indicated by the values (in pixels) of X and Y.</docstr>
      </procedure>
      <property name="PopupPoint">
        <docstr>The point where the pop-up menu opens.</docstr>
      </property>
      <procedure name="DialogKey">
        <docstr>Processes a dialog key for each of the TPopupMenu&apos;s TMenuItems.
DialogKey is called during the message preprocessing to handle dialog characters. If the pressed keys match the ShortCut property of one of the TPopupMenu&apos;s TMenuItems, the OnClick event of that TMenuItem is triggered.</docstr>
      </procedure>
      <property name="ItemsCount">
        <docstr>Represents the number of child TMenuItems of this pop-up menu.</docstr>
      </property>
      <property name="Images">
        <docstr>Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
If the TCustomImageList list is empty, then Images is nil/null.
Call ImagesChanged when Images is changed.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Menus" name="TMenuBar">
    <docstr>Represents an editable menu bar.
TMenuBar describes the structure of a menu bar that can be moved, resized, and edited. TMenuBar is composed of TMenuItems.
Menu items can be added in several ways:

To add a menu item at design time, do any of the following:
Right-click the component and select Add Item from the context menu.
Double-click the component and click the Add Item button on the Items Designer.
Right-click the component, select Items Editor from the context menu, and then click the Add Item button.
To add a menu item at run time, use the AddObject procedure of the TMenuBar.
Use Items and ItemsCount to retrieve information about menu items.
TMenuBar:</docstr>
    <members>
      <function name="GetMenuItem">
        <docstr>Retrieves the TMenuItem specified by AIndex from the menu&apos;s list of children menu items.</docstr>
      </function>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Menus.TMenuBar.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="DoRealign">
        <docstr>Performs the alignment of a FireMonkey control.
FMX.Menus.TMenuBar.DoRealign inherits from FMX.Controls.TControl.DoRealign. All content below this line refers to FMX.Controls.TControl.DoRealign.
Performs the alignment of a FireMonkey control.

 See Also
FMX.Types.AlignObjects</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.Menus.TMenuBar.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoInsertObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DialogKey">
        <docstr>Processes a dialog key. 
FMX.Menus.TMenuBar.DialogKey inherits from FMX.Controls.TControl.DialogKey. All content below this line refers to FMX.Controls.TControl.DialogKey.
Processes a dialog key. 
DialogKey is called during the message preprocessing to handle dialog characters. 
Do not call DialogKey in an application. It is for internal use only.
DialogKey processes the dialog key messages for each of the control&apos;s children.</docstr>
      </procedure>
      <procedure name="DoUpdateOSMenu">
        <docstr>Updates the structure of the menu bar, if possible.</docstr>
      </procedure>
      <procedure name="SetVisible">
        <docstr>Setter function for the Visible property.
FMX.Menus.TMenuBar.SetVisible inherits from FMX.Controls.TControl.SetVisible. All content below this line refers to FMX.Controls.TControl.SetVisible.
Setter function for the Visible property. Value specifies the new value of the Visible property.</docstr>
      </procedure>
      <procedure name="ImagesChanged">
        <docstr>Should be called when the component needs to redraw the image.
ImagesChanged  should be called when you change the Images reference to the TCustomImageList object or the object itself.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.Menus.TMenuBar.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.Menus.TMenuBar.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.Menus.TMenuBar.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.Menus.TMenuBar.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Menus.TMenuBar.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Menus.TMenuBar.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="StartMenuLoop">
        <docstr>Starts the menu loop for this menu bar. There is no need to manually call StartMenuLoop in applications.</docstr>
      </procedure>
      <procedure name="Clear">
        <docstr>Clears this TMenuBar.
Clear removes all the children of this menu bar.</docstr>
      </procedure>
      <property name="ItemsCount">
        <docstr>Returns the total number of menu items in this menu bar.</docstr>
      </property>
      <property name="Images">
        <docstr>Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
If the TCustomImageList list is empty, then Images is nil/null.
Call ImagesChanged when Images is changed.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Menus" name="TMainMenu">
    <docstr>Describes the structure of the form&apos;s main menu.
Use TMainMenu to describe the structure of the form&apos;s main menu. TMainMenu is composed of TMenuItems. 
Menu items can be added in several ways:

To add a menu item at design time, do any of the following:
Right-click the component and select Add Item from the context menu.
Double-click the component and click the Add Item button on the Items Designer.
Right-click the component, select Items Editor from the context menu, and then click the Add Item button.
To add a menu item at run time, use the AddObject procedure of the TMainMenu.</docstr>
    <members>
      <procedure name="ParentChanged">
        <docstr>Notification method called after the parent is changed.
FMX.Menus.TMainMenu.ParentChanged inherits from FMX.Types.TFmxObject.ParentChanged. All content below this line refers to FMX.Types.TFmxObject.ParentChanged.
Notification method called after the parent is changed. ParentChanged is a virtual method to be implemented in subclasses to allow for changing the parent of this FMX object.</docstr>
      </procedure>
      <procedure name="DoRecreateOSMenu">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.Menus.TMainMenu.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoInsertObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.Menus.TMainMenu.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <procedure name="ImagesChanged">
        <docstr>Should be called when the component needs to redraw the image.
ImagesChanged  should be called when you change the Images reference to the TCustomImageList object or the object itself.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Menus.TMainMenu.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Menus.TMainMenu.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="BeforeDestruction">
        <docstr>Performs any necessary actions before the first destructor is called.
FMX.Menus.TMainMenu.BeforeDestruction inherits from System.Classes.TComponent.BeforeDestruction. All content below this line refers to System.Classes.TComponent.BeforeDestruction.
Performs any necessary actions before the first destructor is called.
BeforeDestruction is called automatically immediately before the component&apos;s first destructor executes. Do not call it explicitly in your applications.
As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place.</docstr>
      </procedure>
      <procedure name="RecreateOSMenu">
        <docstr>Recreates the OS specific menu.</docstr>
      </procedure>
      <procedure name="Exchange">
        <docstr>Exchanges two objects from the children list.
FMX.Menus.TMainMenu.Exchange inherits from FMX.Types.TFmxObject.Exchange. All content below this line refers to FMX.Types.TFmxObject.Exchange.
Exchanges two objects from the children list. Exchange exchanges AObject1 with AObject2.</docstr>
      </procedure>
      <procedure name="DialogKey">
        <docstr>Processes a dialog key for every item in the menu.
Do not call DialogKey in an application. It is for internal use only.</docstr>
      </procedure>
      <property name="ItemsCount">
        <docstr>Represents the number of child menu items of this menu.</docstr>
      </property>
      <property name="Images">
        <docstr>Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
If the TCustomImageList list is empty, then Images is nil/null.
Call ImagesChanged when Images is changed.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.SpinBox" name="TSpinBoxModel">
    <docstr></docstr>
    <members>
      <property name="RepeatClick">
        <docstr>Need makes several clicks until the user didn&apos;t raise a finger from the screen.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.SpinBox" name="TSpinBox">
    <docstr>A special presented edit box equipped with buttons to increment or decrement the displayed numeric value.
TSpinBox is a special edit box that can display only numerical values and is equipped with the Increase and Decrease buttons for incrementing or decrementing the displayed value.</docstr>
    <members>
      <function name="DefineModelClass">
        <docstr>Returns a class reference to a data model of this presented control.
FMX.SpinBox.TSpinBox.DefineModelClass inherits from FMX.Controls.Presentation.TPresentedControl.DefineModelClass. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefineModelClass.
Returns a class reference to a data model of this presented control.
Returns a class reference to a data model class that the constructor of this presented control uses to create a data model for the control.
By default DefineModelClass returns TDataModel. Descendant classes reimplement DefineModelClass to determine the data model class that a descendant presented control uses for its data model.

 See Also
FMX.Controls.Model.TDataModelClass
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Presentation.Style.TStyledPresentation.DefineModelClass
Class References</docstr>
      </function>
      <function name="DefinePresentationName">
        <docstr>Returns the name of the default presentation proxy that your presented control uses.
FMX.SpinBox.TSpinBox.DefinePresentationName inherits from FMX.Controls.Presentation.TPresentedControl.DefinePresentationName. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefinePresentationName.
Returns the name of the default presentation proxy that your presented control uses.
You can handle OnPresentationNameChoosing to specify a presentation proxy name to use instead of the name that DefinePresentationName returns.
DefinePresentationName  calls TPresentationProxyFactory.GeneratePresentationName and returns a generated  presentation proxy name based on the class name of the presented control and the control type (Styled or Platform) of the presentation layer. For example:



Class name

Control type

Result


TMyPresentedControl

Styled

&quot;MyPresentedControl-Styled&quot;


TMyPresentedControl

Platform

&quot;MyPresentedControl-Platform&quot;

 See Also
System.TObject.ClassName
FMX.Controls.Presentation.TPresentedControl.ControlType
FMX.Presentation.Factory.TPresentationProxyFactory.Register
FMX.Controls.Presentation.TPresentationProxy
FMX.Controls.Presentation.TPresentedControl.OnPresentationNameChoosing
FMX.Controls.Presentation.TPresentedControl.LoadPresentation</docstr>
      </function>
      <property name="Model">
        <docstr>Returns the Model of the TSpinBox with TSpinBoxModel type.</docstr>
      </property>
      <property name="Increment">
        <docstr>Specifies the numerical value that will be used as an increment or decrement factor for this spin box.
For instance, if you set the Increment value to 5, then pressing the plus (increment) button will increase the display value by 5. Pressing the minus (decrement) button will decrease the display value by 5.
However, if, for instance, Value is 4, Increment is 5, and Min is 0 and you press the minus (decrement) button, the value will become 0. In a similar manner, if, for instance, Value is 8, Increment is 5, and Max is 10 and you press the plus (increment) button, the value will become 10.</docstr>
      </property>
      <property name="RepeatClick">
        <docstr>Determines whether the TSpinBox does several clicks when the user keeps the button held down. 
When RepeatClick is True, the user can hold the button down to do several clicks until the button is released.
By default the RepeatClick property is set to False.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.TabControl" name="TTabItem">
    <docstr>TTabItem is a tab item in a TTabControl component. A TTabControl contains one or more TTabItem objects.
The Text property can be used to define an accelerator key to the control.</docstr>
    <members>
      <procedure name="CalcSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="InvalidateSize">
        <docstr>Changes the size state from Calculated to Invalid so that the size is re-calculated later.
InvalidateSize returns False if the call is performed at the moment of calculation. That is, when the size state is Calculating.</docstr>
      </function>
      <function name="RealignTabs">
        <docstr>Calls TTabControl.RealignTabs.
RealignTabs returns False if the call to TTabControl.RealignTabs is not executed. For example, in the case of recursive calls.</docstr>
      </function>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.TabControl.TTabItem.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <procedure name="ChangeOrder">
        <docstr>Notification method called after the creation order is changed.
FMX.TabControl.TTabItem.ChangeOrder inherits from FMX.Types.TFmxObject.ChangeOrder. All content below this line refers to FMX.Types.TFmxObject.ChangeOrder.
Notification method called after the creation order is changed. ChangeOrder is a virtual method to be implemented in subclasses to allow for changing the creation order of this FMX object.</docstr>
      </procedure>
      <property name="Info">
        <docstr>Holds information about the size of the tab title.
The CalcSize method initializes the Info property.</docstr>
      </property>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.TabControl.TTabItem.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoChanged">
        <docstr>Updates the representation of the text on the control.
FMX.TabControl.TTabItem.DoChanged inherits from FMX.Controls.TTextControl.DoChanged. All content below this line refers to FMX.Controls.TTextControl.DoChanged.
Updates the representation of the text on the control.
DoChanged is called internally from the Change methods.
Do not call DoChanged explicitly; call the Change  method.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.TabControl.TTabItem.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="SetText">
        <docstr>Protected setter implementation for the Text property.
FMX.TabControl.TTabItem.SetText inherits from FMX.Controls.TTextControl.SetText. All content below this line refers to FMX.Controls.TTextControl.SetText.
Protected setter implementation for the Text property.
In descendants, override SetText to allow for further functionality when setting the text using the Text property.
Do not use SetText directly in applications. Use the Text property instead.</docstr>
      </procedure>
      <function name="FindTextObject">
        <docstr>Retrieves the resource object linked to the style of the current TTextControl object.
FMX.TabControl.TTabItem.FindTextObject inherits from FMX.Controls.TTextControl.FindTextObject. All content below this line refers to FMX.Controls.TTextControl.FindTextObject.
Retrieves the resource object linked to the style of the current TTextControl object.
In the current implementation, FindTextObject retrieves the resource object linked to the &apos;text&apos; style.</docstr>
      </function>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.TabControl.TTabItem.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.TabControl.TTabItem.FreeStyle inherits from FMX.Controls.TTextControl.FreeStyle. All content below this line refers to FMX.Controls.TTextControl.FreeStyle.
Frees the style of TStyledControl.
FreeStyle frees some TTextControl-specific style resources like TextObject and TextSettings, then calls the inherited TStyledControl.FreeStyle.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.TabControl.TTabItem.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.TabControl.TTabItem.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseClick">
        <docstr>Calls Click and starts the animation by calling StartTriggerAnimation.
FMX.TabControl.TTabItem.MouseClick inherits from FMX.Controls.TControl.MouseClick. All content below this line refers to FMX.Controls.TControl.MouseClick.
Calls Click and starts the animation by calling StartTriggerAnimation.
MouseClick receives the following parameters: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys -- SHIFT, CTRL, ALT, and CMD (only for Mac) -- were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
 See Also
FMX.Controls.TControl.Click
FMX.Controls.TControl.OnClick
FMX.Controls.TControl.OnMouseLeave
FMX.Controls.TControl.OnMouseEnter
FMX.Controls.TControl.OnMouseMove
FMX.Controls.TControl.OnMouseDown
FMX.Controls.TControl.OnMouseWheel
System.Classes.TShiftState
System.UITypes.TMouseButton
FMX.Ani.TAnimator.StartTriggerAnimation</docstr>
      </procedure>
      <procedure name="DblClick">
        <docstr>Responds to user double-clicks.
FMX.TabControl.TTabItem.DblClick inherits from FMX.Controls.TControl.DblClick. All content below this line refers to FMX.Controls.TControl.DblClick.
Responds to user double-clicks.
DblClick is an event handler for the OnDblClick event. It is automatically called when the left mouse button is pressed and released twice, consecutively, with the pointer over the control.
Call DblClick in applications to simulate a mouse OnDblClick event.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.TabControl.TTabItem.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Provides a response when a key is pressed down while the control has the keyboard focus. 
FMX.TabControl.TTabItem.KeyDown inherits from FMX.Controls.TControl.KeyDown. All content below this line refers to FMX.Controls.TControl.KeyDown.
Provides a response when a key is pressed down while the control has the keyboard focus. 
If the pressed key is the Applications key (Key = vkApps), then KeyDown shows the context menu of the control. Otherwise, KeyDown calls the OnKeyDown event handler if one is assigned. 
TCommonCustomForm and descendant of TControl classes--like TCustomGrid--call KeyDown from their methods handling key pressing. They decode the message parameters into the key code, character code, and shift state. They pass them into the called KeyDown method in the Key, KeyChar, and Shift parameters, respectively:  



Parameters

Descriptions



Key



Is the scan code of the pressed keyboard key or $0.
If a pressed key combination can be a shortcut, then Key &lt;&gt; 0 is a virtual key and KeyChar = #0. 
Physical scan codes of the same key can differ under different platforms (Windows or iOS).
Platform-specific units (for example FMX.Platform.Mac.pas) should translate native scan codes to corresponding Windows codes defined in the UITypes unit.  For example, 

vkReturn = $0D;  {  13 } corresponds to the RETURN keyboard key.
vkF2     = $71;  { 113 } corresponds to the F2 keyboard key.



KeyChar



Is the pressed character (digit) or #0.
If a pressed key combination can be treated as a printable character or digit, then Key = 0 and KeyChar contains a pressed symbol according to the current keyboard&apos;s input language, keyboard mode (CAPS LOCK and NUM LOCK keys), keyboard Shift state, and IME state. Editors can use this symbol to add into a text being edited. 




Shift



Indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the specified key was pressed with the control in focus.


If the control has successfully processed the pressed key combination and no additional processing is required, then KeyDown assigns Key = 0 and KeyChar = #0.  
Override the protected KeyDown method to provide other responses when a key is down while the control has keyboard input focus.
See TCommonCustomForm.KeyDown for more information about parameters.</docstr>
      </procedure>
      <procedure name="ImagesChanged">
        <docstr>Should be called when the component needs to redraw the image.
ImagesChanged should be called
when you change the Images reference to the TCustomImageList object or 
the object itself or when you change the ImageIndex property.</docstr>
      </procedure>
      <function name="ImageIndexStored">
        <docstr>Returns True when the ImageIndex property needs to be stored in the fmx-file.</docstr>
      </function>
      <procedure name="ParentChanged">
        <docstr>Executed right after the value of the Parent property changes.
FMX.TabControl.TTabItem.ParentChanged inherits from FMX.Controls.TControl.ParentChanged. All content below this line refers to FMX.Controls.TControl.ParentChanged.
Executed right after the value of the Parent property changes.
The control does not execute ParentChanged if you assign Parent the same value that it already has.

 See Also
FMX.Controls.TControl.AncestorParentChanged
FMX.Controls.TControl.ClipChildrenChanged
FMX.Controls.TControl.EffectEnabledChanged
FMX.Controls.TControl.EnabledChanged
FMX.Controls.TControl.HandleSizeChanged
FMX.Controls.TControl.HitTestChanged
FMX.Controls.TControl.PaddingChanged
FMX.Controls.TControl.VisibleChanged
FMX.Controls.TControl.AncestorVisibleChanged
FMX.Controls.TControl.ChildrenAlignChanged</docstr>
      </procedure>
      <procedure name="Hide">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Show">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="DoSetSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="Align">
        <docstr>Specifies the alignment options (top, left, client, and so on) of this control. 
Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale.</docstr>
      </property>
      <property name="RotationAngle">
        <docstr>Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
To set the rotation center, use RotationCenter.</docstr>
      </property>
      <property name="RotationCenter">
        <docstr>Specifies the position of the pivot point of the control.
The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
To set the rotation angle, use RotationAngle.</docstr>
      </property>
      <property name="Position">
        <docstr>Aligns the component to the position points of other components (Bounds points).
Specifies the upper-left corner of the current control, relative to its parent. 
The Position can be affected by the Padding of its parent and the Margins of the control.</docstr>
      </property>
      <function name="GetTextSettingsClass">
        <docstr>Returns the class type that instance represents the used text settings.
FMX.TabControl.TTabItem.GetTextSettingsClass inherits from FMX.Controls.TTextControl.GetTextSettingsClass. All content below this line refers to FMX.Controls.TTextControl.GetTextSettingsClass.
Returns the class type that instance represents the used text settings.
GetTextSettingsClass returns the TTextSettingsInfo.TCustomTextSettingsClass (or its descendant)  class reference. An instance of such class provides the DefaultTextSettings,   TextSettings, StyledSettings, ResultingTextSettings, and other properties handling the text representation settings of a control. 
You can override the method in descendant classes to modify the default behavior.
Typical implementations of GetTextSettingsClass returns the class declaring properties like the Font, FontColor, HorzAlign, and WordWrap. Some of these properties can be declared as published to be editable in the Object Inspector.

 See Also
FMX.Controls.TTextSettingsInfo
FMX.Controls.TTextSettingsInfo.TCustomTextSettingsClass
FMX.Controls.TTextSettingsInfo.DefaultTextSettings
FMX.Controls.TTextSettingsInfo.TextSettings
FMX.Controls.TTextSettingsInfo.StyledSettings
FMX.Controls.TTextSettingsInfo.ResultingTextSettings</docstr>
      </function>
      <procedure name="CMGesture">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="TriggerAcceleratorKey">
        <docstr>Allows the object to perform an action when the accelerator key is pressed.
FMX.TabControl.TTabItem.TriggerAcceleratorKey inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey.
Allows the object to perform an action when the accelerator key is pressed.
Use TriggerAcceleratorKey to trigger an action as a response to the accelerator key. For example, use TriggerAcceleratorKey to set focus to the acceleration key receiver control.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.CanTriggerAcceleratorKey</docstr>
      </procedure>
      <procedure name="PaintChildren">
        <docstr>Renders the child controls.
FMX.TabControl.TTabItem.PaintChildren inherits from FMX.Controls.TControl.PaintChildren. All content below this line refers to FMX.Controls.TControl.PaintChildren.
Renders the child controls.
The PaintChildren method is called automatically in the process of painting of the current control. It renders child controls, if any, on the surface specified by the Canvas property. 
The effects that are applied to the control are also applied to its children.
TControl descendants can override PaintChildren to provide specific rendering of the respective controls.</docstr>
      </procedure>
      <procedure name="Painting">
        <docstr>OnPainting event dispatcher. 
FMX.TabControl.TTabItem.Painting inherits from FMX.Controls.TControl.Painting. All content below this line refers to FMX.Controls.TControl.Painting.
OnPainting event dispatcher. 
Painting defines the drawing area of the control by intersecting Canvas with ClipRect if ClipChildren is True and dispatches the OnPainting event.
It is always called internally before DoPaint. 
The Painting method can be overridden by derived controls to establish control-specific rendering conditions.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.TabControl.TTabItem.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="DoPaint">
        <docstr>Processes the painting of the control. 
FMX.TabControl.TTabItem.DoPaint inherits from FMX.Controls.TControl.DoPaint. All content below this line refers to FMX.Controls.TControl.DoPaint.
Processes the painting of the control. 
This method is called internally from PaintTo and PaintChildren. DoPaint defines the drawing area by clipping the Canvas to the areas occupied by the control and its children, paints the children and then the control itself. The call to DoPaint is always preceded by a call to Painting and succeeded by a call to AfterPaint.</docstr>
      </procedure>
      <procedure name="AfterPaint">
        <docstr>Restores Canvas properties after the painting process. 
FMX.TabControl.TTabItem.AfterPaint inherits from FMX.Controls.TControl.AfterPaint. All content below this line refers to FMX.Controls.TControl.AfterPaint.
Restores Canvas properties after the painting process. 
As implemented in TControl, AfterPaint does nothing.
TShape descendants of TControl override AfterPaint to restore Dash and  Thickness to default values.</docstr>
      </procedure>
      <property name="PaintPart">
        <docstr>Specifies the part of the page that needs to be painted. 
The tab control sets the PaintPart property during painting.</docstr>
      </property>
      <property name="Content">
        <docstr>Contains all the controls that you place on the TabItem.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.TabControl.TTabItem.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.TabControl.TTabItem.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <function name="GetTabList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="TabControl">
        <docstr>Returns a TTabControl object that holds this tab page.


Note: You cannot access this TTabControl using the TTabItem.Parent property.</docstr>
      </property>
      <property name="ShowAsDot">
        <docstr>If ShowAsDot is true, then the StyleLookup property has the value tabdotstyle.</docstr>
      </property>
      <property name="Images">
        <docstr>Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
If the TCustomImageList list is empty, then Images is nil/null.
Call ImagesChanged when Images is changed.</docstr>
      </property>
      <property name="AutoSize">
        <docstr>Specifies whether TTabItem header (where the TabItem names appear) is auto-sized based on the length of the Text. 
Set the AutoSize property to True to automatically resize the tab item header according to the length of the Text.
Set the AutoSize property to False to lock autoresize of the TTabItem header.

Tip:  The size of the TTabItem header readjusts when the Font property changes.</docstr>
      </property>
      <property name="CustomIcon">
        <docstr>Specifies custom multi-resolution icons for the tab. This property is of the TFixedMultiResBitmap type. 
A TFixedMultiResBitmap multi-resolution bitmap represents a collection of TFixedBitmapItem bitmap items displayed at different scales. You can create a multi-resolution bitmap with the MultiResBitmap Editor.
Mobile applications need to have images of different scales defined for various devices, such as Retina and non-Retina iOS devices.</docstr>
      </property>
      <property name="IsSelected">
        <docstr>Property that has the True value when the TTabItem object is selected.
IsSelected is a property of TTabItem that has the Boolean value True if the tab item is selected. Otherwise, it has the Boolean value False.</docstr>
      </property>
      <property name="ImageIndex">
        <docstr>Defines the zero-based index enumerating images in the Images list of images.
If you use a non-existing ImageIndex value to access an image in the Images list, then no image is retrieved and no exception is raised. The usual default value is -1. Call ImagesChanged when ImageIndex is changed.</docstr>
      </property>
      <property name="StyleLookup">
        <docstr>Name of the ressource object, to which the current TStyledControl is linked.
If ShowAsDot is True, the name of the ressource object is &quot;tabdotstyle&quot; and you cannot overwrite it. To use a custom resource object name, first ensure that the value of ShowAsDot is False.
For more information, see TStyledControl.StyleLookup.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.TabControl" name="TTabControl">
    <docstr>TTabControl is a tab set that has the appearance of notebook dividers.
Use TTabControl to add a control with multiple tab settings to a FireMonkey form. When the current tab changes, the tab control must directly update its contents to reflect the change, in an OnChange event handler.
Disabling a TTabControl object disables all tabs at once. To enable or disable specific tabs, you can programmatically use the Tabs property as in the following code snippet where the tab with the index of 1 is rendered as disabled:

  TabControl1.Tabs[1].Enabled := False;

Use TTabControl to create rich graphical interfaces with great functionality, such as options and configurations for a specific application.

Code Examples
FMX.ControlsDemo Sample
FMX.MusicPlayer Sample
FMX.TabSlideTransition Sample</docstr>
    <members>
      <field name="ButtonStyleNames">
        <docstr>The styles names which used for the buttons in the header area</docstr>
      </field>
      <function name="GetTabItem">
        <docstr>Protected getter implementation for the Tabs property.</docstr>
      </function>
      <function name="GetTabCount">
        <docstr>Protected read implementation for the TabCount property.</docstr>
      </function>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.TabControl.TTabControl.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.TabControl.TTabControl.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.TabControl.TTabControl.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <procedure name="PaintChildren">
        <docstr>Renders the child controls.
FMX.TabControl.TTabControl.PaintChildren inherits from FMX.Controls.TControl.PaintChildren. All content below this line refers to FMX.Controls.TControl.PaintChildren.
Renders the child controls.
The PaintChildren method is called automatically in the process of painting of the current control. It renders child controls, if any, on the surface specified by the Canvas property. 
The effects that are applied to the control are also applied to its children.
TControl descendants can override PaintChildren to provide specific rendering of the respective controls.</docstr>
      </procedure>
      <procedure name="RealignTabs">
        <docstr>Realigns tabs according to the number of visible tabs, their sizes and offsets.</docstr>
      </procedure>
      <procedure name="DoRealign">
        <docstr>Performs the alignment of a FireMonkey control.
FMX.TabControl.TTabControl.DoRealign inherits from FMX.Controls.TControl.DoRealign. All content below this line refers to FMX.Controls.TControl.DoRealign.
Performs the alignment of a FireMonkey control.

 See Also
FMX.Types.AlignObjects</docstr>
      </procedure>
      <procedure name="ContentAddObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ContentRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.TabControl.TTabControl.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoInsertObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoChange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DialogKey">
        <docstr>Processes a dialog key. 
FMX.TabControl.TTabControl.DialogKey inherits from FMX.Controls.TControl.DialogKey. All content below this line refers to FMX.Controls.TControl.DialogKey.
Processes a dialog key. 
DialogKey is called during the message preprocessing to handle dialog characters. 
Do not call DialogKey in an application. It is for internal use only.
DialogKey processes the dialog key messages for each of the control&apos;s children.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.TabControl.TTabControl.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="GetEffectiveTabPosition">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetEffectiveFullSize">
        <docstr>Used to determine whether the tab buttons take up all the space in the tabs band. 
If the FullSize property is PlatformDefault, GetEffectiveFullSize returns True if the style element FullSize is found. Otherwise, GetEffectiveFullSize returns the same as the FullSize property.</docstr>
      </function>
      <function name="ObjectAtPoint">
        <docstr>Tries to find a control using specific coordinates on the screen. 
First, the search is performed among the additional buttons in the area of titles. Then, the search is performed among the tab titles. After that, the search goes to the general rules set by its ancestor TControl.ObjectAtPoint.</docstr>
      </function>
      <procedure name="MouseWheel">
        <docstr>Dispatcher for the OnMouseWheel event. 
TTabControl calls MouseWheel in response to mouse wheel rotation while the cursor is over the control.
MouseWheel scrolls between the tab items when there is not enough space to display all tab items.
See TControl.MouseWheel for further details.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.TabControl.TTabControl.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <procedure name="ImagesChanged">
        <docstr>Should be called when the component needs to redraw the image.
ImagesChanged  should be called when you change the Images reference to the TCustomImageList object or the object itself.</docstr>
      </procedure>
      <procedure name="DoUpdateTabBarButtons">
        <docstr>Called by UpdateTabBarButtons to update the state of the buttons in the area of the tabs titles. 
You can override this method to change the location and the appearance of the buttons in the area of the tabs titles.

Note: DoUpdateTabBarButtons is called from the UpdateTabBarButtons method; you should not call the DoUpdateTabBarButtons method manually.</docstr>
      </procedure>
      <procedure name="EnabledChanged">
        <docstr>Executes when the value of the Enabled property changes.</docstr>
      </procedure>
      <procedure name="PreloadContent">
        <docstr>Forces to load all styles, measure sizes, build font-glyphs, etc.</docstr>
      </procedure>
      <procedure name="DisableDisappear">
        <docstr>Disables automatically unloading style, when control is not visible on screen for tree with root AControl.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.TabControl.TTabControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.TabControl.TTabControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="SetActiveTabWithTransition">
        <docstr>Sets the focused tab using the specified transition.
SetActiveTabWithTransition sets the currently active tab to ATab using the specified ATransition and ADirection transition parameters.
ATransition specifies the type of transition used to switch the tab. When ATransition = Slide, then the tab control uses visual animation for the switching action. It means that moving of contents in the switched tabs is animated.
ADirection specifies the direction in which the content of the current active tab is replaced with the content of the specified ATab tab. ADirection is considered only when ATransition = Slide. If ADirection = Normal, then the forward left-to-right tab items switching transition animation is used. If ADirection = Reversed, then the backward right-to-left tab items switching transition animation is used. The default is Normal.
Compare with GotoVisibleTab.

Note: SetActiveTabWithTransition Does not work on Android.</docstr>
      </procedure>
      <procedure name="SetActiveTabWithTransitionAsync">
        <docstr>Changes the currently active tab to a new ATab asynchronously.
When the animation ends, callback AOnFinish is called.

Note: SetActiveTabWithTransitionAsync is required when working on Android.</docstr>
      </procedure>
      <procedure name="SetActiveTabWithTransitionAsync">
        <docstr>Changes the currently active tab to a new ATab asynchronously.
When the animation ends, callback AOnFinish is called.

Note: SetActiveTabWithTransitionAsync is required when working on Android.</docstr>
      </procedure>
      <procedure name="FinishCurrentTabTransition">
        <docstr>Finishes current tabs transition.</docstr>
      </procedure>
      <function name="FindVisibleTab">
        <docstr>Returns the first visible tab from the current tab.
Use the FindVisibleTab method to get the first visible tab of type FindKind.
The first overloaded method calculates the index of the found tab in the Index parameter. Index represents:

At input, the index of the tab where the search begins.
At output, if the returned value is True, the index of the found tab; otherwise, the old value.
The second overloaded method returns the index of the found tab. Searching starts with the current tab. If the tab is found, it return its index, otherwise it returns -1.</docstr>
      </function>
      <function name="FindVisibleTab">
        <docstr>Returns the first visible tab from the current tab.
Use the FindVisibleTab method to get the first visible tab of type FindKind.
The first overloaded method calculates the index of the found tab in the Index parameter. Index represents:

At input, the index of the tab where the search begins.
At output, if the returned value is True, the index of the found tab; otherwise, the old value.
The second overloaded method returns the index of the found tab. Searching starts with the current tab. If the tab is found, it return its index, otherwise it returns -1.</docstr>
      </function>
      <procedure name="GoToActiveTab">
        <docstr>Moves the title area of the tabs so that the active tab is visible.
The movement of the tabs is asynchronous.</docstr>
      </procedure>
      <function name="GotoVisibleTab">
        <docstr>Sets the focused tab using the specified transition. Animation of the switch transition depends on mutual positions of the current focused tab and the specified tab.
GotoVisibleTab switches the active tab to the tab specified by the Index parameter if possible (the tab with the specified Index exists and it is visible). GotoVisibleTab switches the active tab using the switch transition specified by the ATransition and ADirection parameters and taking into account mutual positions of the current active tab and the tab specified by Index.
ATransition specifies the type of transition used to switch the tab. When ATransition = Slide, then the tab control uses visual animation for the switching action. That is, moving of contents in the switched tabs is animated. The default ATransition is Slide.  
ADirection specifies the direction in which the content of the current active tab is replaced with the content of the specified Index tab. ADirection is taken into account only when ATransition = Slide. GotoVisibleTab animates switching transitions of tabs taking into account mutual positions of the current active tab and the tab specified by Index:

When ADirection = Normal. If the destination tab is left of the current active tab (lower Index), then the forward left-to-right switching transition animation of tab items is used. If the tab to display is to the right of the active tab (upper Index), then the backward right-to-left switching transition animation of tab items is used.
When ADirection = Reversed, then the switching transitions uses the opposite animation directions to the described above.
The default ADirection is Normal.
In difference to SetActiveTabWithTransition, the 
GotoVisibleTab method animates the switch transition depending on mutual positions of the current focused tab and the specified Index tab.
GotoVisibleTab returns True in case of success and False otherwise.</docstr>
      </function>
      <function name="Next">
        <docstr>Moves the active tab to the next tab.
Use the Next method to move over to the following tab, if it exists.
ATransition specifies the type of transition used to switch the tab.
ADirection specifies the direction in which the content of the tab is replaced with the content of the next tab.</docstr>
      </function>
      <function name="Previous">
        <docstr>Moves the active tab to the previous tab.
Use the Previous method to move over to the previous tab, if it exists.
ATransition specifies the type of transition used to switch the tab.
ADirection specifies the direction in which the content of the tab is replaced with the content of the previous tab.</docstr>
      </function>
      <function name="First">
        <docstr>Moves to the first visible tab in the tab control.
Use the First method to set the active tab to the first visible tab in the tab control.
ATransition specifies the type of transition used to switch the tab.
ADirection specifies the direction in which the content of the tab is replaced with the content of the first tab.</docstr>
      </function>
      <function name="Last">
        <docstr>Moves to the last visible tab in the tab control.
Use the Last method to set the active tab to the last visible tab in the tab control.
ATransition specifies the type of transition used to switch the tab.
ADirection specifies the direction in which the content of the tab is replaced with the content of the last tab.</docstr>
      </function>
      <function name="Delete">
        <docstr>Deletes a tab from the tab control.
Use the Delete method to delete the tab specified by AIndex from the tab control.</docstr>
      </function>
      <function name="Add">
        <docstr>Adds a new tab to the tab control.
Use the Add method to create a new tab object and add it to the tab control. The type of the tab object is specified by the TabClass parameter.
If TabClass is nil, the created tab object will have the default type TTabItem.</docstr>
      </function>
      <function name="Insert">
        <docstr>Inserts a new tab on the specified position.
Use the Insert method to create a new tab object and insert it on the position specified by Index. 
The type of the tab object is specified by the TabClass parameter. If TabClass is nil, the created tab object will have the default type TTabItem.
The Index parameter is 0-based.</docstr>
      </function>
      <function name="HasActiveTab">
        <docstr>Determines whether there is an active tab in the tab control.
HasActiveTab returns True if one of the tabs in the tab control is selected and False otherwise.
The tab control has an active tab if TabIndex is between 0 and TabCount-1.</docstr>
      </function>
      <function name="GetTabList">
        <docstr>Returns the list of tabs contained in this tab control.</docstr>
      </function>
      <procedure name="UpdateTabBarButtons">
        <docstr>Updates the state of the buttons in the area of the tab titles. 
UpdateTabBarButtons calls the DoUpdateTabBarButtons method.</docstr>
      </procedure>
      <property name="TabCount">
        <docstr>Specifies the number of tabs that are present on this tab control component.
Read the TabCount property to obtain the number of tab items that this tab control component has. If there are no tabs present, reading the TabCount property obtains 0.</docstr>
      </property>
      <property name="AniCalculations">
        <docstr>Represents the settings for the inertial scrolling that controls the movement in the title area of the tabs.</docstr>
      </property>
      <property name="TabBarRect">
        <docstr>The coordinates of the rectangle where all the tab titles are placed.</docstr>
      </property>
      <property name="TabContentSize">
        <docstr>The size of the area that contains all the tab titles.</docstr>
      </property>
      <property name="TabContentPosition">
        <docstr>Offset of the area of the tab headers.</docstr>
      </property>
      <property name="TransitionRunning">
        <docstr>Determines whether the transition between tabs is currently running.
TransitionRunning returns True if the transition between tabs is currently running and False otherwise.</docstr>
      </property>
      <property name="EffectiveTabPosition">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="EffectiveFullSize">
        <docstr>Indicates whether the tab buttons take up all the space in the tabs band. 
See its getter method GetEffectiveFullSize for further details.</docstr>
      </property>
      <property name="HasTouchScreen">
        <docstr>Indicates whether the device the application runs on has a touch screen. 
When HasTouchScreen is True the device where the application runs on has a touch screen.</docstr>
      </property>
      <property name="TabBarButtons">
        <docstr>Specifies the buttons to be displayed in the field names of the tabs. 
The set of buttons displayed depends on various factors: the availability of the touch screen, the location of the headers, and the number of tabs.</docstr>
      </property>
      <property name="ActiveTab">
        <docstr>Specifies the currently active tab.
ActiveTab sets or gets the currently active (focused) tab item on the current tab control.</docstr>
      </property>
      <property name="FullSize">
        <docstr>Specifies whether the tab buttons occupy all the space in the tabs band.
Set the FullSize property to True in order for the clickable tab buttons to take up all the space in the tabs band. For instance, if you have a tab control component of a fairly large width and only two tabs, then setting FullSize to True will make the two tab buttons span over the entire width of the tab control.
Set FullSize to False to let Delphi automatically adjust the way the tab buttons occupy the space.</docstr>
      </property>
      <property name="Images">
        <docstr>Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
If the TCustomImageList list is empty, then Images is nil/null.
Call ImagesChanged when Images is changed.</docstr>
      </property>
      <property name="TabHeight">
        <docstr>Specifies the height, in pixels, of the clickable tabs&apos; captions.
Use the TabHeight property to specify the height, in pixels, of the band that holds all the clickable tab buttons that correspond to individual tabs of this tab control component.</docstr>
      </property>
      <property name="TabIndex">
        <docstr>Specifies the index of the active tab.
Use the TabIndex property to set or get the index of the tab that is active (focused) on this tab control component. A value of 0 indicates that the first tab is active, while a value of -1 indicates that none of the tabs is active, or there are none present.</docstr>
      </property>
      <property name="TabPosition">
        <docstr>Specifies the position of the tabs on this TTabControl component.
The default value of the TTabPosition property is PlatformDefault. 
Refer to the TTabPosition help topic for the description of the possible tab positions.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs immediately after changing the active tab on this tab control component.
Write an OnChange event handler to provide additional functionality when changing the active tab of this tab control component.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.MultiView" name="TMultiViewPresentation">
    <docstr></docstr>
    <members>
      <function name="GetParentWidth">
        <docstr>Returns multi view parent width.</docstr>
      </function>
      <function name="GetParentHeight">
        <docstr>Returns multi view parent height.</docstr>
      </function>
      <procedure name="SetExpandedSize">
        <docstr>Sets size of MultiView in opened state.</docstr>
      </procedure>
      <function name="GetExpandedSize">
        <docstr>If controls supports opening and closing, returns size of multiview in opened state.</docstr>
      </function>
      <function name="GetCollapsedSize">
        <docstr>If controls supports opening and closing, returns size of multiview in closed state.</docstr>
      </function>
      <procedure name="DoInstall">
        <docstr>Used for making initialization of presentation and storing previous state of MultiView.</docstr>
      </procedure>
      <procedure name="DoUninstall">
        <docstr>Used for making finalization of presentation and restoring previous state of MultiView.</docstr>
      </procedure>
      <procedure name="DoOpen">
        <docstr>Defines logic of opening MultiView. Parameter can define speed of opening, if presentation supports it.</docstr>
      </procedure>
      <procedure name="DoClose">
        <docstr>Defines logic of closing MultiView. Parameter can define speed of opening, if presentation supports it.</docstr>
      </procedure>
      <procedure name="DoStartMoving">
        <docstr>Used for defining when multi view is beginning to open. if presentation supports animation.</docstr>
      </procedure>
      <procedure name="DoEndMoving">
        <docstr>Used for defining when multi view is ending moving. if presentation supports animation.</docstr>
      </procedure>
      <function name="GetMasterButtonVisible">
        <docstr>Returns should be master button hidden or not</docstr>
      </function>
      <function name="GetDisplayName">
        <docstr>Returns badge title of current presentation, which is displayed in design time in right bottom
           corner of TMultiView</docstr>
      </function>
      <procedure name="BeginInternalRealign">
        <docstr>Begins internal process of realign.</docstr>
      </procedure>
      <procedure name="EndInternalRealign">
        <docstr>Ends internal process of realign.</docstr>
      </procedure>
      <function name="IsInternalRealign">
        <docstr>Are we in a internal process of realign?</docstr>
      </function>
      <procedure name="Install">
        <docstr>Installs presentation</docstr>
      </procedure>
      <procedure name="Uninstall">
        <docstr>Uninstalls presentation</docstr>
      </procedure>
      <procedure name="Open">
        <docstr>Opens MultiView, if presentation supports it.</docstr>
      </procedure>
      <procedure name="Close">
        <docstr>Closes MultiView, if presentation supports it.</docstr>
      </procedure>
      <function name="Opened">
        <docstr>Is MultiView opened?</docstr>
      </function>
      <function name="Moving">
        <docstr>Is MultiView moving?</docstr>
      </function>
      <procedure name="Realign">
        <docstr>Refresh position and size of MultiView</docstr>
      </procedure>
      <function name="CanShowHideInDesignTime">
        <docstr>Does presentation supports openning and closing MultiView?</docstr>
      </function>
      <property name="DisplayName">
        <docstr>Returns badge title of current presentation, which is displayed in design time in right bottom
           corner of TMultiView</docstr>
      </property>
      <property name="ExpandedSize">
        <docstr>Size of MultiView in opened state</docstr>
      </property>
      <property name="CollapsedSize">
        <docstr>Size of MultiView in closed state</docstr>
      </property>
      <property name="MultiView">
        <docstr>Link on MultiView</docstr>
      </property>
      <property name="MasterButtonVisible">
        <docstr>Returns should be master button hidden or not</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.MultiView" name="TCustomMultiView">
    <docstr>The base class for MultiView components.
If you need to create a custom MultiView component, derive it from TCustomMultiView.</docstr>
    <members>
      <function name="GetOrientation">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetDeviceClass">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetDevice">
        <docstr>Returns the current device. 
The GetDevice method returns the current device with TDeviceInfo type.
At design-time, the GetDevice method returns the device of the view that is selected in IDEs View Selector.</docstr>
      </function>
      <function name="IsObjectForContent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.MultiView.TCustomMultiView.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoInsertObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoMasterButtonClick">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ParentChanged">
        <docstr>Sends a PM_REFRESH_PARENT message to the presentation layer through its presentation proxy when the parent of this control changes.
FMX.MultiView.TCustomMultiView.ParentChanged inherits from FMX.Controls.Presentation.TPresentedControl.ParentChanged. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.ParentChanged.
Sends a PM_REFRESH_PARENT message to the presentation layer through its presentation proxy when the parent of this control changes.

 See Also
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Controls.TControl.ParentChanged
FMX.Controls.Presentation.TPresentedControl.AncestorParentChanged</docstr>
      </procedure>
      <function name="IsMobilePreview">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the control after the form file has been read into memory and loads its presentation.
FMX.MultiView.TCustomMultiView.Loaded inherits from FMX.Controls.Presentation.TPresentedControl.Loaded. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Loaded.
Initializes the control after the form file has been read into memory and loads its presentation.
For details, see TControl.Loaded.

 See Also
FMX.Controls.Presentation.TPresentedControl.LoadPresentation
FMX.Controls.TControl.Loaded</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.MultiView.TCustomMultiView.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <procedure name="DoAbsoluteChanged">
        <docstr>Sends a PM_ABSOLUTE_CHANGED message to the presentation layer through its presentation proxy.
FMX.MultiView.TCustomMultiView.DoAbsoluteChanged inherits from FMX.Controls.Presentation.TPresentedControl.DoAbsoluteChanged. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DoAbsoluteChanged.
Sends a PM_ABSOLUTE_CHANGED message to the presentation layer through its presentation proxy.
For details about the circumstances that trigger this procedure, see TControl.DoAbsoluteChanged.

 See Also
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Controls.TControl.DoAbsoluteChanged</docstr>
      </procedure>
      <procedure name="EnabledChanged">
        <docstr>Executed right after the value of the Enabled property changes.
FMX.MultiView.TCustomMultiView.EnabledChanged inherits from FMX.Controls.TControl.EnabledChanged. All content below this line refers to FMX.Controls.TControl.EnabledChanged.
Executed right after the value of the Enabled property changes.
The control does not execute EnabledChanged if you assign Enabled the same value that it already has.
EnabledChanged is never executed for effects, which execute EffectEnabledChanged instead.

 See Also
FMX.Controls.TControl.BeforeEffectEnabledChanged
FMX.Controls.TControl.EffectEnabledChanged
FMX.Controls.TControl.ClipChildrenChanged
FMX.Controls.TControl.HandleSizeChanged
FMX.Controls.TControl.HitTestChanged
FMX.Controls.TControl.PaddingChanged
FMX.Controls.TControl.ParentChanged
FMX.Controls.TControl.VisibleChanged
FMX.Controls.TControl.AncestorVisibleChanged
FMX.Controls.TControl.AncestorParentChanged
FMX.Controls.TControl.ChildrenAlignChanged</docstr>
      </procedure>
      <procedure name="Show">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ControlTypeChanged">
        <docstr>Notifies about the changes of ControlType. 
FMX.MultiView.TCustomMultiView.ControlTypeChanged inherits from FMX.Controls.Presentation.TPresentedControl.ControlTypeChanged. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.ControlTypeChanged.
Notifies about the changes of ControlType.</docstr>
      </procedure>
      <procedure name="WriteState">
        <docstr>Writes the state of the component.
FMX.MultiView.TCustomMultiView.WriteState inherits from System.Classes.TComponent.WriteState. All content below this line refers to System.Classes.TComponent.WriteState.
Writes the state of the component.
WriteState is used internally in the component streaming system. It is not necessary to call it directly. 
This method expects a TWriter object that is used for storing the state of the component.</docstr>
      </procedure>
      <procedure name="ReadState">
        <docstr>Reads the state of the component.
FMX.MultiView.TCustomMultiView.ReadState inherits from System.Classes.TComponent.ReadState. All content below this line refers to System.Classes.TComponent.ReadState.
Reads the state of the component.
ReadState is used internally in the component streaming system. It is not necessary to call it directly. 
ReadState expects a TReader object, which is used for reading the state of the component.</docstr>
      </procedure>
      <procedure name="DoStartShowing">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoStartHiding">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoShown">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoHidden">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.MultiView.TCustomMultiView.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.MultiView.TCustomMultiView.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <procedure name="PaintChildren">
        <docstr>Renders the child controls.
FMX.MultiView.TCustomMultiView.PaintChildren inherits from FMX.Controls.TControl.PaintChildren. All content below this line refers to FMX.Controls.TControl.PaintChildren.
Renders the child controls.
The PaintChildren method is called automatically in the process of painting of the current control. It renders child controls, if any, on the surface specified by the Canvas property. 
The effects that are applied to the control are also applied to its children.
TControl descendants can override PaintChildren to provide specific rendering of the respective controls.</docstr>
      </procedure>
      <procedure name="FreeNotification">
        <docstr>Ensures that AComponent is notified that the component is going to be destroyed.
FMX.MultiView.TCustomMultiView.FreeNotification inherits from System.Classes.TComponent.FreeNotification. All content below this line refers to System.Classes.TComponent.FreeNotification.
Ensures that AComponent is notified that the component is going to be destroyed.
Use FreeNotification to register AComponent as a component that should be notified when the component is about to be destroyed. It is only necessary to register components this way when they are in a different form or have a different owner. For example, if AComponent is in another form and uses the component to implement a property, it must call FreeNotification so that its Notification method is called when the component is destroyed.
For components with the same owner, the Notification method is called automatically when an application explicitly frees the component. This notification is not sent out when components are freed implicitly, because the Owner is already being freed.</docstr>
      </procedure>
      <function name="RequestPresenter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="DefineDrawerPresenterClass">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="DefinePlatformBehaviourPresenter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="DefinePresenterClass">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="DoPresenterChanging">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.MultiView.TCustomMultiView.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TPresentedControl.
FMX.MultiView.TCustomMultiView.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
Destroys this instance of TPresentedControl.

 See Also
FMX.Controls.Presentation.TPresentedControl.Create</docstr>
      </destructor>
      <function name="HasMasterButton">
        <docstr>Verifies whether the component has a master button.
A master button is a UI element that allows you to view or hide the master pane.</docstr>
      </function>
      <function name="HasTargetControl">
        <docstr>Verifies whether the component has the detail pane.</docstr>
      </function>
      <function name="HasPresenter">
        <docstr>Retrieves whether the master pane of the current MultiView component has the Presenter.</docstr>
      </function>
      <procedure name="HideMaster">
        <docstr>Hides the master pane.
Use this method to hide the master pane.</docstr>
      </procedure>
      <procedure name="ShowMaster">
        <docstr>Displays the master pane.
Use this method to display the master pane.</docstr>
      </procedure>
      <procedure name="UpdateAlignment">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="IsShowed">
        <docstr>Verifies whether the master pane is displayed. 
Use this method to verify whether the master pane is displayed. The IsShowed method returns the following values:

true: the master pane is displayed.
false: the master pane is hidden.</docstr>
      </function>
      <procedure name="ClearContent">
        <docstr>Removes all controls from the content.</docstr>
      </procedure>
      <property name="MasterContent">
        <docstr>Holds the content (child controls) of the MultiView.
MasterContent lists child controls in the master pane and does not list the detail pane. 

Note: The detail pane is referenced by the TargetControl property.</docstr>
      </property>
      <property name="Presenter">
        <docstr>Keeps the object providing the presentation of the master pane of the current MultiView component.</docstr>
      </property>
      <property name="CustomPresentationClass">
        <docstr>Refers the custom class for presentations of master panes in  MultiView controls.
The user can customize the master pane presentation. You need to set the MultiView control to Custom and declare your own class that descends from TMultiViewPresentation or from other classes declared in the FMX.MultiView.Presentations.pas unit (such as MyPresentationClass).
The custom presentation class should be set in the CustomPresentationClass property. See the Custom Mode subsection in Mobile Tutorial: Using a MultiView Component to Display Alternate Views of Information (iOS and Android).</docstr>
      </property>
      <property name="TargetControl">
        <docstr>Specifies a datail pane container (such as TPanel) showing elements described in the master pane.
For more information about the master-detail interface, see Mobile Tutorial: Using a MultiView Component to Display Alternate Views of Information (iOS and Android).

Limitations
See FireMonkey Native iOS Controls: Combining Native iOS Controls With Non-native Controls for more information about the limitations when using native controls.

Exceptions
Setting TargetControl may raise the following exception:



Exception

Exception.Message

Scenarios



EComponentError



TargetControl cannot be a child of TMultiView.



You set a child control of a TMultiView as the TargetControl of that TMultiView.
You set a TMultiView as the TargetControl of itself.</docstr>
      </property>
      <property name="PopoverOptions">
        <docstr>Handles appearance options of the master pane in the Popover presentation mode.
In the Popover presentation mode, the master pane is a pop-up menu, which can be displayed or hidden using the master button.
The PopoverOptions property allows you to handle the following options:

AppearanceDuration: specifies the duration of the pop-up window appearance (in seconds). By default, this property is set to 0.25 s.
PopupHeight: specifies the height of the pop-up window (in pixels). By default, this property is set to 400px.
StyleLookup: specifies the name of the resource object (style) to which this pop-up window is linked.
TintColor: specifies the tint applied to this pop-up window.</docstr>
      </property>
      <property name="MasterButton">
        <docstr>Allows you to hide or show the master pane.
If your application has no master button, leave the MasterButton property empty.

Limitations
The master button cannot be used when:

The button is invisible and if the Mode property is set to Panel presentation mode. That is, the master pane is a &quot;docked panel&quot;.
The onClick event handler is not supported.</docstr>
      </property>
      <property name="Mode">
        <docstr>Specifies the presentation mode of the master pane.
The TMultiViewMode type provides the following presentation modes:



Mode

Master Pane Presentation


Drawer

In the Drawer mode, the master pane can be whether hidden or can slide to overlap the detail pane.


Panel

Master and detail panels are always displayed, independently of a device type and orientation. The master panel is docked to the left or right of the MultiView component.


PlatformBehaviour

An application automatically selects the master pane presentation mode depending on the device type and orientation, as described in the tables in the Platform Dependent Behavior Mode subsection below.


Popover

Pop-up menu.


NavigationPane

Navigation pane.


Custom

The user can customize the master pane presentation. The custom presentation class should be set in the CustomPresentationClass property. For details, see Custom Mode description.

For detailed information about the presentation modes, see Master Pane Presentation Modes.

Platform Dependent Behavior Mode
In the PlatformBehaviour mode, you let the application automatically select the master pane presentation mode. In this scenario,  the application behavior depends on the device type, orientation, and the operation system version (only for desktop applications) as described in the following tables:
Mobile Applications



Device Type

Device Orientation  

Master Pane Presentation


Phone

Landscape, Portrait

Drawer (push/overlap)


Tablet

Landscape

Docked panel


Tablet

Portrait

Drawer (push/overlap)

Desktop Applications



OS Version

Master Pane Presentation


Windows 10

Navigation pane


Windows 8 or earlier

Docked panel


OS X

Docked panel</docstr>
      </property>
      <property name="BorderOptions">
        <docstr>Handles appearance options of borders for MultiView components.
TMultiViewBorderOptions defines the  Color and Visible properties.</docstr>
      </property>
      <property name="ShadowOptions">
        <docstr>Handles appearance options of a shadow that the master pane casts on the detail pane.
With ShadowOptions property, you can handle the following appearance options of the shadow:

Color: specifies the shadow color.
Enabled: enables or disables the shadow.
Opacity: specifies the opacity level of the shadow.</docstr>
      </property>
      <property name="SplitViewOptions">
        <docstr>Handles appearance options of the master pane in the Panel presentation mode.
With SplitViewOptions property, you can handle the Placement option. Placement specifies the docked master pane location (left, right, top, or bottom).</docstr>
      </property>
      <property name="DrawerOptions">
        <docstr>Handles appearance options of the master pane in the Drawer presentation mode.
The DrawerOptions property handles the following options:

DurationSliding: specifies the duration of the master pane sliding (in seconds).
Mode: specifies the master pane sliding mode.
Placement: specifies the master pane location (left or right).
TouchAreaSize: specifies the touch area size (in pixels).</docstr>
      </property>
      <property name="NavigationPaneOptions">
        <docstr>Handles the appearance options of the master pane in the NavigationPane presentation mode.
With NavigationPaneOptions, you can manage the CollapsedWidth property of the master pane appearance of the current MultiView component. CollapsedWidth specifies the width (in pixels) of the master pane in the NavigationPane presentation mode when it is collapsed.</docstr>
      </property>
      <event name="OnStartShowing">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnStartHiding">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnShown">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnHidden">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnPresenterChanging">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.MultiView" name="TMultiView">
    <docstr>The class for MultiView components that allows providing the master-detail interface.
With TMultiView, you can implement a master-detail interface, which can be used for any target platform (such as an iOS, Android, or desktop application).
The TMultiView component provides the interface between the master and detail panes:   

In the master pane, you can display a collection of visual controls, such as edit boxes, labels, lists, and so on. These controls may be linked to the concrete views on the detail pane.
The detail pane displays information about the objects selected in the master pane. Whenever you change the selection in the master pane, the detail pane is updated to show details of the new selection.
For more information, see Mobile Tutorial: Using a MultiView Component to Display Alternate Views of Information (iOS and Android) and FMX.MultiViewDemo sample application.</docstr>
  </class>
  <class unit="FMX.ListView" name="TAdapterListView">
    <docstr></docstr>
    <members>
      <procedure name="DoAdapterSet">
        <docstr>Called right after the adapter of the list view is set.</docstr>
      </procedure>
      <procedure name="SetAdapter">
        <docstr>Setter of Adapter.</docstr>
      </procedure>
      <procedure name="InvalidateHeights">
        <docstr>Changes the value of HeightSumsNeedUpdate to True to indicate that the total height of the list view items has changed since the last time that the list view presentation calculated that height.
Subclasses of TAdapterListView that handle the presentation of the list view must change the value of HeightSumsNeedUpdate to False each time that they calculate the total height of the list view items and update the list view presentation accordingly.</docstr>
      </procedure>
      <procedure name="DoItemsChange">
        <docstr>Called after the items of the adapter change.</docstr>
      </procedure>
      <procedure name="DoItemsMayChange">
        <docstr>Called before the items of the adapter might change as a result of filtering or sorting.</docstr>
      </procedure>
      <procedure name="DoItemsCouldHaveChanged">
        <docstr>Called after the items of the adapter might have changed as a result of filtering or sorting.</docstr>
      </procedure>
      <procedure name="DoItemsResize">
        <docstr>Called when the size of the items of the adapter has changed.</docstr>
      </procedure>
      <procedure name="DoItemsInvalidate">
        <docstr>Called when the items of the adapter need to be painted again.</docstr>
      </procedure>
      <procedure name="DoResetView">
        <docstr>Called when the view of the specified item of the adapter needs to be recreated.</docstr>
      </procedure>
      <property name="HeightSumsNeedUpdate">
        <docstr>Indicates whether the total height of the list view items has changed since the last time that the list view presentation calculated that height (True) or not (False).
Subclasses of TAdapterListView that handle the presentation of the list view must change the value of HeightSumsNeedUpdate to False each time that they calculate the total height of the list view items and update the list view presentation accordingly.</docstr>
      </property>
      <property name="Adapter">
        <docstr>Object that handles all interactions between the list view control and its list view items.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.ListView" name="TListViewBase">
    <docstr></docstr>
    <members>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.ListView.TListViewBase.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="IsEditMode">
        <docstr>Returns True if in edit mode.</docstr>
      </function>
      <procedure name="DoSetItemIndexInternal">
        <docstr>Used internally by presentation hook.</docstr>
      </procedure>
      <procedure name="DoUpdateScrollViewPos">
        <docstr>Used internally by presentation hook.</docstr>
      </procedure>
      <procedure name="DoSetScrollViewPos">
        <docstr>Used internally by presentation hook.</docstr>
      </procedure>
      <procedure name="WillEnterEditMode">
        <docstr>Invoked when the Edit mode is being changed.
If the Edit mode requires a different appearance, this is where an update of appearances needs to be initiated.</docstr>
      </procedure>
      <function name="HasButtonsInCells">
        <docstr>Returns True if each list view item contains one or more buttons, or False otherwise.</docstr>
      </function>
      <function name="HasDeletionEditMode">
        <docstr>Returns True if the list view supports a mode where you can select list view items to delete, or False otherwise.</docstr>
      </function>
      <function name="HasCheckboxMode">
        <docstr>Returns True if the list view supports a mode where you can select list view items using checkboxes, or False otherwise.</docstr>
      </function>
      <procedure name="ResetEditModeAnimation">
        <docstr>Stops edit mode transition animation.</docstr>
      </procedure>
      <procedure name="InitEditModeAnimation">
        <docstr>Initializes edit mode transition animation.</docstr>
      </procedure>
      <procedure name="ResetDeleteModeAnimation">
        <docstr>Stops delete mode transition animation.</docstr>
      </procedure>
      <procedure name="InitDeleteModeAnimation">
        <docstr>Initializes delete mode transition animation.</docstr>
      </procedure>
      <procedure name="UpdateDeleteButtonLayout">
        <docstr>Updates the layout to place a Delete button.</docstr>
      </procedure>
      <procedure name="ProceedDeleteItem">
        <docstr>Deletes the item.</docstr>
      </procedure>
      <procedure name="ScrollStretchChanged">
        <docstr>This method is invoked when the value of the ScrollStretchStrength property is changed (UpdateScrollStretchStrength).</docstr>
      </procedure>
      <property name="ScrollStretchStrength">
        <docstr>Specifies the scroll stretch value when the   PullToRefresh property is invoked.</docstr>
      </property>
      <procedure name="SetSelectionCrossfade">
        <docstr>Setter function for the SelectionCrossfade property.</docstr>
      </procedure>
      <function name="GetDeleteButtonText">
        <docstr>Getter for the DeleteButtonText property.</docstr>
      </function>
      <procedure name="SetDeleteButtonText">
        <docstr>Setter function for the DeleteButtonText property.</docstr>
      </procedure>
      <procedure name="SetPullToRefresh">
        <docstr>Setter function for the PullToRefresh property.</docstr>
      </procedure>
      <procedure name="SetControlType">
        <docstr>Setter function for the ControlType property.</docstr>
      </procedure>
      <function name="GetControlType">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetNativeOptions">
        <docstr>Setter function for the NativeOptions property.</docstr>
      </procedure>
      <function name="GetEditModeTransitionAlpha">
        <docstr>Implements the IListViewController.GetEditModeTransitionAlpha method. 
The GetEditModeTransitionAlpha method of TListViewBase implements the GetClientMargins method of IListViewController.</docstr>
      </function>
      <function name="GetDeleteModeTransitionAlpha">
        <docstr>Implements the IListViewController.GetDeleteModeTransitionAlpha method. 
The GetDeleteModeTransitionAlpha method of TListViewBase implements the GetDeleteModeTransitionAlpha method of IListViewController.</docstr>
      </function>
      <procedure name="SetDeleteButtonIndex">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetItemEditOffset">
        <docstr>Implements the IListViewController.GetItemEditOffset method. 
The GetItemEditOffset method of TListViewBase implements the GetItemEditOffset method of IListViewController</docstr>
      </function>
      <function name="GetItemDeleteCutoff">
        <docstr>Implements the IListViewController.GetItemDeleteCutoff  method. 
The GetItemDeleteCutoff method of TListViewBase implements the IListViewController.GetItemDeleteCutoff method of IListViewController.</docstr>
      </function>
      <function name="GetClientMargins">
        <docstr>Implements the IListViewController.GetClientMargins method.
The GetClientMargins method of TListViewBase implements the GetClientMargins method of IListViewController.</docstr>
      </function>
      <function name="GetItemCurrentSelectionAlpha">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetImages">
        <docstr>Returns list of images.
Can be nil.</docstr>
      </function>
      <procedure name="SetImages">
        <docstr>Returns list of images.
Can be nil.</docstr>
      </procedure>
      <procedure name="DoRequestReindexing">
        <docstr>Hook for the  IListViewController.RequestReindexing.</docstr>
      </procedure>
      <procedure name="DoItemResized">
        <docstr>Hook for the  IListViewController.ItemResized.</docstr>
      </procedure>
      <procedure name="DoItemInvalidated">
        <docstr>Notifies the TListView that the item requires repainting.</docstr>
      </procedure>
      <procedure name="DoCheckStateChanged">
        <docstr>Notifies the TListView that a control inside of an item is clicked.</docstr>
      </procedure>
      <procedure name="DoControlClicked">
        <docstr>Notifies the TListView that an item is clicked.</docstr>
      </procedure>
      <function name="GetImageIndex">
        <docstr>Declares the zero-based index of an image. 
If you use a non-existent index to access an image in the images list, then no image is retrieved and no exception is raised. The usual default value is -1.</docstr>
      </function>
      <procedure name="SetImageIndex">
        <docstr>Declares the setter for ImageIndex.</docstr>
      </procedure>
      <function name="GetImageList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetImageList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetStyleResources">
        <docstr>Implements the IListItemStyleResources.GetStyleResources method. 
The GetStyleResources method of TListViewBase implements the GetStyleResources method of IListItemStyleResources.</docstr>
      </function>
      <function name="StyleResourcesNeedUpdate">
        <docstr>Implements the IListItemStyleResources.StyleResourcesNeedUpdate method. 
The StyleResourcesNeedUpdate method of TListViewBase implements the StyleResourcesNeedUpdate method of FMX.ListView.Types.IListItemStyleResources.</docstr>
      </function>
      <procedure name="SetItemSpaces">
        <docstr>Protected setter implementation for the ItemSpaces property.</docstr>
      </procedure>
      <function name="GetItemClientRect">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetEstimatedItemHeight">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetEstimatedHeaderHeight">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetEstimatedFooterHeight">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ImagesChanged">
        <docstr>Should be called when the component needs to redraw the image.
ImagesChanged should be called
when you change the Images reference to the TCustomImageList object or 
the object itself or when you change the ImageIndex property.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the list view.</docstr>
      </procedure>
      <procedure name="AfterPaint">
        <docstr>Restores Canvas properties after the painting process. 
FMX.ListView.TListViewBase.AfterPaint inherits from FMX.Controls.TControl.AfterPaint. All content below this line refers to FMX.Controls.TControl.AfterPaint.
Restores Canvas properties after the painting process. 
As implemented in TControl, AfterPaint does nothing.
TShape descendants of TControl override AfterPaint to restore Dash and  Thickness to default values.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.ListView.TListViewBase.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.ListView.TListViewBase.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>OnMouseMove event dispatcher. 
FMX.ListView.TListViewBase.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
OnMouseMove event dispatcher. 
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.ListView.TListViewBase.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseWheel">
        <docstr>OnMouseWheel event dispatcher. 
FMX.ListView.TListViewBase.MouseWheel inherits from FMX.Controls.TControl.MouseWheel. All content below this line refers to FMX.Controls.TControl.MouseWheel.
OnMouseWheel event dispatcher. 
A control calls MouseWheel in response to any of mouse wheel messages, decoding the message parameters into the shift-key state, wheel rotation, and handle, which it passes in the Shift, WheelDelta, and Handled parameters, respectively:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
WheelDelta indicates the distance the wheel was rotated. WheelDelta is positive if the mouse was rotated upward, negative if the mouse was rotated downward.
Handled indicates whether the scroll bar was already moved, depending on the WheelDelta value. If one of the scrolls bars (vertical or horizontal) was already handled or it does not exist, MouseWheel tries to apply the rolling on the other scroll bar, if it exists.
Override the protected MouseWheel method to provide other responses when the mouse wheel is rotated while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Provides a response when a key is pressed down while the control has the keyboard focus. 
FMX.ListView.TListViewBase.KeyDown inherits from FMX.Controls.TControl.KeyDown. All content below this line refers to FMX.Controls.TControl.KeyDown.
Provides a response when a key is pressed down while the control has the keyboard focus. 
If the pressed key is the Applications key (Key = vkApps), then KeyDown shows the context menu of the control. Otherwise, KeyDown calls the OnKeyDown event handler if one is assigned. 
TCommonCustomForm and descendant of TControl classes--like TCustomGrid--call KeyDown from their methods handling key pressing. They decode the message parameters into the key code, character code, and shift state. They pass them into the called KeyDown method in the Key, KeyChar, and Shift parameters, respectively:  



Parameters

Descriptions



Key



Is the scan code of the pressed keyboard key or $0.
If a pressed key combination can be a shortcut, then Key &lt;&gt; 0 is a virtual key and KeyChar = #0. 
Physical scan codes of the same key can differ under different platforms (Windows or iOS).
Platform-specific units (for example FMX.Platform.Mac.pas) should translate native scan codes to corresponding Windows codes defined in the UITypes unit.  For example, 

vkReturn = $0D;  {  13 } corresponds to the RETURN keyboard key.
vkF2     = $71;  { 113 } corresponds to the F2 keyboard key.



KeyChar



Is the pressed character (digit) or #0.
If a pressed key combination can be treated as a printable character or digit, then Key = 0 and KeyChar contains a pressed symbol according to the current keyboard&apos;s input language, keyboard mode (CAPS LOCK and NUM LOCK keys), keyboard Shift state, and IME state. Editors can use this symbol to add into a text being edited. 




Shift



Indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the specified key was pressed with the control in focus.


If the control has successfully processed the pressed key combination and no additional processing is required, then KeyDown assigns Key = 0 and KeyChar = #0.  
Override the protected KeyDown method to provide other responses when a key is down while the control has keyboard input focus.
See TCommonCustomForm.KeyDown for more information about parameters.</docstr>
      </procedure>
      <function name="ObjectAtPoint">
        <docstr>Returns the control in which a specified point can be found.
FMX.ListView.TListViewBase.ObjectAtPoint inherits from FMX.Controls.TControl.ObjectAtPoint. All content below this line refers to FMX.Controls.TControl.ObjectAtPoint.
Returns the control in which a specified point can be found.
P is the specified point in the object.
ObjectAtPoint returns the control in which the P point is found. 
To start searching within the current control, the control must be visible and enabled. If P is within a child of the control and the child is also a control, the search continues inside the child. 
If P is inside the control (not within a child) and the control can be hit, then ObjectAtPoint returns the control. 
ObjectAtPoint is used internally.</docstr>
      </function>
      <procedure name="DoMouseLeave">
        <docstr>OnMouseLeave event dispatcher.
FMX.ListView.TListViewBase.DoMouseLeave inherits from FMX.Controls.TControl.DoMouseLeave. All content below this line refers to FMX.Controls.TControl.DoMouseLeave.
OnMouseLeave event dispatcher.
DoMouseLeave is called automatically when the mouse pointer leaves the control&apos;s area.
DoMouseLeave starts the animation by calling StartTriggerAnimation and applies effects by calling ApplyTriggerEffect to background the control. 
Override the protected DoMouseLeave method to provide other responses when the mouse pointer leaves the control&apos;s area.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.ListView.TListViewBase.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.ListView.TListViewBase.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.ListView.TListViewBase.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.ListView.TListViewBase.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <procedure name="Invalidate">
        <docstr>Forces the repainting of the surface of the rectangle holding this list view component.</docstr>
      </procedure>
      <procedure name="DoRealign">
        <docstr>Realigns and repaints the ListView.</docstr>
      </procedure>
      <procedure name="DoExit">
        <docstr>OnExit event dispatcher.
FMX.ListView.TListViewBase.DoExit inherits from FMX.Controls.TControl.DoExit. All content below this line refers to FMX.Controls.TControl.DoExit.
OnExit event dispatcher.
DoExit is called automatically when the input focus moves from the current object.
DoExit repaints the control, starts the animation by calling StartTriggerAnimation, and applies effects by calling ApplyTriggerEffect. When a control receives focus, it is highlighted. The animations and effects applied by DoExit background the control.
Override the protected DoExit method to provide other responses when the focus moves from the current control.</docstr>
      </procedure>
      <procedure name="DoChange">
        <docstr>Responds to changing the visibility or appearance of the list view component and also to changing the indexes of list items.
The DoChange method also fires an OnChange event.</docstr>
      </procedure>
      <procedure name="DoChangeRepainted">
        <docstr>Handles the TDelayedIncident.ChangeRepainted incident.</docstr>
      </procedure>
      <procedure name="DoListItemChange">
        <docstr>Invokes the OnItemChange handler.</docstr>
      </procedure>
      <procedure name="DoListItemClick">
        <docstr>Invokes the OnListItemClick handler.</docstr>
      </procedure>
      <procedure name="DoEditModeChange">
        <docstr>Invokes the OnEditModeChange handler.</docstr>
      </procedure>
      <procedure name="DoEditModeChanging">
        <docstr>Responds to entering of the list view into edit mode.
The DoEditModeChanging method also fires an OnEditModeChanging event.</docstr>
      </procedure>
      <procedure name="DoResetEditModeAnimation">
        <docstr>Called at the end of the animation that plays when the edit mode is toggled.</docstr>
      </procedure>
      <procedure name="DoUpdateScrollingLimits">
        <docstr>Updates the scrolling limits and animation boundaries.</docstr>
      </procedure>
      <procedure name="DoItemsMayChange">
        <docstr>Called before the items of the adapter might change as a result of filtering or sorting.
FMX.ListView.TListViewBase.DoItemsMayChange inherits from FMX.ListView.TAdapterListView.DoItemsMayChange. All content below this line refers to FMX.ListView.TAdapterListView.DoItemsMayChange.
Called before the items of the adapter might change as a result of filtering or sorting.

 See Also
FMX.ListView.TAdapterListView.DoItemsCouldHaveChanged
FMX.ListView.TAdapterListView.DoItemsChange
FMX.ListView.TAdapterListView.DoItemsInvalidate
FMX.ListView.TAdapterListView.DoItemsResize</docstr>
      </procedure>
      <procedure name="DoItemsCouldHaveChanged">
        <docstr>Called after the items of the adapter might have changed as a result of filtering or sorting.
FMX.ListView.TListViewBase.DoItemsCouldHaveChanged inherits from FMX.ListView.TAdapterListView.DoItemsCouldHaveChanged. All content below this line refers to FMX.ListView.TAdapterListView.DoItemsCouldHaveChanged.
Called after the items of the adapter might have changed as a result of filtering or sorting.

 See Also
FMX.ListView.TAdapterListView.DoItemsMayChange
FMX.ListView.TAdapterListView.DoItemsChange
FMX.ListView.TAdapterListView.DoItemsResize
FMX.ListView.TAdapterListView.DoItemsInvalidate</docstr>
      </procedure>
      <procedure name="DoItemsInvalidate">
        <docstr>Called when the items of the adapter need to be painted again.
FMX.ListView.TListViewBase.DoItemsInvalidate inherits from FMX.ListView.TAdapterListView.DoItemsInvalidate. All content below this line refers to FMX.ListView.TAdapterListView.DoItemsInvalidate.
Called when the items of the adapter need to be painted again.

 See Also
FMX.ListView.TAdapterListView.DoItemsChange
FMX.ListView.TAdapterListView.DoItemsCouldHaveChanged
FMX.ListView.TAdapterListView.DoItemsMayChange
FMX.ListView.TAdapterListView.DoItemsResize
FMX.Controls.TControl.Repaint</docstr>
      </procedure>
      <procedure name="DoItemsChange">
        <docstr>Called after the items of the adapter change.
FMX.ListView.TListViewBase.DoItemsChange inherits from FMX.ListView.TAdapterListView.DoItemsChange. All content below this line refers to FMX.ListView.TAdapterListView.DoItemsChange.
Called after the items of the adapter change.

 See Also
FMX.ListView.TAdapterListView.DoItemsMayChange
FMX.ListView.TAdapterListView.DoItemsCouldHaveChanged
FMX.ListView.TAdapterListView.DoItemsInvalidate
FMX.ListView.TAdapterListView.DoItemsResize</docstr>
      </procedure>
      <procedure name="DoAdapterSet">
        <docstr>Called right after the adapter of the list view is set.
FMX.ListView.TListViewBase.DoAdapterSet inherits from FMX.ListView.TAdapterListView.DoAdapterSet. All content below this line refers to FMX.ListView.TAdapterListView.DoAdapterSet.
Called right after the adapter of the list view is set.</docstr>
      </procedure>
      <function name="DeleteItem">
        <docstr>Deletes an item.</docstr>
      </function>
      <procedure name="DoDeleteItem">
        <docstr>Delets a specific item.
It is called from DeleteItem</docstr>
      </procedure>
      <function name="GetFinalItemSpaces">
        <docstr>Returns the area available for item layout.</docstr>
      </function>
      <function name="GetFinalItemSize">
        <docstr>Returns the size of the item.</docstr>
      </function>
      <function name="CanObserve">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.</docstr>
      </function>
      <procedure name="ObserversBeforeSelection">
        <docstr>Notify observers about the selection change.</docstr>
      </procedure>
      <function name="ShouldHandleEvents">
        <docstr>Returns True if this ListView should handle input events.</docstr>
      </function>
      <procedure name="DoUpdatingItemView">
        <docstr>Dispatches the OnUpdatingItemView event.
DoUpdatingItemView receives the following parameters:

AListItem is the target list view item.
AHandled determines whether the event handler of OnUpdatingItemView takes care of updating the appearance of the list view item (True) or DoUpdatingItemView must update the appearance of the list view item instead (False).
DoUpdatingItemView passes itself (as the Sender parameter) and the received AListItem and AHandled parameters to the event handler of OnUpdatingItemView.</docstr>
      </procedure>
      <procedure name="DoUpdateItemView">
        <docstr>Dispatches the OnUpdateItemView event.
DoUpdateItemView receives a single parameter, AItem, which is the target list view item.
DoUpdateItemView passes itself (as the Sender parameter) and the received AItem to the event handler of OnUpdateItemView.</docstr>
      </procedure>
      <function name="GetGlyphButton">
        <docstr>Gets the glyph button for item Index.</docstr>
      </function>
      <event name="OnUpdatingItemView">
        <docstr>Occurs before the item view is updated (before calling ResetObjects).</docstr>
      </event>
      <event name="OnUpdateItemView">
        <docstr>Occurs after the item view is updated (after calling ResetObjects).</docstr>
      </event>
      <event name="OnEditModeChange">
        <docstr>Occurs immediately after the list view component enters the edit mode.
Write an OnEditModeChange event handler to provide additional functionality after entering the edit mode. 
OnEditModeChange is an event of type TNotifyEvent.</docstr>
      </event>
      <event name="OnEditModeChanging">
        <docstr>Occurs immediately before the list view component enters the edit mode.
Write an OnEditModeChanging event handler to provide additional functionality before entering the edit mode. 
OnEditModeChanging is an event of type TNotifyEvent.</docstr>
      </event>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.ListView.TListViewBase.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.ListView.TListViewBase.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <function name="GetDefaultMargins">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="EndUpdate">
        <docstr>Marks the end of an update session of the control and its children.
FMX.ListView.TListViewBase.EndUpdate inherits from FMX.Controls.TControl.EndUpdate. All content below this line refers to FMX.Controls.TControl.EndUpdate.
Marks the end of an update session of the control and its children.
The update session must be started first by calling BeginUpdate.
EndUpdate decreases the FUpdating semaphore. If all update sessions end and FUpdating is 0, EndUpdate invokes Realign to process layout changes.

 See Also
FMX.Controls.TControl.FUpdating
FMX.Controls.TControl.BeginUpdate
FMX.Controls.TControl.IsUpdating
FMX.Controls.TControl.Realign</docstr>
      </procedure>
      <procedure name="RebuildList">
        <docstr>Re-creates the list and updates visible item content when using native presentation.</docstr>
      </procedure>
      <procedure name="ScrollTo">
        <docstr>Scrolls the view instantly (without scrolling effect) to the desired item, placing it in the view.
Use the ScrollTo method in order to immediately scroll, without a slow scrolling graphical effect, to the item specified through its index (the AItemIndex parameter), and place it in the view.</docstr>
      </procedure>
      <property name="ItemIndex">
        <docstr>Specifies the index of the selected item in this list view component.</docstr>
      </property>
      <property name="Selected">
        <docstr>List item that is currently selected on the list view.
This property is nil if no item is selected.
To use Selected as an instance of Appearances.TListViewItem, you must cast it as such:


Delphi:

SelectedItemText := TListViewItem(TListView1.Selected).Text;



C++:

SelectedItemText = ((TListViewItem*)(TListView1-&gt;Selected))-&gt;Text;</docstr>
      </property>
      <property name="ScrollViewPos">
        <docstr>Specifies the position of the vertical scroll in the list. Setting ScrollViewPos to 0 scrolls the list view to its top.</docstr>
      </property>
      <function name="GetItemRect">
        <docstr>Returns a TRectF that surrounds the specified item.
The GetItemRect method returns a rectangle with floating-point coordinates (TRectF) that surrounds the item specified through its index (the AItemIndex parameter).</docstr>
      </function>
      <procedure name="StopPullRefresh">
        <docstr>StopPullRefresh is a boolean method. It should be called when the &quot;pull to refresh&quot; mode has been triggered to stop the spinning wheel.
StopPullRefresh can be set to

True, as result the spinning wheel does not disappear automatically and StopPullRefresh method needs to be called after the refresh operation is done.
False (default value), as result the spinning wheel disappears automatically shortly after triggering the effect.
Note: This works only in native IOS control and only when the  PullRefreshWait property is set to True.</docstr>
      </procedure>
      <property name="ItemSpaces">
        <docstr>Specifies the space in logical units around the content of each list item.</docstr>
      </property>
      <property name="Images">
        <docstr>Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
If the TCustomImageList list is empty, then Images is nil/null.
Call ImagesChanged when Images is changed.</docstr>
      </property>
      <property name="SideSpace">
        <docstr>Specifies the space in logical units on all sides around the list box, encompassing the items.</docstr>
      </property>
      <property name="Transparent">
        <docstr>Specifies whether this list view control is transparent or not. When the control is transparent (Transparent is set to True), its background will not be drawn.</docstr>
      </property>
      <property name="AllowSelection">
        <docstr>Specifies whether the items are selectable or not.
The AllowSelection property specifies whether the items are selectable or not.

Tip: If items are not selectable, you will still be able to click on the embedded controls.</docstr>
      </property>
      <property name="AlternatingColors">
        <docstr>Specifies whether the fill colors for odd and even elements are rendered as alternating or not.
The AlternatingColors property specifies whether the background of the individual items in the list should appear rendered in alternating colors.</docstr>
      </property>
      <property name="ShowSelection">
        <docstr>Determines whether the selection is visible when selecting list view items. The ShowSelection property can be disabled when the list view has check boxes.</docstr>
      </property>
      <property name="CanSwipeDelete">
        <docstr>Sets the swipe-to-delete feature on list view items.
CanSwipeDelete specifies that a swipe gesture on individual list view items enables the end user to choose either to delete or retain the item.
When this feature has been enabled in the Object Inspector, and the end user swipes an item in a listview, the user has the opportunity to delete the item: a Delete button temporarily appears on the item.  The user can then click the Delete button to delete the item from the listview, or can release the swipe to retain the item in the list view.

Tip: When you swipe an item, this item shows the same behavior and appearance as a list item selected when your list view is in edit mode. For  a preview of this appearance, see TPublishedAppearance.ItemEditAppearance.
The swipe-to-delete feature is supported on mobile apps (iOS and Android), as well as desktop apps (Windows and OS X) when touch input is available.</docstr>
      </property>
      <property name="AutoTapScroll">
        <docstr>Specifies whether tapping on the topmost side of this list view automatically scrolls to the top of the list.
Set the AutoTapScroll property to True in order to allow for automatically scrolling to the top of the list when tapping with your finger on the topmost region of this list view component. Set AutoTapScroll to False in order to disable this feature.</docstr>
      </property>
      <property name="AutoTapTreshold">
        <docstr>Specifies the threshold value for the auto tap scrolling.</docstr>
      </property>
      <property name="DisableMouseWheel">
        <docstr>Specifies whether scrolling this list view using the mouse wheel works or not.
Set the DisableMouseWheel property to False to allow scrolling this list view using the mouse wheel. Set DisableMouseWheel to True to disable this feature.</docstr>
      </property>
      <property name="ItemCount">
        <docstr>Specifies the number of items in this list view component. ItemCount is a read-only property.
Read the ItemCount property in order to obtain the number of list items in this list view component.</docstr>
      </property>
      <event name="OnListItemClick">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnItemClickEx">
        <docstr>Occurs immediately after clicking an item from the list view. OnItemClickEx also receives mouse coordinates inside the clicked item.
Write an OnItemClickEx event handler to respond to clicking an item from the list view component.   
It is safe to modify the contents of the list view in the OnItemClickEx event handler (you may add, remove, update or change the order of list view items). If you do not need to do that, you can also use OnItemClick event handler. It is safe to modify the content of the items themselves in both of those handlers.
The OnItemClickEx event handler receives the following parameters:



Parameter

Description



Sender



The instance of TCustomListView to which the clicked item belongs.




ItemIndex



The index of the clicked item.




LocalClickPos



The coordinates of the click.




ItemObject



The instance of TListItemObject that you click on.</docstr>
      </event>
      <event name="OnItemChange">
        <docstr>Occurs immediately after changing the selected item from the list view.
Write an OnItemChange event handler to respond when changing the selected item in the list view component.
OnItemChange is an event of type TItemEvent.</docstr>
      </event>
      <event name="OnChange">
        <docstr>Occurs when the ItemIndex property changes as a result of a user selecting a different item.
Write an OnChange event handler to respond to changes of the ItemIndex property.  OnChange allows a response once the list has been successfully changed. 
OnChange is an event of type TNotifyEvent. If you want to wait for the list to be repainted to reflect the change, see OnChangeRepainted.

Note: The OnChange event does not occur when you change the ItemIndex property from code. That is the intended functionality. If you want to replicate the behaviour of a user selecting a different item, call OnChange explicitly.</docstr>
      </event>
      <event name="OnChangeRepainted">
        <docstr>Occurs when the ItemIndex property changes as a result of a user selecting a different item.
Write an OnChangeRepainted event handler to respond to changes of the ItemIndex property.  OnChangeRepainted allows a response once the list has been successfully changed and repainted. 
OnChangeRepainted is an event of type TNotifyEvent. If you do not need to wait for the list to be repainted to reflect the change, see OnChange.

Note: The OnChangeRepainted event does not occur when you change the ItemIndex property from code. That is the intended functionality. If you want to replicate the behaviour of a user selecting a different item, call OnChangeRepainted explicitly.</docstr>
      </event>
      <event name="OnItemsChange">
        <docstr>Event that occurs after a list of items has been changed.</docstr>
      </event>
      <event name="OnScrollViewChange">
        <docstr>This method is called when ScrollViewPos has changed as a result of scrolling a list or doing it manually in the code.</docstr>
      </event>
      <event name="OnDeletingItem">
        <docstr>Occurs when a user requests the deletion of a list view item, before this deletion takes place. You can define an event handler for this event to prevent the deletion from actually happening based on your own criteria.
Event handlers for this event must expect the following parameters:

Sender, the list view.
AIndex, the index of the list view item to be deleted.
ACanDelete, variable that determines whether the list view item is to be deleted or not.
To prevent the deletion from happening, set ACanDelete to False in your event handler.
The code snippet below shows a dialog box asking for confirmation before deleting an item. If you click Cancel, ACanDelete is set to False, canceling the list view item deletion:


Delphi:

procedure TMainForm.ListViewDeletingItem(Sender: TObject; AIndex: Integer; var ACanDelete: Boolean);
var
  Input: Integer;
begin
  Input := TDialogServiceSync.MessageDialog(
    &apos;Are you sure that you want to remove &quot;&apos; +
        (Sender as TListView).Items[AIndex].Text + &apos;&quot; from the list?&apos;,
    TMsgDlgType.mtConfirmation, mbOKCancel, TMsgDlgBtn.mbOK, 0);
  if Input = 2 then // Cancel
    ACanDelete := False;
end;



C++:

void __fastcall TMainForm::ListViewDeletingItem(TObject *Sender, int AIndex, bool &amp;ACanDelete)
{
  TListView* list = reinterpret_cast&lt;TListView*&gt;(Sender);
  int input = TDialogServiceSync::MessageDialog(
      &quot;Are you sure that you want to remove \&quot;&quot; +
          list-&gt;Items-&gt;Item[AIndex]-&gt;Text + &quot;\&quot; from the list?&quot;,
      TMsgDlgType::mtConfirmation, mbOKCancel, TMsgDlgBtn::mbOK, 0);
  if (input == 2) { // Cancel
        ACanDelete = false;
  }
}</docstr>
      </event>
      <event name="OnDeleteItem">
        <docstr>Occurs when a user requests the deletion of a list view item, after this deletion takes place. To catch the deletion before it takes place and be able to prevent it from actually happening, write an event handler for OnDeletingItem instead.
Event handlers for this event must expect the following parameters:

Sender, the list view.
AIndex, the index of the list view item that has been deleted.
Note: You cannot access the data of the deleted item at this point, since a different item is now using that index in the list view. Write an event handler for OnDeletingItem instead if you need to access information about the deleted item.
The code snippet below updates the text in a status bar after an item is deleted to show the position of the deleted item, as well as the number of remaining items in the list:


Delphi:

procedure TMainForm.ListViewDeleteItem(Sender: TObject; AIndex: Integer);
begin
  StatusBar.Text := &apos;Item &apos; + IntToStr(AIndex+1) + &apos; has been removed from the list. &apos; +
                    IntToStr((Sender as TListView).Items.Count) + &apos; items remaining.&apos;;
end;



C++:

void __fastcall TMainForm::ListViewDeleteItem(TObject *Sender, int AIndex)
{
  TListView* list = reinterpret_cast&lt;TListView*&gt;(Sender);
  MainForm-&gt;StatusBar-&gt;Text = &quot;Item &quot; + UnicodeString(AIndex+1) + &quot; has been removed from the list. &quot; +
                              UnicodeString(list-&gt;Items-&gt;Count) + &quot; items remaining.&quot;;
}</docstr>
      </event>
      <event name="OnDeleteChangeVisible">
        <docstr>Occurs when the visibility of the Delete button of a list item changes.
This event only works when you hide or show the Delete button displayed after a swipe gesture. It does not work when you hide or show the Delete button of a list item when your list view is in edit mode and your list uses an edit mode item appearance of type &quot;Delete&quot;.
Sender is the list view and AValue determines whether the Delete button was hidden (False) and now is visible, or it was visible (True) and now is hidden.
For example, the following event handler fills a status bar with a tip when a Delete button is shown on a list item, and removes that tip from the status bar as soon as the Delete button is hidden again:


Delphi:

procedure TMainForm.ListViewDeleteChangeVisible(Sender: TObject; AValue: Boolean);
begin
  if (AValue = False) then
    StatusBar.Text := &apos;Click &quot;Delete&quot; to remove the target item from the list.&apos;
  else
    StatusBar.Text := &apos;&apos;;
end;



C++:

void __fastcall TMainForm::ListViewDeleteChangeVisible(TObject *Sender, bool AValue)
{
  if (AValue) {
    MainForm-&gt;StatusBar-&gt;Text = &quot;Click \&quot;Delete\&quot; to remove the target item from the list.&quot;;
  } else {
    MainForm-&gt;StatusBar-&gt;Text = &quot;&quot;;
  }
}</docstr>
      </event>
      <event name="OnSearchChange">
        <docstr>Occurs when the search box in a list view loses the focus and its content has changed since it gained the focus. This event exposes the OnChange event of the TSearchBox that implements the search box of a list view.
For example, the code snippet below updates the text in a status bar on this event to show the number of items left in the list after the specified filter is applied:


Delphi:

procedure TMainForm.ListViewSearchChange(Sender: TObject);
var
  I: Integer;
  SearchBox: TSearchBox;
  List: TListView;
begin
  List := Sender as TListView;
  for I := 0 to List.Controls.Count-1 do
    if List.Controls[I].ClassType = TSearchBox then
    begin
      SearchBox := TSearchBox(List.Controls[I]);
      Break;
    end;
  StatusBar.Text := IntToStr(List.Items.Count) + &apos; list items match &apos; + QuotedStr(SearchBox.Text) + &apos;.&apos;;
end;



C++:

void __fastcall TMainForm::ListViewSearchChange(TObject *Sender)
{
  TSearchBox* searchBox;
  TListView* list = reinterpret_cast&lt;TListView*&gt;(Sender);
  for (int i = 0; i &lt; list-&gt;Controls-&gt;Count; i++) {
        searchBox = dynamic_cast&lt;TSearchBox*&gt;(list-&gt;Controls-&gt;Items[i]);
        if (searchBox) break;
  }
  MainForm-&gt;StatusBar-&gt;Text = UnicodeString(list-&gt;Items-&gt;Count) + &quot; list items match &quot; + QuotedStr(searchBox-&gt;Text) + &quot;.&quot;;
}</docstr>
      </event>
      <event name="OnFilter">
        <docstr>Occurs when a search box filters. 
Write an event handler for OnFilter to set a custom search filter for TSearchBox.
The OnFilter event with the TFilterEvent type has the following parameters:



Parameter

Description


Sender

The object whose event handler is called.


AFilter

The string being filtered among the different items (AValue parameter).


AValue

The string of the item where the search of AFilter is being performed.


Accept

Boolean parameter to use when there is a filter condition.
Use Accept to add a filter condition; if a value is filtered by the filter condition, Accept must be True.



For example, the below code snippet adds a custom filter to force the item (AValue) to start with the string being filtered (AFilter):


Delphi: 

procedure TForm2.ListView1Filter(Sender: TObject; const AFilter, AValue: string;
  var Accept: Boolean);
begin
  Accept :=  AValue.StartsWith(AFilter, True);
end;



C++: 

void __fastcall TForm1::ListView1Filter(TObject *Sender, const UnicodeString AFilter,
		  const UnicodeString AValue, bool &amp;Accept)
{
	Accept = StartsStr(AFilter.LowerCase(), AValue.LowerCase());
}


Note:  Enable the SearchVisible property to show the search box on top of your list view.</docstr>
      </event>
      <event name="OnPullRefresh">
        <docstr>Occurs when a user pulls down the item list.
Write an event handler for OnPullRefresh to specify what happens when you pull down the list of items.

Note: For this event to occur, you should set the PullToRefresh property to true.</docstr>
      </event>
      <property name="DeleteButtonText">
        <docstr>Specifies the name of the Delete button designed to delete the TListView items. 
This button can be displayed if the CanSwipeDelete property is set True.</docstr>
      </property>
      <property name="EditMode">
        <docstr>Specifies whether this list view component is in the edit mode (True) or in the regular mode (False).
On some platforms, the list view shows an animation when the value of the EditMode property changes at run time.</docstr>
      </property>
      <property name="SearchVisible">
        <docstr>Set SearchVisible to True to show a search box on top of your list view
Shows a search box on top of your list view that can filter the content of the list.
To access the search box control from code, simply loop trough the controls of your list view until you find an instance of TSearchBox. For an example, see the code snippet at FMX.ListView.TListViewBase.OnSearchChange.</docstr>
      </property>
      <property name="SearchAlwaysOnTop">
        <docstr>Search box partially hidden in a list view where SearchAlwaysOnTop is False
Your list view component keeps the search box on top as you scroll. If SearchAlwaysOnTop is False, the search box behaves as a list item: scrolling down the list hides the search box, and you must scroll up to show the search box again.
SearchAlwaysOnTop has no effect if SearchVisible is False.
SearchAlwaysOnTop is supported only on the iOS platform.</docstr>
      </property>
      <property name="SelectionCrossfade">
        <docstr>Enables the selection of Crossfade animation .</docstr>
      </property>
      <property name="PullToRefresh">
        <docstr>Determines whether the &quot;pull list to refresh&quot; feature is enabled.
When this property is set to true, the Pull-to-Refresh feature is enabled and the end user can pull down a list view to refresh the contents.
To enable the Pull-to-Refresh feature, select the TListView component in the Form Designer, and do the following:

On the Properties page of the Object Inspector, set the PullToRefresh property to true.
Open the Events page, and double-click the right-hand column for OnPullRefresh.
When the Code Editor opens, you can implement the OnPullRefresh event handler. In this event handler, you can specify how to refresh the list view. For example, you might update existing list items, add new items, or delete specified items.
Note: In the case of native iOS controls, you can use the PullRefreshWait property to set whether the animated spinning indicator disappears automatically, or if it disappears when you call StopPullRefresh.</docstr>
      </property>
      <property name="PullRefreshWait">
        <docstr>Determines if the spinning wheel disappears automatically or not.
When set to True, the spinning wheel does not disappear automatically and you have to call the StopPullRefresh method after doing a refresh operation. If PullRefreshWait is set to False (default), then the spinning wheel disappears automatically shortly after triggering the effect. This option only works in native iOS controls and does not have effect otherwise.

Note: You must set the PullToRefresh property to True to use PullRefreshWait.</docstr>
      </property>
      <property name="ControlType">
        <docstr>Describes if the Control type is Styled or Native.</docstr>
      </property>
      <property name="NativeOptions">
        <docstr>Set of properties to customize the appearance and behavior of the list view when ControlType is Platform.
This group of properties provides the subproperties described in the following table. All subproperties are disabled by default.



Subproperty

Description



Grouped



Make cells use a grouped style. The grouped style is the style that the list of iOS settings uses.



False

True









Indexed



Shows an index on the right-hand side of the list with the first letter of each header. You may tap a letter to navigate to the header that the letter represents.
If you want to display something other than the first letter of each header, use the IndexTitle of each header item to define a custom text to show for that header. Long index titles may hide important information behind them, use no more than few characters.



False

True









Styled



Make the native presentation use the style settings defined in your list view control for the following aspects of your list view:

Font
Text color and selected text color
Text alignment, both vertical and horizontal
Word wrapping and trimming
You cannot customize any other aspects of the native presentation of a list view. If you need to customize your list view further, change ControlType to Styled to use the regular FireMonkey presentation instead.



False

True

ControlType: Styled</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.ListView" name="TPresentedListView">
    <docstr></docstr>
    <members>
      <procedure name="ExecuteInterlocked">
        <docstr>Executes the specified procedure as long as there is no other call to ExecuteInterlocked in progress called from a separate thread. If there is a call to ExecuteInterlocked in progress, the specified procedure is never executed.</docstr>
      </procedure>
      <function name="CanSelectItem">
        <docstr>Returns True if the underlying data model allows the presentation layer to select the specified item; it returns False otherwise.</docstr>
      </function>
      <function name="CanUnselectItem">
        <docstr>Returns True if the underlying data model allows the presentation layer to unselect the specified item; it returns False otherwise.</docstr>
      </function>
      <procedure name="DidSelectItem">
        <docstr>The presentation layer executes this method to indicate that it has selected the specified item.</docstr>
      </procedure>
      <procedure name="DidUnselectItem">
        <docstr>The presentation layer executes this method to indicate that it has unselected the specified item.</docstr>
      </procedure>
      <procedure name="ChangeOrder">
        <docstr>Notification method called after the creation order is changed.
FMX.ListView.TPresentedListView.ChangeOrder inherits from FMX.Types.TFmxObject.ChangeOrder. All content below this line refers to FMX.Types.TFmxObject.ChangeOrder.
Notification method called after the creation order is changed. ChangeOrder is a virtual method to be implemented in subclasses to allow for changing the creation order of this FMX object.</docstr>
      </procedure>
      <procedure name="ParentChanged">
        <docstr>Executed right after the value of the Parent property changes.
FMX.ListView.TPresentedListView.ParentChanged inherits from FMX.Controls.TControl.ParentChanged. All content below this line refers to FMX.Controls.TControl.ParentChanged.
Executed right after the value of the Parent property changes.
The control does not execute ParentChanged if you assign Parent the same value that it already has.

 See Also
FMX.Controls.TControl.AncestorParentChanged
FMX.Controls.TControl.ClipChildrenChanged
FMX.Controls.TControl.EffectEnabledChanged
FMX.Controls.TControl.EnabledChanged
FMX.Controls.TControl.HandleSizeChanged
FMX.Controls.TControl.HitTestChanged
FMX.Controls.TControl.PaddingChanged
FMX.Controls.TControl.VisibleChanged
FMX.Controls.TControl.AncestorVisibleChanged
FMX.Controls.TControl.ChildrenAlignChanged</docstr>
      </procedure>
      <procedure name="PaintChildren">
        <docstr>Renders the child controls.
FMX.ListView.TPresentedListView.PaintChildren inherits from FMX.Controls.TControl.PaintChildren. All content below this line refers to FMX.Controls.TControl.PaintChildren.
Renders the child controls.
The PaintChildren method is called automatically in the process of painting of the current control. It renders child controls, if any, on the surface specified by the Canvas property. 
The effects that are applied to the control are also applied to its children.
TControl descendants can override PaintChildren to provide specific rendering of the respective controls.</docstr>
      </procedure>
      <procedure name="AncestorVisibleChanged">
        <docstr>Notifies its child controls that the visibility of an ancestor of your control has changed to Visible.
FMX.ListView.TPresentedListView.AncestorVisibleChanged inherits from FMX.Controls.TControl.AncestorVisibleChanged. All content below this line refers to FMX.Controls.TControl.AncestorVisibleChanged.
Notifies its child controls that the visibility of an ancestor of your control has changed to Visible.

 See Also
FMX.Controls.TControl.AncestorParentChanged
FMX.Controls.TControl.ChildrenAlignChanged
FMX.Controls.TControl.ClipChildrenChanged
FMX.Controls.TControl.EffectEnabledChanged
FMX.Controls.TControl.EnabledChanged
FMX.Controls.TControl.HandleSizeChanged
FMX.Controls.TControl.HitTestChanged
FMX.Controls.TControl.PaddingChanged
FMX.Controls.TControl.ParentChanged</docstr>
      </procedure>
      <procedure name="DoSetItemIndexInternal">
        <docstr>Used internally by presentation hook.

Used internally by presentation hook.</docstr>
      </procedure>
      <procedure name="DoEditModeChange">
        <docstr>Responds to entering of the list view into edit mode.
The DoEditModeChange method also fires an OnEditModeChange event.</docstr>
      </procedure>
      <procedure name="DoItemsChange">
        <docstr>This virtual method is called inmediately after a list of items has been changed.</docstr>
      </procedure>
      <procedure name="DoItemsInvalidate">
        <docstr>Called when the items of the adapter need to be painted again.
FMX.ListView.TPresentedListView.DoItemsInvalidate inherits from FMX.ListView.TAdapterListView.DoItemsInvalidate. All content below this line refers to FMX.ListView.TAdapterListView.DoItemsInvalidate.
Called when the items of the adapter need to be painted again.

 See Also
FMX.ListView.TAdapterListView.DoItemsChange
FMX.ListView.TAdapterListView.DoItemsCouldHaveChanged
FMX.ListView.TAdapterListView.DoItemsMayChange
FMX.ListView.TAdapterListView.DoItemsResize
FMX.Controls.TControl.Repaint</docstr>
      </procedure>
      <procedure name="DoItemInvalidated">
        <docstr>Notifies the TListView that the item requires repainting.
FMX.ListView.TPresentedListView.DoItemInvalidated inherits from FMX.ListView.TListViewBase.DoItemInvalidated. All content below this line refers to FMX.ListView.TListViewBase.DoItemInvalidated.
Notifies the TListView that the item requires repainting.</docstr>
      </procedure>
      <procedure name="DoCheckStateChanged">
        <docstr>Notifies the TListView that a control inside of an item is clicked.
FMX.ListView.TPresentedListView.DoCheckStateChanged inherits from FMX.ListView.TListViewBase.DoCheckStateChanged. All content below this line refers to FMX.ListView.TListViewBase.DoCheckStateChanged.
Notifies the TListView that a control inside of an item is clicked.</docstr>
      </procedure>
      <procedure name="DoUpdateScrollViewPos">
        <docstr>Used internally by presentation hook.

Used internally by presentation hook.</docstr>
      </procedure>
      <procedure name="DoSetScrollViewPos">
        <docstr>Used internally by presentation hook.

Used internally by presentation hook.</docstr>
      </procedure>
      <procedure name="DoDeleteItem">
        <docstr>Delets a specific item.
FMX.ListView.TPresentedListView.DoDeleteItem inherits from FMX.ListView.TListViewBase.DoDeleteItem. All content below this line refers to FMX.ListView.TListViewBase.DoDeleteItem.
Delets a specific item.
It is called from DeleteItem</docstr>
      </procedure>
      <procedure name="DoResetEditModeAnimation">
        <docstr>Called at the end of the animation that plays when the edit mode is toggled.
FMX.ListView.TPresentedListView.DoResetEditModeAnimation inherits from FMX.ListView.TListViewBase.DoResetEditModeAnimation. All content below this line refers to FMX.ListView.TListViewBase.DoResetEditModeAnimation.
Called at the end of the animation that plays when the edit mode is toggled.</docstr>
      </procedure>
      <procedure name="DoUpdateScrollingLimits">
        <docstr>Updates the scrolling limits and animation boundaries.
FMX.ListView.TPresentedListView.DoUpdateScrollingLimits inherits from FMX.ListView.TListViewBase.DoUpdateScrollingLimits. All content below this line refers to FMX.ListView.TListViewBase.DoUpdateScrollingLimits.
Updates the scrolling limits and animation boundaries.</docstr>
      </procedure>
      <procedure name="DoAbsoluteChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="PMAncesstorPresentationLoaded">
        <docstr>Notification that indicates that the ancestor of the TPresentedControl class loaded the presentation.</docstr>
      </procedure>
      <procedure name="RecreateNativePresentation">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="ShouldHandleEvents">
        <docstr>Returns True if this ListView should handle input events.

FMX.ListView.TPresentedListView.ShouldHandleEvents inherits from FMX.ListView.TListViewBase.ShouldHandleEvents. All content below this line refers to FMX.ListView.TListViewBase.ShouldHandleEvents.
Returns True if this ListView should handle input events.</docstr>
      </function>
      <function name="GetRootObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetContentFrame">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetControlOpacity">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetAdapter">
        <docstr>Implements the IListViewPresentationParent.GetAdapter method. 
The GetAdapter method of TPresentedListView implements the GetAdapter method of IListViewPresentationParent.</docstr>
      </function>
      <function name="GetItemText">
        <docstr>Implements the IListViewPresentationParent.GetItemText method. 
The GetItemText method of TPresentedListView implements the GetItemText method of IListViewPresentationParent.</docstr>
      </function>
      <function name="GetItemIndexTitle">
        <docstr>Implements the IListViewPresentationParent.GetItemIndexTitle method. 
The GetItemIndexTitle method of TPresentedListView implements the GetItemIndexTitle method of IListViewPresentationParent.</docstr>
      </function>
      <procedure name="ItemButtonClicked">
        <docstr>Implements the IListViewPresentationParent.ItemButtonClicked method. 
The ItemButtonClicked method of TPresentedListView implements the ItemButtonClicked method of IListViewPresentationParent.</docstr>
      </procedure>
      <procedure name="InvokePullRefresh">
        <docstr>Implements the IListViewPresentationParent.InvokePullRefresh method.
The InvokePullRefresh method of TPresentedListView implements the InvokePullRefresh method of IListViewPresentationParent</docstr>
      </procedure>
      <procedure name="SetSearchFilter">
        <docstr>Implements the IListViewPresentationParent.SetSearchFilter method. 
The SetSearchFilter method of TPresentedListView implements the SetSearchFilter method of IListViewPresentationParent.</docstr>
      </procedure>
      <function name="GetTableViewFlags">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetTableViewOptions">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetCreatingNativeView">
        <docstr>Sets a Boolean flag that indicates a native view is being created. It is used as a guard condition to prevent TListView logic from interfering with the presentation while a view is being initialized.</docstr>
      </procedure>
      <function name="GetIsTransparent">
        <docstr>It is True if the TListView is transparent.</docstr>
      </function>
      <function name="GetOpacity">
        <docstr>Gets to control opacity.</docstr>
      </function>
      <function name="GetBackgroundStyleColor">
        <docstr>Gets the background color defined by the TListView style.</docstr>
      </function>
      <procedure name="DoItemsResize">
        <docstr>Called when the size of the items of the adapter has changed.
FMX.ListView.TPresentedListView.DoItemsResize inherits from FMX.ListView.TAdapterListView.DoItemsResize. All content below this line refers to FMX.ListView.TAdapterListView.DoItemsResize.
Called when the size of the items of the adapter has changed.

 See Also
FMX.ListView.TAdapterListView.DoItemsMayChange
FMX.ListView.TAdapterListView.DoItemsChange
FMX.ListView.TAdapterListView.DoItemsCouldHaveChanged
FMX.ListView.TAdapterListView.DoItemsInvalidate</docstr>
      </procedure>
      <function name="HasDesignPresentationAttached">
        <docstr>It is True if a design presentation is attached.</docstr>
      </function>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.ListView.TPresentedListView.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="BeforeDestruction">
        <docstr>Performs any necessary actions before the first destructor is called.
Performs any necessary actions before the first destructor is called.
FMX.ListView.TPresentedListView.BeforeDestruction inherits from System.Classes.TComponent.BeforeDestruction. All content below this line refers to System.Classes.TComponent.BeforeDestruction.
Performs any necessary actions before the first destructor is called.
BeforeDestruction is called automatically immediately before the component&apos;s first destructor executes. Do not call it explicitly in your applications.
As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place.</docstr>
      </procedure>
      <procedure name="RecalcEnabled">
        <docstr>Forces the current control to recalculate its enabled state. 
FMX.ListView.TPresentedListView.RecalcEnabled inherits from FMX.Controls.TControl.RecalcEnabled. All content below this line refers to FMX.Controls.TControl.RecalcEnabled.
Forces the current control to recalculate its enabled state.  RecalcEnabled also forces the control&apos;s children to recalculate their enabled state.</docstr>
      </procedure>
      <procedure name="Show">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Hide">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.ListView.TPresentedListView.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the list view.</docstr>
      </procedure>
      <procedure name="RebuildList">
        <docstr>Recreates the list and updates the visible items content in native presentation. 
When using native presentation, RebuildList recreates the list and updates the visible items content.
To use the native presentation, you must set the ControlType property to Platform.</docstr>
      </procedure>
      <procedure name="StopPullRefresh">
        <docstr>This method should be called when &apos;pull to refresh&apos; mode has been triggered to stop the spinning wheel.
StopPullRefresh has only effect in native iOS control and only when the PullRefreshWait property is set to True.</docstr>
      </procedure>
      <procedure name="RecalcOpacity">
        <docstr>Forces the current control to recalculate its Opacity property. 
FMX.ListView.TPresentedListView.RecalcOpacity inherits from FMX.Controls.TControl.RecalcOpacity. All content below this line refers to FMX.Controls.TControl.RecalcOpacity.
Forces the current control to recalculate its Opacity property.  RecalcOpacity also forces the control&apos;s children to recalculate their Opacity property.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.ListView" name="TAppearanceListView">
    <docstr></docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.ListView.TAppearanceListView.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="ObjectsNotify">
        <docstr>Handler of the TAppearanceListViewItems.OnNotify property.</docstr>
      </procedure>
      <procedure name="SetAppearanceListViewItems">
        <docstr>The TAppearanceListView needs adapter to be the TAppearanceListViewItems or derivative.
If the TAppearanceListView is used with a custom adapter, use the Items property to set it instead of the Adapter property of the base class.</docstr>
      </procedure>
      <procedure name="DoResetView">
        <docstr>Called when the view of the specified item of the adapter needs to be recreated.
FMX.ListView.TAppearanceListView.DoResetView inherits from FMX.ListView.TAdapterListView.DoResetView. All content below this line refers to FMX.ListView.TAdapterListView.DoResetView.
Called when the view of the specified item of the adapter needs to be recreated.</docstr>
      </procedure>
      <function name="HasButtonsInCells">
        <docstr>Returns True if each list view item contains one or more buttons, or False otherwise.
FMX.ListView.TAppearanceListView.HasButtonsInCells inherits from FMX.ListView.TListViewBase.HasButtonsInCells. All content below this line refers to FMX.ListView.TListViewBase.HasButtonsInCells.
Returns True if each list view item contains one or more buttons, or False otherwise.

 See Also
FMX.ListView.TListViewBase.CanSwipeDelete
FMX.ListView.TListViewBase.EditMode
FMX.ListView.TListViewBase.HasCheckboxMode
FMX.ListView.TListViewBase.HasDeletionEditMode
FMX.ListView.TListViewBase.PullRefreshWait
FMX.ListView.TListViewBase.PullToRefresh
FMX.ListView.TListViewBase.SearchAlwaysOnTop
FMX.ListView.TListViewBase.SearchVisible
FMX.Controls.TControl.Enabled
FMX.Controls.TControl.Visible</docstr>
      </function>
      <function name="HasDeletionEditMode">
        <docstr>Returns True if the list view supports a mode where you can select list view items to delete, or False otherwise.
FMX.ListView.TAppearanceListView.HasDeletionEditMode inherits from FMX.ListView.TListViewBase.HasDeletionEditMode. All content below this line refers to FMX.ListView.TListViewBase.HasDeletionEditMode.
Returns True if the list view supports a mode where you can select list view items to delete, or False otherwise.

 See Also
FMX.ListView.TListViewBase.CanSwipeDelete
FMX.ListView.TListViewBase.EditMode
FMX.ListView.TListViewBase.HasButtonsInCells
FMX.ListView.TListViewBase.HasCheckboxMode
FMX.ListView.TListViewBase.PullRefreshWait
FMX.ListView.TListViewBase.PullToRefresh
FMX.ListView.TListViewBase.SearchAlwaysOnTop
FMX.ListView.TListViewBase.SearchVisible
FMX.Controls.TControl.Enabled
FMX.Controls.TControl.Visible</docstr>
      </function>
      <function name="HasCheckboxMode">
        <docstr>Returns True if the list view supports a mode where you can select list view items using checkboxes, or False otherwise.
FMX.ListView.TAppearanceListView.HasCheckboxMode inherits from FMX.ListView.TListViewBase.HasCheckboxMode. All content below this line refers to FMX.ListView.TListViewBase.HasCheckboxMode.
Returns True if the list view supports a mode where you can select list view items using checkboxes, or False otherwise.

 See Also
FMX.ListView.TListViewBase.CanSwipeDelete
FMX.ListView.TListViewBase.EditMode
FMX.ListView.TListViewBase.HasButtonsInCells
FMX.ListView.TListViewBase.HasDeletionEditMode
FMX.ListView.TListViewBase.PullRefreshWait
FMX.ListView.TListViewBase.PullToRefresh
FMX.ListView.TListViewBase.SearchAlwaysOnTop
FMX.ListView.TListViewBase.SearchVisible
FMX.Controls.TControl.Enabled
FMX.Controls.TControl.Visible</docstr>
      </function>
      <procedure name="SetItemHeight">
        <docstr>Setter of ItemHeight.</docstr>
      </procedure>
      <procedure name="SetItemEditHeight">
        <docstr>Setter of ItemEditHeight.</docstr>
      </procedure>
      <procedure name="SetHeaderHeight">
        <docstr>Setter of HeaderHeight.</docstr>
      </procedure>
      <procedure name="SetFooterHeight">
        <docstr>Setter of FooterHeight.</docstr>
      </procedure>
      <function name="GetAppearanceListViewItem">
        <docstr>Returns the list view item that is located at the specified index of the list of items.</docstr>
      </function>
      <function name="GetItemHeight">
        <docstr>Returns the height of the list view item that has the specified index in the list of items, or the value of ItemHeight if you do not specify any index.</docstr>
      </function>
      <function name="GetItemHeight">
        <docstr>Returns the height of the list view item that has the specified index in the list of items, or the value of ItemHeight if you do not specify any index.</docstr>
      </function>
      <function name="GetItemEditHeight">
        <docstr>Getter of ItemEditHeight.</docstr>
      </function>
      <function name="GetHeaderHeight">
        <docstr>Getter of HeaderHeight.</docstr>
      </function>
      <function name="GetFooterHeight">
        <docstr>Getter of FooterHeight.</docstr>
      </function>
      <procedure name="WillEnterEditMode">
        <docstr>Invoked when the Edit mode is being changed.

FMX.ListView.TAppearanceListView.WillEnterEditMode inherits from FMX.ListView.TListViewBase.WillEnterEditMode. All content below this line refers to FMX.ListView.TListViewBase.WillEnterEditMode.
Invoked when the Edit mode is being changed.
If the Edit mode requires a different appearance, this is where an update of appearances needs to be initiated.</docstr>
      </procedure>
      <procedure name="DoResetEditModeAnimation">
        <docstr>Called at the end of the animation that plays when the edit mode is toggled.
FMX.ListView.TAppearanceListView.DoResetEditModeAnimation inherits from FMX.ListView.TListViewBase.DoResetEditModeAnimation. All content below this line refers to FMX.ListView.TListViewBase.DoResetEditModeAnimation.
Called at the end of the animation that plays when the edit mode is toggled.</docstr>
      </procedure>
      <procedure name="DoAdapterSet">
        <docstr>Called right after the adapter of the list view is set.
FMX.ListView.TAppearanceListView.DoAdapterSet inherits from FMX.ListView.TAdapterListView.DoAdapterSet. All content below this line refers to FMX.ListView.TAdapterListView.DoAdapterSet.
Called right after the adapter of the list view is set.</docstr>
      </procedure>
      <procedure name="DoRequestReindexing">
        <docstr>Hook for the  IListViewController.RequestReindexing.
FMX.ListView.TAppearanceListView.DoRequestReindexing inherits from FMX.ListView.TListViewBase.DoRequestReindexing. All content below this line refers to FMX.ListView.TListViewBase.DoRequestReindexing.
Hook for the  IListViewController.RequestReindexing.</docstr>
      </procedure>
      <procedure name="DoItemResized">
        <docstr>Hook for the  IListViewController.ItemResized.
FMX.ListView.TAppearanceListView.DoItemResized inherits from FMX.ListView.TListViewBase.DoItemResized. All content below this line refers to FMX.ListView.TListViewBase.DoItemResized.
Hook for the  IListViewController.ItemResized.</docstr>
      </procedure>
      <procedure name="DoCheckStateChanged">
        <docstr>Notifies the TListView that a control inside of an item is clicked.
FMX.ListView.TAppearanceListView.DoCheckStateChanged inherits from FMX.ListView.TListViewBase.DoCheckStateChanged. All content below this line refers to FMX.ListView.TListViewBase.DoCheckStateChanged.
Notifies the TListView that a control inside of an item is clicked.</docstr>
      </procedure>
      <procedure name="DoControlClicked">
        <docstr>Notifies the TListView that an item is clicked.
FMX.ListView.TAppearanceListView.DoControlClicked inherits from FMX.ListView.TListViewBase.DoControlClicked. All content below this line refers to FMX.ListView.TListViewBase.DoControlClicked.
Notifies the TListView that an item is clicked.</docstr>
      </procedure>
      <function name="GetAppearanceProperties">
        <docstr>Returns an array with the objects of appearance properties of list view items.
The array contains the objects of appearance properties in the following order:

Appearance of regular items in edit mode.
Appearance of regular items.
Appearance of header items.
Appearance of footer items.</docstr>
      </function>
      <procedure name="RefreshAppearances">
        <docstr>Refresh items with specified purposes.
Refresh all items if the set is empty.</docstr>
      </procedure>
      <procedure name="UpdateAppearanceStyleResources">
        <docstr>Refresh items with specified purposes.</docstr>
      </procedure>
      <procedure name="ItemAppearanceChange">
        <docstr>Called when the appearance of the items is changed.</docstr>
      </procedure>
      <procedure name="ItemAppearanceChangeObjects">
        <docstr>Notifies the owner of the change in the appearance view.</docstr>
      </procedure>
      <procedure name="ItemAppearanceChangeHeight">
        <docstr>Called when the heights of the items are changed.</docstr>
      </procedure>
      <procedure name="EditModeAppearances">
        <docstr>Prepares the appearance of the list view items for the animation that plays when the list view enters the edit mode.
The list view calls EditModeAppearances when the EditMode property of the list view changes from False to True and the run-time platform supports edit mode animations, provided that the event handler of OnEditModeChanging did not prepare the appearance already.</docstr>
      </procedure>
      <procedure name="InitializeItemAppearance">
        <docstr>Fills the AppearanceClass property of the specified instance of TItemAppearanceProperties with a default value.</docstr>
      </procedure>
      <procedure name="DoListItemClick">
        <docstr>Dispatches the OnItemClick event.
DoListItemClick receives a single parameter, AItem, which is the clicked list view item.
If AItem is an instance of TListViewItem, DoListItemClick passes itself (as the Sender parameter) and the received AItem to the event handler of OnItemClick.</docstr>
      </procedure>
      <procedure name="DoUpdatingItemView">
        <docstr>Dispatches the OnUpdatingItemView event.
DoUpdatingItemView receives the following parameters:

AListItem is the target list view item.
AHandled determines whether the event handler of OnUpdatingItemView takes care of updating the appearance of the list view item (True) or DoUpdatingItemView must update the appearance of the list view item instead (False).
DoUpdatingItemView passes itself (as the Sender parameter) and the received AListItem and AHandled parameters to the event handler of OnUpdatingItemView.
If AListItem is an instance of TListViewItem, DoUpdatingItemView also passes itself (as the Sender parameter) and the received AListItem and AHandled parameters to the event handler of OnUpdatingObjects.</docstr>
      </procedure>
      <procedure name="DoUpdateItemView">
        <docstr>Dispatches the OnUpdateItemView and OnUpdateObjects events.
DoUpdateItemView receives a single parameter, AItem, which is the target list view item.
DoUpdateItemView passes itself (as the Sender parameter) and the received AItem to the event handler of OnUpdateItemView.
If AItem is an instance of TListViewItem, DoUpdateItemView also passes itself (as the Sender parameter) and the received AItem to the event handler of OnUpdateObjects.</docstr>
      </procedure>
      <property name="ItemHeight">
        <docstr>Height in pixels of each regular list view item.</docstr>
      </property>
      <property name="ItemEditHeight">
        <docstr>Height in pixels of each regular list view item when the list view is in edit mode.</docstr>
      </property>
      <property name="HeaderHeight">
        <docstr>Height in pixels of each header list view item.</docstr>
      </property>
      <property name="FooterHeight">
        <docstr>Height in pixels of each footer list view item.</docstr>
      </property>
      <property name="ItemEditAppearanceClassName">
        <docstr>Name of the appearance class of regular list view items in edit mode.</docstr>
      </property>
      <property name="ItemAppearanceClassName">
        <docstr>Name of the appearance class of regular list view items.</docstr>
      </property>
      <property name="HeaderAppearanceClassName">
        <docstr>Name of the appearance class of header list view items.</docstr>
      </property>
      <property name="FooterAppearanceClassName">
        <docstr>Name of the appearance class of footer list view items.</docstr>
      </property>
      <property name="ItemAppearanceName">
        <docstr>Name of the appearance of regular list view items.
When your list view switches between display mode and edit mode, the item appearance switches between the appearance defined in the ItemAppearanceName property (display mode) and the appearance defined in the ItemEditAppearanceName property (edit mode). Items may display an animation as their appearance changes.
Possible values are:



ItemAppearanceName

ItemEditAppearanceName

List Item Preview


Not Selected

Selected


Custom

Custom






ImageListItem

ImageListItemDeleteImageListItemShowCheck






ImageListItemBottomDetail

ImageListItemBottomDetailShowCheck






ImageListItemBottomDetailRightButton

ImageListItemBottomDetailRightButtonShowCheck






ImageListItemRightButton

ImageListItemRightButtonDeleteImageListItemRightButtonShowCheck






ListItem

ListItemDeleteListItemShowCheck






ListItemRightDetail

ListItemRightDetailDeleteListItemRightDetailShowCheck</docstr>
      </property>
      <property name="ItemEditAppearanceName">
        <docstr>Name of the appearance of regular list view items in edit mode.
When your list view switches between display mode and edit mode, the item appearance switches between the appearance defined in the ItemAppearanceName property (display mode) and the appearance defined in the ItemEditAppearanceName property (edit mode). Items may display an animation as their appearance changes.
You can find the possible values in the table below.



ItemEditAppearance

ItemAppearanceName

Editing Mode

List Item Preview


Not Selected

Selected


Custom

Custom

Custom






ImageListItemBottomDetailShowCheck

ImageListItemBottomDetail

Select






ImageListItemBottomDetailRightButtonShowCheck

ImageListItemBottomDetailRightButton

Select






ImageListItemDelete

ImageListItem

Delete






ImageListItemRightButtonDelete

ImageListItemRightButton

Delete






ImageListItemRightButtonShowCheck

ImageListItemRightButton

Select






ImageListItemShowCheck

ImageListItem

Select






ListItemDelete

ListItem

Delete






ListItemRightDetailDelete

ListItemRightDetail

Delete






ListItemRightDetailShowCheck

ListItemRightDetail

Select






ListItemShowCheck

ListItem

Select





Each edit mode item appearance matches a display mode item appearance (ItemAppearanceName). The type of editing mode described in the table above determines how list items behave.



Item

Behavior


Delete

Tap a list item to show a Delete button. Tap Delete to delete the item, tap anywhere else to hide the Delete button.


Select

Tap a list item to select it. Tap again to unselect it. You can select more than one item (multiselect).


Custom

Your custom implementation of the edit mode item appearance determines the behavior of list items.</docstr>
      </property>
      <property name="HeaderAppearanceName">
        <docstr>Name of the appearance of header list view items.
Possible values are:



Item

Description


Custom

Custom appearance.


ListHeader

Default appearance.</docstr>
      </property>
      <property name="FooterAppearanceName">
        <docstr>Name of the appearance of footer list view items.
Possible values are:



Item

Description


Custom

Custom appearance.


ListHeader

Default appearance.</docstr>
      </property>
      <property name="ItemAppearance">
        <docstr>Specifies the various options that are used when rendering the list view items.

Note: This is a design-time property. At run time access the relevant properties of the list view instead. See TPublishedAppearance for more information.
Use the ItemAppearance property in order to control how an item from this list view component is displayed. The ItemAppearance property controls the footer, header, and list item appearance and height, and also the list item appearance and height when in edit mode.</docstr>
      </property>
      <property name="ItemAppearanceObjects">
        <docstr>Allows you to specify properties of individual item appearance objects. These objects include footer, header, item, and item in edit mode objects.
Use the ItemAppearanceObjects property in order to control various properties of the objects that might be part of this list view component. For instance, you can specify accessory and text settings for the items or you can affect text settings for the footer and header items.</docstr>
      </property>
      <event name="OnButtonChange">
        <docstr>Occurs immediately when you check a glyph button (such as a check box or a delete button) inside a list view item.
Write an OnButtonChange event handler to provide additional functionality when checking a glyph button (such as a check box or a delete button) inside a list view item.</docstr>
      </event>
      <event name="OnButtonClick">
        <docstr>Occurs immediately when you click on a text button or a glyph button inside a list view item.
Write an OnButtonClick event handler to provide additional functionality when clicking on a text button or a glyph button inside a list view item.</docstr>
      </event>
      <constructor name="Create">
        <docstr>Creates an instance of TAppearanceListView with the specified component as its owner.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TAppearanceListView.</docstr>
      </destructor>
      <procedure name="BeginUpdate">
        <docstr>Marks the start of an update session of the control and its children.
FMX.ListView.TAppearanceListView.BeginUpdate inherits from FMX.Controls.TControl.BeginUpdate. All content below this line refers to FMX.Controls.TControl.BeginUpdate.
Marks the start of an update session of the control and its children. 
It increases the value of the FUpdating semaphore. A call to BeginUpdate must be complemented by calls to EndUpdate after the update is finished.
FUpdating is an internal semaphore used to mark the process of control updating. Painting of a control is disabled while FUpdating is higher than 0.

 See Also
FMX.Controls.TControl.FUpdating
FMX.Controls.TControl.EndUpdate
FMX.Controls.TControl.IsUpdating</docstr>
      </procedure>
      <procedure name="EndUpdate">
        <docstr>Marks the end of an update session of the control and its children.
FMX.ListView.TAppearanceListView.EndUpdate inherits from FMX.Controls.TControl.EndUpdate. All content below this line refers to FMX.Controls.TControl.EndUpdate.
Marks the end of an update session of the control and its children.
The update session must be started first by calling BeginUpdate.
EndUpdate decreases the FUpdating semaphore. If all update sessions end and FUpdating is 0, EndUpdate invokes Realign to process layout changes.

 See Also
FMX.Controls.TControl.FUpdating
FMX.Controls.TControl.BeginUpdate
FMX.Controls.TControl.IsUpdating
FMX.Controls.TControl.Realign</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.ListView.TAppearanceListView.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <property name="Items">
        <docstr>Provides access to individual items in this list view component.
Use the Items property in order to access each individual item stored in this list view component. The Items property is also used if you want to add items to the list view, in a programmatic manner. Otherwise, you would normally add the items automatically via LiveBindings.</docstr>
      </property>
      <event name="OnItemClick">
        <docstr>Occurs immediately after clicking an item from the list view.
Write an OnItemClick event handler to respond to clicking on an item from the list view component.
OnItemClick is an event of type TItemEvent.
Do not modify the contents of the list view in the OnItemClick event handler (do not add, remove, update or change the order of list view items). If you need to do that, use OnItemClickEx event handler instead. It is safe to modify the content of the items themselves in both of those handlers.
The OnItemClick event handler receives the following parameters:



Parameter

Description



Sender



The instance of TCustomListView to which the clicked item belongs.




AItem



The instance of Appearances.TListViewItem that you click on.</docstr>
      </event>
      <event name="OnUpdatingObjects">
        <docstr>Occurs immediately before the list view component is updated.
Write an OnUpdatingObjects event handler to provide additional functionality before updating the list view component. 
OnUpdatingObjects is an event of type TItemEvent.</docstr>
      </event>
      <event name="OnUpdateObjects">
        <docstr>Occurs immediately after the list view component is updated.
Write an OnUpdateObjects event handler to provide additional functionality after updating the list view component. 
OnUpdateObjects is an event of type TItemEvent.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.ListView" name="TListView">
    <docstr>Represents a FireMonkey list view component that you can use to hold and present various types of items.
The TListView displays a collection of items in a list that is optimized for LiveBindings and for fast and smooth scrolling. 
The items in the list view can have one or more of the following appearance features:

A caption or detail text (for example, using the Item.Text bindable member of TListView)
An associated image (for example, using the Item.Bitmap bindable member of TListView)
An accessory icon (for example, using the ItemEditAppearance property in the Object Inspector)
A graphic or a text button attached (for example, using the Item.ButtonText bindable member of TListView)
You can customize the appearance of a list view by modifying the layout of the list items, including the caption, the associated image, text details, or the accessory icon.
TListView has the edit mode in which  you can select several items.

Example
You can add items to a TListView either by binding to a data source, or by code (TListView.Items.Add).  
Here is a code example that shows how to add items to a TListView:


Delphi:

var
  LItem: TListViewItem;
  I: Integer;
begin
  for I := 1 to 10 do
  begin
    LItem := ListView1.Items.Add;
    LItem.Text := IntToStr(I); 
 end;
end;

// To achieve the best performance use BeginUpdate and EndUpdate.

var
  LItem: TListViewItem;
  I: Integer;
begin
  ListView1.BeginUpdate;
  try
    for I := 1 to 10 do
    begin
      LItem := ListView1.Items.Add;
      LItem.Text := IntToStr(I);
    end;
  finally
    ListView1.EndUpdate;
  end;
end;



C++:

for (int i = 1; i &lt;= 10; i++) {
  TListViewItem* item = ListView1-&gt;Items-&gt;Add();
  item-&gt;Text = IntToStr(i);
}

// To achieve the best performance use BeginUpdate and EndUpdate.

ListView1-&gt;BeginUpdate();
try {
  for (int i = 1; i &lt;= 10; i++) {
    TListViewItem* item = ListView1-&gt;Items-&gt;Add();
    item-&gt;Text = IntToStr(i);
  }
} catch (...) {
}
ListView1-&gt;EndUpdate();</docstr>
    <members>
      <procedure name="InitializeItemAppearance">
        <docstr>Fills the AppearanceClass property of the specified instance of TItemAppearanceProperties with a default value.
FMX.ListView.TListView.InitializeItemAppearance inherits from FMX.ListView.TAppearanceListView.InitializeItemAppearance. All content below this line refers to FMX.ListView.TAppearanceListView.InitializeItemAppearance.
Fills the AppearanceClass property of the specified instance of TItemAppearanceProperties with a default value.

 See Also
FMX.ListView.TAppearanceListView.Create</docstr>
      </procedure>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TContainedBindComponent">
    <docstr>Base class for all common binding components descending from it.
TContainedBindComponent is an abstract class that is the base class for TCommonBindComponent.</docstr>
    <members>
      <function name="GetBindingsList">
        <docstr>Protected getter method for the BindingsList property.</docstr>
      </function>
      <procedure name="ReadState">
        <docstr>Reads the state of this component.
ReadState is used internally in the component streaming system. It is not necessary to call it directly.
ReadState expects a TReader object, which is used for reading the state of the component.</docstr>
      </procedure>
      <function name="GetControlComponent">
        <docstr>Protected getter method for the ControlComponent property.</docstr>
      </function>
      <procedure name="SetControlComponent">
        <docstr>Protected setter method for the ControlComponent property.</docstr>
      </procedure>
      <procedure name="CheckControlComponent">
        <docstr>Verifies whether the control component is assigned.
If the ControlComponent is nil, then CheckControlComponent raises an exception.</docstr>
      </procedure>
      <function name="GetDisplayName">
        <docstr>Protected getter implementation for the DisplayName property.</docstr>
      </function>
      <function name="Designing">
        <docstr>Returns whether this component is in design mode.</docstr>
      </function>
      <function name="Loading">
        <docstr>Returns whether this component is in loading mode.</docstr>
      </function>
      <procedure name="DoReactivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of the TContainedBindComponent class.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of the TContainedBindComponent class.</docstr>
      </destructor>
      <function name="CanSetControlComponent">
        <docstr>Returns whether the control component can be set a given value.
As implemented in TContainedBindComponent, CanSetControlComponent always returns True, but in descendants it actually returns whether the given Value (that is itself a TComponent) can be assigned to the control component.</docstr>
      </function>
      <function name="GetParentComponent">
        <docstr>Returns the containing component.
GetParentComponent returns a reference to the component that contains the current component, or nil if there is no container. Use HasParent to determine whether a component has a containing component.</docstr>
      </function>
      <function name="HasParent">
        <docstr>Verifies whether the contained binding component has a parent.
HasParent returns True if the contained binding component has a parent, False otherwise.</docstr>
      </function>
      <procedure name="SetParentComponent">
        <docstr>Sets the parent component of this component.
SetParentComponent is used internally in the component streaming system. It is not necessary to call it directly.</docstr>
      </procedure>
      <property name="BindingsList">
        <docstr>Specifies a list that holds the binding expressions.</docstr>
      </property>
      <property name="Index">
        <docstr>Returns the index of this component in the bindings list.</docstr>
      </property>
      <property name="ControlComponent">
        <docstr>Specifies the component that will be bound to the source component, by means of LiveBindings.</docstr>
      </property>
      <property name="DisplayName">
        <docstr>Returns a string containing the name of this component.</docstr>
      </property>
      <property name="Category">
        <docstr>Specifies a category for this component.
For example, for a binding expression called BindExpressionForm121, of type TBindExpression, the following code:

  ShowMessage(BindExpressionForm121.Category);

shows the following message: Binding Expressions.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TCustomBindingsList">
    <docstr>Represents the base class for the binding list.
The TCustomBindingsList class implements a list of binding expressions, output converters, method scopes, and other binding list-related functionality.</docstr>
    <members>
      <procedure name="AddBindComp">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RemoveBindComp">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
Data.Bind.Components.TCustomBindingsList.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Data.Bind.Components.TCustomBindingsList.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Data.Bind.Components.TCustomBindingsList.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <function name="GetMethodsScope">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetOutputConverter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Notify">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="GetChildren">
        <docstr>Enumerates all child components.
Data.Bind.Components.TCustomBindingsList.GetChildren inherits from System.Classes.TComponent.GetChildren. All content below this line refers to System.Classes.TComponent.GetChildren.
Enumerates all child components.
GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
GetChildren expects a TGetChildProc routine that receives all enumerated components. 
Root represents the owner of the components that will be enumerated.
This method does nothing in TComponent and is expected to be overridden in descendants.</docstr>
      </procedure>
      <property name="Methods">
        <docstr>Specifies a list of available methods. For more information about these methods, read the LiveBindings Methods topic.</docstr>
      </property>
      <property name="OutputConverters">
        <docstr>Specifies a list of available output converters. For more information about output converters, read the LiveBindings Output Converters help topic.</docstr>
      </property>
      <function name="GetEnumerator">
        <docstr>Returns a TComponent enumerator.
Data.Bind.Components.TCustomBindingsList.GetEnumerator inherits from System.Classes.TComponent.GetEnumerator. All content below this line refers to System.Classes.TComponent.GetEnumerator.
Returns a TComponent enumerator.
GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop.</docstr>
      </function>
      <property name="BindCompCount">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="UseAppManager">
        <docstr>Specifies whether the bindings list uses the global application manager for managed bindings.</docstr>
      </property>
      <property name="PromptDeleteUnused">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="DependencyList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TBindingsList">
    <docstr>Implements the bindings list component. TBindingsList is built on the TCustomBindingsList component and publishes additional properties that can be accessed from within the Object Inspector.</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TEvalEnumeratorToEditor">
    <docstr></docstr>
    <members>
      <property name="Source">
        <docstr>Enumerator of data source records, such as records in a dataset.</docstr>
      </property>
      <property name="SourceMemberName">
        <docstr>Data source member name, such as a FieldName.</docstr>
      </property>
      <property name="Editor">
        <docstr>Editor for a list, such as a FMX TListView.</docstr>
      </property>
      <property name="EditorMemberName">
        <docstr>Member name for a list, such as &quot;Text&quot;.</docstr>
      </property>
      <property name="UseEvalShortcuts">
        <docstr>Indicate whether the assignment can be evaluated without expression engine.</docstr>
      </property>
      <property name="Expression">
        <docstr>Expression engine description of assignment.</docstr>
      </property>
      <event name="OnEvalError">
        <docstr>Event to execute when the expression engine raises an exception</docstr>
      </event>
      <property name="Custom">
        <docstr>Indicate whether the expression has been customized.  A customized expression must
           be evaluated with expression engine, rather than by shortcut.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TEvalEnumerator">
    <docstr></docstr>
    <members>
      <property name="Source">
        <docstr>Enumerator of data source records, such as records in a dataset.</docstr>
      </property>
      <property name="SourceMemberName">
        <docstr>Data source member name, such as a FieldName.</docstr>
      </property>
      <property name="UseEvalShortcuts">
        <docstr>Indicate whether the assignment can be evaluated without expression engine.</docstr>
      </property>
      <property name="Expression">
        <docstr>Expression engine description of expression to evaluate.</docstr>
      </property>
      <event name="OnEvalError">
        <docstr>Event to call when the expression engine raises an exception</docstr>
      </event>
      <property name="Custom">
        <docstr>Indicate whether the expression has been customized.  A customized
           expression must be evaluated with expression engine, rather than as a shortcut</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TCustomBindGridList">
    <docstr></docstr>
    <members>
      <procedure name="FillHeaderRecord">
        <docstr>Evaluate expressions to fill a break header</docstr>
      </procedure>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TBindComponentDelegate">
    <docstr></docstr>
    <members>
      <procedure name="Reactivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetActive">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="GenerateExpressions">
        <docstr>Automatically generates the bindings expressions for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <procedure name="ClearGeneratedExpressions">
        <docstr>Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <procedure name="Activated">
        <docstr>Informs the wrapper binding component that a delegate (or contained) binding component has been activated.</docstr>
      </procedure>
      <function name="CanActivate">
        <docstr>Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
The CanActivate method returns True if the delegate (or contained) binding component can be activated, False otherwise.</docstr>
      </function>
      <function name="RequiresControlHandler">
        <docstr>Used internally for observing purposes.</docstr>
      </function>
      <function name="GetSourceScopes">
        <docstr>Returns an array of scopes for the source component.</docstr>
      </function>
      <procedure name="MemberRenaming">
        <docstr>Used for renaming a member of this binding component.
MemberRenaming is used for renaming component members. The old member name is given through the ACurMemberName parameter, while the new member name is given through the ANewMemberName parameter.</docstr>
      </procedure>
      <function name="GetUseEvalShortcuts">
        <docstr>Returns True if this binding component delegate supports evaluation shortcuts or False otherwise.
Subclasses of TBindComponentDelegate that support evaluation shortcuts must reimplement GetUseEvalShortcuts to return True.</docstr>
      </function>
      <function name="GetDelegates">
        <docstr>Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.</docstr>
      </function>
      <event name="OnAssigningValue">
        <docstr>Event that occurs as an expression is evaluated and is assigning to a value of an object member. Event handlers can intercede in the assignment operation.</docstr>
      </event>
      <event name="OnAssignedValue">
        <docstr>Event that occurs after an expression has been evaluated and has assigned a value to an object member.</docstr>
      </event>
      <event name="OnEvalError">
        <docstr>Event that occurs when an exception is raised while evaluating an expression, such as a conversion error. Event handlers can intercede and raise a different exception.</docstr>
      </event>
      <event name="OnActivating">
        <docstr>Event that occurs when activating the binding expressions of this delegate wrapper.</docstr>
      </event>
      <event name="OnActivated">
        <docstr>Event that occurs when the binding expressions of this delegate wrapper have been activated.</docstr>
      </event>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TLinkControlDelegate">
    <docstr></docstr>
    <members>
      <function name="GetControlComponent">
        <docstr>Protected getter method for the ControlComponent property.</docstr>
      </function>
      <procedure name="SetControlComponent">
        <docstr>Protected setter method for the ControlComponent property.</docstr>
      </procedure>
      <function name="GetControlComponentMemberName">
        <docstr>Returns a string containing the name of the control component member. When a control member is specified, expressions execute against the member rather than against the control component.</docstr>
      </function>
      <procedure name="SetActive">
        <docstr>Activates or deactivates the bind control value of this link delegate wrapper.</docstr>
      </procedure>
      <procedure name="BindActivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="CanSetControlComponent">
        <docstr>Returns whether the given parameter can be used as the control component of this binding component.
CanSetControlComponent returns whether the given Value (that is itself a TComponent) can be used as the control component of this binding component.</docstr>
      </function>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TLinkControlToFieldDelegate">
    <docstr></docstr>
    <members>
      <procedure name="SetDataSource">
        <docstr>Protected setter implementation for the DataSource property.</docstr>
      </procedure>
      <function name="GetDataSource">
        <docstr>Protected getter implementation for the DataSource property.</docstr>
      </function>
      <procedure name="SetSourceMember">
        <docstr>Protected setter implementation for the FieldName property defined in subclasses.
Both TCustomLinkControlToField and TCustomLinkListControlToField use SetSourceMember as the setter implementation.</docstr>
      </procedure>
      <function name="GetSourceMember">
        <docstr>Protected getter implementation for the FieldName property defined in subclasses.
Both TCustomLinkControlToField and TCustomLinkListControlToField use GetSourceMember as the getter implementation.</docstr>
      </function>
      <function name="GetDisplaysMultipleSourceMembers">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="DataSource">
        <docstr>Specifies a TBaseLinkingBindSource object to which this delegate component links.
Use DataSource to determine or set the TBaseLinkingBindSource object that connects to a specific dataset.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TCustomLinkControlToField">
    <docstr></docstr>
    <members>
      <procedure name="Reactivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="AllowBidirectional">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="CheckAllowBidirectional">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
Data.Bind.Components.TCustomLinkControlToField.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <function name="GetSourceScopes">
        <docstr>Returns an array of scopes for the source component.
Data.Bind.Components.TCustomLinkControlToField.GetSourceScopes inherits from Data.Bind.Components.TBindComponentDelegate.GetSourceScopes. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GetSourceScopes.
Returns an array of scopes for the source component.</docstr>
      </function>
      <procedure name="MemberRenaming">
        <docstr>Used for renaming a member of this binding component.
Data.Bind.Components.TCustomLinkControlToField.MemberRenaming inherits from Data.Bind.Components.TBindComponentDelegate.MemberRenaming. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.MemberRenaming.
Used for renaming a member of this binding component.
MemberRenaming is used for renaming component members. The old member name is given through the ACurMemberName parameter, while the new member name is given through the ANewMemberName parameter.</docstr>
      </procedure>
      <procedure name="SetAutoActivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetControlExpression">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetActive">
        <docstr>Activates or deactivates the bind control value of this link delegate wrapper.
Data.Bind.Components.TCustomLinkControlToField.SetActive inherits from Data.Bind.Components.TLinkControlDelegate.SetActive. All content below this line refers to Data.Bind.Components.TLinkControlDelegate.SetActive.
Activates or deactivates the bind control value of this link delegate wrapper.</docstr>
      </procedure>
      <function name="GetActive">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="CanActivate">
        <docstr>Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
Data.Bind.Components.TCustomLinkControlToField.CanActivate inherits from Data.Bind.Components.TBindComponentDelegate.CanActivate. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.CanActivate.
Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
The CanActivate method returns True if the delegate (or contained) binding component can be activated, False otherwise.</docstr>
      </function>
      <procedure name="ClearGeneratedExpressions">
        <docstr>Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto.
Data.Bind.Components.TCustomLinkControlToField.ClearGeneratedExpressions inherits from Data.Bind.Components.TBindComponentDelegate.ClearGeneratedExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.ClearGeneratedExpressions.
Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <function name="RequiresControlHandler">
        <docstr>Used internally for observing purposes.
Data.Bind.Components.TCustomLinkControlToField.RequiresControlHandler inherits from Data.Bind.Components.TBindComponentDelegate.RequiresControlHandler. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.RequiresControlHandler.
Used internally for observing purposes.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
Data.Bind.Components.TCustomLinkControlToField.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <function name="GetUseEvalShortcuts">
        <docstr>Setter of UseEvalShortcuts.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates an instance of the TContainedBindComponent class.
Data.Bind.Components.TCustomLinkControlToField.Create inherits from Data.Bind.Components.TContainedBindComponent.Create. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Create.
Creates an instance of the TContainedBindComponent class.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of the TContainedBindComponent class.
Data.Bind.Components.TCustomLinkControlToField.Destroy inherits from Data.Bind.Components.TContainedBindComponent.Destroy. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Destroy.
Destroys an instance of the TContainedBindComponent class.</docstr>
      </destructor>
      <procedure name="ClearExpressionProperties">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetDelegates">
        <docstr>Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.
Data.Bind.Components.TCustomLinkControlToField.GetDelegates inherits from Data.Bind.Components.TBindComponentDelegate.GetDelegates. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GetDelegates.
Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.</docstr>
      </function>
      <property name="Binding">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FieldName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="AutoActivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Active">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Direction">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <procedure name="GenerateExpressions">
        <docstr>Automatically generates the bindings expressions for the quick binding component this delegate wraps onto.
Data.Bind.Components.TCustomLinkControlToField.GenerateExpressions inherits from Data.Bind.Components.TBindComponentDelegate.GenerateExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GenerateExpressions.
Automatically generates the bindings expressions for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <property name="Control">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ControlMemberName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Track">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="CustomFormat">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="CustomParse">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="LookupDataSource">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="LookupKeyFieldName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="LookupValueFieldName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="UseEvalShortcuts">
        <docstr>Determines whether this binding component delegate uses evaluation shortcuts (True) or not (False).</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TCustomLinkListControlToField">
    <docstr></docstr>
    <members>
      <procedure name="Reactivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetActive">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetActive">
        <docstr>Activates or deactivates the bind control value of this link delegate wrapper.
Data.Bind.Components.TCustomLinkListControlToField.SetActive inherits from Data.Bind.Components.TLinkControlDelegate.SetActive. All content below this line refers to Data.Bind.Components.TLinkControlDelegate.SetActive.
Activates or deactivates the bind control value of this link delegate wrapper.</docstr>
      </procedure>
      <function name="GetControlComponentMemberName">
        <docstr>Returns a string containing the name of the control component member.
Data.Bind.Components.TCustomLinkListControlToField.GetControlComponentMemberName inherits from Data.Bind.Components.TLinkControlDelegate.GetControlComponentMemberName. All content below this line refers to Data.Bind.Components.TLinkControlDelegate.GetControlComponentMemberName.
Returns a string containing the name of the control component member. When a control member is specified, expressions execute against the member rather than against the control component.</docstr>
      </function>
      <function name="CanActivate">
        <docstr>Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
Data.Bind.Components.TCustomLinkListControlToField.CanActivate inherits from Data.Bind.Components.TBindComponentDelegate.CanActivate. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.CanActivate.
Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
The CanActivate method returns True if the delegate (or contained) binding component can be activated, False otherwise.</docstr>
      </function>
      <procedure name="ClearGeneratedExpressions">
        <docstr>Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto.
Data.Bind.Components.TCustomLinkListControlToField.ClearGeneratedExpressions inherits from Data.Bind.Components.TBindComponentDelegate.ClearGeneratedExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.ClearGeneratedExpressions.
Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <function name="RequiresControlHandler">
        <docstr>Used internally for observing purposes.
Data.Bind.Components.TCustomLinkListControlToField.RequiresControlHandler inherits from Data.Bind.Components.TBindComponentDelegate.RequiresControlHandler. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.RequiresControlHandler.
Used internally for observing purposes.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
Data.Bind.Components.TCustomLinkListControlToField.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <function name="GetDisplaysMultipleSourceMembers">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetControlEditorName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetFieldName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
Data.Bind.Components.TCustomLinkListControlToField.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="GetUseEvalShortcuts">
        <docstr>Setter of UseEvalShortcuts.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates an instance of the TContainedBindComponent class.
Data.Bind.Components.TCustomLinkListControlToField.Create inherits from Data.Bind.Components.TContainedBindComponent.Create. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Create.
Creates an instance of the TContainedBindComponent class.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of the TContainedBindComponent class.
Data.Bind.Components.TCustomLinkListControlToField.Destroy inherits from Data.Bind.Components.TContainedBindComponent.Destroy. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Destroy.
Destroys an instance of the TContainedBindComponent class.</docstr>
      </destructor>
      <procedure name="ClearExpressionProperties">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="FillList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetDelegates">
        <docstr>Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.
Data.Bind.Components.TCustomLinkListControlToField.GetDelegates inherits from Data.Bind.Components.TBindComponentDelegate.GetDelegates. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GetDelegates.
Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.</docstr>
      </function>
      <property name="BindLink">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FieldName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="AutoActivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Active">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Direction">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="BufferCount">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="AutoBufferCount">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <procedure name="GenerateExpressions">
        <docstr>Automatically generates the bindings expressions for the quick binding component this delegate wraps onto.
Data.Bind.Components.TCustomLinkListControlToField.GenerateExpressions inherits from Data.Bind.Components.TBindComponentDelegate.GenerateExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GenerateExpressions.
Automatically generates the bindings expressions for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <property name="Control">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ControlMemberName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="CustomFormat">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="CustomParse">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FillExpressions">
        <docstr>Specifies additional optional expressions to use when filling the list control. Use this collection when multiple expressions are needed to fill an item in the list.
For instance, you can use FillExpressions in order to populate a FireMonkey list box item Text and Detail properties. Use the FillDisplayCustomFormat and FillDisplayCustomFormat properties in order to fill the Text property and add an item to the FillExpressions collection, for the Detail property.</docstr>
      </property>
      <property name="ListItemStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FillHeaderExpressions">
        <docstr>Specifies a collection of expressions to fill a list header. This property is optional.</docstr>
      </property>
      <property name="FillBreakFieldName">
        <docstr>Specifies the field used to determine a break. This property is optional.</docstr>
      </property>
      <property name="FillBreakCustomFormat">
        <docstr>Specifies a custom expression that is used with the field defined by the FillBreakFieldName property. For instance, the expression StrCopy(%s, 0, 1); causes a break when the first character of the field is different. This property is optional.</docstr>
      </property>
      <property name="FillHeaderFieldName">
        <docstr>Specifies the field to display in the list header. If FillBreakFieldName and FillBreakCustomFormat are blank, then the value determined using FillHeaderFieldName and FillBreakCustomFormat controls breaks. This is the only required field to cause breaking.</docstr>
      </property>
      <property name="FillHeaderCustomFormat">
        <docstr>Specifies a custom expression that is used with the field defined by the FillHeaderFieldName property. For instance, the expression StrCopy(%s, 0, 1); displays the first character of the field in the header. This property is optional.</docstr>
      </property>
      <property name="FillBreakGroups">
        <docstr>Specifies a collection of break value ranges. The break value falls within an item in this collection. The display value associated with the item is displayed in the header. This property is optional.</docstr>
      </property>
      <event name="OnFillingListItem">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnFilledListItem">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnFillingList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnFilledList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <property name="UseEvalShortcuts">
        <docstr>Determines whether this binding component delegate uses evaluation shortcuts (True) or not (False).</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TLinkPropertyToFieldDelegate">
    <docstr></docstr>
    <members>
      <procedure name="SetDataSource">
        <docstr>Protected setter implementation for the DataSource property.</docstr>
      </procedure>
      <function name="GetDataSource">
        <docstr>Protected getter implementation for the DataSource property.</docstr>
      </function>
      <procedure name="SetSourceMember">
        <docstr>Protected setter implementation for the FieldName property.</docstr>
      </procedure>
      <function name="GetSourceMember">
        <docstr>Protected getter implementation for the FieldName property.</docstr>
      </function>
      <function name="GetControlComponent">
        <docstr>Protected getter implementation for the Component property.</docstr>
      </function>
      <procedure name="SetControlComponent">
        <docstr>Protected setter implementation for the Component property.</docstr>
      </procedure>
      <procedure name="SetComponentProperty">
        <docstr>Protected setter implementation for the ComponentProperty property.</docstr>
      </procedure>
      <procedure name="SetActive">
        <docstr>Protected setter implementation for the Active property.</docstr>
      </procedure>
      <procedure name="BindActivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="DataSource">
        <docstr>Specifies a TDataSource object to which this delegate component links.
Use DataSource to determine or set the TDataSource object that connects to a specific dataset.</docstr>
      </property>
      <property name="Component">
        <docstr>Specifies the component that this wrapping binding component references.</docstr>
      </property>
      <property name="ComponentProperty">
        <docstr>Specifies the name of the property of the component that this wrapping binding component references.</docstr>
      </property>
      <property name="FieldName">
        <docstr>Specifies the field name that this wrapping binding component references.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TBaseBindScopeComponent">
    <docstr>Base class for the binding scope component. TBaseBindScopeComponent is the ancestor for the TCustomBindScope component. TBaseBindScopeComponent provides functionality for adding scope mappings, getting scope members and values, returning the scope itself or the scope of a member. It also provides properties for accessing the binding expressions in this scope and the scope mappings.</docstr>
    <members>
      <procedure name="SetScopeMappings">
        <docstr>Protected setter implementation for the ScopeMappings property.</docstr>
      </procedure>
      <function name="AddScopeMappings">
        <docstr>Adds the given scope mapping to the ScopeMappings list. The scope mapping to be added is given through the AScope parameter.</docstr>
      </function>
      <function name="GetMember">
        <docstr>Returns the member for the given member name.
The GetMember method returns the scope member, as a TObject, for the member name given through the AMemberName parameter. This member is later used in the generated bindings expressions.

Tip: This member object or its properties may be referenced by bindings expressions.</docstr>
      </function>
      <function name="GetValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetScope">
        <docstr>Returns the binding scope for this source component.
The GetScope method returns the binding scope for this source component. This binding scope allows expressions to access properties and methods of the source component, as opposed to GetMemberScope, which allows expressions to access properties and methods of a member of the source component, such as a field.</docstr>
      </function>
      <function name="GetMemberScope">
        <docstr>Returns the binding scope for the given member name.
The GetMemberScope method returns the binding scope for the member name given through the AMemberName parameter.</docstr>
      </function>
      <function name="GetScopeObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="PosLockEnter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="PosLockLeave">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetPosLock">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="AddExpression">
        <docstr>Adds the given bind component to the Expressions list. The binding component is given through the AExpression parameter.</docstr>
      </procedure>
      <procedure name="RemoveExpression">
        <docstr>Removes the given binding component from the Expressions list. The binding component to be removed is given through the AExpression parameter.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
Data.Bind.Components.TBaseBindScopeComponent.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="ActivateExpressions">
        <docstr>Activates or deactivates all the binding expressions of this binding scope component at once.
The ActivateExpressions method activates or deactivates, depending on the value of the AValue parameter, all the binding expressions contained by this binding scope component at once.

Tip: If one or more of the binding expressions does not support one of the IBindLink, IBindPosition, or IBindActivate interfaces, then ActivateExpressions does nothing for that particular binding expression.</docstr>
      </procedure>
      <property name="Expressions">
        <docstr>Specifies a list of binding components that are using this source component.</docstr>
      </property>
      <property name="ScopeMappings">
        <docstr>Specifies an owned collection of scope mappings.
The ScopeMappings property specifies an owned collection whose elements are scope mappings. ScopeMappings are used to add name/value pairs that can be referenced by expressions that reference this source component.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Data.Bind.Components.TBaseBindScopeComponent.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Data.Bind.Components.TBaseBindScopeComponent.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TEvalShortcutEnumeratorToEditor">
    <docstr></docstr>
    <members>
      <procedure name="Evaluate">
        <docstr>Evaluate expression to assign a value from a data source to an editor</docstr>
      </procedure>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TEvalShortcutEnumerator">
    <docstr></docstr>
    <members>
      <function name="Evaluate">
        <docstr>Evaluate an expression to retrieve a value from a data source</docstr>
      </function>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TEvalShortcutFactory">
    <docstr></docstr>
    <members>
      <function name="Supports">
        <docstr>Provide an evaluator for assigning from data source to editor</docstr>
      </function>
      <function name="Supports">
        <docstr>Indicate whether this factory can provide an evaluator for assigning from data source to editor</docstr>
      </function>
      <function name="Supports">
        <docstr>Provide an evaluator for retrieving a value from a data source</docstr>
      </function>
      <function name="Supports">
        <docstr>Indicate whether this factory can provide an evaluator for retrieving a value from  a data source to editor</docstr>
      </function>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TEvalShortcutFactories">
    <docstr></docstr>
    <members>
      <function name="Supports">
        <docstr>Provide an evaluator for assigning from data source to editor</docstr>
      </function>
      <function name="Supports">
        <docstr>Indicate whether a factory can provide an evaluator for assigning from data source to editor</docstr>
      </function>
      <function name="Supports">
        <docstr>Provide an evaluator for retrieving a value from a data source</docstr>
      </function>
      <function name="Supports">
        <docstr>Indicate whether a factory can provide an evaluator for assigning from  a data source to editor</docstr>
      </function>
      <procedure name="Register">
        <docstr>Register an evaluator shortcut factory</docstr>
      </procedure>
      <procedure name="Unregister">
        <docstr>Unregister an evaluator shortcut factory</docstr>
      </procedure>
      <property name="Instance">
        <docstr>Singleton instance property.  Use this property to access instance methods.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.EditBox" name="TCustomEditBox">
    <docstr>Base class for all edit boxes that manipulate only numerical values.
TCustomEditBox is the base class for all edit boxes that manipulate only numerical values, such as a TNumberBox. TCustomEditBox implements functionality to set the minimum and maximum value that this edit box can display, and also the possibility to specify the number of decimal digits of the displayed value.
If you want to create your own custom edit box control that manipulates number data, then you should derive from TCustomEditBox.</docstr>
    <members>
      <function name="ValueStored">
        <docstr>It returns False in case Value has a default value, which means there is no need to store it.</docstr>
      </function>
      <function name="HorzIncrementStored">
        <docstr>Returns whether the HorzIncrement value is stored in the form file.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the control after the form file has been read into memory and loads its presentation.
FMX.EditBox.TCustomEditBox.Loaded inherits from FMX.Controls.Presentation.TPresentedControl.Loaded. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Loaded.
Initializes the control after the form file has been read into memory and loads its presentation.
For details, see TControl.Loaded.

 See Also
FMX.Controls.Presentation.TPresentedControl.LoadPresentation
FMX.Controls.TControl.Loaded</docstr>
      </procedure>
      <procedure name="SetValue">
        <docstr>Protected setter implementation for the Value property.
SetValue sets a value to the Value property of edit boxes.</docstr>
      </procedure>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.EditBox.TCustomEditBox.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
FMX.EditBox.TCustomEditBox.SetData inherits from FMX.Types.TFmxObject.SetData. All content below this line refers to FMX.Types.TFmxObject.SetData.
Protected setter implementation for the Data property.</docstr>
      </procedure>
      <function name="GetActionLinkClass">
        <docstr>Returns the appropriate action link class associated with the track bar.
GetActionLinkClass returns a TValueRangeActionLink.</docstr>
      </function>
      <procedure name="ActionChange">
        <docstr>Specifies the behavior of a TCustomEditBox control when Action changes. 
Depending on the CheckDefaults value,  ActionChange uses the TValueRangeAction.ValueRange property of the Sender action to set the new value to the  
ValueRange property of TCustomEditBox. Then ActionChange calls the inherited TControl.ActionChange method.  
Do not call ActionChange explicitly in an application. It is for internal use.</docstr>
      </procedure>
      <property name="DefaultValueRange">
        <docstr>Returns the default interval for the values of the control.</docstr>
      </property>
      <function name="DefineModelClass">
        <docstr>Returns a class reference to a data model of this presented control.
FMX.EditBox.TCustomEditBox.DefineModelClass inherits from FMX.Controls.Presentation.TPresentedControl.DefineModelClass. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefineModelClass.
Returns a class reference to a data model of this presented control.
Returns a class reference to a data model class that the constructor of this presented control uses to create a data model for the control.
By default DefineModelClass returns TDataModel. Descendant classes reimplement DefineModelClass to determine the data model class that a descendant presented control uses for its data model.

 See Also
FMX.Controls.Model.TDataModelClass
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Presentation.Style.TStyledPresentation.DefineModelClass
Class References</docstr>
      </function>
      <function name="DefinePresentationName">
        <docstr>Returns the name of the default presentation proxy that your presented control uses.
FMX.EditBox.TCustomEditBox.DefinePresentationName inherits from FMX.Controls.Presentation.TPresentedControl.DefinePresentationName. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefinePresentationName.
Returns the name of the default presentation proxy that your presented control uses.
You can handle OnPresentationNameChoosing to specify a presentation proxy name to use instead of the name that DefinePresentationName returns.
DefinePresentationName  calls TPresentationProxyFactory.GeneratePresentationName and returns a generated  presentation proxy name based on the class name of the presented control and the control type (Styled or Platform) of the presentation layer. For example:



Class name

Control type

Result


TMyPresentedControl

Styled

&quot;MyPresentedControl-Styled&quot;


TMyPresentedControl

Platform

&quot;MyPresentedControl-Platform&quot;

 See Also
System.TObject.ClassName
FMX.Controls.Presentation.TPresentedControl.ControlType
FMX.Presentation.Factory.TPresentationProxyFactory.Register
FMX.Controls.Presentation.TPresentationProxy
FMX.Controls.Presentation.TPresentedControl.OnPresentationNameChoosing
FMX.Controls.Presentation.TPresentedControl.LoadPresentation</docstr>
      </function>
      <property name="Model">
        <docstr>The data model representing the data used by the presentation of the current control.
FMX.EditBox.TCustomEditBox.Model inherits from FMX.Controls.Presentation.TPresentedControl.Model. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Model.
The data model representing the data used by the presentation of the current control.
The constructor of your presented control creates a data model for your presented control. The class of the data model is the class that DefineModelClass returns.

 See Also
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Presentation
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.DefineModelClass</docstr>
      </property>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.EditBox.TCustomEditBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <procedure name="AfterConstruction">
        <docstr>Responds after the last constructor has executed and loads the control presentation.
FMX.EditBox.TCustomEditBox.AfterConstruction inherits from FMX.Controls.Presentation.TPresentedControl.AfterConstruction. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.AfterConstruction.
Responds after the last constructor has executed and loads the control presentation.
AfterConstruction is called automatically after the object&apos;s last constructor has executed. Do not call it explicitly in your applications.</docstr>
      </procedure>
      <procedure name="ValueInc">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ValueDec">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="HorzIncrement">
        <docstr>Represents the value with which the number is incremented or decremented when, while holding down the mouse button, you move the mouse horizontally.
HorzIncrement represents the value added or decreased from the number when, while holding down the mouse button, you move the mouse to the left or to the right.</docstr>
      </property>
      <property name="ValueRange">
        <docstr>Provides access to the Value and its Min and Max boundaries.</docstr>
      </property>
      <property name="DecimalDigits">
        <docstr>Specifies the number of decimal positions of the displayed Value.
This property has effect only if the ValueType property is set to Float.</docstr>
      </property>
      <property name="Min">
        <docstr>Contains the minimum value the number displayed by an edit control can show.
Min sets the minimum value that can be displayed by edit controls that manipulate only numerical values.</docstr>
      </property>
      <property name="Max">
        <docstr>Contains the maximum value the number displayed by an edit control can show.
Max sets the maximum value that can be displayed by edit controls that manipulate only numerical values.</docstr>
      </property>
      <property name="Value">
        <docstr>Contains the default number displayed by an edit control.</docstr>
      </property>
      <property name="ValueType">
        <docstr>Defines the integer or float type of the Value number displayed by the edit box control.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Controls" name="THint">
    <docstr></docstr>
    <members>
      <field name="FHint">
        <docstr>Field to store the hint.</docstr>
      </field>
      <field name="FEnabled">
        <docstr>Field to store the status (enabled or not) of the hint.</docstr>
      </field>
      <procedure name="SetEnabled">
        <docstr>Method that updates the state of enabled.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Constructor. A constructor needs the native handle of the view that holds the hint. To give an example,
           in MS Windows is the HWND of the native window.</docstr>
      </constructor>
      <procedure name="SetHint">
        <docstr>Sets the full hint string.</docstr>
      </procedure>
      <function name="GetHint">
        <docstr>Gets the full hint string.</docstr>
      </function>
      <function name="GetShortText">
        <docstr>The hint can follows the following pattern:  &apos;A short Text| A Long text&apos;. It means, the hint can hold
           two texts separated by the &apos;|&apos; character. This method returns the short text of the hint.</docstr>
      </function>
      <function name="GetLongText">
        <docstr>Returns the long text of the hint.</docstr>
      </function>
      <procedure name="SetPosition">
        <docstr>If the specific implementation supports it, this metods places the hint in the given position.</docstr>
      </procedure>
      <procedure name="RegisterClass">
        <docstr>Register a class to create hint instances. When a new THint instance is needed, the registered classes are invoked
           to create the needed instance.</docstr>
      </procedure>
      <function name="CreateNewInstance">
        <docstr>Returns an instance created by the first available registered class. This method can return nil if there are no classes 
           registered or none of the registered classes can create a THint instance.</docstr>
      </function>
      <function name="ContainsRegistredHintClasses">
        <docstr>Returns True if there are some THint class registered.</docstr>
      </function>
      <property name="Enabled">
        <docstr>If this property is true, the hint can be displayed, if it is False, the hint won&apos;t be displayed.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Controls" name="TCustomControlAction">
    <docstr>TCustomControlAction is the base class for the actions that can be associated with some of the controls.
You can add a control action to a control by setting the Action property of the control, if it is supported. In the Object Inspector choose New Standard Action &gt; No Category &gt; TControl Action for the Action property.</docstr>
    <members>
      <procedure name="Notification">
        <docstr>Responds when components are created or destroyed.
FMX.Controls.TCustomControlAction.Notification inherits from System.Classes.TBasicAction.Notification. All content below this line refers to System.Classes.TBasicAction.Notification.
Responds when components are created or destroyed.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. 
TBasicAction overrides the System.Classes.TComponent.Notification method. Notification checks whether the component specified by AComponent is the same as the component stored in the ActionComponent property and whether it is about to be freed. If so, Notification sets the ActionComponent property to nil (Delphi) or NULL (C++).</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Instantiates and initializes a FireMonkey TCustomAction object.
FMX.Controls.TCustomControlAction.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
Instantiates and initializes a FireMonkey TCustomAction object.
Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True .</docstr>
      </constructor>
      <property name="PopupMenu">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Controls" name="TControlActionLink">
    <docstr></docstr>
    <members>
      <function name="DoShowHint">
        <docstr>This method is invoked to allow a link to customize a Hint that is going to be displayed.</docstr>
      </function>
      <procedure name="SetHint">
        <docstr>This method sets the string of the hint.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Controls" name="TControl">
    <docstr>TControl is the base class for FMX on-screen components. Subclasses are roughly divided into primitive shapes and styleable controls.
TControl extends TFmxObject to present objects that are seen, by adding properties and methods for:

Size and position
Margins and padding
Alignment with others
Visibility, opacity, scale, and rotation
Mouse interaction and hit testing
Keyboard interaction
Focus and tab order
Triggers for animations and effects
Painting</docstr>
    <members>
      <procedure name="RepaintJointArea">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoAbsoluteChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="CheckHitTest">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetInPaintTo">
        <docstr>Sets the InPaintTo property.
Value specifies the value to set the InPaintTo to. 
SetInPaintTo is used internally by PaintTo to have the InPaintTo flag set while the control is being painted. Value is likewise applied to all of the control&apos;s children.</docstr>
      </procedure>
      <procedure name="EndUpdateNoChanges">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetHint">
        <docstr>Setter for the Hint property.</docstr>
      </procedure>
      <procedure name="SetEnabled">
        <docstr>Setter of Enabled.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <procedure name="Updated">
        <docstr>Clears the csUpdating state in the component&apos;s ComponentState property when the component finishes updating.
FMX.Controls.TControl.Updated inherits from System.Classes.TComponent.Updated. All content below this line refers to System.Classes.TComponent.Updated.
Clears the csUpdating state in the component&apos;s ComponentState property when the component finishes updating.
Do not call Updated directly. It is used internally to clear the csUpdating flag of the ComponentState property. A call to Updated always follows a call to Updating, which sets the flag.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Controls.TControl.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Controls.TControl.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="ParentChanged">
        <docstr>Executed right after the value of the Parent property changes.
The control does not execute ParentChanged if you assign Parent the same value that it already has.</docstr>
      </procedure>
      <procedure name="ChangeOrder">
        <docstr>Notification method called after the creation order is changed.
FMX.Controls.TControl.ChangeOrder inherits from FMX.Types.TFmxObject.ChangeOrder. All content below this line refers to FMX.Types.TFmxObject.ChangeOrder.
Notification method called after the creation order is changed. ChangeOrder is a virtual method to be implemented in subclasses to allow for changing the creation order of this FMX object.</docstr>
      </procedure>
      <procedure name="ChangeChildren">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetVisible">
        <docstr>Setter function for the Visible property. Value specifies the new value of the Visible property.</docstr>
      </procedure>
      <function name="DoSetWidth">
        <docstr>Warning: DoSetWidth is deprecated. Please use DoSetSize. 



Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="DoSetHeight">
        <docstr>Warning: DoSetHeight is deprecated. Please use DoSetSize. 



Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="DoSetSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="HandleSizeChanged">
        <docstr>Executed right after the value of the Size property changes.
The control does not execute HandleSizeChanged if you assign Size the same value that it already has.</docstr>
      </procedure>
      <procedure name="DoMatrixChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetHeight">
        <docstr>Setter function for the Height property. Value specifies the new value of the Height property.</docstr>
      </procedure>
      <procedure name="SetWidth">
        <docstr>Setter function for the Width property. Value specifies the new value of the Width property.</docstr>
      </procedure>
      <procedure name="SetSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetAbsoluteRect">
        <docstr>Getter function for the AbsoluteRect property.</docstr>
      </function>
      <function name="GetChildrenMatrix">
        <docstr>Returns the children transformation matrix.
The AbsoluteMatrix is calculated as:

  AbsoluteMatrix = (LocalMatrix * Parent.GetChildrenMatrix) * Parent.AbsoluteMatrix

TScaledLayout overrides GetChildrenMatrix to prescale layout contents.</docstr>
      </function>
      <function name="GetAbsoluteScale">
        <docstr>Getter function for the AbsoluteScale property.</docstr>
      </function>
      <function name="GetParentedRect">
        <docstr>Warning: GetParentedRect is deprecated. Please use GetBoundsRect. 


Getter function for the ParentedRect property.</docstr>
      </function>
      <function name="GetClipRect">
        <docstr>Getter function for the ClipRect property.</docstr>
      </function>
      <function name="GetEffectsRect">
        <docstr>Returns the rectangle occupied by the effects applied over the control.  It is used when the control is updated.</docstr>
      </function>
      <function name="GetAbsoluteEnabled">
        <docstr>Getter function for the AbsoluteEnabled property.</docstr>
      </function>
      <function name="GetChildrenRect">
        <docstr>Getter function for the ChildrenRect property.</docstr>
      </function>
      <function name="GetLocalRect">
        <docstr>Getter function for the LocalRect property.</docstr>
      </function>
      <function name="GetBoundsRect">
        <docstr>Getter function for the BoundsRect property.</docstr>
      </function>
      <procedure name="SetBoundsRect">
        <docstr>Setter function for the BoundsRect property. Value specifies the new value of the BoundsRect property.</docstr>
      </procedure>
      <function name="IsHeightStored">
        <docstr>Warning: IsHeightStored is deprecated. Please use IsSizeStored. 



Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="IsWidthStored">
        <docstr>Warning: IsWidthStored is deprecated. Please use IsSizeStored. 



Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="IsPositionStored">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="IsSizeStored">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetPopupMenu">
        <docstr>Setter function for the PopupMenu property. Value specifies the new value of the PopupMenu property.</docstr>
      </procedure>
      <function name="GetAbsoluteMatrix">
        <docstr>Getter function for the AbsoluteMatrix property.</docstr>
      </function>
      <function name="GetHasClipParent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetUpdateRect">
        <docstr>Getter function for the UpdateRect property.</docstr>
      </function>
      <function name="DoGetUpdateRect">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetAbsoluteOpacity">
        <docstr>Getter function for the AbsoluteOpacity property.</docstr>
      </function>
      <procedure name="BeginAutoDrag">
        <docstr>Begins the drag operation automatically.
BeginAutoDrag is called automatically when a user drags a control whose DragMode is dmAutomatic. Do not call BeginAutoDrag in application code. 
Write an event handler for OnDragOver to specify what happens when a dragged object is over the area of the current control.</docstr>
      </procedure>
      <procedure name="Capture">
        <docstr>Saves the control that currently captures all the mouse messages.
Capture sets the current root&apos;s Captured property if root is not empty.
ReleaseCapture prevents the current control from receiving all the mouse messages.</docstr>
      </procedure>
      <procedure name="ReleaseCapture">
        <docstr>Prevents the control from currently capturing all the mouse messages.
Capture empties the root&apos;s Captured property.</docstr>
      </procedure>
      <property name="EnableExecuteAction">
        <docstr>Defines whether the control can use Action.OnExecute for mouse clicks, key pressing, and input on touch devices (gestures).
If  EnableExecuteAction is True and the OnClick event handler is not assigned (or is equal to Action.OnExecute), then Click executes the assigned Action, otherwise the OnClick event handler is executed.
Click is an event handler for the OnClick event. It is automatically called when the left mouse button is pressed and released with the pointer over the control.
EnableExecuteAction is True in TTextControl, TImageControl, TSwitch, and their descendants, while False in others.</docstr>
      </property>
      <procedure name="Click">
        <docstr>Responds to user clicks, key pressing, and input on touch devices (gestures).
Click is an event handler for the OnClick event. It is automatically called when the left mouse button is pressed and released with the pointer over the control. Click also can be called in DialogKey and other methods handling an input from keyboards and touch devices.
Call Click in applications to simulate an OnClick mouse event.  
If EnableExecuteAction is True and the OnClick event handler is not assigned (or is equal to Action.OnExecute), then Click executes the assigned Action, otherwise executes the OnClick event handler.</docstr>
      </procedure>
      <procedure name="DblClick">
        <docstr>Responds to user double-clicks.
DblClick is an event handler for the OnDblClick event. It is automatically called when the left mouse button is pressed and released twice, consecutively, with the pointer over the control.
Call DblClick in applications to simulate a mouse OnDblClick event.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>OnMouseMove event dispatcher. 
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseWheel">
        <docstr>OnMouseWheel event dispatcher. 
A control calls MouseWheel in response to any of mouse wheel messages, decoding the message parameters into the shift-key state, wheel rotation, and handle, which it passes in the Shift, WheelDelta, and Handled parameters, respectively:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
WheelDelta indicates the distance the wheel was rotated. WheelDelta is positive if the mouse was rotated upward, negative if the mouse was rotated downward.
Handled indicates whether the scroll bar was already moved, depending on the WheelDelta value. If one of the scrolls bars (vertical or horizontal) was already handled or it does not exist, MouseWheel tries to apply the rolling on the other scroll bar, if it exists.
Override the protected MouseWheel method to provide other responses when the mouse wheel is rotated while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseClick">
        <docstr>Calls Click and starts the animation by calling StartTriggerAnimation.
MouseClick receives the following parameters: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys -- SHIFT, CTRL, ALT, and CMD (only for Mac) -- were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Provides a response when a key is pressed down while the control has the keyboard focus. 
If the pressed key is the Applications key (Key = vkApps), then KeyDown shows the context menu of the control. Otherwise, KeyDown calls the OnKeyDown event handler if one is assigned. 
TCommonCustomForm and descendant of TControl classes--like TCustomGrid--call KeyDown from their methods handling key pressing. They decode the message parameters into the key code, character code, and shift state. They pass them into the called KeyDown method in the Key, KeyChar, and Shift parameters, respectively:  



Parameters

Descriptions



Key



Is the scan code of the pressed keyboard key or $0.
If a pressed key combination can be a shortcut, then Key &lt;&gt; 0 is a virtual key and KeyChar = #0. 
Physical scan codes of the same key can differ under different platforms (Windows or iOS).
Platform-specific units (for example FMX.Platform.Mac.pas) should translate native scan codes to corresponding Windows codes defined in the UITypes unit.  For example, 

vkReturn = $0D;  {  13 } corresponds to the RETURN keyboard key.
vkF2     = $71;  { 113 } corresponds to the F2 keyboard key.



KeyChar



Is the pressed character (digit) or #0.
If a pressed key combination can be treated as a printable character or digit, then Key = 0 and KeyChar contains a pressed symbol according to the current keyboard&apos;s input language, keyboard mode (CAPS LOCK and NUM LOCK keys), keyboard Shift state, and IME state. Editors can use this symbol to add into a text being edited. 




Shift



Indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the specified key was pressed with the control in focus.


If the control has successfully processed the pressed key combination and no additional processing is required, then KeyDown assigns Key = 0 and KeyChar = #0.  
Override the protected KeyDown method to provide other responses when a key is down while the control has keyboard input focus.
See TCommonCustomForm.KeyDown for more information about parameters.</docstr>
      </procedure>
      <procedure name="KeyUp">
        <docstr>OnKeyUp event dispatcher. 
KeyUp provides a response when a key is released while the control has keyboard focus. KeyUp calls the OnKeyUp event handler if one is assigned.
A control calls KeyUp in response to any key-up messages, decoding the message parameters into the key code, character code, and shift state. The control passes them in the Key, KeyChar, and Shift parameters, respectively:

Key is the scan code of the released keyboard key.
KeyChar is the character code of the released key.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when you release the previously pressed key with the control in focus.
Override the protected KeyUp method to provide other responses when a key is released while the control has keyboard input focus.</docstr>
      </procedure>
      <procedure name="DialogKey">
        <docstr>Processes a dialog key. 
DialogKey is called during the message preprocessing to handle dialog characters. 
Do not call DialogKey in an application. It is for internal use only.
DialogKey processes the dialog key messages for each of the control&apos;s children.</docstr>
      </procedure>
      <procedure name="AfterDialogKey">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="ShowContextMenu">
        <docstr>Displays the PopupMenu context menu of this control on the specified ScreenPosition screen point.
ShowContextMenu returns True if PopupMenu was successfully displayed.  Otherwise, ShowContextMenu returns False. 
To set or get a context (pop-up) menu for the current control, use the PopupMenu property.
Descendants can override this method. For example, descendants can show a default context menu if PopupMenu = nil.</docstr>
      </function>
      <procedure name="DragEnter">
        <docstr>OnDragEnter event dispatcher. 
Data specifies the dragged object.
Point specifies the current point of the mouse cursor within the client area of the control.
A control calls DragEnter when a dragged object enters the control area.
Override the protected DragEnter method to provide other responses when a dragged object enters the control area.</docstr>
      </procedure>
      <procedure name="DragOver">
        <docstr>OnDragOver event dispatcher. 
Data specifies the dragged object.
Point specifies the current point of the  mouse cursor within the client area of the control.
Operation is the operation parameter (None, Move, Copy, Link) that specifies the action to perform when an item is dragged over the object.  

None is the default. No action takes place, it does not display any name.
Move - the word Move is displayed once an item is dragged over the object.
Copy - the word Copy is displayed once an item is dragged over the object.
Link - the word Link is displayed once an item is dragged over the object.
A control calls DragOver when a dragged object is over the control area.
Override the protected DragOver method to provide other responses when a dragged object is over the control area.</docstr>
      </procedure>
      <procedure name="DragDrop">
        <docstr>OnDragDrop event dispatcher. 
Data specifies the dragged object.
Point specifies the current point of the mouse cursor, within the client area of the control.
A control calls DragDrop when a dragged object is dropped on the control area.
Override the protected DragDrop method to provide other responses when a dragged object is dropped on the control area.</docstr>
      </procedure>
      <procedure name="DragLeave">
        <docstr>OnDragLeave event dispatcher. 
A control calls DragLeave when a dragged object leaves the control area.
Override the protected DragLeave method to provide other responses when a dragged object leaves the control area.</docstr>
      </procedure>
      <procedure name="DragEnd">
        <docstr>OnDragEnd event dispatcher. 
A control calls DragEnd when a dragging session ends.
Override the protected DragEnd method to provide other responses when the dragging session ends.</docstr>
      </procedure>
      <function name="GetDefaultTouchTargetExpansion">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanFocus">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanParentFocus">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="EnterChildren">
        <docstr>Checks whether the input is taken by the control or by its parent.
EnterChildren returns True if the input is taken directly by the control&apos;s parent, and False otherwise. 
Usually, EnterChildren returns False. If the control is an item such as TListBoxItem, a TTreeViewItem, or TMenuItem, EnterChildren returns True.</docstr>
      </function>
      <function name="ExitChildren">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetParentedVisible">
        <docstr>Returns the value of the ParentedVisible property.
GetParentedVisible is a protected method in the TControl class and is used to obtain the current value of the ParentedVisible property.</docstr>
      </function>
      <procedure name="NeedUpdateEffects">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="BeforeEffectEnabledChanged">
        <docstr>Executed right before the value of the Enabled property of an effect changes, and provides the value of the property before it changes.
The control does not execute BeforeEffectEnabledChanged if you assign Enabled the same value that it already has.</docstr>
      </procedure>
      <procedure name="EffectEnabledChanged">
        <docstr>Executed right after the value of the Enabled property of an effect changes, and provides the new value of the property.
The control does not execute EffectEnabledChanged if you assign Enabled the same value that it already has.
Effects execute EffectEnabledChanged instead of FMX.Controls.TControl.EnabledChanged.</docstr>
      </procedure>
      <procedure name="Realign">
        <docstr>Performs the realignment of the control&apos;s children within itself.  
The children are realigned taking into account their alignment properties, margins, and padding.
It is called internally every time the control&apos;s visual properties are changed. Realign is also called by EndUpdate, if there are no opened update sessions (FUpdating is 0).</docstr>
      </procedure>
      <procedure name="ChildrenAlignChanged">
        <docstr>Executed when the alignment of the children of the control changes.
The alignment of the children of the control may change for any of the following reasons:

The alignment of a child control changes.
The anchoring of a control changes.
The control looses one of its child controls.</docstr>
      </procedure>
      <function name="GetAlign">
        <docstr>Getter function for the Align property.</docstr>
      </function>
      <procedure name="SetAlign">
        <docstr>Setter function for the Align property. Value specifies the new value of the Align property.</docstr>
      </procedure>
      <function name="GetAnchors">
        <docstr>Getter function for the Anchors property.</docstr>
      </function>
      <procedure name="SetAnchors">
        <docstr>Setter function for the Anchors property.
Value specifies the new value of the Anchors property.</docstr>
      </procedure>
      <function name="GetMargins">
        <docstr>Getter function for the Margins property.</docstr>
      </function>
      <function name="GetPadding">
        <docstr>Getter function for the Padding property.</docstr>
      </function>
      <function name="GetWidth">
        <docstr>Getter function for the Width property.</docstr>
      </function>
      <function name="GetHeight">
        <docstr>Getter function for the Height property.</docstr>
      </function>
      <function name="GetLeft">
        <docstr>Getter function for the Left property.</docstr>
      </function>
      <function name="GetTop">
        <docstr>Getter function for the Top property.</docstr>
      </function>
      <function name="GetAllowAlign">
        <docstr>Getter function for the AllowAlign property.</docstr>
      </function>
      <function name="GetAnchorRules">
        <docstr>Getter function for the AnchorRules property.</docstr>
      </function>
      <function name="GetAnchorOrigin">
        <docstr>Getter function for the AnchorOrigin property.</docstr>
      </function>
      <function name="GetOriginalParentSize">
        <docstr>Getter function for the OriginalParentSize property.</docstr>
      </function>
      <function name="GetAnchorMove">
        <docstr>Getter function for the AnchorMove property.</docstr>
      </function>
      <procedure name="SetAnchorMove">
        <docstr>Setter function for the AnchorMove property.
Value specifies the new value of the AnchorMove property.</docstr>
      </procedure>
      <function name="GetAdjustSizeValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetAdjustType">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetContainerWidth">
        <docstr>Getter function for the ContainerWidth property.
The container width is equal to the control width.</docstr>
      </function>
      <function name="GetContainerHeight">
        <docstr>Getter function for the ContainerHeight property.
The container height is equal to the control height.</docstr>
      </function>
      <function name="GetObject">
        <docstr>Returns the current control as a TFmxObject.</docstr>
      </function>
      <function name="GetParent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetVisible">
        <docstr>Getter function for the Visible property.</docstr>
      </function>
      <function name="GetDesignInteractive">
        <docstr>Getter function for the DesignInteractive property.</docstr>
      </function>
      <function name="GetPopupMenu">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="DoEnter">
        <docstr>OnEnter event dispatcher.
DoEnter is called automatically when the control receives the input focus.
DoEnter repaints the control, starts the animation by calling StartTriggerAnimation, and applies effects by calling ApplyTriggerEffect. The applied animations and effects highlight the focused control.
Override the protected DoEnter method to provide other responses when the current control receives focus.</docstr>
      </procedure>
      <procedure name="DoExit">
        <docstr>OnExit event dispatcher.
DoExit is called automatically when the input focus moves from the current object.
DoExit repaints the control, starts the animation by calling StartTriggerAnimation, and applies effects by calling ApplyTriggerEffect. When a control receives focus, it is highlighted. The animations and effects applied by DoExit background the control.
Override the protected DoExit method to provide other responses when the focus moves from the current control.</docstr>
      </procedure>
      <procedure name="DoActivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoDeactivate">
        <docstr>Dispatcher of the OnDeactivate event.</docstr>
      </procedure>
      <procedure name="DoMouseEnter">
        <docstr>OnMouseEnter event dispatcher.
DoMouseEnter is called automatically when the mouse pointer enters the control&apos;s area.
DoMouseEnter starts the animation by calling StartTriggerAnimation and applies effects by calling ApplyTriggerEffect to highlight the control. 
Override the protected DoMouseEnter method to provide other responses when the mouse pointer enters the control&apos;s area.</docstr>
      </procedure>
      <procedure name="DoMouseLeave">
        <docstr>OnMouseLeave event dispatcher.
DoMouseLeave is called automatically when the mouse pointer leaves the control&apos;s area.
DoMouseLeave starts the animation by calling StartTriggerAnimation and applies effects by calling ApplyTriggerEffect to background the control. 
Override the protected DoMouseLeave method to provide other responses when the mouse pointer leaves the control&apos;s area.</docstr>
      </procedure>
      <function name="CheckForAllowFocus">
        <docstr>Verifies whether the current control can receive focus. 
A control can receive focus if the ParentedVisible, CanFocus, and AbsoluteEnabled properties are True.
CheckForAllowFocus returns True if the control can receive focus, and False otherwise.</docstr>
      </function>
      <function name="GetDragMode">
        <docstr>Getter function for the DragMode property.</docstr>
      </function>
      <procedure name="SetDragMode">
        <docstr>Setter function for the DragMode property. ADragMode specifies the new value of the DragMode property.</docstr>
      </procedure>
      <function name="GetLocked">
        <docstr>Getter function for the Locked property.</docstr>
      </function>
      <function name="GetHitTest">
        <docstr>Getter function for the HitTest property.</docstr>
      </function>
      <function name="GetAcceptsControls">
        <docstr>Getter function for the AcceptsControls property.</docstr>
      </function>
      <procedure name="SetAcceptsControls">
        <docstr>Setter function for the AcceptsControls property.</docstr>
      </procedure>
      <function name="FindTarget">
        <docstr>Returns the target control.
P is the current position of the dragged object.
Data is the dragged object. 
FindTarget checks whether P belongs to the current control or any of its children (using a recursive method) and, if so, returns the control that contains P.
If the target control or any of its children is in designing mode or is not visible, FindTarget returns nil.</docstr>
      </function>
      <function name="ObjectAtPoint">
        <docstr>Returns the control in which a specified point can be found.
P is the specified point in the object.
ObjectAtPoint returns the control in which the P point is found. 
To start searching within the current control, the control must be visible and enabled. If P is within a child of the control and the child is also a control, the search continues inside the child. 
If P is inside the control (not within a child) and the control can be hit, then ObjectAtPoint returns the control. 
ObjectAtPoint is used internally.</docstr>
      </function>
      <function name="HasHint">
        <docstr>Returns True if the control has an available hint to display.</docstr>
      </function>
      <function name="GetHintString">
        <docstr>Returns the text of the hint.</docstr>
      </function>
      <function name="GetHintObject">
        <docstr>Returns the custom hint object that manages the hint display.
Usually, this is an instance of THint.</docstr>
      </function>
      <function name="CanShowHint">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="BroadcastGesture">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="CMGesture">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="TouchManager">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetFirstControlWithGesture">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetFirstControlWithGestureEngine">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetListOfInteractiveGestures">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Tap">
        <docstr>Called when the Tap gesture on the style presentation is recognized.</docstr>
      </procedure>
      <function name="GetFirstVisibleObjectIndex">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetLastVisibleObjectIndex">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.</docstr>
      </function>
      <function name="FillTextFlags">
        <docstr>Returns the filling direction of the control&apos;s text.
FillTextFlags is used by controls that provide the text area to get the filling direction of the text, depending on the reading direction of the control of the current Root, if it exists.</docstr>
      </function>
      <procedure name="ApplyEffect">
        <docstr>Applies effects to the control, if specified.
This method is called internally during the process of component rendering. 
Do not call this method. To apply an effect to a control, add an effect component as a child to the control.</docstr>
      </procedure>
      <procedure name="PaintInternal">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="SupportsPaintStage">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="CanRepaint">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="RepaintRect">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="PaintChildren">
        <docstr>Renders the child controls.
The PaintChildren method is called automatically in the process of painting of the current control. It renders child controls, if any, on the surface specified by the Canvas property. 
The effects that are applied to the control are also applied to its children.
TControl descendants can override PaintChildren to provide specific rendering of the respective controls.</docstr>
      </procedure>
      <procedure name="Painting">
        <docstr>OnPainting event dispatcher. 
Painting defines the drawing area of the control by intersecting Canvas with ClipRect if ClipChildren is True and dispatches the OnPainting event.
It is always called internally before DoPaint. 
The Painting method can be overridden by derived controls to establish control-specific rendering conditions.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="DoPaint">
        <docstr>Processes the painting of the control. 
This method is called internally from PaintTo and PaintChildren. DoPaint defines the drawing area by clipping the Canvas to the areas occupied by the control and its children, paints the children and then the control itself. The call to DoPaint is always preceded by a call to Painting and succeeded by a call to AfterPaint.</docstr>
      </procedure>
      <procedure name="AfterPaint">
        <docstr>Restores Canvas properties after the painting process. 
As implemented in TControl, AfterPaint does nothing.
TShape descendants of TControl override AfterPaint to restore Dash and  Thickness to default values.</docstr>
      </procedure>
      <procedure name="DrawDesignBorder">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRealign">
        <docstr>Performs the alignment of a FireMonkey control.</docstr>
      </procedure>
      <procedure name="DoBeginUpdate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoEndUpdate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Move">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <procedure name="DoResized">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Disappear">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Show">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Hide">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AncestorVisibleChanged">
        <docstr>Notifies its child controls that the visibility of an ancestor of your control has changed to Visible.</docstr>
      </procedure>
      <procedure name="AncestorParentChanged">
        <docstr>Notifies its child controls that the parent of an ancestor of your control has changed.</docstr>
      </procedure>
      <procedure name="ClipChildrenChanged">
        <docstr>Executed right after the value of the ClipChildren property changes.
The control does not execute ClipChildrenChanged if you assign ClipChildren the same value that it already has.</docstr>
      </procedure>
      <procedure name="HitTestChanged">
        <docstr>Executed right after the value of the HitTest property changes.
The control does not execute HitTestChanged if you assign HitTest the same value that it already has.</docstr>
      </procedure>
      <procedure name="PaddingChanged">
        <docstr>Executed right after the value of the Padding property changes.
The control does not execute PaddingChanged if you assign Padding the same value that it already has.</docstr>
      </procedure>
      <property name="MinClipWidth">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="MinClipHeight">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="SmallSizeControl">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.Controls.TControl.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoInsertObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoDeleteChildren">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="PaintStage">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="TempCanvas">
        <docstr>Temporary copy of the canvas on which the control is drawn.
It is used internally in the process of painting. Do not use it in applications.</docstr>
      </property>
      <procedure name="SetLeft">
        <docstr>Setter function for the Left property. Value specifies the new value of the Left property.</docstr>
      </procedure>
      <procedure name="SetTop">
        <docstr>Setter function for the Top property. Value specifies the new value of the Top property.</docstr>
      </procedure>
      <procedure name="UpdateExplicitBounds">
        <docstr>Updates the explicit bounds&apos; properties of the control.
UpdateExplicitBounds is called by SetBounds after updating the control&apos;s anchors rules, to update the ExplicitLeft, ExplicitTop, ExplicitWidth, and ExplicitHeight properties.  
It is for internal use only.</docstr>
      </procedure>
      <procedure name="UpdateAnchorRules">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="Left">
        <docstr>Specifies the horizontal coordinate of the left edge of a component, relative to its parent. 
The Left property is used to determine where the left side of the control begins or to reposition the left side of the control.
If the control is contained in another control, the Left and Top properties are relative to the parent control. If the control is contained directly by the form, the property values are relative to the form. For forms, the value of the Left property is relative to the screen, in pixels. 
Use Position in applications to allow read and write access.</docstr>
      </property>
      <property name="Top">
        <docstr>Specifies the vertical coordinate of the upper-left corner of a control, relative to its parent, in pixels. 
The Top property is used to locate the top of the control or to reposition the control to a different Y coordinate.
If the control is contained in another control, the Left and Top properties are relative to the parent control. If the control is contained directly by the form, the property values are relative to the form. For forms, the value of the Top property is relative to the screen, in pixels. 
Use Position in applications to allow read and write access.</docstr>
      </property>
      <property name="ExplicitLeft">
        <docstr>Specifies the explicit horizontal pixel coordinate of the left edge of a component, relative to its parent.
ExplicitLeft is a read-only property used internally by Delphi. Use Left in applications to allow read and write access.</docstr>
      </property>
      <property name="ExplicitTop">
        <docstr>Specifies the explicit vertical pixel coordinate of the top edge of a component, relative to its parent.
ExplicitTop is a read-only property used internally by Delphi. Use Top in applications to allow read and write access.</docstr>
      </property>
      <property name="ExplicitWidth">
        <docstr>Specifies the explicit horizontal size of the control (in pixels). 
ExplicitWidth is a read-only property used internally by Delphi. Use Width in applications to allow read and write access.</docstr>
      </property>
      <property name="ExplicitHeight">
        <docstr>Specifies the explicit vertical size of the control (in pixels).
ExplicitHeight is a read-only property used internally by Delphi. Use Height in applications to allow read and write access.</docstr>
      </property>
      <function name="GetActionLinkClass">
        <docstr>Returns the associated action link class.
FMX.Controls.TControl.GetActionLinkClass inherits from FMX.Types.TFmxObject.GetActionLinkClass. All content below this line refers to FMX.Types.TFmxObject.GetActionLinkClass.
Returns the associated action link class.
Returns the class reference for the TActionLink class or for one of its descendants. 
In TFmxObject, GetActionLinkClass always returns nil.
In descendant classes, GetActionLinkClass should return the appropriate class type for the action link used with the class object. When a control object of the descendant from the TFmxObject class tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass. If GetActionLinkClass returns a non-nil value, then the action object is assigned to Action. If the control object does not support actions, then GetActionLinkClass should return nil. In this case, attempting to set a value to the Action property raises the following exception:  

StrEActionNoSuported = &apos;Class %s does not support the action&apos;</docstr>
      </function>
      <procedure name="ActionChange">
        <docstr>Specifies the behavior of a TControl control when Action changes. 
Depending on the CheckDefaults value,  ActionChange uses properties of the Sender action to set new values to the  
Enabled, Hint, Visible, OnClick, and PopupMenu parameters of TControl. Then ActionChange calls the inherited TFmxObject.ActionChange method.  
Do not call ActionChange explicitly in an application. It is for internal use.</docstr>
      </procedure>
      <function name="EnabledStored">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="VisibleStored">
        <docstr>Returns True when the Visible property needs to be stored in the fmx-file.</docstr>
      </function>
      <procedure name="EnabledChanged">
        <docstr>Executed right after the value of the Enabled property changes.
The control does not execute EnabledChanged if you assign Enabled the same value that it already has.
EnabledChanged is never executed for effects, which execute EffectEnabledChanged instead.</docstr>
      </procedure>
      <procedure name="VisibleChanged">
        <docstr>Executed right after the value of the Visible property changes.
The control does not execute VisibleChanged if you assign Visible the same value that it already has.</docstr>
      </procedure>
      <function name="IsControlRectEmpty">
        <docstr>Returns True if the control rect is empty.</docstr>
      </function>
      <function name="GetControls">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="DoGesture">
        <docstr>Processes the unhandled gesturing events.
DoGesture is run automatically for all gesturing events that were not handled by the user. DoGesture is run only if OnGesture is not set or if it did not handle the gesture event. 
Override DoGesture in descending classes to support default behavior for gesture events that were not handled by the user. In TControl, the DoGesture method simply returns and does no special processing.</docstr>
      </procedure>
      <function name="GetTabStopController">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetTabListClass">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="DoubleClick">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="RotationAngle">
        <docstr>Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
To set the rotation center, use RotationCenter.</docstr>
      </property>
      <property name="RotationCenter">
        <docstr>Specifies the position of the pivot point of the control.
The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
To set the rotation angle, use RotationAngle.</docstr>
      </property>
      <property name="Scale">
        <docstr>Specifies the scale of the control.
Set the Scale coordinates to specify the scale on each axis.
The initial scale rate is 1 on each axis.

Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale.</docstr>
      </property>
      <property name="DisabledOpacity">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ParentContent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ParentShowHint">
        <docstr>If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Controls.TControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Controls.TControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="SetNewScene">
        <docstr>Sets a new Scene for the current control.
AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
SetNewScene sets the same scene for the control&apos;s children.</docstr>
      </procedure>
      <procedure name="SetBounds">
        <docstr>Sets the boundaries of the current control.
Use SetBounds to change all of the boundary properties of the control at one time. 
X specifies the X coordinate of the Position of the control.
Y specifies the Y coordinate of the Position of the control.
AWidth specifies the value of the Width of the control.
AHeight specifies the value of the Height of the control.
The same effect can be achieved by setting the Position, Width, and Height properties separately, but SetBounds changes all properties at once, ensuring that the control will not repaint between changes.
After setting the boundary properties, SetBounds specifies to the control to maintain the alignment of the control within its parent and of its children within it. The given parameter does not necessarily reflect in the Position, Width, and Height properties. The properties can be updated when the alignment is applied.</docstr>
      </procedure>
      <function name="AbsoluteToLocal">
        <docstr>Translates coordinated of the specified Point from an global perspective to a local coordinates of this control. 
The absolute context for a control is the parent form area, and the local context is the control area.
Point is the point to be transformed.
AbsoluteToLocal returns the transformed point.
To have the inverse effect over a point, use LocalToAbsolute.</docstr>
      </function>
      <function name="AbsoluteToLocal">
        <docstr>Translates coordinated of the specified Point from an global perspective to a local coordinates of this control. 
The absolute context for a control is the parent form area, and the local context is the control area.
Point is the point to be transformed.
AbsoluteToLocal returns the transformed point.
To have the inverse effect over a point, use LocalToAbsolute.</docstr>
      </function>
      <function name="LocalToAbsolute">
        <docstr>Transforms and returns a specified point from the local perspective to the absolute perspective. 
Use LocalToAbsolute to get the transposed coordinates of a point from the local context to the absolute context of the current control. The absolute context for a control is the parent form area, and the local context is the control area.
P is the point to be transformed.
LocalToAbsolute returns the transformed point.
To have the inverse effect over a point, use AbsoluteToLocal.</docstr>
      </function>
      <function name="LocalToAbsolute">
        <docstr>Transforms and returns a specified point from the local perspective to the absolute perspective. 
Use LocalToAbsolute to get the transposed coordinates of a point from the local context to the absolute context of the current control. The absolute context for a control is the parent form area, and the local context is the control area.
P is the point to be transformed.
LocalToAbsolute returns the transformed point.
To have the inverse effect over a point, use AbsoluteToLocal.</docstr>
      </function>
      <function name="ScreenToLocal">
        <docstr>Transforms and returns a specified point from the screen perspective to the local perspective. 
P is the point to be transformed.
ScreenToLocal is used internally.</docstr>
      </function>
      <function name="LocalToScreen">
        <docstr>Transforms and returns a specified point from the local perspective to the screen perspective. 
P is the point to be transformed.
LocalToScreen is used internally when applying a certain placement.</docstr>
      </function>
      <function name="ConvertLocalPointFrom">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="ConvertLocalPointTo">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="AbsoluteToLocalVector">
        <docstr>Transforms and returns a specified vector from the absolute perspective to the local perspective. 
Use AbsoluteToLocalVector to get the transposed coordinates of a vector from the absolute context to the local context of the current control. The absolute context for a control is the parent form area, and the local context is the control area.
P is the vector to be transformed.
AbsoluteToLocalVector returns the transformed vector.
To have the inverse effect over a point, use LocalToAbsoluteVector.</docstr>
      </function>
      <function name="LocalToAbsoluteVector">
        <docstr>Transforms and returns a specified vector from the local perspective to the absolute perspective. 
Use LocalToAbsoluteVector to get the transposed coordinates of a vector from the local context to the absolute context of the current control. The absolute context for a control is the parent form area, and the local context is the control area.
P is the vector to be transformed.
LocalToAbsoluteVector returns the transformed vector.
To have the inverse effect over a vector, use AbsoluteToLocalVector.</docstr>
      </function>
      <function name="PointInObject">
        <docstr>Checks whether the point, specified by the absolute coordinates, belongs to the control area.
PointInObject returns True if the specified point belongs to the control area, and False otherwise. 
The X and Y are the absolute coordinates (relative to the main form) of the point to be checked (compare with PointInObjectLocal):

X is the X coordinate.
Y is the Y coordinate.
The points of the control boundary specified by BoundsRect belong to the control and PointInObject returns True for them.

Note: PointInObject simply converts absolute coordinates of the point to local coordinates and calls PointInObjectLocal.</docstr>
      </function>
      <function name="PointInObjectLocal">
        <docstr>Checks whether the point specified by local coordinates belongs to the control area.
PointInObjectLocal returns True if the specified point belongs to the control area, and False otherwise. 
The X and Y are the local coordinates of the point to be checked (compare with PointInObject):

X is the X coordinate.
Y is the Y coordinate.
The local coordinates of the upper-left corner of the control rectangle are (0,0), and the local coordinates of the lower-right corner are (Width, Height). 
The points of the control boundary specified by BoundsRect belong to the control and PointInObjectLocal returns True for them.
If a control supports the Touch property, the control area can be optionally inflated on the values specified by the TouchTargetExpansion property. TouchTargetExpansion keeps four optional parameters representing the expansion for the four sides of the control in pixels (Bottom, Left, Right, and Top). 
The dclasses can change the &apos;control area&apos; definition. For example:

The FMX.Objects.TSelection class extends the &apos;control area&apos; definition relative to BoundsRect. FMX.Objects.TSelection.PointInObjectLocal also returns True if the point belongs to any of small rectangles of the four grip controls used to manage the selection shape. The rectangles of the grip controls are rectangles surrounding the four corners of the TSelection rectangle. The Width and Height of these rectangles are equal to 2 * GripSize. For example, the grip control&apos;s rectangle of the upper-right corner UR_Corner of TSelection is defined by the following corners:
(UR_Corner.Top - GripSize, UR_Corner.Right - GripSize)--upper-left corner of the grip.
(UR_Corner.Top + GripSize, UR_Corner.Right + GripSize)--lower-right corner of the grip.
FMX.Objects.TSelectionPoint.PointInObjectLocal returns True if the specified point belongs to the rectangle of the grip control corresponding to the TSelectionPoint object, and False otherwise.</docstr>
      </function>
      <function name="MakeScreenshot">
        <docstr>Takes and returns a screenshot of the control.
MakeScreenshot creates a new TBitmap, draws on it the image of the current control by calling PaintTo, and returns it.</docstr>
      </function>
      <procedure name="BeginUpdate">
        <docstr>Marks the start of an update session of the control and its children. 
It increases the value of the FUpdating semaphore. A call to BeginUpdate must be complemented by calls to EndUpdate after the update is finished.
FUpdating is an internal semaphore used to mark the process of control updating. Painting of a control is disabled while FUpdating is higher than 0.</docstr>
      </procedure>
      <function name="IsUpdating">
        <docstr>Returns True if this control is in the middle of one or more update sessions. It returns False otherwise.</docstr>
      </function>
      <procedure name="EndUpdate">
        <docstr>Marks the end of an update session of the control and its children.
The update session must be started first by calling BeginUpdate.
EndUpdate decreases the FUpdating semaphore. If all update sessions end and FUpdating is 0, EndUpdate invokes Realign to process layout changes.</docstr>
      </procedure>
      <procedure name="RecalcAbsoluteNow">
        <docstr>Recalculates AbsoluteMatrix.
It is used in the painting process. Do not call RecalcAbsoluteNow in an application.</docstr>
      </procedure>
      <procedure name="RecalcUpdateRect">
        <docstr>Forces the current control to recalculate its UpdateRect property.  RecalcUpdateRect also forces the control&apos;s parent--if necessary--and children to recalculate their UpdateRect property.</docstr>
      </procedure>
      <procedure name="RecalcOpacity">
        <docstr>Forces the current control to recalculate its Opacity property.  RecalcOpacity also forces the control&apos;s children to recalculate their Opacity property.</docstr>
      </procedure>
      <procedure name="RecalcAbsolute">
        <docstr>Forces the current control to recalculate the AbsoluteMatrix property.  RecalcAbsolute also forces the control&apos;s children to recalculate their AbsoluteMatrix.</docstr>
      </procedure>
      <procedure name="RecalcEnabled">
        <docstr>Forces the current control to recalculate its enabled state.  RecalcEnabled also forces the control&apos;s children to recalculate their enabled state.</docstr>
      </procedure>
      <procedure name="RecalcHasEffect">
        <docstr>Forces the current control to recalculate its HasEffect property.  RecalcHasEffect also forces the control&apos;s parent to recalculate its HasEffect property.</docstr>
      </procedure>
      <procedure name="RecalcHasClipParent">
        <docstr>Forces the current control to recalculate its HasClipParent property.</docstr>
      </procedure>
      <procedure name="PrepareForPaint">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RecalcSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="UpdateEffects">
        <docstr>Updates the effects of the current control and of the control&apos;s parent.
UpdateEffects is called every time the current control is changed (repainted, realigned, resized). UpdateEffects is also used when a new child is added to the control by calling AddObject.</docstr>
      </procedure>
      <procedure name="ApplyTriggerEffect">
        <docstr>Applies the specified mouse trigger effect to all the children of this FMX object that are of type TEffect.
ApplyTriggerEffect iterates through all the children of this FMX object and, if one of them is of type TEffect, applies the mouse trigger given through the ATrigger parameter (which can be &apos;IsMouseOver&apos;, &apos;IsMouseOver&apos;, &apos;IsDragOver&apos;, and so on).
AInstance specifies the instance of the FMX object to which the trigger effect is applied.</docstr>
      </procedure>
      <procedure name="StartTriggerAnimation">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="StartTriggerAnimationWait">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetFocus">
        <docstr>Sets the focus to the current control, if CanFocus is True. When the current control receives focus, the OnCanFocus event is triggered.</docstr>
      </procedure>
      <procedure name="ResetFocus">
        <docstr>Removes the focus from a control or from any children of the control.</docstr>
      </procedure>
      <procedure name="PaintTo">
        <docstr>Paints the current control to a specified canvas. 
ACanvas specifies the canvas to draw on.
ARect specifies the rectangle area of the ACanvas to draw on.
AParent specifies the Parent of the control. By default, it is empty.
PaintTo is called in the process of applying effects on the control in ApplyEffect, in which the control is first painted on the effect&apos;s canvas using PaintTo and then the effect is processed. It is also used in MakeScreenshot in order to produce a screenshot bitmap.
Descendants of TControl override PaintTo to provide specific rendering of the respective controls.</docstr>
      </procedure>
      <procedure name="Repaint">
        <docstr>Forces the control to repaint its image on the screen.
Repaint updates the effects applied to the control, if any, and adds a new update rectangle--which corresponds to the control&apos;s UpdateRect--to the control&apos;s Scene.
Call Repaint when the control&apos;s displayed area needs to be updated.</docstr>
      </procedure>
      <procedure name="InvalidateRect">
        <docstr>Adds a rectangle to the update region of the scene.
ARect specifies the rectangle to be invalidated.
InvalidateRect transposes ARect to the local perspective and then adds it to the update region of the Scene.</docstr>
      </procedure>
      <procedure name="Lock">
        <docstr>Locks the current control, so it cannot be changed at design time. Lock also locks the current control&apos;s children.</docstr>
      </procedure>
      <property name="AbsoluteMatrix">
        <docstr>Specifies the absolute transformation matrix of the control. 
AbsoluteMatrix is calculated using FLocalMatrix and AbsoluteMatrix of its parent.
The calculation only takes place if FRecalcAbsolute is True and the result is then cached in the FAbsoluteMatrix field.
If the calculation is not taking place during an update session and InPaintTo is not set, it initiates Repaint.
AbsoluteMatrix is used when the control is painted or needs to be repainted.</docstr>
      </property>
      <property name="AbsoluteOpacity">
        <docstr>Specifies the absolute opacity of the control. 
If the control has another TControl as parent, AbsoluteOpacity depends on the absolute opacity of its parent. 
To explicitly set the opacity of a control, use the Opacity property.</docstr>
      </property>
      <property name="AbsoluteWidth">
        <docstr>Specifies the absolute width of the control. 
Usually, it has the same values as the Width property. The value can be affected by the transformations applied over the control.</docstr>
      </property>
      <property name="AbsoluteHeight">
        <docstr>Specifies the absolute height of the control. 
Usually, it has the same value as the Height property. The value can be affected by the transformations applied over the control.</docstr>
      </property>
      <property name="AbsoluteScale">
        <docstr>Specifies the absolute scale of the control. 
The absolute scale of a control is the scale relative to the scale of its parent.
AbsoluteScale is kept as a TPointF. The X coordinate is the scale for the X axis and Y is the scale for the Y axis.</docstr>
      </property>
      <property name="AbsoluteEnabled">
        <docstr>Specifies whether the control is absolutely enabled. 
AbsoluteEnabled is True only if Enabled is True and the parent also reports AbsoluteEnabled as True. Therefore, this logic climbs the parent hierarchy to determine whether the control is truly enabled or not.
If Parent is set and the parent&apos;s AbsoluteEnabled property is False, AbsoluteEnabled is set to False, otherwise it has the value of the Enabled property.</docstr>
      </property>
      <property name="AbsoluteRect">
        <docstr>Specifies the absolute rectangle that bounds the control.  It returns the bounding rectangle of the control in absolute coordinates (relative to the main form).</docstr>
      </property>
      <property name="AbsoluteClipRect">
        <docstr>Specifies the absolute rectangle of the control after all its parent controls clip it.</docstr>
      </property>
      <property name="AxisAlignedRect">
        <docstr>A TRectF defined by the width and height of the control.
This TRectF is normalized. DoGetUpdateRect uses this property.</docstr>
      </property>
      <property name="ApplyingEffect">
        <docstr>A flag that signals when a control is in the process of applying an effect.
The ApplyEffect method uses this flag to correctly render a control.</docstr>
      </property>
      <property name="HasEffect">
        <docstr>Specifies whether the control has an applied effect.
HasEffect is False if an effect was applied to the control, and True otherwise.</docstr>
      </property>
      <property name="HasDisablePaintEffect">
        <docstr>Specifies whether the control&apos;s effect is painted.
HasDisablePaintEffect is True if the control has disabled the painting effect, and False otherwise.</docstr>
      </property>
      <property name="HasAfterPaintEffect">
        <docstr>Specifies whether the control has an effect that is applied after the control is painted.
HasAfterPaintEffect is True if the control has an effect that is applied after the control is painted, and False otherwise.</docstr>
      </property>
      <property name="HasClipParent">
        <docstr>Control that is a direct child of this control and has clipped this control.</docstr>
      </property>
      <property name="ChildrenRect">
        <docstr>Specifies the bigger rectangle area occupied by parent and children controls. 
ChildrenRect is a rectangle obtained by performing a union operation between the rectangles occupied by the parent control and the children controls. 

Use the ChildrenRect.Width property on the parent, to obtain the width of the rectangle.
Use the ChildrenRect.Height property on the parent, to obtain the height of the rectangle.
Note: They are read-only properties.</docstr>
      </property>
      <property name="DefaultSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FixedSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="InvertAbsoluteMatrix">
        <docstr>Specifies the inverse matrix of AbsoluteMatrix.</docstr>
      </property>
      <property name="InPaintTo">
        <docstr>Specifies whether the control is currently being painted.
InPaintTo is True if the current control is being painted.</docstr>
      </property>
      <property name="LocalRect">
        <docstr>Specifies the local rectangle for painting the control. 
The coordinates of the upper-left corner of the rectangle are (0,0) and the coordinates of the bottom right corner are (Width, Height).</docstr>
      </property>
      <property name="Pressed">
        <docstr>Indicates whether the control is currently pressed.
Mouse action event handlers use this property as a flag to determine how to proceed in some cases.</docstr>
      </property>
      <property name="PressedPosition">
        <docstr>A point that indicates where exactly on the control the click occured.
MouseDown sets PressedPosition if Button is mbLeft.</docstr>
      </property>
      <property name="UpdateRect">
        <docstr>Specifies the rectangle area of the control that needs to be updated. 
UpdateRect is a union between the rectangle areas that need to be painted over the control when:

The control receives focus.
The control gets new effects.
The control&apos;s children are updated.
The control&apos;s parent is updated.</docstr>
      </property>
      <property name="BoundsRect">
        <docstr>Specifies the bounding rectangle of the control. 
The coordinates of the upper-left corner of the bounding rectangle are X and Y coordinates of the control Position. The coordinates of the lower-right corner are X+Width and Y+Height. 
For example:

R:=Control.BoundsRect;

The coordinates of the R rectangle are:

R.Left = Control.Position.X;
R.Top = Control.Position.Y;
R.Right = Control.Position.X + Control.Width;
R.Bottom = Control.Position.Y + Control.Height;

When BoundsRect is set, the Position property is set to be the upper-left corner of the given bound rectangle, and the Width and Height of the control receive the values of the width and height of the given bound rectangle.
For example:

Control.BoundsRect:=R;

The controls have the following properties:

Control.Position.X= R.Left;
Control.Position.Y= R.Top;
Control.Width= R.Width;
Control.Height= R.Height;</docstr>
      </property>
      <property name="ParentedRect">
        <docstr>Specifies the bounding rectangle of the control within its parent.</docstr>
      </property>
      <property name="ParentedVisible">
        <docstr>Specifies whether all the control&apos;s parents are visible. 
A control can be set to visible if all its parents are also visible.
ParentedVisible returns True if the control&apos;s parents are visible, and False otherwise.</docstr>
      </property>
      <property name="ClipRect">
        <docstr>Specifies the bound rectangle to be clipped. 
The values of ClipRect are specified by:

Left and Top, equal to 0.
Right, equal to Width.
Bottom, equal to Height.</docstr>
      </property>
      <property name="Canvas">
        <docstr>Provides the drawing surface of the control. 
Canvas defines an area within which you can explicitly position child elements by using coordinates that are relative to the drawing area.
For more details, see TCanvas.</docstr>
      </property>
      <property name="Controls">
        <docstr>Stores an array of child controls attached to this parent control.</docstr>
      </property>
      <property name="ControlsCount">
        <docstr>Number of controls that are direct children of this control.</docstr>
      </property>
      <property name="ParentControl">
        <docstr>Specifies the parent control of this control.

Tip: You cannot set the parent control of this control as the control itself (Self (Delphi) or this (C++Builder)).</docstr>
      </property>
      <property name="Scene">
        <docstr>Specifies the current scene in which the control is drawn.  
The Scene of the control is also the scene of its children.</docstr>
      </property>
      <property name="AutoCapture">
        <docstr>Specifies whether the control captures mouse events.
When a control captures the mouse, all subsequent mouse events go to that control until the user releases the mouse button.</docstr>
      </property>
      <property name="CanFocus">
        <docstr>Specifies whether the current control can receive focus. 
CanFocus is True if it can receive focus, and False otherwise.
If it is set to False, the control cannot be selected when using the TAB key.
A control can receive focus after it is created.</docstr>
      </property>
      <property name="CanParentFocus">
        <docstr>Specifies whether the parent of this control should be evaluated to receive focus.
CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise.</docstr>
      </property>
      <property name="DisableFocusEffect">
        <docstr>Specifies whether the control has the focus effect disabled.
Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False.</docstr>
      </property>
      <property name="IsInflated">
        <docstr>Whether the current style of this control has been actually applied to the control.
IsInflated is  True if the current style of the control has been applied to the control. It is False otherwise.
For example, if you change the style of a control at run time, IsInflated is False until the control is updated to show its new style.</docstr>
      </property>
      <procedure name="EnumControls">
        <docstr>Loops through the controls that are children of this control, and runs the specified procedure once per control, with a different control as the first parameter in each call.

Warning: EnumControls is deprecated as a function. You should use it as a procedure instead. This page describes the syntax and use of the EnumControls procedure.
EnumControls loops not only through direct children of this control, but also through their children (grand-children), and so on, using a depth-first search algorithm.
Each time EnumControls visits a control during the search, it executes the Proc procedure. This procedure receives the visited control as argument, and it returns a value of type TEnumControlsResult. The return value defines what EnumControls does next. You may return any of the following values:

Continue lets EnumControls keep searching the controls as usual.
Discard makes the search skip the children of the current control (the control in the first parameter), as well as their children (grand-children) and so on.
Stop interrupts the search loop. If EnumControls were a language-level control loop, Stop would be the Break keyword.
Example
The following is an example call to EnumControls that loops through the children of a panel (Panel1) and fills a list (ListOfVisibleControls) with all the controls that are visible:


In Delphi:

Panel1.EnumControls(function (Control: TControl): TEnumControlsResult
  begin
    if not Control.Visible then
      Result := TEnumControlsResult.Discard
    else
      begin
        ListOfVisibleControls.Add(Control);
        Result := TEnumControlsResult.Continue;
      end;
  end);



In C++:

1. Define a class that implements the TFunc__2 interface:
class TMethodReference : public TCppInterfacedObject&lt;TFunc__2&lt;TControl*,TEnumControlsResult&gt; &gt;
{
public:
    TEnumControlsResult __fastcall Invoke(TControl* Control)
    {
        if (!Control-&gt;Visible)
            return TEnumControlsResult::Discard;
        else {
            TForm2::ListOfVisibleControls-&gt;Add(Control);
            return TEnumControlsResult::Continue;
        }
    }
};

2. Then pass an instance of this class to EnumControls:
Panel1-&gt;EnumControls(new TMethodReference);</docstr>
      </procedure>
      <function name="EnumControls">
        <docstr>Loops through the controls that are children of this control, and runs the specified procedure once per control, with a different control as the first parameter in each call.

Warning: EnumControls is deprecated as a function. You should use it as a procedure instead. This page describes the syntax and use of the EnumControls procedure.
EnumControls loops not only through direct children of this control, but also through their children (grand-children), and so on, using a depth-first search algorithm.
Each time EnumControls visits a control during the search, it executes the Proc procedure. This procedure receives the visited control as argument, and it returns a value of type TEnumControlsResult. The return value defines what EnumControls does next. You may return any of the following values:

Continue lets EnumControls keep searching the controls as usual.
Discard makes the search skip the children of the current control (the control in the first parameter), as well as their children (grand-children) and so on.
Stop interrupts the search loop. If EnumControls were a language-level control loop, Stop would be the Break keyword.
Example
The following is an example call to EnumControls that loops through the children of a panel (Panel1) and fills a list (ListOfVisibleControls) with all the controls that are visible:


In Delphi:

Panel1.EnumControls(function (Control: TControl): TEnumControlsResult
  begin
    if not Control.Visible then
      Result := TEnumControlsResult.Discard
    else
      begin
        ListOfVisibleControls.Add(Control);
        Result := TEnumControlsResult.Continue;
      end;
  end);



In C++:

1. Define a class that implements the TFunc__2 interface:
class TMethodReference : public TCppInterfacedObject&lt;TFunc__2&lt;TControl*,TEnumControlsResult&gt; &gt;
{
public:
    TEnumControlsResult __fastcall Invoke(TControl* Control)
    {
        if (!Control-&gt;Visible)
            return TEnumControlsResult::Discard;
        else {
            TForm2::ListOfVisibleControls-&gt;Add(Control);
            return TEnumControlsResult::Continue;
        }
    }
};

2. Then pass an instance of this class to EnumControls:
Panel1-&gt;EnumControls(new TMethodReference);</docstr>
      </function>
      <function name="GetTabList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="ShowInDesigner">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="ShouldTestMouseHits">
        <docstr>Indicates whether a control should be ignored in ObjectAtPoint.
False if the control should be ignored in ObjectAtPoint. ShouldTestMouseHits normally returns the same value as the value of Visible property of the control.
TFrame overrides this method to allow itself to be painted in design time regardless of the value of its Visible property.</docstr>
      </function>
      <property name="IsMouseOver">
        <docstr>Specifies whether the mouse cursor is over the control.
IsMouseOver is True when the mouse is passing over the control.
For effect triggers, setting IsMouseOver to True triggers the effect while the mouse passes over the control.</docstr>
      </property>
      <property name="IsDragOver">
        <docstr>Specifies whether a dragged object is over the area of the current control.
IsDragOver is True when the dragged object is over the current control.
For effect triggers, setting IsDragOver to True triggers the effect when the dragged object is over the current control.</docstr>
      </property>
      <property name="IsFocused">
        <docstr>Specifies whether the control is in focus.
IsFocused is True when the focus is on the control.
For effect triggers, setting IsFocused to True triggers the effect when the user selects the control.</docstr>
      </property>
      <property name="IsVisible">
        <docstr>Specifies whether the control is visible.
IsVisible is True when the control is visible. Use Visible in applications to allow write access.
For effect triggers, setting IsVisible to True triggers the effect when the control is visible on the form.</docstr>
      </property>
      <property name="Align">
        <docstr>Specifies the alignment options (top, left, client, and so on) of this control. 
Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale.</docstr>
      </property>
      <property name="Anchors">
        <docstr>Specifies how the control is anchored to its parent. 
Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale.</docstr>
      </property>
      <property name="Cursor">
        <docstr>Image to use to represent the mouse pointer when it passes into the region covered by the control.
Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form).</docstr>
      </property>
      <property name="InheritedCursor">
        <docstr>Image used to represent the mouse pointer when it passes into the region covered by the control.
The value of the read-only InheritedCursor property is the value of the Cursor property unless Cursor has the default value, in which case InheritedCursor contains the first non-default InheritedCursor value of its ancestors (parent, grand-parent, and so on until the parent form). If every ancestor of this control has InheritedCursor set to the default value, InheritedCursor has the default value in this control as well.
Changing the value of Cursor in this control or in any ancestor of this control may affect the value of InheritedCursor in this control.</docstr>
      </property>
      <property name="DragMode">
        <docstr>Specifies how the control initiates drag-and-drop operations.
Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic.</docstr>
      </property>
      <property name="EnableDragHighlight">
        <docstr>Specifies whether the control is highlighted when the dragged object is over it.</docstr>
      </property>
      <property name="Enabled">
        <docstr>Specifies whether the control responds to mouse, keyboard, and timer events. 
Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
To re-enable a control, set Enabled to True.
This property applies to all TControl descendants.</docstr>
      </property>
      <property name="Position">
        <docstr>Aligns the component to the position points of other components (Bounds points).
Specifies the upper-left corner of the current control, relative to its parent. 
The Position can be affected by the Padding of its parent and the Margins of the control.</docstr>
      </property>
      <property name="Locked">
        <docstr>Specifies whether the control is locked at design time. 
A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
To lock the control, set Locked to True. 
By default, Locked is False, and the control can be modified at design time.</docstr>
      </property>
      <property name="Width">
        <docstr>Specifies the horizontal size of the control (in pixels).
Use the Width property to read or change the width of the control.</docstr>
      </property>
      <property name="Height">
        <docstr>Height specifies the vertical size of the control (in dp).
Use the Height property to read or change the height of the control.</docstr>
      </property>
      <property name="Size">
        <docstr>Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
Use the Size property to read or change the size of the control.</docstr>
      </property>
      <property name="Padding">
        <docstr>Aligns the component to the padding points of other components. 
The Padding of a control specifies how close, in pixels, the control&apos;s children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
The control&apos;s children are repositioned and resized, if necessary, to maintain the Padding. 
If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
The following image shows how Padding and Margins properties affect alignment, position, and size of controls.


Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls.</docstr>
      </property>
      <property name="Margins">
        <docstr>Aligns the component to the margins points of other components. 
The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control&apos;s guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
The following image shows how Padding and Margins properties affect alignment, position, and size of controls.</docstr>
      </property>
      <property name="Opacity">
        <docstr>Specifies the control opacity. 
Set Opacity to customize the transparency of the current control.
Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
Opacity applies to the control&apos;s children.</docstr>
      </property>
      <property name="ClipChildren">
        <docstr>Specifies if children of the control should be clipped to the control&apos;s on-screen region.
Set ClipChildren to 

True if you want child controls to be clipped to the control&apos;s on-screen region.
False if you want child controls to be able to extend beyond the region of the parent control.</docstr>
      </property>
      <property name="ClipParent">
        <docstr>Specifies whether the current control has clipped its parent. 
When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
Parts of the control that do not contain visible objects cut off holes in the parent&apos;s image.
ClipParent is ignored in PaintChildren and other painting methods.
If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False.</docstr>
      </property>
      <property name="HitTest">
        <docstr>Enables the control to capture mouse events.

If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.

Example of HitTest
1. On a form, place a TPanel component.
2. Inside the panel, place a TPathLabel component.
3. Implement the OnClick event for both the TPanel and the TPathLabel:

procedure TForm1.Panel1Click(Sender: TObject);
begin
  ShowMessage(&apos;OnClick event fired for TPanel&apos;);
end;

procedure TForm1.PathLabel1Click(Sender: TObject);
begin
  ShowMessage(&apos;OnClick event fired for TPathLabel&apos;);
end;

4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel.</docstr>
      </property>
      <property name="PopupMenu">
        <docstr>Specifies the context (pop-up) menu object. 
Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called.</docstr>
      </property>
      <property name="TabOrder">
        <docstr>Indicates the position of the control in its parent&apos;s tab order.
TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
Each control has a unique tab-order value within its parent. 
Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order.</docstr>
      </property>
      <property name="Visible">
        <docstr>Specifies whether the component appears onscreen.
Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.</docstr>
      </property>
      <event name="CustomSceneAddRect">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnDragEnter">
        <docstr>Occurs when a dragged object enters the area of the current control.
OnDragEnter also occurs when DragEnter is called.
Write an event handler for OnDragEnter to specify what happens when a dragged object enters the area of the current control.</docstr>
      </event>
      <event name="OnDragLeave">
        <docstr>Occurs when a dragged object leaves the area of the current control.
OnDragLeave also occurs when DragLeave is called.
Write an event handler for OnDragLeave to specify what happens when a dragged object leaves the area of the current control.</docstr>
      </event>
      <event name="OnDragOver">
        <docstr>Occurs when a dragged object is over the area of the current control.
OnDragOver also occurs when DragOver is called.
Write an event handler for OnDragOver to specify what happens when a dragged object is over the area of the current control.
For most controls, HitTest is True by default. However, this is not true for TLabel, TPathLabel and, TMagnifierGlass where HitTest is False by default; these controls do not capture the OnDragOver event unless you set HitTest to True.
This event provides the following arguments to its event handler:

Sender is a pointer to the object that called this function.
Data is the dragged object.
Point is the current point of the mouse pointer within the client area of the control.
Operation is the operation parameter (None, Move, Copy, Link) that specifies the action to perform when an item is dragged over the object.
None is the default. No action takes place, it does not display any name.
Move - the word Move is displayed once an item is dragged over the object.
Copy - the word Copy is displayed once an item is dragged over the object.
Link - the word Link is displayed once an item is dragged over the object.</docstr>
      </event>
      <event name="OnDragDrop">
        <docstr>Occurs when a dragged control is dropped.
OnDragDrop also occurs when DragDrop is called.
Write an event handler for OnDragDrop to specify what happens when a dragged control is dropped.</docstr>
      </event>
      <event name="OnDragEnd">
        <docstr>Occurs when the dragging of a control ends.
A dragging session can be ended either by dropping the control or by canceling the dropping.
OnDragEnd also occurs when DragEnd is called.
Write an event handler for OnDragEnd to specify what happens when the dragging session ends.</docstr>
      </event>
      <event name="OnKeyDown">
        <docstr>Occurs when a key is pressed while the control has focus.
OnKeyDown is called from KeyDown methods of GUI components, for example, of controls and forms.
Write an event handler for OnKeyDown to specify what happens when a control or a form has the input focus and a key is pressed.</docstr>
      </event>
      <event name="OnKeyUp">
        <docstr>Occurs when a key is released while the control has focus.
OnKeyUp also occurs when KeyUp is called.
Write an event handler for OnKeyUp to specify what happens when the control is in focus and a key is released.</docstr>
      </event>
      <event name="OnClick">
        <docstr>Occurs when the control is clicked.
For controls (such as TLabel and TPathLabel) that have the HitTest property set to False by default, the OnClick and OnDblClick mouse events pass through to the control behind this control. 
Usually, the OnClick event happens when the left mouse button is pressed and released with the pointer over the control or when Click is called. 
For buttons controls, the OnClick event also happens when the control is in focus and the SPACEBAR or ENTER key is pressed. 
For controls with state, like TRadioButton and TCheckBox, OnClick does not change the state (the IsChecked property is not changed). OnClick cannot be associated to a form.</docstr>
      </event>
      <event name="OnDblClick">
        <docstr>Occurs when the left mouse button is double-clicked with the pointer over the control.
OnDblClick also occurs when DblClick is called.
For controls (such as TLabel and TPathLabel) that have the HitTest property set to False by default, the OnClick and OnDblClick mouse events pass through to the control behind this control.</docstr>
      </event>
      <event name="OnCanFocus">
        <docstr>Occurs when a control can receive focus. 
SetFocus is an event handler for OnCanFocus. 
Write an event handler for OnCanFocus to customize the behavior when the control receives focus.</docstr>
      </event>
      <event name="OnEnter">
        <docstr>Occurs when the control receive input focus.
OnEnter also occurs when DoEnter is called.
Write an event handler for OnEnter to specify what happens when the control receive input focus.</docstr>
      </event>
      <event name="OnExit">
        <docstr>Occurs when the input focus is taken from the control.
OnExit also occurs when DoExit is called.
Write an event handler for OnExit to specify what happens when the input focus is taken from the control.

Note:  For example in TEdit control, you may want to prevent the user from leaving the control until a certain value has been entered into it. This can be done with the code like this:
procedure TForm1.Edit1Exit(Sender: TObject);
begin
  if Edit1.Text &lt;&gt; &apos;Hello&apos; then
   Edit1.Abort;
end;
 
Notice that the code like Edit1.SetFocus; does not have the expected effect.</docstr>
      </event>
      <event name="OnMouseDown">
        <docstr>Occurs when a mouse button is pressed over a control. 
OnMouseDown also occurs when MouseDown is called.
Write an event handler for OnMouseDown to specify what happens when one of the mouse buttons is pressed over the control.</docstr>
      </event>
      <event name="OnMouseMove">
        <docstr>Occurs when the mouse cursor moves while over the control area. 
OnMouseMove also occurs when MouseMove is called.
Write an event handler for OnMouseMove to specify what happens when the mouse cursor is moved while over the control area.</docstr>
      </event>
      <event name="OnMouseUp">
        <docstr>Occurs when the mouse button that was pressed over the control is released. 
OnMouseUp also occurs when MouseUp is called.
Write an event handler for OnMouseUp to specify what happens when the button of the mouse that was pressed over the control is released.</docstr>
      </event>
      <event name="OnMouseWheel">
        <docstr>Occurs when the mouse wheel moves while the control has focus. 
OnMouseWheel also occurs when the MouseWheel is called.
Write an event handler for OnMouseWheel to specify what happens when the mouse wheel is moved while the control has focus.</docstr>
      </event>
      <event name="OnMouseEnter">
        <docstr>Occurs when the mouse cursor enters the area of the control. 
OnMouseEnter also occurs when DoMouseEnter is called.
Write an event handler for OnMouseEnter to specify what happens when the mouse cursor is moved inside the control area.</docstr>
      </event>
      <event name="OnMouseLeave">
        <docstr>Occurs when the mouse cursor leaves the control area. 
OnMouseLeave also occurs when DoMouseLeave is called.
Write an event handler for OnMouseLeave to specify what happens when the mouse cursor is moved outside the control area.</docstr>
      </event>
      <event name="OnPainting">
        <docstr>Occurs when the control is painted. 
OnPainting also occurs when Painting is called.
Write an event handler for OnPainting to change the way the control is painted.</docstr>
      </event>
      <event name="OnPaint">
        <docstr>Occurs when the control is redrawn. 
OnPaint also occurs when DoPaint is called.
Write an event handler for OnPaint to change the way the control renders itself.

Tip:  Notice that calling BeginScene in the OnPaint event handlers has no effect, because BeginScene is called before the OnPaint event handler runs. This guarantees that painting always occurs in OnPaint without requiring extra and probably unexpected code to allow drawing to have an effect.</docstr>
      </event>
      <event name="OnResize">
        <docstr>Occurs immediately after the control is resized. 
OnResize also occurs when Resize is called.
Write an event handler for OnResize to make any final adjustments after a control is resized.

Note:  This function is deprecated, instead use the OnResized function.</docstr>
      </event>
      <event name="OnResized">
        <docstr>Occurs immediately after the control is resized.  
This event is invoked when the control is resized, and all the controls children are aligned.</docstr>
      </event>
      <event name="OnActivate">
        <docstr>Occurs when the window where this control gains the focus, and the control of the window that has the focus is either this control itself or a descendant of this control. A descendant may be a child, a grand-child, and so on.</docstr>
      </event>
      <event name="OnDeactivate">
        <docstr>Occurs when the window where this control is loses the focus while this control or a descendant of this control has the focus. A descendant may be a child, a grand-child, and so on.</docstr>
      </event>
      <event name="OnApplyStyleLookup">
        <docstr>Occurs when a style is applied to the control.
Write an OnApplyStyleLookup event handler to customize the process of applying a style. 
ApplyStyleLookup is an event handler for OnApplyStyleLookup. Override it to customize the process of applying a style.
OnApplyStyleLookup is used for styled controls.</docstr>
      </event>
      <property name="TouchTargetExpansion">
        <docstr>Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:</docstr>
      </property>
      <property name="TabStop">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="DisableDisappear">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ShowHint">
        <docstr>Specifies whether the Hint can be shown. 
If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control.</docstr>
      </property>
      <property name="Hint">
        <docstr>Specifies the text string that appears when the user moves the mouse over a control. 
See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints.</docstr>
      </property>
      <property name="Touch">
        <docstr>Specifies the touch manager component associated with the control.
Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
Touch is used to: 

Associate a TGestureManager.
(TGestureManager manages all the standard gestures that can be used by the control.)
Select the standard, interactive, or custom gestures to associate with the control.
(You can also connect each gesture to an action; see Assigning Actions to Gestures.)</docstr>
      </property>
      <event name="OnGesture">
        <docstr>Occurs when you perform a gesture associated with this control.
Write an event handler for OnGesture to perform custom processing for gesture events. OnGesture is fired on controls that subscribed for specific gestures using the TTouchManager class. If your code did process the gesture event, do not forget to set the Handled parameter to True so that the event is not propagated further.
If no event handler is associated with the control, the default DoGesture method is executed performing its own processing for the event. 
OnGesture is an event handler of type FMX.Types.TGestureEvent.</docstr>
      </event>
      <event name="OnTap">
        <docstr>Occurs when a user taps the control using a finger or a similar device (not a mouse).
Write an event handler for OnTap to specify what happens when the user taps the form.
Events occur in the following order:

OnTap
OnSelectCell
OnSelChanged</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Controls" name="TStyledControl">
    <docstr>TStyledControl is the base class for customizable and user-interaction controls.
TStyledControl extends TControl to act as the immediate superclass for concrete user-facing widgets.
For descendants of TStyledControl, you can set the style resource and the basis for FireMonkey&apos;s dynamic look-and-feel. Subclasses of TStyledControl search their style resource among those assigned to the StyleBook property of the form, using a simple search routine based on class names returned by the GetStyleObject method. The access to the subcomponents defined by the same style permits the parent control to be modified at run time. To apply a style to a control, set the StyleLookup property to the name of the style.
For more details about the style and design of FireMonkey components, see FireMonkey Component Rendering and Customizing with Styles.
Descendants of TStyledControl are controls like TPanel, TLabel, TCheckBox, TImageControl, or TCalendar.</docstr>
    <members>
      <function name="SearchInto">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetBackIndex">
        <docstr>Gets the index of TStyledControl. It always returns 1. It is for internal use only.</docstr>
      </function>
      <function name="IsHelpContextStored">
        <docstr>Specifies whether HelpContext is stored. It is for internal use only.</docstr>
      </function>
      <procedure name="SetHelpContext">
        <docstr>Setter method for the HelpContext property. It is for internal use only.</docstr>
      </procedure>
      <procedure name="SetHelpKeyword">
        <docstr>Setter method for the HelpKeyword property. It is for internal use only.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Controls.TStyledControl.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <function name="DoSetSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="DoApplyStyleLookup">
        <docstr>Executed internally each time ApplyStyleLookup is called for this TStyledControl object.
DoApplyStyleLookup activates the OnApplyStyleLookup event handler.</docstr>
      </procedure>
      <procedure name="StyleDataChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="RequestStyleData">
        <docstr>Requests the value of the StylesData property of the style object.</docstr>
      </function>
      <procedure name="Painting">
        <docstr>OnPainting event dispatcher. 
FMX.Controls.TStyledControl.Painting inherits from FMX.Controls.TControl.Painting. All content below this line refers to FMX.Controls.TControl.Painting.
OnPainting event dispatcher. 
Painting defines the drawing area of the control by intersecting Canvas with ClipRect if ClipChildren is True and dispatches the OnPainting event.
It is always called internally before DoPaint. 
The Painting method can be overridden by derived controls to establish control-specific rendering conditions.</docstr>
      </procedure>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <function name="GetStyleContext">
        <docstr>Returns context for behavior manager.</docstr>
      </function>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <function name="GetParentClassStyleLookupName">
        <docstr>Getter for the ParentClassStyleLookupName property.</docstr>
      </function>
      <procedure name="DoEnter">
        <docstr>Responds when receiving input focus.
DoEnter is called automatically when the control receives the input focus.</docstr>
      </procedure>
      <procedure name="Disappear">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AdjustSize">
        <docstr>Sets the size of the control.
AdjustSize sets the size values that AdjustSizeValue specifies.</docstr>
      </procedure>
      <procedure name="AdjustFixedSize">
        <docstr>Sets the fixed size of the control.
AdjustFixedSize sets the fixed size according to ChooseAdjustType.</docstr>
      </procedure>
      <function name="ChooseAdjustType">
        <docstr>Returns an adjust type based on the provided FixedSize.
FixedSize is the value of the FixedSize property of the control that is passed to AdjustFixedSize.</docstr>
      </function>
      <procedure name="DoStyleChanged">
        <docstr>Indicates that the control needs to update the style and calls Repaint.
FMX calls DoStyleChanged after the style was changed.</docstr>
      </procedure>
      <procedure name="StyleLookupChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RecycleResourceLink">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="KillResourceLink">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoDeleteChildren">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GenerateStyleName">
        <docstr>Generates a style lookup name based on the provided AClassName.
The generated style name is composed of the class name without the leading T, followed by the string &quot;style&quot;. For example, if you provide TEdit as AClassName, GenerateStyleName returns the string Editstyle.</docstr>
      </function>
      <function name="GetStyleObject">
        <docstr>Gets the style resource object linked to TStyledControl.
GetStyleObject is called when the style is applied. Apply a style by calling the ApplyStyleLookup method.
If no style is defined for the current control, it receives the style of the current scene. If the current scene does not have a resource object, GetStyleObject continues to look through the default styles and Parent&apos;s style.
Do not call GetStyleObject in an application.</docstr>
      </function>
      <function name="GetStyleObject">
        <docstr>Gets the style resource object linked to TStyledControl.
GetStyleObject is called when the style is applied. Apply a style by calling the ApplyStyleLookup method.
If no style is defined for the current control, it receives the style of the current scene. If the current scene does not have a resource object, GetStyleObject continues to look through the default styles and Parent&apos;s style.
Do not call GetStyleObject in an application.</docstr>
      </function>
      <procedure name="SetAdjustSizeValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetAdjustType">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetResourceLink">
        <docstr>Returns the style resource for this control as TFmxObject.</docstr>
      </function>
      <function name="GetResourceControl">
        <docstr>Returns the style resource for this control as TControl.</docstr>
      </function>
      <property name="IsNeedStyleLookup">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ResourceLink">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ResourceControl">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <function name="GetAdjustSizeValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetAdjustType">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
FMX.Controls.TStyledControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <procedure name="BeforeDestruction">
        <docstr>Performs any necessary actions before the first destructor is called.
FMX.Controls.TStyledControl.BeforeDestruction inherits from System.Classes.TComponent.BeforeDestruction. All content below this line refers to System.Classes.TComponent.BeforeDestruction.
Performs any necessary actions before the first destructor is called.
BeforeDestruction is called automatically immediately before the component&apos;s first destructor executes. Do not call it explicitly in your applications.
As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place.</docstr>
      </procedure>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
FMX.Controls.TStyledControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="AdjustType">
        <docstr>Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control.
Use one of the values of TAdjustType.</docstr>
      </property>
      <property name="AdjustSizeValue">
        <docstr>Updates the width and height of this control according to its current style.</docstr>
      </property>
      <property name="StyleState">
        <docstr>This property allows you to define the current state of style. It changes when calls virtual methods: FMX.Controls.TStyledControl.FreeStyle, FMX.Controls.TStyledControl.ApplyStyle, and FMX.Controls.TStyledControl.DoApplyStyleLookup.</docstr>
      </property>
      <procedure name="RecalcSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="FindStyleResource">
        <docstr>Finds the linked resource object for the style specified by name.
The AStyleLookup parameter specifies the name of the style.
If AStyleLookup is empty, FindStyleResource returns nil. If no resource object is linked directly to the control, FindStyleResource looks to the styles of the control&apos;s children. If no resource object is found, it returns nil.
Clone determines whether the returned style resource object should be the original style object (False) or a copy of the original (True).</docstr>
      </function>
      <function name="FindStyleResource">
        <docstr>Finds the linked resource object for the style specified by name.
The AStyleLookup parameter specifies the name of the style.
If AStyleLookup is empty, FindStyleResource returns nil. If no resource object is linked directly to the control, FindStyleResource looks to the styles of the control&apos;s children. If no resource object is found, it returns nil.
Clone determines whether the returned style resource object should be the original style object (False) or a copy of the original (True).</docstr>
      </function>
      <function name="FindAndCloneStyleResource">
        <docstr>Finds the specified resource object and makes a copy.
AStyleLookup specifies the name of the resource object to search for. A clone of the original resource is set on AResource.
FindAndCloneStyleResource returns true if the corresponding resource object is found and it is of type T. Otherwise it returns nil.</docstr>
      </function>
      <procedure name="SetNewScene">
        <docstr>Sets a new Scene for the current control.
FMX.Controls.TStyledControl.SetNewScene inherits from FMX.Controls.TControl.SetNewScene. All content below this line refers to FMX.Controls.TControl.SetNewScene.
Sets a new Scene for the current control.
AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
SetNewScene sets the same scene for the control&apos;s children.</docstr>
      </procedure>
      <procedure name="ApplyStyleLookup">
        <docstr>Gets and applies the style of a TStyledControl.
ApplyStyleLookup gets the style by calling the GetStyleObject method and applies it through the ApplyStyle method.</docstr>
      </procedure>
      <procedure name="NeedStyleLookup">
        <docstr>Call this procedure to indicate that this control requires to get and apply its style lookup.
This forces the next call to ApplyStyleLookup to get and apply its style lookup.</docstr>
      </procedure>
      <procedure name="Inflate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="PrepareForPaint">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="StartTriggerAnimation">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="StartTriggerAnimationWait">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="AutoTranslate">
        <docstr>Specifies whether the control&apos;s text should be translated. 
Set AutoTranslate to True to permit the control text (if it exists) to be translated, when the control is used in an application available in several languages. Set it to False to keep the text unchanged.</docstr>
      </property>
      <property name="DefaultStyleLookupName">
        <docstr>Returns a string with the name of the default style of this control.
The name of the default style is composed of the class name without the leading T, followed by the string style, for instance panelstyle.</docstr>
      </property>
      <property name="ParentClassStyleLookupName">
        <docstr>The name of the default style of the parent class of this control.
The name of the style is composed of the class name without the leading T, followed by the string &quot;style&quot;. For example, if the class name is TEdit, the style name is Editstyle.</docstr>
      </property>
      <property name="HelpType">
        <docstr>Specifies whether the control&apos;s context-sensitive Help topic is identified by a context ID or by keyword.
If HelpType is htContext, the HelpContext property value identifies the control&apos;s Help topic. 
If HelpType is htKeyword, the HelpKeyword property value identifies the control&apos;s Help topic.</docstr>
      </property>
      <property name="HelpKeyword">
        <docstr>Contains the keyword string that identifies the Help topic for the control.
To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
No keyword (zero-length string, the default) means that no Help topic is provided for the control.</docstr>
      </property>
      <property name="HelpContext">
        <docstr>Contains the numeric context ID that identifies the Help topic for the control.
In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
A topic ID of 0 (default) means that no Help topic is provided for the control.</docstr>
      </property>
      <property name="StyleLookup">
        <docstr>Specifies the name of the resource object to which the current TStyledControl is linked.
StyleLookup becomes especially useful with the introduction of Metropolis UI styles. Metropolis UI styles contain lots of styles for buttons, panes, lists, and other control elements. Each control has the default style, but you can change this default style to any style accessible for the class of a control. The StyleLookup property can be used to specify such additional style. In the Object Inspector, you can select in the StyleLookup property the name of an additional style for the control -- like searchbuttontext -- from the general style loaded into the TStyleBook or from the default style for the used platform. See StyleLookup Support for Metropolis UI Controls.


Note:  At design time, using the StyleLookup property of a control in any form in the current project group you can access any custom style defined in any TStyleBook component used in the current project group. That is, even if the form does not have a particular TStyleBook component, controls from this form can use custom  styles defined in this TStyleBook component (if this TStyleBook component is used in any form in the current project group). At run time, only styles in the current project and only after an owner of the TStyleBook containing these styles is already created can be accessed.</docstr>
      </property>
      <property name="LoadableStyle">
        <docstr>LoadableStyle is used to retrieve the style object.</docstr>
      </property>
      <function name="LookupStyleObject">
        <docstr>Looks for the style resource object linked to the TStyledControl.
If no style is defined for the current control, LookupStyleObject seeks in the current scene for the active style.
If the current scene does not have a resource object, LookupStyleObject continues the search through the default styles and Parent&apos;s style.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.Controls" name="TStyleChangedMessage">
    <docstr></docstr>
    <members>
      <property name="Scene">
        <docstr>Scene where the style has been changed, nil if the change is global</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Controls" name="TStyleCollectionItem">
    <docstr></docstr>
    <members>
      <procedure name="LoadFromBinary">
        <docstr>Reload style from binary stream</docstr>
      </procedure>
      <procedure name="SaveToBinary">
        <docstr>Save style to binary stream</docstr>
      </procedure>
      <procedure name="Clear">
        <docstr>Clear style and binary stream</docstr>
      </procedure>
      <property name="IsEmpty">
        <docstr>Return true is style is empty</docstr>
      </property>
      <procedure name="LoadFromStream">
        <docstr>Load style from stream</docstr>
      </procedure>
      <procedure name="LoadFromFile">
        <docstr>Load style from file</docstr>
      </procedure>
      <procedure name="SaveToStream">
        <docstr>Save style to stream</docstr>
      </procedure>
      <property name="StyleBook">
        <docstr>Link to owner StyleBook</docstr>
      </property>
      <property name="Style">
        <docstr>Style that stored on this item</docstr>
      </property>
      <property name="UnsupportedPlatform">
        <docstr>If style can not be load on current platform tihs property is True and Style is empty</docstr>
      </property>
      <property name="Platform">
        <docstr>Name used to idenity style in collection</docstr>
      </property>
      <property name="Resource">
        <docstr>Design-time only property used to show Style Designer</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Controls" name="TStyleCollection">
    <docstr></docstr>
    <members>
      <function name="Add">
        <docstr>Create and add new item</docstr>
      </function>
      <property name="Items[Index]">
        <docstr>Access property for style collection items</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Controls" name="TStyleBook">
    <docstr>TStyleBook stores a collection of styles for a form.
There are two ways to create and use a TStyleBook component:

Drop a TStyleBook component from the Tool Palette onto the Form Designer and make your new TStyleBook component the value of the StyleBook property of the form. This works for desktop applications and mobile applications.
Right-click a control on a FireMonkey desktop form and choose either Edit Default Style or Edit Custom Style. This automatically creates a TStyleBook component, sets it to the form&apos;s StyleBook, and opens the Style Designer.
TStyleBook stores the style definition as text in the Resource property and can be loaded from a .style file.
Double-clicking the TStyleBook component on the form opens the Style Designer.

TStyleBook and Form Inheritance
If you want all the descendant forms to have the same style as the base form, place the TStyleBook in the base form.
If you want the descendant forms to have different styles, place separate TStyleBooks in the descendant forms.
Note: At design time, using the StyleLookup property of a control in any form in the current project group you can access any custom style defined in any TStyleBook component used in the current project group. That is, even if the form does not have a particular TStyleBook component, controls from this form can use custom  styles defined in this TStyleBook component (if this TStyleBook component is used in any form in the current project group). At run time, only styles in the current project and only after an owner of the TStyleBook containing these styles is already created can be accessed.</docstr>
    <members>
      <function name="GetStyle">
        <docstr>Gets the style of the  CurrentItem stored in  TStyleCollectionItem. Getter of  Style. 
 TStyleCollectionItem stores one style for the specified platform. GetStyle  gets the style item.
The style is a  TFmxObject type.</docstr>
      </function>
      <function name="CustomFindStyleResource">
        <docstr>Use it to look for a style in a global pool.</docstr>
      </function>
      <procedure name="ChooseStyleIndex">
        <docstr>It chooses style depending on context.</docstr>
      </procedure>
      <procedure name="CreateDefaultItem">
        <docstr>Creates an empty item on demand.
 CreateDefaultItem calls  Add to create a  TStyleCollectionItem and add it to the  TStyleCollection. The new style collection item is placed at the end of the  Items array.
Add returns the new style collection item. 
Add inherits from System.Classes.TCollection.Add.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Loads the style. Loaded is called automatically to load the style definition from the file that is set using the FileName property.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Provides an interface for a method that reads and writes otherwise unpublished data. DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="ReadResources">
        <docstr>Reads the resources from the given stream. ReadResources is called automatically to read resources from the given stream into the TStyleBook object.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates and initializes a TStyleBook instance. Create constructs a TStyleBook object and initializes its data before the object is first used.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TStyleBook and frees the associated memory.
Do not call Destroy directly. Call Free instead. Free verifies that the object reference is not nil before calling Destroy.</docstr>
      </destructor>
      <property name="DesignInfo">
        <docstr>DesignInfo is a  TStyleBookDesignInfo record that contains design-time information only used by the Form designer.

 ClassName: Class name of the selected control.
 CustomStyle: True when edit custom style mode is active.
 DefaultStyleLookup: The default StyleLookup for the selected control.
 Name: Name of the selected control.
 StyleLookup: Name of the StyleLookup for the selected control.
 Control: The selected control itself.</docstr>
      </property>
      <procedure name="Clear">
        <docstr>Clears the style collection of a  TStyleBook.
 TStyleCollection is a collection that stores the styles for the different platforms.
 Clear deletes all items from the collection.</docstr>
      </procedure>
      <function name="GetStyle">
        <docstr>Gets the style of the  CurrentItem stored in  TStyleCollectionItem. Getter of  Style. 
 TStyleCollectionItem stores one style for the specified platform. GetStyle  gets the style item.
The style is a  TFmxObject type.</docstr>
      </function>
      <procedure name="LoadFromStream">
        <docstr>Method to load a style to the  TStyleBook, from a stream.
To load the style from a file use  LoadFromFile.

procedure TForm1.FormCreate(Sender: TObject);
var
  S: TFileStream; 
begin
  S :=  TFileStream.Create(&apos;Air.Style&apos;, fmOpenRead);
  Stylebook1.LoadFromStream(S);
end;

procedure TForm2.FormCreate(Sender: TObject);
var
  iStream: TMemoryStream;
begin
  StyleBook1.LoadFromFile(&apos;Air.Style&apos;); //Loads the style from a file.
  iStream := TMemoryStream.Create; //Instanziate the memory stream var.
  TStyleStreaming.SaveToStream(StyleBook1.Style, iStream); //saves the style as a memory stream.
  StyleBook1.Clear; //Clear the styles from the stylebook.
  iStream.Position := 0; //Sets the position to start the streaming.
  StyleBook1.LoadFromStream(iStream); //Loads the style to the stylebook from the memory stream.
end;</docstr>
      </procedure>
      <procedure name="LoadFromFile">
        <docstr>Method to load a style to a  TStyleBook, from a file.
Select the full path to the file or the file name when located in the project folder.
FireMonkey styles are delivered in the RAD Studio product installation, at the following paths:

C:\Program Files (x86)\Embarcadero\Studio\21.0\Redist\styles\Fmx
C:\Users\Public\Documents\Embarcadero\Studio\21.0\Styles
Apply the style to the form using the  StyleBook  property of the form, for example:

procedure TForm1.FormCreate(Sender: TObject);
begin
  StyleBook1.LoadFromFile(&apos;Air.Style&apos;);
  Form1.StyleBook := StyleBook1;
end;

To load a style to an  item of the  TStyleCollection, that is a style for each platform added to the  TStyleBook, then use FMX.Controls.TStyleCollectionItem.LoadFromFile.</docstr>
      </procedure>
      <property name="Style">
        <docstr>Represents the current style as a TFmxObject.</docstr>
      </property>
      <property name="CurrentItemIndex">
        <docstr>Index of the current style in the style collection.
 CurrentItemIndex is the index of the current  StyleCollectionItem from the  StyleCollection array.
 CurrentItemIndex is an integer value.</docstr>
      </property>
      <property name="CurrentItem">
        <docstr>Current style in the style collection.
 CurrentItem is the current  StyleCollectionItem from the  StyleCollection.</docstr>
      </property>
      <property name="Resource">
        <docstr>The style definition. Resource is a string list containing the style defined by the TStyleBook.</docstr>
      </property>
      <property name="UnsupportedPlatform">
        <docstr>Indicates whether the style can be loaded in the current target platform. 
If the style cannot be loaded, UnsupportedPlatform is True and Style is empty.</docstr>
      </property>
      <property name="FileName">
        <docstr>The name of the file that contains the style definition.
Use FileName to specify the .style file from which the TStyleBook loads its Resource.
Setting the FileName also loads and applies the style.</docstr>
      </property>
      <property name="UseStyleManager">
        <docstr>Specifies whether the TStyleManager replaces the default style for the whole application.</docstr>
      </property>
      <property name="Styles">
        <docstr>Contains the  collection of  styles stored in the  TStyleBook.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Controls" name="TTextControl">
    <docstr>Base class for all text controls such as TDateEdit.
TTextControl is the base class for all graphical controls that display text, such as TTimeEdit, TListBoxItem, TTabItem, and so on.
TTextControl encapsulates standard functionality to manipulate the displayed text, offering the possibility of changing the font, the alignment of the text, or enabling word wrapping.
If you need to create a new control from scratch that displays text (for instance, an enhanced label graphical control or a custom redesigned check box control), then you should derive your component from TTextControl.
TTextControl implements the ITextSettings interface. This interface provides methods and properties to manage the most common text representation properties of general text objects independently of the particular types of these objects. TTextControl and its descendants contain the public property TextSettings of the TTextSettings type. Using the methods and the properties declared in the ITextSettings interface, you can manage the text representation TFont.Family, TFont.Size, TFont.Style, FontColor, HorzAlign, VertAlign, Trimming, and WordWrap properties defining visual parameters of the text representation. For more information, see Setting Text Parameters in FireMonkey.
TTextControl uses the TTextSettingsInfo service class to manage sets of styled text representation properties stored in the DefaultTextSettings, TextSettings, StyledSettings, and ResultingTextSettings properties.
TTextControl implements the IAcceleratorKeyReceiver interface to allow the use of this control as an accelerator key receiver.</docstr>
    <members>
      <procedure name="DoRootChanging">
        <docstr>DoRootChanging is executed when the root container (typically a form) is defined or changes.
For example, DoRootChanging is executed when this control is added to a form or moved from one form to another. 
When this control works as an accelerator key receiver, DoRootChanging overrides TControl.DoRootChanging to:

Register this control to a specific form when the text control is added to the form.
Unregister and register this control from one form to another when this control is moved between forms.</docstr>
      </procedure>
      <function name="DoFilterControlText">
        <docstr>Filters the string contained in the Text property.
For example, you can use DoFilterControlText to filter the ampersand symbol of the accelerator key character.
If the control is registered as an accelerator key receiver, you can override this method to do your own filtering to the accelerator keys.</docstr>
      </function>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Controls.TTextControl.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.Controls.TTextControl.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FreeStyle frees some TTextControl-specific style resources like TextObject and TextSettings, then calls the inherited TStyledControl.FreeStyle.</docstr>
      </procedure>
      <procedure name="DoStyleChanged">
        <docstr>Calls the inherited TStyledControl.DoStyleChanged, then tries to translate the Text.
DoStyleChanged calls the inherited TStyledControl.DoStyleChanged to set that the control needs to update the style, then calls Repaint to redraw the control, and then tries to translate the control&apos;s Text calling Translate.</docstr>
      </procedure>
      <procedure name="SetText">
        <docstr>Protected setter implementation for the Text property.
In descendants, override SetText to allow for further functionality when setting the text using the Text property.
Do not use SetText directly in applications. Use the Text property instead.</docstr>
      </procedure>
      <procedure name="SetTextInternal">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetName">
        <docstr>Sets the value of the Name property.
FMX.Controls.TTextControl.SetName inherits from System.Classes.TComponent.SetName. All content below this line refers to System.Classes.TComponent.SetName.
Sets the value of the Name property.
SetName is the virtual property setter for the Name property. It calls the ChangeName method, which performs the actual name change.
ChangeName is not virtual; override SetName instead when modifying the behavior of the Name property.

Warning: Using SetName to change the name of a component at run time causes any references to the old name to become undefined. Any subsequent code that uses the old name will cause an exception.</docstr>
      </procedure>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.Controls.TTextControl.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
FMX.Controls.TTextControl.SetData inherits from FMX.Types.TFmxObject.SetData. All content below this line refers to FMX.Types.TFmxObject.SetData.
Protected setter implementation for the Data property.</docstr>
      </procedure>
      <procedure name="ActionChange">
        <docstr>Specifies the behavior of a TTextControl control when Action changes. 
Depending on the CheckDefaults value,  ActionChange uses the TCustomAction.Text property of the Sender action to set the new value to the  
Text property of TTextControl. Then ActionChange calls the inherited TControl.ActionChange method.  
Do not call ActionChange explicitly in an application. It is for internal use.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.Controls.TTextControl.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <function name="FindTextObject">
        <docstr>Retrieves the resource object linked to the style of the current TTextControl object.
In the current implementation, FindTextObject retrieves the resource object linked to the &apos;text&apos; style.</docstr>
      </function>
      <procedure name="UpdateTextObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="TextObject">
        <docstr>Keeps the resource object linked to the style of the current TTextControl object.
In the current implementation, TextObject keeps the resource object linked to the &apos;text&apos; style.</docstr>
      </property>
      <procedure name="DoTextChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoEndUpdate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="CalcTextObjectSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetTextSettings">
        <docstr>Copies the values of the styled text representation properties of the specified Value object to the current TTextControl object.
SetTextSettings calls 

TTextSettings.Assign(Value);</docstr>
      </procedure>
      <procedure name="SetStyledSettings">
        <docstr>Setter for the StyledSettings property.</docstr>
      </procedure>
      <procedure name="DoChanged">
        <docstr>Updates the representation of the text on the control.
DoChanged is called internally from the Change methods.
Do not call DoChanged explicitly; call the Change  method.</docstr>
      </procedure>
      <function name="StyledSettingsStored">
        <docstr>Retrieves whether any of the default values of font properties that are stored in the StyledSettings property is changed.
StyledSettingsStored retrieves whether StyledSettings needs to be stored in the .fmx form file, keeping the description of the FMX form.
StyledSettingsStored returns True if StyledSettings &lt;&gt; DefaultStyledSettings. The DefaultStyledSettings property is set during the style loading in the ApplyStyle method. See also AllStyledSettings.</docstr>
      </function>
      <function name="GetTextSettingsClass">
        <docstr>Returns the class type that instance represents the used text settings.
GetTextSettingsClass returns the TTextSettingsInfo.TCustomTextSettingsClass (or its descendant)  class reference. An instance of such class provides the DefaultTextSettings,   TextSettings, StyledSettings, ResultingTextSettings, and other properties handling the text representation settings of a control. 
You can override the method in descendant classes to modify the default behavior.
Typical implementations of GetTextSettingsClass returns the class declaring properties like the Font, FontColor, HorzAlign, and WordWrap. Some of these properties can be declared as published to be editable in the Object Inspector.</docstr>
      </function>
      <procedure name="TriggerAcceleratorKey">
        <docstr>Allows the object to perform an action when the accelerator key is pressed.
FMX.Controls.TTextControl.TriggerAcceleratorKey inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey.
Allows the object to perform an action when the accelerator key is pressed.
Use TriggerAcceleratorKey to trigger an action as a response to the accelerator key. For example, use TriggerAcceleratorKey to set focus to the acceleration key receiver control.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.CanTriggerAcceleratorKey</docstr>
      </procedure>
      <function name="CanTriggerAcceleratorKey">
        <docstr>Determines whether the object reacts to the accelerator key or not.
FMX.Controls.TTextControl.CanTriggerAcceleratorKey inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.CanTriggerAcceleratorKey. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.CanTriggerAcceleratorKey.
Determines whether the object reacts to the accelerator key or not.
Use CanTriggerAcceleratorKey for objects that are not intended to react to the accelerator key, for example: a hidden tab page or a hidden submenu. The object triggers the action if CanTriggerAcceleratorKey is True. Otherwise, the object cannot trigger the action.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey</docstr>
      </function>
      <function name="GetAcceleratorChar">
        <docstr>Returns the character key that serves as the  keyboard accelerator for the receiver object.
FMX.Controls.TTextControl.GetAcceleratorChar inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.GetAcceleratorChar. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.GetAcceleratorChar.
Returns the character key that serves as the  keyboard accelerator for the receiver object.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.GetAcceleratorCharIndex</docstr>
      </function>
      <function name="GetAcceleratorCharIndex">
        <docstr>Returns the index of the accelerator character within the text string of the receiver object.
FMX.Controls.TTextControl.GetAcceleratorCharIndex inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.GetAcceleratorCharIndex. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.GetAcceleratorCharIndex.
Returns the index of the accelerator character within the text string of the receiver object.
Use GetAcceleratorCharIndex to highlight the accelerator character when the text string contains several times the same character.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.GetAcceleratorChar</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Controls.TTextControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Controls.TTextControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="AfterConstruction">
        <docstr>Responds after the last constructor has executed.
FMX.Controls.TTextControl.AfterConstruction inherits from System.TObject.AfterConstruction. All content below this line refers to System.TObject.AfterConstruction.
Responds after the last constructor has executed.
AfterConstruction is called automatically after the object&apos;s last constructor has executed. Do not call it explicitly in your applications. 
The AfterConstruction method implemented in TObject does nothing. Override this method when creating a class that performs an action after the object is created. For example, TCustomForm overrides AfterConstruction to generate an OnCreate event.</docstr>
      </procedure>
      <function name="ToString">
        <docstr>Returns a string containing the class name followed by the text that is rendered over the surface of this TTextControl object.
ToString returns a string containing the concatenation of two substrings:

The first substring contains the class name of the instance that is being called (retrieved by TObject.ToString). For example, calling  on a TCheckBox instance returns a substring containing TCheckBox.
The second substring contains the text from the Text property. This is the text that will be rendered over the surface of the object in which ToString is called.</docstr>
      </function>
      <property name="Text">
        <docstr>Specifies the text that will be rendered over the surface of this TTextControl object.
Set the Text property to specify the text that will be displayed by this TTextControl. Text can be any string.
If there are any effects already applied before changing the Text property, they will be preserved for the new text. Also, the surface of this TTextControl is repainted.
In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an &lt;accelerator_letter&gt; with an ampersand &amp; character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &amp;Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+&lt;accelerator_letter&gt; key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand &amp; character in a Text property specify doubled ampersand &amp;&amp; characters.

Tip:  If you specify a new text string that is exactly the same as the one already displayed, the effects will not be re-updated and this TTextControl object will not be repainted.
Note: FMX.ExtCtrls.TPopupBox.Text is not a writable property in the same way as FMX.Controls.TTextControl.Text. The FMX.ExtCtrls.TPopupBox.Text property cannot be &quot;any string&quot;, but instead must be just one of the strings in the FMX.ExtCtrls.TPopupBox.Items property and, in this case, FMX.ExtCtrls.TPopupBox.ItemIndex is updated accordingly.</docstr>
      </property>
      <property name="DefaultTextSettings">
        <docstr>Stores a TTextSettings type object keeping the default values of the text representation properties.
DefaultTextSettings is set during the loading of the style in the ApplyStyle method. 
DefaultTextSettings is initialized in Create with the following values: 

Font.Size := 11 ;          // depends on the platform     
Font.Family = &apos;Tahoma&apos;;    // depends on the platform
Font.Style := [] ;
FontColor := TAlphaColorRec.Black;
TextAlign := TTextAlign.Leading;
VertTextAlign := TTextAlign.Center;
Trimming := TTextTrimming.None;
WordWrap := False;</docstr>
      </property>
      <property name="TextSettings">
        <docstr>Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
TTextSettings type objects provide all styled text representation properties and methods to manage them.
The styled text representation properties are 
FontColor, TextAlign,
VertTextAlign,
Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
VertTextAlign properties of the control.</docstr>
      </property>
      <property name="StyledSettings">
        <docstr>Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
Text representation properties are used as parameters for drawing texts in controls.
The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
StyledSettings can contain the Family, Size, Style, FontColor, and 
Other values defined in TStyledSetting. The &quot;Relation between TStyledSetting constants and TTextSettings properties&quot; table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):

With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
VertTextAlign properties of the control.</docstr>
      </property>
      <property name="ResultingTextSettings">
        <docstr>Keeps final values of text representation properties. These values are really used to draw texts in a control. 
ResultingTextSettings keeps a TTextSettings object that manages the final values of the text representation properties. These values are really used to draw texts in a control. 
To obtain values stored in ResultingTextSettings, a control uses the StyledSettings property. For example, if StyledSettings contains the TStyledSetting.Family value, then the TFont.Family value is taken from the DefaultTextSettings. (That is the font family name defined in the loaded style is used. The font family name defined by the programmer in the Object Editor is ignored.) Oppositely, if StyledSettings does not contain TStyledSetting.Family, then the font family name defined by the programmer in the Object Editor is used and the font family name defined in the loaded style is ignored.
The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
RecalculateTextSettings updates the ResultingTextSettings.</docstr>
      </property>
      <procedure name="Change">
        <docstr>Calls DoChanged when any of the styled text representation properties of the current TTextControl control is changed.
Change is called when any of the Font, FontColor, VertTextAlign, Trimming or WordWrap properties is changed. 
If the control is not in a loading or destroying state (csLoading or csDestroying), Change calls DoChanged to update the representation of the text on the control.</docstr>
      </procedure>
      <property name="Font">
        <docstr>Specifies the font to use when rendering the text.
Set Font to specify the font to use when rendering the text. To change to a new font, specify a new TFont object. To modify a font, change the value of the Family, Size, or Style of the TFont object.</docstr>
      </property>
      <property name="FontColor">
        <docstr>Specifies the font color of the text in this TTextControl control.
Use the FontColor property to read or change the font color of the text in this TTextControl control. The default value of the FontColor property is TAlphaColorRec.Black.</docstr>
      </property>
      <property name="VertTextAlign">
        <docstr>Specifies how the text will be displayed in terms of vertical alignment.
The VertTextAlign property specifies how the TTextControl control displays the text in terms of vertical alignment. VertTextAlign can have one of the following values (defined in TTextAlign):

Center (default)--aligns the text on a vertical axis, at the middle of the TTextControl object.
Leading--aligns the text on a vertical axis, at the topmost position inside the TTextControl object.
Trailing--aligns the text on a vertical axis, at the bottommost position inside the TTextControl object.
When you use text representation properties stored in ITextSettings.TextSettings, remember that VertTextAlign corresponds to VertAlign.</docstr>
      </property>
      <property name="TextAlign">
        <docstr>Specifies how the text will be displayed in terms of horizontal alignment.
The TextAlign property specifies how the TTextControl object will display the text in terms of horizontal alignment. TextAlign can have one of the following values (defined in TTextAlign):

Center (default)--aligns the text on a horizontal axis, at the middle of the TTextControl object.
Leading--aligns the text on a horizontal axis, at the leftmost position inside the TTextControl object.
Trailing--aligns the text on a horizontal axis, at the rightmost position inside the TTextControl object.
When you use text representation properties stored in ITextSettings.TextSettings, remember that TextAlign corresponds to HorzAlign.</docstr>
      </property>
      <property name="WordWrap">
        <docstr>Specifies whether the text inside the TTextControl object wraps when it is longer than the width of the control.
Set WordWrap to True to allow the TTextControl control to display multiple lines of text. When WordWrap is True, text that is too long for the TTextControl object wraps at the right margin and continues in additional lines.
Set WordWrap to False for the text to span onto a single line of the TTextControl. However, in this case, the text that is too long for TTextControl appears truncated.
The default value for the WordWrap property is False.</docstr>
      </property>
      <property name="Trimming">
        <docstr>Specifies the behavior of the text, when it overflows the area for drawing the text.
Trimming may take the following values defined in the TTextTrimming type: None, Character, and Word.
If the value of this property is not None and the text does not fit in the drawing area, then it is trimmed to fit the area and an ellipsis sign is printed after the trimmed text.

Note: Under the iOS platform, Trimming works only when WordWrap = False.</docstr>
      </property>
      <property name="PrefixStyle">
        <docstr>Determines whether the ampersand character (&amp;) is considered as a special prefix character.
The default value is TPrefixStyle.HidePrefix, which means that the (first) ampersand is hidden at run-time.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Controls" name="TPopup">
    <docstr>TPopup provides a pop-up window.
Use TPopup to display content in a temporary window.   
By default, a TPopup content is empty. You can add any number of objects to the TPopup content:

To add a control to the TPopup content, set the Parent property of the control or create it with the TPopup as its owner.
To access the TPopup children, use ChildrenCount and Children properties.
To position a TPopup, use the following properties:

PlacementRectangle
PlacementTarget
HorizontalOffset
VerticalOffset
Placement
When TPopup is open, it does not reposition itself if its parent is repositioned. To drag a TPopup together with its parent, set the DragWithParent property to True.
TPopup supports animations and graphic effects. The animations and graphic effects are applied to the displayed window, and not to every child of the TPopup. For opacity effects, set the effects directly to the TPopup children. TPopup children do not inherit the animations and effects applied to the parent.
If TPopup is not explicitly sized, it is sized by its content. In this case, if an effect is applied that increases the content&apos;s displayed size, part of the content might be obscured. To avoid this, explicitly set the size for TPopup or set its bounds through the BoundsRect, Margins, and Padding properties.   
To open and explicitly close a TPopup, set the TPopup.IsOpen property to True and False, respectively. 
(We do not recommend using Popup and ClosePopup.)</docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.Controls.TPopup.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Controls.TPopup.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Controls.TPopup.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Controls.TPopup.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="DialogKey">
        <docstr>Processes a dialog key. 
DialogKey is called during the message preprocessing to handle dialog characters. 
Do not call DialogKey in an application. It is for internal use only.</docstr>
      </procedure>
      <procedure name="DoClosePopup">
        <docstr>Dispatcher of the OnClosePopup event.</docstr>
      </procedure>
      <procedure name="DoPopup">
        <docstr>Dispatcher of the OnPopup event.</docstr>
      </procedure>
      <procedure name="ClosePopup">
        <docstr>Closes the current TPopup. 

Note: We do not recommend using Popup and ClosePopup. To open and explicitly close a TPopup, set the TPopup.IsOpen property to True and False, respectively.
Call ClosePopup to explicitly close a TPopup. If there is more than one pop-ups opened, ClosePopup closes only the specified instance.
To take specific action when TPopup closes, write an OnClosePopup event handler.</docstr>
      </procedure>
      <function name="CreatePopupForm">
        <docstr>For internal use.
Creates a new TCustomPopupForm pop-up form.
This pop-up form is stored in the PopupForm property. Popup calls CreatePopupForm.</docstr>
      </function>
      <property name="PopupForm">
        <docstr>Holds the form that appears on the screen after the Popup method execution. 
The value of the PopupForm property is nil if the form does not exist.</docstr>
      </property>
      <function name="VisibleStored">
        <docstr>Specifies whether TPopup has an associated action. 
The VisibleStored method returns True if TPopup has an associated action (if the ActionClient property is True). This method returns False otherwise.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates and initializes a TPopup instance.
Create constructs a TPopup object and initializes its data before the object is used.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the TPopup instance.
Do not call Destroy directly in an application. Call Free instead. Free verifies that the TPopup object is not nil before calling Destroy.</docstr>
      </destructor>
      <procedure name="Popup">
        <docstr>Displays the TPopup window. 

Note: We do not recommend using Popup and ClosePopup. To open and explicitly close a TPopup, set the TPopup.IsOpen property to True and False, respectively.
When AShowModal is True, then Popup drops down TPopup as a modal dialog. 
Popup applies the specified placement and style to TPopup, before making it visible.
To set the placement, use the PlacementRectangle, PlacementTarget, HorizontalOffset, VerticalOffset, and Placement properties.</docstr>
      </procedure>
      <function name="PopupModal">
        <docstr>Returns whether and how the modal form of TPopup closes. 
PopupModal returns 0 if the modal form is not closed. Otherwise PopupModal returns the value of the ModalResult property.
To change how the modal form of TPopup is closed, set the ModalResult property.
You can check a return value using the global IsAbortResult, IsAnAllResult, IsNegativeResult, or IsPositiveResult functions and use the  StripAllFromResult function to convert the return value from a constant that refers to &quot;all&quot; to the corresponding simple constant.</docstr>
      </function>
      <function name="HasPopupForm">
        <docstr>Returns whether the PopupForm property holds a pop-up form. 
HasPopupForm returns True if PopupForm holds the pop-up form that appears on the screen after the Popup method execution.</docstr>
      </function>
      <procedure name="BringToFront">
        <docstr>Brings this FMX visual object on top of other overlapping visual controls that are on the same form.
FMX.Controls.TPopup.BringToFront inherits from FMX.Types.TFmxObject.BringToFront. All content below this line refers to FMX.Types.TFmxObject.BringToFront.
Brings this FMX visual object on top of other overlapping visual controls that are on the same form.
You can call BringToFront at run time as in the following code snippet:

  Label1.BringToFront;

or, at design time, by right-clicking the FMX visual control and selecting Control &gt; Bring to Front from the pop-up menu.</docstr>
      </procedure>
      <property name="AniDuration">
        <docstr>Sets the animation duration during appearing or closing of the pop-up window.
AniDuration defines time (in seconds) of a custom animation execution. The OnAniTimer event is periodically triggered during the AniDuration time after the pop-up window starts appearing or closing. During the AniDuration time, the AniPosition property changes from 0 to 1 (during opening) and from 1 to 0 (during closing) respectively. The OnAniTimer event handler contains the code that is performed during animation. 

Note: AniDuration does not influence on a duration of an external animation (for example TFloatAnimation animation) if such is assigned to the TPopup pop-up window.</docstr>
      </property>
      <property name="BorderWidth">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ModalResult">
        <docstr>Determines whether and how the TPopup closes its modal form. 
TModalResult describes possible values of ModalResult.
You can check a ModalResult value  using the global IsAbortResult, IsAnAllResult, IsNegativeResult, or IsPositiveResult functions and use the  StripAllFromResult function to convert the ModalResult value from a constant that refers to &quot;all&quot; to the corresponding simple constant.</docstr>
      </property>
      <property name="IsOpen">
        <docstr>Is True if the TPopup is dropped down, False otherwise.</docstr>
      </property>
      <property name="ClosingAnimation">
        <docstr>Is True if the TPopup has a closing animation, False otherwise.</docstr>
      </property>
      <property name="PopupFormSize">
        <docstr>Sets the size of the TPopup through a TSizeF object.
For example, the following code will set up the TPopup Width to 200 and Height to 250: 
Delphi:

  p1.PopupFormSize := TSizeF.Create(200, 250);

C++ Builder:

  p1-&gt;PopupFormSize = TSizeF-&gt;Create(200, 250);</docstr>
      </property>
      <property name="PreferedDisplayIndex">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <event name="OnAniTimer">
        <docstr>Periodically occurs during TCustomPopupForm custom animation execution.
The OnAniTimer event periodically occurs during  AniDuration time while a custom animation executes during appearing and closing of the current TPopup pop-up window.
Write an OnAniTimer event handler to provide animation functionality during appearing and closing of the current pop-up window. AniDuration defines the animation duration in seconds. 
To show a TPopup window you can set the IsOpen property to True or call the Popup method. Rendering the TPopup window, the owner form calls CreatePopupForm to create an instance of a TCustomPopupForm pop-up form stored in the PopupForm property. Notice that all visual components placed in the TPopup window are contained in the ContentControl created in the PopupForm pop-up form. 
The OnAniTimer event handler has the type TNotifyEvent declared as follows:

 TNotifyEvent = procedure(Sender: TObject) of object;

Therefore, the Sender parameter, in the following example, can be cast to TCustomPopupForm. See how this is used in the AniTimeProc event handler of the OnAniTimer event in the following example implementing animation of appearing and closing of the TPopup window:

type
  TForm1 = class(TForm)
    Button1: TButton;
    Popup1: TPopup;
    Button2: TButton;
    Rectangle1: TRectangle;
    procedure FormCreate(Sender: TObject);
  public
    T: TDateTime;
    procedure AniTimeProc(Sender: TObject);
  end;

var
  Form1: TForm1;

implementation

procedure TForm1.AniTimeProc(Sender: TObject);
begin
  Button1.Text := FloatToStr(RoundTo((Now - T) * 86400{SecPerDay}, -2));
  TCustomPopupForm(Sender).ContentControl.Opacity := TCustomPopupForm(Sender).AniPosition;
  TCustomPopupForm(Sender).Left := Self.Left + Round(100 * TCustomPopupForm(Sender).AniPosition);
end;

procedure TForm1.Button2Click(Sender: TObject);
begin
  T := Now;
  Popup1.Popup;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  Popup1.AniDuration := 4;
  Popup1.OnAniTimer := AniTimeProc;
end;

end.

Notice that OnAniTimer can use AniPosition and other properties of TCustomPopupForm.</docstr>
      </event>
      <property name="DragWithParent">
        <docstr>Specifies whether the TPopup is dragged together with its parent.
If DragWithParent is set to True, TPopup is dragged too, when its parent is the target of a drag-and-drop operation. The default value is False. 
For example, the TPopup of a combo box is dragged with its parent.</docstr>
      </property>
      <property name="HideWhenPlacementTargetInvisible">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="HorizontalOffset">
        <docstr>Sets and gets the horizontal distance between the target origin and the TPopup alignment point. 
To set the target origin and the alignment point, use the PlacementTarget, Placement, and PlacementRectangle properties. 
HorizontalOffset has no effect if Placement has one of the values: Absolute, Mouse, MouseCenter.</docstr>
      </property>
      <property name="Placement">
        <docstr>Determines how to position the TPopup form  relative to a rectangle specified by the PlacementRectangle or PlacementTarget properties, relative to the screen, or relative to the mouse (pointing device) position.
Placement also specifies the behavior of the TPopup form, when it overlaps screen boundaries. The default value is Bottom.
TPlacement determines possible values of Placement.
Use Placement, PlacementTarget, and PlacementRectangle to set the target origin and the alignment point of TPopup.</docstr>
      </property>
      <property name="PlacementRectangle">
        <docstr>Gets or sets the rectangle element relative to which TPopup is positioned. 
Use Placement, PlacementTarget, and PlacementRectangle to set the target origin and the alignment point of TPopup. 
This is an example of a TPopup with PlacementRectangle:</docstr>
      </property>
      <property name="PlacementTarget">
        <docstr>Gets or sets the target relative to which TPopup is positioned. 
If PlacementTarget is not set, and TPopup has a parent, TPopup is positioned relative to its parent. If PlacementTarget and Parent are not set, TPopup is positioned relative to the main window. 
Use Placement, PlacementTarget, and PlacementRectangle to set the target origin and the alignment point of TPopup.</docstr>
      </property>
      <property name="StyleBook">
        <docstr>Gets and sets the TPopup stored style.
To create a new style, use the Style Designer. See details here: Style Resource Storage.</docstr>
      </property>
      <property name="VerticalOffset">
        <docstr>Sets and gets the vertical distance between the target origin and the TPopup alignment point.
To set the target origin and the alignment point, use the PlacementTarget, Placement, and PlacementRectangle properties. 
VerticalOffset has no effect if Placement has one of the values: Absolute, Mouse, MouseCenter.</docstr>
      </property>
      <event name="OnClosePopup">
        <docstr>Occurs when the TPopup object is closed. Write an OnClosePopup event handler to take specific action when the TPopup closes.</docstr>
      </event>
      <event name="OnPopup">
        <docstr>Occurs just before the pop-up window appears.
Write an OnPopup event handler to take specific action just before the pop-up window appears.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Forms" name="TApplication">
    <docstr></docstr>
    <members>
      <function name="TrackActivity">
        <docstr>Provides a mechanism for checking if application analytics has been enabled without accessing the
            AnalyticsManager property (which will create an instance of an application manager if one does not already
            exist). Returns True if an instance of TAnalyticsManager is assigned to the application. Returns False
            otherwise.</docstr>
      </function>
      <procedure name="CancelHint">
        <docstr>Cancels the display of a hint for a control.</docstr>
      </procedure>
      <procedure name="HideHint">
        <docstr>Hides the current hint.</docstr>
      </procedure>
      <property name="ShowHint">
        <docstr>Determines whether Help Hints are enabled or disabled for the entire application.</docstr>
      </property>
      <event name="OnHint">
        <docstr>Occurs when the mouse pointer moves over a control or menu item that can display a Help Hint.</docstr>
      </event>
      <property name="IsRealCreateFormsCalled">
        <docstr>Returns true if RealCreateForms was invoked; otherwise, false.</docstr>
      </property>
      <property name="AnalyticsManager">
        <docstr>Returns an instance of TAnalyticsManager. An instance will be created if one does not already exist.
           There should only be one AnalyticsManager per application.</docstr>
      </property>
      <property name="Hint">
        <docstr>Specifies the text string that appears in the Help Hint box.</docstr>
      </property>
      <property name="HintShortCuts">
        <docstr>Enables the display of keyboard shortcuts.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Forms" name="TWindowBorder">
    <docstr></docstr>
    <members>
      <procedure name="StyleChanged">
        <docstr>Notifies when form changed style.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Forms" name="TFormChangingFocusControl">
    <docstr></docstr>
    <members>
      <field name="PreviousFocusedControl">
        <docstr>Previous focused control.</docstr>
      </field>
      <field name="NewFocusedControl">
        <docstr>New control, which are going to have focus.</docstr>
      </field>
    </members>
  </class>
  <class unit="FMX.Forms" name="TFormSystemStatusBar">
    <docstr></docstr>
    <members>
      <property name="BackgroundColor">
        <docstr>Background color of system status bar</docstr>
      </property>
      <property name="Visibility">
        <docstr>Different modes of showing system status bar</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Forms" name="TCommonCustomForm">
    <docstr>TCommonCustomForm represents the base class for all forms, whether they are 2D or 3D.
TCommonCustomForm is the base class for all TCustomForm and TCustomForm3D, and all their derived objects such as TForm and TForm3D.</docstr>
    <members>
      <procedure name="ReleaseForm">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoDeleteChildren">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetBackIndex">
        <docstr>Returns the first item in the children list.
FMX.Forms.TCommonCustomForm.GetBackIndex inherits from FMX.Types.TFmxObject.GetBackIndex. All content below this line refers to FMX.Types.TFmxObject.GetBackIndex.
Returns the first item in the children list. This value is usually 0, but for styled objects, which have a style as the first object in the children list, this value is 1.</docstr>
      </function>
      <procedure name="InvalidateRect">
        <docstr>Schedules a repaint of the specified rectangle zone on the given form.
InvalidateRect takes in the R TRectF parameter and repaints the rectangle.</docstr>
      </procedure>
      <procedure name="Recreate">
        <docstr>Re-creates this form.
Recreate sets this form state to Recreating, then destroys and re-creates its handle, finalizing by showing the form on the screen. In the end, Recreate restores the original form&apos;s state by removing the Recreating attribute.
If the form is in a csDesigning state, Recreate exits doing nothing.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ConstrainedResize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AdjustSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetActive">
        <docstr>Sets the value of the Active property.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Forms.TCommonCustomForm.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="FindTarget">
        <docstr>Returns the specified control located at the given coordinates.
FindTarget iterates through all the children of this form and searches for the control given through the Data parameter at the coordinates specified by P. If the given control was not found, FindTarget returns nil, otherwise it returns the object.
FindTarget is used internally in drag-and-drop operations.

Tip: The control searched for must be an IControl, must be Visible, and HitTest must be set to True.</docstr>
      </function>
      <procedure name="SetFormFamily">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="UpdateStyleBook">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetStyleBookWithoutUpdate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ShowInDesigner">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="QueryInterface">
        <docstr>Returns a reference to a specified interface if the current component supports that interface.
FMX.Forms.TCommonCustomForm.QueryInterface inherits from System.Classes.TComponent.QueryInterface. All content below this line refers to System.Classes.TComponent.QueryInterface.
Returns a reference to a specified interface if the current component supports that interface.
QueryInterface checks whether the component supports the interface specified by IID and, if so, returns a reference to that interface as the Obj parameter. If the component does not support the interface, the Obj parameter returns nil (Delphi) or NULL (C++).
QueryInterface returns the S_OK execution code on success. HResult type 
defines the following execution codes: S_OK, S_FALSE, E_NOINTERFACE, E_UNEXPECTED, and E_NOTIMPL.

Note: For components that act as COM object wrappers, QueryInterface calls the QueryInterface method of the internal COM object.</docstr>
      </function>
      <procedure name="Realign">
        <docstr>Realigns all the child objects of this form and repaints the form&apos;s surface by a call to InvalidateRect.</docstr>
      </procedure>
      <procedure name="ChildrenAlignChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AddPreloadPropertyNames">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetPreloadProperties">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="CreateHandle">
        <docstr>Creates the window for this form and assigns it a handle. CreateHandle is overridden in subclasses to add extra functionality when creating the window containing this form.</docstr>
      </procedure>
      <procedure name="DestroyHandle">
        <docstr>Destroys the window handle created by CreateHandle. DestroyHandle is overridden in subclasses to add extra functionality when destroying the window containing this form.</docstr>
      </procedure>
      <procedure name="ResizeHandle">
        <docstr>Resizes this form according to ClientWidth and ClientHeight.
ResizeHandle is overridden in subclasses to implement functionality to resize the dimensions of this form according to the values of the ClientWidth and ClientHeight properties.</docstr>
      </procedure>
      <function name="GetObject">
        <docstr>Returns a reference to this form object.</docstr>
      </function>
      <function name="GetActiveControl">
        <docstr>Retrieves the active control.
Retrieves the IControl type object stored in the FActiveControl field.</docstr>
      </function>
      <procedure name="SetActiveControl">
        <docstr>Sets the focus to the specified AControl control.
SetActiveControl sets the focus to the specified AControl control (sets the active control), if possible.
The descendant TCustomForm class uses this protected SetActiveControl method in the setter of the ActiveControl property.
SetActiveControl internally calls FMX.Controls.TControl.SetFocus.</docstr>
      </procedure>
      <procedure name="SetCaptured">
        <docstr>Sets the value of the Captured property.</docstr>
      </procedure>
      <function name="NewFocusedControl">
        <docstr>Retrieves the control that can obtain the focus.
NewFocusedControl checks whether the specified Value control can obtain the focus. If Value cannot obtain the focus, then NewFocusedControl returns the youngest parent of Value that can obtain the focus. Otherwise, NewFocusedControl returns nil.</docstr>
      </function>
      <procedure name="SetFocused">
        <docstr>Protected setter implementation for the Focused property.
SetFocused sets the focus to the specified control. The control must be located on this form and must exist.</docstr>
      </procedure>
      <procedure name="SetHovered">
        <docstr>Sets the Hovered property and activates the functionality informing that the mouse pointer has entered the area of the control. 
Sets the control stored in the Hovered property and activates an animation and effects informing that the mouse pointer has entered the area of the control by calling DoMouseEnter.</docstr>
      </procedure>
      <procedure name="SetTransparency">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetCaptured">
        <docstr>Protected getter implementation for the Captured property.</docstr>
      </function>
      <function name="GetFocused">
        <docstr>Returns the value of the Focused property.</docstr>
      </function>
      <function name="GetBiDiMode">
        <docstr>Protected getter implementation for the BiDiMode property.</docstr>
      </function>
      <function name="GetHovered">
        <docstr>Retrieves the control stored in the Hovered property.</docstr>
      </function>
      <procedure name="BeginInternalDrag">
        <docstr>Implements functionality to start the drag-and-drop operation for the given object on the surface of the given form.
ABitmap specifies the image that will be displayed while dragging the object specified by the Source parameter.</docstr>
      </procedure>
      <function name="GetStyleBook">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetStyleBook">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="PaintRects">
        <docstr>Repaints all the rectangles given through the UpdateRects parameter. UpdateRects is an array of TRectF rectangles.</docstr>
      </procedure>
      <function name="GetContextHandle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetContextHandle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="ContextHandle">
        <docstr>Used internally by the canvas of this form.</docstr>
      </property>
      <function name="CreateBorder">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.Forms.TCommonCustomForm.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <procedure name="FreeNotification">
        <docstr>Ensures that AComponent is notified that the component is going to be destroyed.
FMX.Forms.TCommonCustomForm.FreeNotification inherits from System.Classes.TComponent.FreeNotification. All content below this line refers to System.Classes.TComponent.FreeNotification.
Ensures that AComponent is notified that the component is going to be destroyed.
Use FreeNotification to register AComponent as a component that should be notified when the component is about to be destroyed. It is only necessary to register components this way when they are in a different form or have a different owner. For example, if AComponent is in another form and uses the component to implement a property, it must call FreeNotification so that its Notification method is called when the component is destroyed.
For components with the same owner, the Notification method is called automatically when an application explicitly frees the component. This notification is not sent out when components are freed implicitly, because the Owner is already being freed.</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.Forms.TCommonCustomForm.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="Updated">
        <docstr>Clears the csUpdating state in the component&apos;s ComponentState property when the component finishes updating.
FMX.Forms.TCommonCustomForm.Updated inherits from System.Classes.TComponent.Updated. All content below this line refers to System.Classes.TComponent.Updated.
Clears the csUpdating state in the component&apos;s ComponentState property when the component finishes updating.
Do not call Updated directly. It is used internally to clear the csUpdating flag of the ComponentState property. A call to Updated always follows a call to Updating, which sets the flag.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Forms.TCommonCustomForm.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="ValidateRename">
        <docstr>Ensures that renaming an owned component does not create a name conflict.
FMX.Forms.TCommonCustomForm.ValidateRename inherits from System.Classes.TComponent.ValidateRename. All content below this line refers to System.Classes.TComponent.ValidateRename.
Ensures that renaming an owned component does not create a name conflict.
ValidateRename checks whether a component can rename one of its owned components, passed in AComponent, from its current name (CurName) to the string passed in NewName. If AComponent is nil (Delphi) or NULL (C++) or NewName is already the name of a component in the Components list, ValidateRename raises an EComponentError exception.
ValidateRename is used internally when the Name property is modified. It is not necessary to call it directly.</docstr>
      </procedure>
      <procedure name="GetChildren">
        <docstr>Enumerates all child components.
FMX.Forms.TCommonCustomForm.GetChildren inherits from System.Classes.TComponent.GetChildren. All content below this line refers to System.Classes.TComponent.GetChildren.
Enumerates all child components.
GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
GetChildren expects a TGetChildProc routine that receives all enumerated components. 
Root represents the owner of the components that will be enumerated.
This method does nothing in TComponent and is expected to be overridden in descendants.</docstr>
      </procedure>
      <procedure name="GetDeltaStreams">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetContainerWidth">
        <docstr>Returns the value of the ClientWidth property.</docstr>
      </function>
      <function name="GetContainerHeight">
        <docstr>Returns the value of the ClientHeight property.</docstr>
      </function>
      <procedure name="UpdateActions">
        <docstr>UpdateActions updates all the actions associated to the current form.</docstr>
      </procedure>
      <function name="GetActionLinkClass">
        <docstr>Returns the associated action link class.
FMX.Forms.TCommonCustomForm.GetActionLinkClass inherits from FMX.Types.TFmxObject.GetActionLinkClass. All content below this line refers to FMX.Types.TFmxObject.GetActionLinkClass.
Returns the associated action link class.
Returns the class reference for the TActionLink class or for one of its descendants. 
In TFmxObject, GetActionLinkClass always returns nil.
In descendant classes, GetActionLinkClass should return the appropriate class type for the action link used with the class object. When a control object of the descendant from the TFmxObject class tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass. If GetActionLinkClass returns a non-nil value, then the action object is assigned to Action. If the control object does not support actions, then GetActionLinkClass should return nil. In this case, attempting to set a value to the Action property raises the following exception:  

StrEActionNoSuported = &apos;Class %s does not support the action&apos;</docstr>
      </function>
      <procedure name="ActionChange">
        <docstr>Specifies the behavior of a TCommonCustomForm form when Action changes. 
Depending on the CheckDefaults value,  ActionChange uses properties of the Sender action to set new values to the  
Visible and Caption properties of TCommonCustomForm. Then ActionChange calls the inherited TControl.ActionChange method.  
Do not call ActionChange explicitly in an application. It is for internal use.</docstr>
      </procedure>
      <function name="CaptionStore">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="VirtualKeyboardChangeHandler">
        <docstr>The listener for virtual keyboard events of the form.
TCommonCustomForm uses the System.Messaging.TMessageManager.SubscribeToMessage method to subscribe the VirtualKeyboardChangeHandler listener to the TVKStateChangeMessage virtual keyboard events.
The VirtualKeyboardChangeHandler listener handles the KeyboardVisible and 
KeyboardBounds properties by calling the 
OnVirtualKeyboardShown and OnVirtualKeyboardHidden event handlers.</docstr>
      </procedure>
      <procedure name="IsDialogKey">
        <docstr>Determines whether the pressed key should be processed only by the control having the focus or by all children controls and menus of the form.
IsDialogKey is used internally in the KeyDown method.
IsDialog returns True, if KeyChar &lt; &apos; &apos; or Shift identifies any of the CTRL, ALT, or CMD keys. That is, if the KeyChar and Shift combination identifies some control combination -- not a printable character. IsDialog returns False, if the Key and KeyChar combination identifies some printable character.  The &apos; &apos; character has the $20 ASCII value. ASCII values less than $20 identify control combinations.  
IsDialogKey has the following parameters:

Key is the scan code of the pressed keyboard key. This parameter is ignored.
KeyChar is the character code of the pressed key.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when you press the key.
IsDialog is the return boolean parameter.
See also
FMX.Forms.TCommonCustomForm.KeyDown</docstr>
      </procedure>
      <procedure name="DoShow">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoHide">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoClose">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoScaleChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoStyleChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoMouseDown">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoMouseMove">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoMouseUp">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoMouseWheel">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoFocusChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoPaddingChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoTap">
        <docstr>Processes the unhandled OnTap events. 
DoTap is run automatically for all tap events that were not handled by the user. DoTap is run only if OnTap is not set or if it did not handle the tap event. 
Override DoTap in descending classes to support default behavior for tap events that were not handled by the user.</docstr>
      </procedure>
      <function name="GetWindowStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="DoParentFormChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRootChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="MainMenu">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <procedure name="DoGesture">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="BroadcastGesture">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="CMGesture">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="TouchManager">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetFirstControlWithGesture">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetFirstControlWithGestureEngine">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetListOfInteractiveGestures">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Tap">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="MultiTouch">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Engage">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Disengage">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ScaleChangedHandler">
        <docstr>Event handler for the event that occurs when there is a change in the scale of the control.
For instance, changing from retina to non-retina screen on OS X platforms implies a change in the scale factor of the control.</docstr>
      </procedure>
      <procedure name="StyleChangedHandler">
        <docstr>Event handler for the event that occurs when there is a style change.
Note: When there is a style change, the control sends a TStyleChangedMessage message.</docstr>
      </procedure>
      <procedure name="TriggerHints">
        <docstr>Calls the TriggerOnHint method of all the objects that are registered in the registry.</docstr>
      </procedure>
      <procedure name="RegisterHintReceiver">
        <docstr>Registers a new receiver.</docstr>
      </procedure>
      <procedure name="UnregisterHintReceiver">
        <docstr>Unregisters a receiver.
AReceiver specifies the receiver to remove from the registry list.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates and initializes this form.
Create calls the inherited Create to create this form. Create
retrieves the IFMXWindowService,  IFMXCursorService,  
IFMXFullScreenWindowService, and
IFMXWindowsTouchService services.  
Create calls  InitializeNewForm to initialize such form parameters as bounds, width and height, border icons, style, border style, and client size for the form. 
AOwner specifies the owner of this form. 
An AOwner (usually the application) is responsible for freeing the created form.
Most applications do not call this constructor, but rather instantiate a descendant of TForm that is defined in the forms designer. Forms added to an application at design time are created automatically.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Forms.TCommonCustomForm.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="InitializeNewForm">
        <docstr>Performs several initializations required by this form.
These initializations include bounds, width and height, border icons, border style, and client size for the form. InitializeNewForm is used by the form constructors.</docstr>
      </procedure>
      <procedure name="AfterConstruction">
        <docstr>Responds after the last constructor has executed.
FMX.Forms.TCommonCustomForm.AfterConstruction inherits from System.TObject.AfterConstruction. All content below this line refers to System.TObject.AfterConstruction.
Responds after the last constructor has executed.
AfterConstruction is called automatically after the object&apos;s last constructor has executed. Do not call it explicitly in your applications. 
The AfterConstruction method implemented in TObject does nothing. Override this method when creating a class that performs an action after the object is created. For example, TCustomForm overrides AfterConstruction to generate an OnCreate event.</docstr>
      </procedure>
      <procedure name="BeforeDestruction">
        <docstr>Performs any necessary actions before the first destructor is called.
FMX.Forms.TCommonCustomForm.BeforeDestruction inherits from System.Classes.TComponent.BeforeDestruction. All content below this line refers to System.Classes.TComponent.BeforeDestruction.
Performs any necessary actions before the first destructor is called.
BeforeDestruction is called automatically immediately before the component&apos;s first destructor executes. Do not call it explicitly in your applications.
As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place.</docstr>
      </procedure>
      <function name="ObjectAtPoint">
        <docstr>Returns the object located at the given coordinates.
ObjectAtPoint iterates through all the children of this form and returns the component situated at the coordinates given through the AScreenPoint TPointF parameter.
If the object at the specified coordinates was not found, or is not an IControl, or its state is csDesigning, ObjectAtPoint returns nil. Otherwise the object is returned as IControl.</docstr>
      </function>
      <procedure name="CreateChildFormList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>Executes each time you press a mouse button.
MouseDown has the following parameters:

Button specifies the mouse button that has been pressed.
Shift determines the state of the CTRL, ALT, and SHIFT keys at the moment you press the mouse button.
X specifies the horizontal position of the mouse.
Y specifies the vertical position of the mouse.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>Executes each time you move the mouse over the surface of this form.
MouseMove has the following parameters:

Shift determines the state of the CTRL, ALT, and SHIFT keys at the moment you released the mouse button.
X specifies the horizontal position of the mouse.
Y specifies the vertical position of the mouse.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>Executes each time you release a mouse button.
MouseUp has the following parameters:

Button specifies the mouse button that has been released.
Shift determines the state of the CTRL, ALT, and SHIFT keys at the moment you released the mouse button.
X specifies the horizontal position of the mouse.
Y specifies the vertical position of the mouse.</docstr>
      </procedure>
      <procedure name="MouseWheel">
        <docstr>Executes each time you roll the mouse wheel.
MouseWheel has the following parameters:

Shift determines the state of the CTRL, ALT, and SHIFT keys at the moment you released the mouse button.
WheelDelta indicates the distance the wheel was rotated. WheelDelta is positive if the mouse was rotated upward, and negative if the mouse was rotated downward.
Handled specifies whether this form handles the mouse wheel, or other child controls do this.</docstr>
      </procedure>
      <procedure name="MouseLeave">
        <docstr>Executes each time the mouse leaves the surface of this form.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Executed when a key is pressed while this form has the input focus.
In FireMonkey framework KeyDown is the main method to process pressing of keys in forms. KeyDown is executed each time a key is pressed, when this form has the input focus. KeyDown is used internally: to activate menus and actions and to treat TAB requests to cycle through the children controls of this form. Editors can use KeyDown to add symbols into a text being edited. 
You can override KeyDown to provide additional key treating in subclasses.
KeyDown has the following parameters:



Parameters

Descriptions



Key



Is the scan code of the pressed keyboard key or $0.
The UITypes unit defines Virtual Keys providing symbolic constants for scan codes of keyboard keys.
Physical scan codes of the same key can differ under different platforms (Windows or iOS). Under FireMonkey framework, platform-specific units (for example FMX.Platform.Mac.pas) should translate native (iOS for FMX.Platform.Mac.pas unit) scan codes to the corresponding Windows codes defined in the UITypes unit. As the result Key always has scan code values defined by vkXXXX constants in UITypes. For example, 

vkReturn = $0D;  {  13 } corresponds to the RETURN keyboard key
vkEscape = $1B;  {  27 } corresponds to the ESCAPE
vkSpace  = $20;  {  32 } corresponds to the SPACE
vkF2     = $71;  { 113 } corresponds to the F2 keyboard key
Keys of digits and letters -- independently of the selected input language and case of alphabetic keys -- have values corresponding to the &apos;0&apos;..&apos;9&apos; and  &apos;A&apos;..&apos;Z&apos; symbols. For example, Key = vkP = $50 corresponds to the &apos;P&apos; keyboard key.
If Key = $0, then KeyChar contains a pressed symbol according to the current keyboard&apos;s input language, keyboard mode (CAPS LOCK and NUM LOCK keys), keyboard Shift state, and Input Method Editor (IME) state.  
Combinations of the Key and Shift parameters can be translated to shortcut key combinations.    




KeyChar



Is the pressed character (digit) or #0.
If a pressed key combination can be handled as a printable character or digit, then Key = 0 and KeyChar contains a pressed symbol according to the current keyboard&apos;s input language, keyboard mode (CAPS LOCK and NUM LOCK keys), keyboard Shift state, and IME state. Editors can use this symbol to add into a text being edited. 




Shift



Determines the state of the CTRL, ALT, SHIFT, and CMD (only for Mac) keys at the moment you press the key.



KeyDown processes pressed keys according to the following algorithm: 

KeyDown first calls the IsDialogKey with the same parameters as those specified for KeyDown. The IsDialog parameter returns True if KeyChar &lt; &apos; &apos; or Shift is any of the CTRL, ALT or CMD keys. That is, if the KeyChar and Shift combination identifies some control combination -- not a printable character. Otherwise, it returns False. The &apos; &apos; character has the $20 ASCII value. ASCII values less than $20 identify control combinations.
If IsDialogKey returns True in the IsDialog parameter, then the pressed key combination is passed, in the following order, to all child controls, menus and action lists in the form until this key combination is processed:
To the control having focus.
To the context menu of the control having focus.
To all other menus and context menus in the form.
To all other controls (not having focus) in the form.
To action lists in the form and in all child components having assigned action list elements.
To menus and action lists in all other forms.
If the pressed key combination was processed during one of the previous steps, then KeyDown sets Key = 0 and KeyChar = #0 and terminates.
If Key = vkTab, then KeyDown moves the focus to the next control in the controls &quot;tab order&quot; and terminates.
If Key &lt;&gt; 0 or KeyChar &lt;&gt; #0, then KeyDown calls the KeyDown method of the control having focus and then calls the OnKeyDown event handler of the form if one is assigned.
In the finally block, KeyDown stores the current date and time in the LastKeyPress and LastUserActive properties of the current application.</docstr>
      </procedure>
      <procedure name="KeyUp">
        <docstr>Is executed each time when a key is released while this form has the input focus.
First, KeyUp calls the OnKeyUp event handler (if one is defined) of the control having input focus, then KeyUp calls the OnKeyUp event handler. In the finally block, KeyUp stores the current date and time in the LastKeyPress and LastUserActive properties of the current application.
KeyUp has the following parameters:

Key is the scan code of the pressed keyboard key. The UITypes unit defines Virtual Keys providing symbolic constants for scan codes of keyboard keys.
KeyChar is the character representation of the pressed key.
Shift determines the state of the CTRL, ALT, SHIFT, and CMD (only for Mac) keys at the moment you press the key.
You can override KeyUp to provide additional ways to handle keys in subclasses.</docstr>
      </procedure>
      <procedure name="MouseCapture">
        <docstr>Sets the mouse capture to this window, which belongs to the current thread.</docstr>
      </procedure>
      <procedure name="ReleaseCapture">
        <docstr>Releases the mouse capture from this window that belongs to the current thread and restores normal mouse input processing.</docstr>
      </procedure>
      <procedure name="RecreateResources">
        <docstr>Recreates the context where the form renders itself.</docstr>
      </procedure>
      <procedure name="HandleNeeded">
        <docstr>The HandleNeeded method requests the form to create its handle at this moment and all the resources associated to it.</docstr>
      </procedure>
      <procedure name="Activate">
        <docstr>Activation event dispatcher.
The form component calls Activate when it gets the focus either because of a change in the active windows within an application or because of the application becoming active. Activate fires an OnActivate event.</docstr>
      </procedure>
      <procedure name="Deactivate">
        <docstr>Deactivation event dispatcher.
The form component calls Deactivate when it loses the focus either because of a change in the active windows within an application or because of the application becoming inactive. Deactivate fires an OnDeactivate event.</docstr>
      </procedure>
      <procedure name="DragEnter">
        <docstr>Executes when you drag an object while entering the surface of this form.
Override DragEnter to add additional code that executes when you enter the surface of this form while dragging an object.
Data is the object being dragged.
Point is the position of the mouse.</docstr>
      </procedure>
      <procedure name="DragOver">
        <docstr>Executes when you drag an object over the surface of this form.
Override DragOver to add additional code that executes when you drag an object over the surface of this form. DragOver sets the Accept parameter to True to indicate that you can drop the dragged object on this form. It sets Accept to False to indicate that you cannot drop the dragged object on this form.
The Data parameter is the object being dragged. 
Point indicates the current position of the mouse.</docstr>
      </procedure>
      <procedure name="DragDrop">
        <docstr>Executes when you drop an object over the surface of this form.
Override DragDrop to add additional code that executes when you drop an object over the surface of this form.
The Data parameter is the object that was dropped onto this form. The Point parameter has the mouse coordinates where the object was dropped.</docstr>
      </procedure>
      <procedure name="DragLeave">
        <docstr>Executes when you drag an object while leaving the surface of this form.
Override DragLeave to add additional code that executes when you leave the surface of this form while dragging an object.</docstr>
      </procedure>
      <procedure name="EnterMenuLoop">
        <docstr>Starts the menu loop for the main menu bars that this form might contain.
EnterMenuLoop iterates through all the child controls of this form and, if one of them is a TMenuBar, then starts its menu loop.</docstr>
      </procedure>
      <procedure name="StartWindowDrag">
        <docstr>Signals that this form&apos;s window is about to be dragged. StartWindowDrag exits if this form has a csDesigning component state.</docstr>
      </procedure>
      <procedure name="StartWindowResize">
        <docstr>Signals that this form&apos;s window is about to be resized. StartWindowResize exits if this form has a csDesigning component state.</docstr>
      </procedure>
      <procedure name="AddRecognizer">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RemoveRecognizer">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetRecognizers">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetBounds">
        <docstr>Sets the boundaries for this form.
SetBounds has the following parameters:

ALeft--the left boundary
ATop--the top boundary
AWidth--the right boundary
AHeight--the bottom boundary</docstr>
      </procedure>
      <procedure name="SetBounds">
        <docstr>Sets the boundaries for this form.
SetBounds has the following parameters:

ALeft--the left boundary
ATop--the top boundary
AWidth--the right boundary
AHeight--the bottom boundary</docstr>
      </procedure>
      <procedure name="SetBoundsF">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetBoundsF">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetBounds">
        <docstr>Bounds of form - position and size.</docstr>
      </function>
      <function name="GetBoundsF">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="ClientToScreen">
        <docstr>Converts the given mouse coordinates to screen coordinates. The local coordinates on the surface of this form are given through the Point parameter.</docstr>
      </function>
      <function name="ScreenToClient">
        <docstr>Transforms the global screen coordinates to local client area coordinates. The global screen coordinates are given through the Point parameter.</docstr>
      </function>
      <function name="CanShow">
        <docstr>Retrieves whether the form is not visible.
CanShow returns True if  Visible is False (when the form is not visible).</docstr>
      </function>
      <function name="CloseQuery">
        <docstr>Close-attempt event dispatcher.
CloseQuery is called automatically when an attempt is made to close the form. CloseQuery can allow the form to close by returning True, or prevent the form from closing by returning False.
As implemented in TCommonCustomForm, CloseQuery calls the OnCloseQuery event handler, if it exists. If no such event handler exists, CloseQuery returns True.</docstr>
      </function>
      <function name="ClientRect">
        <docstr>Returns a TRectF with the coordinates of the client area. The width of the rectangle is the same as ClientWidth and the height of the rectangle is ClientHeight.</docstr>
      </function>
      <procedure name="RecreateOsMenu">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="Close">
        <docstr>Closes the form and returns the close action that the form uses.
Call Close to close a form.
Attempts to close a form can be aborted by the CloseQuery event dispatcher or the OnCloseQuery event handler.

Note: When the main form of the application closes, the application terminates.</docstr>
      </function>
      <procedure name="Show">
        <docstr>Displays the form onscreen. 
The form is displayed onscreen, with the specified Position.


Attention: On macOS, the Secondary window created by a modal windows must also be shown using ShowModal. Do not call Show for a window that is being shown from a window shown using ShowModal.</docstr>
      </procedure>
      <procedure name="Hide">
        <docstr>Hides the form.
Hide sets the Visible property to False.</docstr>
      </procedure>
      <procedure name="BringToFront">
        <docstr>Brings this FMX visual object on top of other overlapping visual controls that are on the same form.
FMX.Forms.TCommonCustomForm.BringToFront inherits from FMX.Types.TFmxObject.BringToFront. All content below this line refers to FMX.Types.TFmxObject.BringToFront.
Brings this FMX visual object on top of other overlapping visual controls that are on the same form.
You can call BringToFront at run time as in the following code snippet:

  Label1.BringToFront;

or, at design time, by right-clicking the FMX visual control and selecting Control &gt; Bring to Front from the pop-up menu.</docstr>
      </procedure>
      <procedure name="SendToBack">
        <docstr>Sends this FMX visual object to the background letting other overlapping visual controls that are on the same form to be on top of it.
FMX.Forms.TCommonCustomForm.SendToBack inherits from FMX.Types.TFmxObject.SendToBack. All content below this line refers to FMX.Types.TFmxObject.SendToBack.
Sends this FMX visual object to the background letting other overlapping visual controls that are on the same form to be on top of it.
You can call SendToBack at run time as in the following code snippet:

  Label1.SendToBack;

or, at design time by right-clicking the FMX visual control and selecting  Control &gt; Send To Back from the pop-up menu.</docstr>
      </procedure>
      <function name="ShowModal">
        <docstr>Shows the form as a modal dialog box.
Use ShowModal to show the form as a modal dialog box. When a modal form is opened the application cannot continue to run until the modal form is closed. Thus, ShowModal does not return until the form has closed. When the form has closed, it returns the value of the ModalResult property.
To close a modal form, set its ModalResult property to a nonzero value.


Tip: If the form contains buttons with a ModalResult property set to a value other than mrNone, the form automatically closes when the user clicks one of these buttons and returns the ModalResult value as the return value of ShowModal.
Warning: Modal dialog boxes are not supported in Android apps. We recommend do not use modal dialog boxes on either of the mobile platforms (iOS and Android) because unexpected behavior can result. Avoiding usage of modal dialog boxes eliminates potential problems in debugging and supporting your mobile apps.
Attention: On macOS, secondary windows shown from a modal window must also be shown modally using ShowModal, otherwise secondary windows do not gain focus.</docstr>
      </function>
      <procedure name="ShowModal">
        <docstr>Shows the form as a modal dialog box.
Use ShowModal to show the form as a modal dialog box. When a modal form is opened the application cannot continue to run until the modal form is closed. Thus, ShowModal does not return until the form has closed. When the form has closed, it returns the value of the ModalResult property.
To close a modal form, set its ModalResult property to a nonzero value.


Tip: If the form contains buttons with a ModalResult property set to a value other than mrNone, the form automatically closes when the user clicks one of these buttons and returns the ModalResult value as the return value of ShowModal.
Warning: Modal dialog boxes are not supported in Android apps. We recommend do not use modal dialog boxes on either of the mobile platforms (iOS and Android) because unexpected behavior can result. Avoiding usage of modal dialog boxes eliminates potential problems in debugging and supporting your mobile apps.
Attention: On macOS, secondary windows shown from a modal window must also be shown modally using ShowModal, otherwise secondary windows do not gain focus.</docstr>
      </procedure>
      <function name="CloseModal">
        <docstr>Prepares a modal form for closing and returns the close action that the form uses.
Do not call CloseModal in your application. CloseModal is used by the the FireMonkey framework when a modal form needs to be closed. CloseModal does not close the form by itself; it simply calls the registered close events and updates the ModalResult property.</docstr>
      </function>
      <function name="IsPopupForm">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="IsPopupForm">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Invalidate">
        <docstr>Schedules a repaint of this form.
Invalidate informs the form that its entire surface needs to be repainted. Calling Invalidate can prevent flicker caused by a series of partial repaints. There is no performance penalty for calling Invalidate multiple times before the form is actually repainted.</docstr>
      </procedure>
      <procedure name="BeginUpdate">
        <docstr>Starts updating all the child controls in this form.
BeginUpdate starts updating all the child controls placed on this form, thus speeding any operations you might perform on the form or on multiple children. BeginUpdate signals the beginning of an update operation and must be followed by EndUpdate when all the updates have been completed.</docstr>
      </procedure>
      <procedure name="EndUpdate">
        <docstr>Ends updating all the child controls in this form.
EndUpdate ends updating all the child controls placed on this form, finalizing any updates you might have performed on the form or on multiple children. EndUpdate signals the end of an update operation and must be preceded by BeginUpdate and by the updates themselves.</docstr>
      </procedure>
      <function name="GetTabList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="IsHandleAllocated">
        <docstr>Returns true only if the handle is allocated.</docstr>
      </function>
      <property name="Handle">
        <docstr>Specifies the handle of this form.</docstr>
      </property>
      <property name="ParentForm">
        <docstr>Specifies the parent form of this form.
The ParentForm parent form must be an instance of a TCommonCustomForm descendant. ParentForm contains the parent component of the current TCommonCustomForm form. ParentForm is responsible for deleting the current TCommonCustomForm form.
The value of ParentForm is set when you change the Parent property. If Parent is a form, then ParentForm is set to the value of Parent. Otherwise, ParentForm is set to the value of the form, to which the Parent belongs.</docstr>
      </property>
      <property name="FormStyle">
        <docstr>Determines the form style.
FormStyle is one of the Normal, Popup, or StayOnTop values defined in TFormStyle.</docstr>
      </property>
      <property name="ModalResult">
        <docstr>Represents the return value of a form that is used as a modal dialog box.
Use ModalResult to close the form when it is displayed modally.
By default, ModalResult is mrNone. Set ModalResult to any nonzero value to close the form. The ModalResult value  becomes the return value of the ShowModal function called to display the form.
The following table lists the constants defined in the System.UITypes unit to be used for the ModalResult property of the TModalResult type.



Constant

Value

Meaning



mrNone



0



None. Used as a default value before the user exits.




mrOk



idOK = 1



The user exited with the OK button.




mrCancel



idCancel = 2



The user exited with the CANCEL button.




mrAbort



idAbort = 3



The user exited with the ABORT button.




mrRetry



idRetry = 4



The user exited with the RETRY button.




mrIgnore



idIgnore = 5



The user exited with the IGNORE button.




mrYes



idYes = 6



The user exited with the YES button.




mrNo



idNo = 7



The user exited with the NO button.




mrClose



idClose = 8



The user exited with the CLOSE button.




mrHelp



idHelp = 9



The user exited with the HELP button.




mrTryAgain



idTryAgain = 10



The user exited with the TRY AGAIN button.




mrContinue



idContinue = 11



The user exited with the CONTINUE button.




mrAll



mrContinue + 1 (12 or $C)



The user exited with the ALL button.




mrNoToAll



mrAll +1 (13 or $D)



The user exited with the NO TO ALL button.




mrYesToAll



mrNoToAll +1 (14 or $E)



The user exited with the YES TO ALL button.


You can check a ModalResult value  using the global IsAbortResult, IsAnAllResult, IsNegativeResult, or IsPositiveResult functions and use the StripAllFromResult function to convert ModalResult values that refer to &quot;ALL&quot; buttons to identifying values corresponding simple buttons (Ok, No, or Yes). 

Note: This property can be modified automatically setting corresponding ModalResult properties of controls in the modal form.</docstr>
      </property>
      <property name="FormState">
        <docstr>Indicates transitional state information about the form.
Read FormState to determine the state of the form. FormState indicates when the form is in various transitional states or when certain operations have occurred. The following table lists the values that can be included in a form&apos;s state:





Value

Meaning



Recreating



The form is recreating its handle and its window is being shown on the screen.




Modal



The form was created as a modal window.</docstr>
      </property>
      <property name="Designer">
        <docstr>Specifies the designer interface for the form.
The Designer property is used internally at design time. Never assign a value to this property. This is done automatically by the form designer. Only use this property when designing classes for use in the form designer, such as property editors and component editors.</docstr>
      </property>
      <property name="Captured">
        <docstr>Specifies the control that has captured the mouse. Captured is read-only.</docstr>
      </property>
      <property name="Focused">
        <docstr>Specifies the control that has the focus set on it.</docstr>
      </property>
      <property name="Hovered">
        <docstr>Identifies the control over which the mouse pointer is hovering.
Used internally for mouse hovering-over purposes.</docstr>
      </property>
      <property name="Active">
        <docstr>Specifies whether the form has focus.
Use Active to determine whether the form has focus. The Active form receives all keyboard input. If it has a title bar, it is drawn using the active colors specified by the operating system.
If Active is True, the form has focus; if Active is False, the form does not have focus.</docstr>
      </property>
      <property name="BiDiMode">
        <docstr>Indicates the layout of this form when running under Middle Eastern versions of the operating system.
Use BiDiMode to specify the bi-directional mode for the application. The bi-directional mode controls the direction in which text appears (left-to-right or right-to-left), the placement of vertical scroll bars, and the default alignment of text when the application runs in Middle Eastern locales.</docstr>
      </property>
      <property name="Caption">
        <docstr>Specifies a text string that identifies the form to the user.
Use Caption to specify the text string that labels the form, identifying it to the user.</docstr>
      </property>
      <property name="Cursor">
        <docstr>Specifies the mouse cursor that will be used on this form.</docstr>
      </property>
      <property name="Border">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="BorderStyle">
        <docstr>Specifies the appearance and behavior of the form border.
Use BorderStyle to get or set the appearance and behavior of the form border. BorderStyle can be any of the following TFmxFormBorderStyle values:



Value

Meaning



Single



Not resizable; minimize/maximize menu




None



Not resizable; no visible border line




Sizeable



Standard resizable border




ToolWindow



Similar to Single, but with a smaller caption




SizeToolWin



Similar to Sizeable, but with a smaller caption


Notes:

In iOS applications, None makes your form run in fullscreen mode. With any other value, your iOS app shows the iOS status bar.
In Android applications, the BorderStyle property does not control fullscreen display. Instead, you should set the theme property on the  Project &gt; Options &gt; Version Info  page of your Android project:
Setting the theme = TitleBar means that your Android app includes a title or status bar.
Setting the theme = NoTitleBar means that your Android app runs in fullscreen mode, without a title or status bar.</docstr>
      </property>
      <property name="BorderIcons">
        <docstr>Specifies which icons appear on the title bar of the form.
Use BorderIcons to get or set the icons that appear on the title bar of the form. BorderIcons can include any of the following TBorderIcons values:



Value

Meaning



biSystemMenu



The form has a Control menu (also known as a System menu).




biMinimize



The form has a Minimize button.




biMaximize



The form has a Maximize button.




biHelp



Has no effect in FireMonkey.</docstr>
      </property>
      <property name="Bounds">
        <docstr>Bounds of form - position and size.</docstr>
      </property>
      <property name="BoundsF">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ClientHeight">
        <docstr>Specifies the height (in pixels) of the form&apos;s client area.
Use ClientHeight to determine the height (in pixels) of the form&apos;s client area. The client area is the usable area inside the form&apos;s border, excluding the title bar, scroll bars, and so on.
Set ClientHeight to change the height of the form&apos;s window based on the desired client area. To change the height of the form&apos;s window based on the total size of the window (including the border, menu, status bar and so on), use the Height property instead.</docstr>
      </property>
      <property name="ClientWidth">
        <docstr>Specifies the width (in pixels) of the form&apos;s client area.
Use ClientWidth to determine the width (in pixels) of the form&apos;s client area. The client area is the usable area inside the form&apos;s border. Set ClientWidth to change the width of the form&apos;s window based on the desired client area. To change the width of the form&apos;s window based on the total size of the window (including the border, status bar, and so on), use the Width property instead.</docstr>
      </property>
      <property name="OriginalContainerSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Padding">
        <docstr>Specifies the padding of the form. 
The Padding of a form specifies how close, in pixels, the child of the form can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the form.
The child of the form is repositioned and resized, if necessary, to fit the Padding.</docstr>
      </property>
      <property name="Position">
        <docstr>Represents the size and placement of the form.
Use Position to get or set the size and placement of the form. Position can have one of the following TFormPosition values:



Value

Meaning



Designed



The form appears positioned on the screen and with the same height and width as it had at design time.




Default



The form appears in a position on the screen and with a height and width determined by the operating system. Each time you run the application, the form moves slightly down and to the right. The right side of the form is always near the rightmost side of the screen, and the bottom of the form is always near the bottom of the screen, regardless of the screen&apos;s resolution.
The operating system only supports this for overlapped windows. For a pop-up or child window (that has a BorderStyle of None, for example), the window is positioned in the upper-left corner of the screen.
On OS X, the default position for new windows is the upper-left corner of the screen.




DefaultPosOnly



The form displays with the size you created it at design time, but the operating system chooses its position on the screen. Each time you run the application, the form moves slightly down and to the right. When the form can no longer move down and to the right and keep the same size while remaining entirely visible on the screen, the form displays in the upper-left corner of the screen.
The operating system only supports this for overlapped windows. For a pop-up or child window (that has a BorderStyle of None, for example), the window is positioned in the upper-left corner of the screen.
On OS X, the default position for new windows is the upper-left corner of the screen.




DefaultSizeOnly



The form appears in the position you left it at design time, but the operating system chooses its size. The right side of the form is always near the rightmost side of the screen, and the bottom of the form is always near the bottom of the screen, regardless of the screen&apos;s resolution.




ScreenCenter



The form remains the size you left it at design time, but is positioned in the center of the screen.




DesktopCenter



The form remains the size you left it at design time, but is positioned in the center of the screen. No adjustments are made for multi-monitor applications.




MainFormCenter



The form remains the size you left it at design time, but is positioned in the center of the application&apos;s main form. No adjustments are made for multi-monitor applications. This position should only be used with secondary forms. If set for a main form, it acts like ScreenCenter.




OwnerFormCenter



The form remains the size you left it at design time, but is positioned in the center of the owner form. If there is no owner form, this position acts like MainFormCenter.


Note that, if Position is set to Default, DefaultPosOnly, or DefaultSizeOnly, and BorderStyle is set to None, the form will be positioned at (0,0).</docstr>
      </property>
      <property name="StyleBook">
        <docstr>Specifies the style book for this form. For more information on how to customize the looks of a FireMonkey application with styles, refer to the Customizing FireMonkey Applications with Styles help topic.</docstr>
      </property>
      <property name="SystemStatusBar">
        <docstr>System status bar settings on mobile platforms.</docstr>
      </property>
      <property name="Transparency">
        <docstr>Indicates whether the form is transparent or not.
Use Transparency to determine whether the form is displayed as a totally transparent one. However, note that in this situation, all the controls will not be transparent and will be displayed normally. Only the form&apos;s background will be set to a transparent state.
If you set Transparency to True, the form will not display its title bar, nor its border. This means that you need to apply programmatic methods (involving setting of the Top and Left properties) to move the form on the screen surface.</docstr>
      </property>
      <property name="Width">
        <docstr>Specifies the horizontal size of the form (in pixels).
Use the Width property to read or change the width of the form.</docstr>
      </property>
      <property name="Height">
        <docstr>Specifies the vertical size of the form (in pixels).
Use the Height property to read or change the height of the form.</docstr>
      </property>
      <property name="Constraints">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Visible">
        <docstr>Indicates whether the form is visible.
Use Visible to determine whether the form is visible.
If Visible is True, the form is visible unless it is completely obscured by other forms. If Visible is False, the form is not visible.
The Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.</docstr>
      </property>
      <property name="WindowState">
        <docstr>Represents how the form appears on the screen.
Set WindowState to minimize, maximize, or restore the form window. Read WindowState to determine whether the form is minimized, maximized, or in a normal state.
Possible values for the WindowState property are:

wsMaximized
wsMinimized
wsNormal</docstr>
      </property>
      <property name="WindowStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FullScreen">
        <docstr>Indicates whether the form is in fullscreen mode.
Use FullScreen to specify whether the form is in fullscreen mode.</docstr>
      </property>
      <property name="ShowFullScreenIcon">
        <docstr>Indicates whether the Mac fullscreen icon is visible.
Use ShowFullScreenIcon to specify whether the Mac fullscreen icon  or  is visible. 

Note: ShowFullScreenIcon has no visible effect in Windows.</docstr>
      </property>
      <property name="FormFactor">
        <docstr>Specifies the form factor for this FireMonkey form, that is, the TFormFactor properties: width, height, orientations, and devices.</docstr>
      </property>
      <property name="FormFamily">
        <docstr>Is a string property that specifies the form family this form is part of. 
The logic can choose a different form as the main form depending on size, if an app has several forms with the same .FormFamily value as the app&apos;s main form.</docstr>
      </property>
      <property name="SaveState">
        <docstr>Specifies the save state of the FireMonkey form.  
The SaveState property is an instance of the TFormSaveState class, used to save the state of a form so this state can be restored once the application is restarted.</docstr>
      </property>
      <property name="ShowHint">
        <docstr>Determines whether help hints are enabled or disabled for first level child controls in the form.
For more information about the rules for enabling hints for a control, see   Using Hints to Show Contextual Help in a FireMonkey Application.
 TCommonCustomForm.ShowHint is a Boolean property set as True by default. When you place a child control in the form, and set the  TControl.Hint property, the hint is displayed because the TControl.ParentShowHint is True by default.
If the  TCommonCustomForm.ShowHint property of the form is set to False, the hint is not displayed in the child control.
To show the hint for a control, even when the  TCommonCustomForm.ShowHint property of the form is set to False, set  TControl.ShowHint for the control to True.</docstr>
      </property>
      <event name="OnCreate">
        <docstr>Occurs when the form is created.
Use OnCreate to perform special processing when the form is created and is invoked by the constructor. Either implement this event or override the constructor of the form; do not perform both actions. Any objects created in the OnCreate event should be freed by the OnDestroy event.
When a form is being created and its Visible property is True, the following events occur in the order listed:

OnCreate
OnActivate</docstr>
      </event>
      <event name="OnDestroy">
        <docstr>Occurs when the form is destroyed.
Use OnDestroy to perform special processing when the form is destroyed. Either implement this event or override the destructor of the class, but not both. This event should destroy any objects created in the OnCreate event.</docstr>
      </event>
      <event name="OnClose">
        <docstr>Occurs when the form closes.
Use OnClose to perform special processing when the form closes. The OnClose event specifies which event handler to call when a form is about to close. The handler specified by OnClose might, for example, test that all fields in a data entry form have valid contents before allowing the form to close.
A form is closed by the Close method or when the user chooses Close from the form&apos;s system menu.
The TCloseEvent type points to a method that handles the closing of a form. The value of the Action parameter determines whether the form actually closes. 
The following table lists the possible values of Action:




Value

Meaning



caNone



The form is not allowed to close, so nothing happens.




caHide



The form is not closed, but just hidden. Your application can still access a hidden form. This is the default value for Action.




caFree



The form is closed and all allocated memory for the form is freed.




caMinimize



The form is minimized, rather than closed.



By default, Action is set to caHide.
To close the form and free it in an OnClose event, set Action to caFree.

Note: When the application shuts down, the main form receives an OnClose event, but any child forms do not receive the OnClose event.</docstr>
      </event>
      <event name="OnCloseQuery">
        <docstr>Occurs when there is an attempt to close the form.
Use OnCloseQuery to specify the conditions under which the form can close. An OnCloseQuery event handler returns a Boolean CanClose value that determines whether a form is allowed to close. Its default value is True. 
You can use an OnCloseQuery event handler to ask users whether they are sure they want the form closed immediately. For example, you can use the handler to display a message box that prompts the user to save a file before closing the form.
The TCloseQueryEvent type points to the method that determines whether a form can be closed. The value of the CanClose parameter determines whether the form can be closed or not.</docstr>
      </event>
      <event name="OnActivate">
        <docstr>Occurs when the form becomes active.
Use OnActivate to perform special processing when the form receives focus. A form becomes active when the focus is transferred to it (when the user clicks in the form, for example).</docstr>
      </event>
      <event name="OnDeactivate">
        <docstr>Occurs when the form loses focus.
Use OnDeactivate to perform special processing when the active form becomes inactive and another form in the same application becomes the active one.</docstr>
      </event>
      <event name="OnKeyDown">
        <docstr>Occurs when a key is pressed while the form has focus.
OnKeyDown also occurs when KeyDown is called.
Write an event handler for OnKeyDown to specify what happens when the form is in focus and a key is pressed.</docstr>
      </event>
      <event name="OnKeyUp">
        <docstr>Occurs when a key is released while the form has focus.
OnKeyUp also occurs when KeyUp is called.
Write an event handler for OnKeyUp to specify what happens when the form is in focus and a key is released.</docstr>
      </event>
      <event name="OnMouseDown">
        <docstr>Occurs when a mouse button is pressed over the form. 
OnMouseDown also occurs when MouseDown is called.
Write an event handler for OnMouseDown to specify what happens when one of the mouse buttons is pressed over the form.</docstr>
      </event>
      <event name="OnMouseMove">
        <docstr>Occurs when the mouse cursor moves while over the form area. 
OnMouseMove also occurs when MouseMove is called.
Write an event handler for OnMouseMove to specify what happens when the mouse pointer is moved while over the form area.</docstr>
      </event>
      <event name="OnMouseUp">
        <docstr>Occurs when the mouse button that was pressed over the form is released. 
OnMouseUp also occurs when MouseUp is called.
Write an event handler for OnMouseUp to specify what happens when the button of the mouse that was pressed over the form is released.</docstr>
      </event>
      <event name="OnMouseWheel">
        <docstr>Occurs when the mouse wheel moves while the form has focus. 
OnMouseWheel also occurs when MouseWheel is called.

Note: On OS X platforms, this function can be called when the mouse wheel is moved while the mouse pointer is over the window. It is not necessary for the window to have focus. 
Write an event handler for OnMouseWheel to specify what happens when the mouse wheel is moved while the form is in focus.</docstr>
      </event>
      <event name="OnResize">
        <docstr>Occurs immediately after the form is resized.
Use OnResize to make any final adjustments after the form is resized.
OnResize is an event handler of type TNotifyEvent.</docstr>
      </event>
      <event name="OnConstrainedResize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnShow">
        <docstr>Occurs when the form is shown (that is, when its Visible property is set to True).
Use OnShow to perform special processing when the form is shown (that is, when the form&apos;s Visible property is set to True).</docstr>
      </event>
      <event name="OnHide">
        <docstr>Occurs when the form is hidden (that is, when its Visible property is set to False).
Use OnHide to perform special processing when the form is hidden (that is, when the form&apos;s Visible property is set to False).</docstr>
      </event>
      <event name="OnFocusChanged">
        <docstr>Occurs when the current Form loses the focus.
Use OnFocusChanged to manage custom actions in case the focus changes from the current form to another control.</docstr>
      </event>
      <event name="OnVirtualKeyboardShown">
        <docstr>Occurs when the virtual keyboard of the form is shown.
Use OnVirtualKeyboardShown to perform special processing when the virtual keyboard of the form is shown.
The Sender parameter of the  event handler identifies the form that called the event handler. The Bounds parameter of the  event handler specifies the screen coordinates of the window of the virtual keyboard.</docstr>
      </event>
      <event name="OnVirtualKeyboardHidden">
        <docstr>Occurs when the virtual keyboard of the form is hidden.
Use OnVirtualKeyboardHidden to perform special processing when the virtual keyboard of the form is hidden.
The Sender parameter of the  event handler identifies the form that called the event handler. The Bounds parameter of the  event handler specifies the screen coordinates of the window of the virtual keyboard.</docstr>
      </event>
      <event name="OnSaveState">
        <docstr>Occurs when the form is about to go to background on mobile devices or when the form is about to be closed on desktop. 
Any form-related data should be saved during the OnSaveState event so this data can be restored once the application is restarted.</docstr>
      </event>
      <property name="Touch">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <event name="OnGesture">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnTap">
        <docstr>Occurs when a user taps the form using a finger or a similar device (not a mouse).
Write an event handler for OnTap to specify what happens when the user taps the form.</docstr>
      </event>
      <event name="OnTouch">
        <docstr>Occurs when the user touches the form area.
You can implement an event handler to manage custom actions when OnTouch occurs.
Note: The number of touch points is platform-specific.</docstr>
      </event>
      <property name="Left">
        <docstr>Specifies the X coordinate of the upper-left corner of the form, relative to the screen.
Use Left to locate the top of the form or reposition the form to a different X coordinate. The Left property, like the Top property, is the position of the form relative to its container (the screen), in pixels.</docstr>
      </property>
      <property name="Top">
        <docstr>Specifies the Y coordinate of the upper-left corner of the form, relative to the screen.
Use Top to locate the top of the form or reposition the form to a different Y coordinate. The Top property, like the Left property, is the position of the form relative to its container (the screen), in pixels.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Forms" name="TCustomForm">
    <docstr>TCustomForm represents the base class from which you derive other windows such as dialog boxes and forms.
Create a subclass derived from TCustomForm if you want to create new forms such as dialog boxes. A derived form can contain one or more FireMonkey objects, such as TLabel, TComboBox, and so on.
Note that every descendant of TCustomForm is a 2D FireMonkey form or dialog box.</docstr>
    <members>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Forms.TCustomForm.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.Forms.TCustomForm.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoDeleteChildren">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ChangeChildren">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="UpdateStyleBook">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ApplyStyleLookup">
        <docstr>Applies the style for this form.</docstr>
      </procedure>
      <procedure name="AddPreloadPropertyNames">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetPreloadProperties">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoPaint">
        <docstr>Fires an OnPaint event.</docstr>
      </procedure>
      <function name="GetStyleObject">
        <docstr>Gets the style resource object linked to this form.
GetStyleObject is called when the style is applied through a call to the ApplyStyleLookup method.
GetStyleObject internally calls LookupStyleObject.</docstr>
      </function>
      <procedure name="PaintBackground">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="CreateHandle">
        <docstr>Creates the window for this form and assigns it a handle.
FMX.Forms.TCustomForm.CreateHandle inherits from FMX.Forms.TCommonCustomForm.CreateHandle. All content below this line refers to FMX.Forms.TCommonCustomForm.CreateHandle.
Creates the window for this form and assigns it a handle. CreateHandle is overridden in subclasses to add extra functionality when creating the window containing this form.</docstr>
      </procedure>
      <procedure name="DestroyHandle">
        <docstr>Destroys the window handle created by CreateHandle.
FMX.Forms.TCustomForm.DestroyHandle inherits from FMX.Forms.TCommonCustomForm.DestroyHandle. All content below this line refers to FMX.Forms.TCommonCustomForm.DestroyHandle.
Destroys the window handle created by CreateHandle. DestroyHandle is overridden in subclasses to add extra functionality when destroying the window containing this form.</docstr>
      </procedure>
      <procedure name="ResizeHandle">
        <docstr>Resizes this form according to ClientWidth and ClientHeight.
FMX.Forms.TCustomForm.ResizeHandle inherits from FMX.Forms.TCommonCustomForm.ResizeHandle. All content below this line refers to FMX.Forms.TCommonCustomForm.ResizeHandle.
Resizes this form according to ClientWidth and ClientHeight.
ResizeHandle is overridden in subclasses to implement functionality to resize the dimensions of this form according to the values of the ClientWidth and ClientHeight properties.</docstr>
      </procedure>
      <procedure name="PaintRects">
        <docstr>Repaints all the rectangles given through the UpdateRects parameter.
FMX.Forms.TCustomForm.PaintRects inherits from FMX.Forms.TCommonCustomForm.PaintRects. All content below this line refers to FMX.Forms.TCommonCustomForm.PaintRects.
Repaints all the rectangles given through the UpdateRects parameter. UpdateRects is an array of TRectF rectangles.</docstr>
      </procedure>
      <procedure name="RecreateCanvas">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RecalcControlsUpdateRect">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Realign">
        <docstr>Realigns all the child objects of this form and repaints the form&apos;s surface by a call to InvalidateRect. 
FMX.Forms.TCustomForm.Realign inherits from FMX.Forms.TCommonCustomForm.Realign. All content below this line refers to FMX.Forms.TCommonCustomForm.Realign.
Realigns all the child objects of this form and repaints the form&apos;s surface by a call to InvalidateRect.</docstr>
      </procedure>
      <procedure name="DoScaleChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoStyleChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetWindowStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="StyleChangedHandler">
        <docstr>Event handler for the event that occurs when there is a style change.
FMX.Forms.TCustomForm.StyleChangedHandler inherits from FMX.Forms.TCommonCustomForm.StyleChangedHandler. All content below this line refers to FMX.Forms.TCommonCustomForm.StyleChangedHandler.
Event handler for the event that occurs when there is a style change.
Note: When there is a style change, the control sends a TStyleChangedMessage message.

 See Also
FMX.Forms.TCommonCustomForm.ScaleChangedHandler
FMX.Controls.TStyleChangedMessage</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates and initializes this form.
FMX.Forms.TCustomForm.Create inherits from FMX.Forms.TCommonCustomForm.Create. All content below this line refers to FMX.Forms.TCommonCustomForm.Create.
Creates and initializes this form.
Create calls the inherited Create to create this form. Create
retrieves the IFMXWindowService,  IFMXCursorService,  
IFMXFullScreenWindowService, and
IFMXWindowsTouchService services.  
Create calls  InitializeNewForm to initialize such form parameters as bounds, width and height, border icons, style, border style, and client size for the form. 
AOwner specifies the owner of this form. 
An AOwner (usually the application) is responsible for freeing the created form.
Most applications do not call this constructor, but rather instantiate a descendant of TForm that is defined in the forms designer. Forms added to an application at design time are created automatically.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Forms.TCustomForm.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="InitializeNewForm">
        <docstr>Performs several initializations required by this form.
FMX.Forms.TCustomForm.InitializeNewForm inherits from FMX.Forms.TCommonCustomForm.InitializeNewForm. All content below this line refers to FMX.Forms.TCommonCustomForm.InitializeNewForm.
Performs several initializations required by this form.
These initializations include bounds, width and height, border icons, border style, and client size for the form. InitializeNewForm is used by the form constructors.</docstr>
      </procedure>
      <procedure name="EndUpdate">
        <docstr>Ends updating all the child controls in this form.
FMX.Forms.TCustomForm.EndUpdate inherits from FMX.Forms.TCommonCustomForm.EndUpdate. All content below this line refers to FMX.Forms.TCommonCustomForm.EndUpdate.
Ends updating all the child controls in this form.
EndUpdate ends updating all the child controls placed on this form, finalizing any updates you might have performed on the form or on multiple children. EndUpdate signals the end of an update operation and must be preceded by BeginUpdate and by the updates themselves.</docstr>
      </procedure>
      <procedure name="PaintTo">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RecreateResources">
        <docstr>Recreates the canvas  where the form renders itself.</docstr>
      </procedure>
      <property name="Canvas">
        <docstr>Provides access to the drawing area of the form.
Use Canvas to draw directly on the client area of the form.</docstr>
      </property>
      <property name="Fill">
        <docstr>Specifies the way the background on this form is filled.
Use Fill to get or set the brush that defines the way the background of this form is painted (gradient, solid, and so on).

Tip: Using a brush for Fill overrides the functionality of the Transparency property.</docstr>
      </property>
      <property name="Quality">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ActiveControl">
        <docstr>Specifies the active control on the form.
Use ActiveControl to get or set the active control (having the focus) on the form. Only one control can have the focus at a given time, in an application.
If the form does not have the focus, ActiveControl is the control, on the form, that receives the focus when the form itself receives the focus.</docstr>
      </property>
      <property name="StyleLookup">
        <docstr>Specifies the name of the style to look up and apply to this form. The FireMonkey Component Design help topic shows, among other useful things related to component designing, how to apply a style to a TPanel component.</docstr>
      </property>
      <event name="OnPaint">
        <docstr>Occurs when the form is redrawn.
Use OnPaint to perform special processing when the form is redrawn. Any special painting on the form should be done in this event. OnPaint occurs before any controls on the form are painted.

Tip: Notice that calling BeginScene in the OnPaint event handlers has no effect, because BeginScene is called before the OnPaint event handler runs. This guarantees that painting always occurs in OnPaint without requiring extra and probably unexpected code to allow drawing to have an effect.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Forms" name="TCustomPopupForm">
    <docstr>TCustomPopupForm represents the base class for FMX pop-up forms.
Create a subclass derived from TCustomPopupForm if you want to create new pop-up forms. A derived pop-up form can contain one or more FireMonkey objects, such as TLabel, TComboBox, and so on.
Note that every descendant of TCustomPopupForm is a 2D FireMonkey pop-up form.</docstr>
    <members>
      <procedure name="DoBeforeShow">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoBeforeClose">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoClose">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoPaddingChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoApplyPlacement">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.Forms.TCustomPopupForm.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <procedure name="Updated">
        <docstr>Clears the csUpdating state in the component&apos;s ComponentState property when the component finishes updating.
FMX.Forms.TCustomPopupForm.Updated inherits from System.Classes.TComponent.Updated. All content below this line refers to System.Classes.TComponent.Updated.
Clears the csUpdating state in the component&apos;s ComponentState property when the component finishes updating.
Do not call Updated directly. It is used internally to clear the csUpdating flag of the ComponentState property. A call to Updated always follows a call to Updating, which sets the flag.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Forms.TCustomPopupForm.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="DoAniTimer">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Realign">
        <docstr>Realigns all the child objects of this form and repaints the form&apos;s surface by a call to InvalidateRect. 
FMX.Forms.TCustomPopupForm.Realign inherits from FMX.Forms.TCommonCustomForm.Realign. All content below this line refers to FMX.Forms.TCommonCustomForm.Realign.
Realigns all the child objects of this form and repaints the form&apos;s surface by a call to InvalidateRect.</docstr>
      </procedure>
      <procedure name="DoRealPlacementChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="IsVisibleOnScreen">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates and initializes this pop-up form.
Create calls CreateNew, which creates this pop-up form and sets initial values to several properties of the created pop-up form. Then Create initializes the PlacementTarget, 
Parent, and StyleBook properties for the created pop-up form.  
AOwner specifies the owner of this pop-up form. The AOwner is responsible for freeing the created pop-up form.
AStyleBook specifies the style book to set for the StyleBook property of this pop-up form.  
APlacementTarget specifies the PlacementTarget property for this pop-up form.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Forms.TCustomPopupForm.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="ApplyPlacement">
        <docstr>Positions the current pop-up form.
ApplyPlacement positions the TCustomPopupForm pop-up form using the current Size and Placement properties.</docstr>
      </procedure>
      <function name="CanShow">
        <docstr>Retrieves whether the form is not visible.
First CanShow calls the inherited 
TCommonCustomForm.CanShow. If TCommonCustomForm.CanShow returns False, CanShow exits returning False. If TCommonCustomForm.CanShow returns True, CanShow initiates animation 
(AniDuration, AniPosition, DoAniTimer) and
exits returning True.</docstr>
      </function>
      <function name="CloseQuery">
        <docstr>Close-attempt event dispatcher.
FMX.Forms.TCustomPopupForm.CloseQuery inherits from FMX.Forms.TCommonCustomForm.CloseQuery. All content below this line refers to FMX.Forms.TCommonCustomForm.CloseQuery.
Close-attempt event dispatcher.
CloseQuery is called automatically when an attempt is made to close the form. CloseQuery can allow the form to close by returning True, or prevent the form from closing by returning False.
As implemented in TCommonCustomForm, CloseQuery calls the OnCloseQuery event handler, if it exists. If no such event handler exists, CloseQuery returns True.</docstr>
      </function>
      <property name="AniDuration">
        <docstr>Sets the animation duration for the pop-up form to close or to show.
AniDuration is measured in seconds.
AniDuration defines a duration time for execution of the custom event handler assigned to the OnAniTimer event of the current TCustomPopupForm pop-up form. 

Note: AniDuration does not influence onto an animation duration of an external animation (for example TFloatAnimation animation) if such is assigned to the TCustomPopupForm pop-up form. AniDuration is used for the custom event handler assigned to the OnAniTimer event.</docstr>
      </property>
      <property name="AniPosition">
        <docstr>Read-only property returning values between 0 and 1. You can use AniPosition in an OnAniTimer event handler.
The AniPosition value changes during AniDuration time of a custom animation execution from 0 to 1 (during opening of the current pop-up form) and from 1 to 0 (during closing) respectively.
AniPosition might be used as a parameter in intermediate values of animated properties in an OnAniTimer event handler. For example, you can use AniPosition to calculate an intermediate position or intermediate opacity during custom animation. Where AniPosition = 0 corresponds to a starting moment and AniPosition = 1 to a termination of opening animation.
For example, in the sample below the form Width (as a component of the form Size) changes from 0 (when AniPosition = 0) to 200 (when AniPosition = 1) during appearing of the pop-up form and vice versa on the form closing:

...
procedure TForm1.AniTimerProc(Sender: TObject);
begin
  if Sender is TCustomPopupForm then
  begin
//    You can use AniPosition whether to define Opacity or Size
//    TCustomPopupForm(Sender).ContentControl.Opacity := TCustomPopupForm(Sender).AniPosition;
    TCustomPopupForm(Sender).Size := TSize.Create(Round(200 * TCustomPopupForm(Sender).AniPosition), 100);
  end;
end;

procedure TForm1.Button1Click(Sender: TObject);
var
  R: TRectangle;
begin
  R := TRectangle.Create(Self);
  F := TCustomPopupForm.Create(Self);
  F.AniDuration := 0.5;
  F.ContentControl := R;
  F.OnAniTimer := AniTimerProc;
  F.PlacementTarget := Button1;
  F.Show;
end;
...

Commented line shows how to use AniPosition to animate a form transparency. 
See also discussion in TPopup.OnAniTimer.</docstr>
      </property>
      <property name="AutoFree">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ContentControl">
        <docstr>Specifies the control that is shown on the pop-up form.
If a pop-up form does not contain any visible control, then the pop-up form is totally transparent. Therefore, some visible control should be placed onto the pop-up form. This control is specified by the ContentControl property. 

Note: A ContentCtrl control can be associated to a PopupForm pop-up form using the Parent property of the control, like in the following example: ContentCtrl.Parent := ParentForm. However, we recommend using the ContentControl property like ParentForm.ContentControl := ContentCtrl, because  TCustomPopupForm handling ContentControl takes into account the current scale and rotation of the ContentCtrl control.</docstr>
      </property>
      <property name="ContentPadding">
        <docstr>Specifies the padding of the pop-up form. 
The ContentPadding of a pop-up form specifies how close, in pixels, the children of the form can come to each of the form edges (top, left, bottom, right). See also Padding.
The adhering of the pop-up form is executed to the boundaries of this indented &apos;padding rectangle&apos;.</docstr>
      </property>
      <property name="DragWithParent">
        <docstr>Specifies whether the current TCustomPopupForm can be dragged after it is shown.
For example, if DragWithParent is True, TCustomPopupForm is dragged together with its parent form when the parent form is the target of a drag-and-drop operation. When Placement is Mouse or MouseCenter, then the pop-up form moves following the mouse cursor. On mobile devices, after changing the orientation (portrait/landscape) the pop-up form can change its position in order not to be partially positioned outside of the screen boundaries. 
The default is True.</docstr>
      </property>
      <property name="HideWhenPlacementTargetInvisible">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Offset">
        <docstr>The offset of the padding rectangle  relative to the rectangle of the pop-up form.
Defines the number of pixels, by which the pop-up form is displaced  relatively to the main form position; this number is obtained taking into account all positioning properties used in the TCustomPopupForm class. The Offset direction depends on a Placement value. The Offset property is used, for example, in multi-level menus, when pop-up forms of submenus are placed overlapping a form of a previous level.</docstr>
      </property>
      <property name="Placement">
        <docstr>Gets or sets how the TCustomPopupForm is positioned relative to rectangles specified by the PlacementRectangle or PlacementTarget properties, relative to the screen, or relative to the mouse (pointing device) position.
TPlacement defines possible values of Placement.
TPlacement also specifies the behavior of the TCustomPopupForm, when it overlaps screen boundaries. The default value is Bottom.
This figure demonstrates the TopCenter value.

In the figure, ScreenPlacementRect is the colored Fuchsia rectangle of the Show popup button. 
Use Placement, PlacementTarget, and PlacementRectangle to set the positioning of TCustomPopupForm.</docstr>
      </property>
      <property name="PlacementRectangle">
        <docstr>Gets or sets a rectangle, relative to which the TCustomPopupForm is positioned. 
Screen coordinates of PlacementRectangle are calculated relative to PlacementTarget (if specified). Otherwise, relative to the top left corner of the screen. The following rules are used:

If PlacementRectangle is not specified (width or height equals to zero 0), but PlacementTarget is specified, then the coordinates and size of PlacementTarget are used.
If neither PlacementRectangle nor PlacementTarget are specified, then adhering of the top left corner of the form is implemented to the mouse cursor.
Use Placement, PlacementTarget, and PlacementRectangle to set the target origin and the alignment point of the TCustomPopupForm.</docstr>
      </property>
      <property name="PlacementTarget">
        <docstr>The target control, relative to which the TCustomPopupForm is positioned. 
If PlacementTarget is not set, and the TCustomPopupForm has a ParentForm, then the TCustomPopupForm is positioned relative to its parent. If PlacementTarget and ParentForm are not set, TCustomPopupForm is positioned relative to the main window. 
Use Placement, 
RealPlacement, and PlacementRectangle to set the target origin and the alignment point of TCustomPopupForm.</docstr>
      </property>
      <property name="PreferedDisplayIndex">
        <docstr>Specifies the index of the display that shows the pop-up form.
Specifies the index of the display in the Displays array that shows the current pop-up form.
PreferedDisplayIndex is used for context menus. When an application opens several submenus of context menus, all these submenus should be shown on the same display, even if a new pop-up submenu can be shown on a neighbor display.
If a specified PreferedDisplayIndex does not exist, then a pop-up form is shown on a display that is the closest to the place where the form should appear according to all specified positioning parameters Placement, PlacementTarget, and PlacementRectangle.</docstr>
      </property>
      <property name="RealPlacement">
        <docstr>Used internally.
The CreateNew constructor initializes RealPlacement equal to Placement. At run time RealPlacement can be changed according to the real environment properties. For example, if a run-time environment supports the mouse, then RealPlacement can be set to  
TPlacement.Mouse, otherwise to
TPlacement.Absolute.</docstr>
      </property>
      <property name="ScreenContentRect">
        <docstr>Screen coordinates of the rectangle relative to which controls in the pop-up form are positioned.
ScreenContentRect is the rectangle inside which all controls of the pop-up form are positioned. 
Notice that some &apos;decorative elements&apos;, like &apos;triangular peaks&apos; on  TCalloutPanel rectangles, can be positioned outside the ScreenContentRect.</docstr>
      </property>
      <property name="ScreenPlacementRect">
        <docstr>Screen coordinates of the rectangle relative to which the pop-up form is positioned.
ScreenPlacementRect is defined taking into account PlacementRectangle and PlacementTarget.

In the figure, ScreenPlacementRect is the colored Fuchsia rectangle of the Show popup button.</docstr>
      </property>
      <property name="Size">
        <docstr>The working area size of the current pop-up form.
Size defines the width and height of the working area of the current TCustomPopupForm pop-up form. Size defines the rectangle to which all controls of the form are aligned. 
In the following picture the Size rectangular of the pop-up form is specified with the green dashes. The physical rectangle of the pop-up form window (defined by Width and Height) is  marked with red dashes. 

As you see from the picture, the physical rectangle is not used for positioning. 
ClientWidth and ClientHeight of the working area  of the form are defined automatically according to the specified Size and Padding. If PlacementRectangle is defined and Placement is Absolute, then Size is ignored. 
Use a TSizeF object to set the Size of a pop-up form.  
For example, the following code will set up the working area width to 200 and height to 250: 

  Form1.Size := TSizeF.Create(200, 250);</docstr>
      </property>
      <event name="OnAniTimer">
        <docstr>Periodically occurs during TCustomPopupForm custom animation execution.
The OnAniTimer event periodically occurs during  AniDuration time while an animation executes during appearing and closing of the current pop-up form.
Write an OnAniTimer event handler to provide animation functionality during appearing and closing of a pop-up form. See the example in TPopup.OnAniTimer. 
AniDuration defines the custom animation duration in seconds. OnAniTimer can use AniPosition and other properties.</docstr>
      </event>
      <event name="BeforeShow">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="BeforeClose">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnRealPlacementChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Forms" name="TForm">
    <docstr>TForm represents a standard FireMonkey application window (form).
When you create forms in the Form designer at design time, they are implemented as descendants of TForm. Forms can represent the application&apos;s main window, or dialog boxes or various preferences-related windows. A form can contain any other FireMonkey objects, such as TButton, TCheckBox,  TComboBox objects, and so on.</docstr>
  </class>
  <class unit="FMX.Forms" name="TFrame">
    <docstr>TFrame is a container for components; it can be nested within forms or other frames.
When you create frames, they are implemented as descendants of TFrame.
A frame, like a form, is a container for other components. It uses the same ownership mechanism as forms for automatic instantiation and destruction of the components on it, and the same parent-child relationships for synchronization of component properties. But frames can be nested within forms or other frames, and they can be saved on the Component palette for easy reuse. After a frame is created and saved, it continues to function as a unit and to inherit changes from the components (including other frames) it contains. Moreover, an embedded frame continues to inherit changes made to the frame from which it is derived.</docstr>
    <members>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Forms.TFrame.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.Forms.TFrame.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.Forms.TFrame.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <procedure name="DoResized">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="CheckHitTest">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetVisible">
        <docstr>Getter function for the Visible property.
FMX.Forms.TFrame.GetVisible inherits from FMX.Controls.TControl.GetVisible. All content below this line refers to FMX.Controls.TControl.GetVisible.
Getter function for the Visible property.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Forms.TFrame.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <procedure name="AfterConstruction">
        <docstr>Responds after the last constructor has executed.
FMX.Forms.TFrame.AfterConstruction inherits from System.TObject.AfterConstruction. All content below this line refers to System.TObject.AfterConstruction.
Responds after the last constructor has executed.
AfterConstruction is called automatically after the object&apos;s last constructor has executed. Do not call it explicitly in your applications. 
The AfterConstruction method implemented in TObject does nothing. Override this method when creating a class that performs an action after the object is created. For example, TCustomForm overrides AfterConstruction to generate an OnCreate event.</docstr>
      </procedure>
      <procedure name="GetChildren">
        <docstr>Enumerates all child components.
FMX.Forms.TFrame.GetChildren inherits from System.Classes.TComponent.GetChildren. All content below this line refers to System.Classes.TComponent.GetChildren.
Enumerates all child components.
GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
GetChildren expects a TGetChildProc routine that receives all enumerated components. 
Root represents the owner of the components that will be enumerated.
This method does nothing in TComponent and is expected to be overridden in descendants.</docstr>
      </procedure>
      <function name="ShouldTestMouseHits">
        <docstr>Indicates whether a control should be ignored in ObjectAtPoint.
FMX.Forms.TFrame.ShouldTestMouseHits inherits from FMX.Controls.TControl.ShouldTestMouseHits. All content below this line refers to FMX.Controls.TControl.ShouldTestMouseHits.
Indicates whether a control should be ignored in ObjectAtPoint.
False if the control should be ignored in ObjectAtPoint. ShouldTestMouseHits normally returns the same value as the value of Visible property of the control.
TFrame overrides this method to allow itself to be painted in design time regardless of the value of its Visible property.

 See Also
FMX.Forms.TFrame
FMX.Controls.TControl.ObjectAtPoint
FMX.Controls.TControl.Visible</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.Forms" name="TScreen">
    <docstr></docstr>
    <members>
      <function name="Size">
        <docstr>The size of primary display.</docstr>
      </function>
      <function name="GetDesktopCenterRect">
        <docstr>Tries to return a rectangular having the specified Size and positioned in the center of the desktop.
           See also IFMXMultiDisplayService.GetDesktopCenterRect</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.ScrollBox" name="TScrollContentSize">
    <docstr></docstr>
    <members>
      <procedure name="DoChanged">
        <docstr>Notifies abount changed size (Width, Height)</docstr>
      </procedure>
      <function name="GetOwner">
        <docstr>Returns owenr of the Data</docstr>
      </function>
      <property name="ScrollBox">
        <docstr>Link on Owner ScrollBox</docstr>
      </property>
      <property name="Size">
        <docstr>Size of content</docstr>
      </property>
      <event name="OnChange">
        <docstr>Event, which is invoked, when size was changed</docstr>
      </event>
      <property name="Width">
        <docstr>Width of content</docstr>
      </property>
      <property name="Height">
        <docstr>Height of content</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.ScrollBox" name="TCustomScrollBoxModel">
    <docstr></docstr>
    <members>
      <procedure name="DoViewportPositionChange">
        <docstr>Invoked, when ScrollBox changed content position or size</docstr>
      </procedure>
      <function name="IsOpaque">
        <docstr>Need ScrollBox updates effects, when content is scrolled? (False by default)</docstr>
      </function>
      <property name="ContentBounds">
        <docstr>Returns current content bounds. If content bounds size is calculati</docstr>
      </property>
      <property name="AutoHide">
        <docstr>Defines that scrollbars are automatically hiding when scroll is done</docstr>
      </property>
      <property name="Bounces">
        <docstr>Whether it is possible to scroll of content abroad</docstr>
      </property>
      <property name="ContentSize">
        <docstr>Current content size</docstr>
      </property>
      <property name="EnabledScroll">
        <docstr>Enable or disabled scroll</docstr>
      </property>
      <property name="ScrollAnimation">
        <docstr>Enable or disabled scrolling animation</docstr>
      </property>
      <property name="ScrollDirections">
        <docstr>Defines avaiable scroll directions</docstr>
      </property>
      <property name="ShowScrollBars">
        <docstr>Defines scrollbars visibility</docstr>
      </property>
      <property name="ShowSizeGrip">
        <docstr>Shows small control in the right-bottom corner that represent size changin control</docstr>
      </property>
      <property name="TouchTracking">
        <docstr>Defines that control reacts on touch events</docstr>
      </property>
      <property name="ViewportSize">
        <docstr>Returns the size of displaing area</docstr>
      </property>
      <event name="OnCalcContentBounds">
        <docstr>Event that raises after control calculates its content size</docstr>
      </event>
      <event name="OnViewportPositionChange">
        <docstr>Raises when the value of ViewportPosition was changed</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.ScrollBox" name="TScrollContent">
    <docstr></docstr>
    <members>
      <property name="ScrollBox">
        <docstr>Link to the ScrollBox that owns currect content instance</docstr>
      </property>
      <event name="OnGetClipRect">
        <docstr>The handler for this event should return the clip rectangle</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.ScrollBox" name="TCustomPresentedScrollBox">
    <docstr></docstr>
    <members>
      <procedure name="Loaded">
        <docstr>Initializes the control after the form file has been read into memory and loads its presentation.
FMX.ScrollBox.TCustomPresentedScrollBox.Loaded inherits from FMX.Controls.Presentation.TPresentedControl.Loaded. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Loaded.
Initializes the control after the form file has been read into memory and loads its presentation.
For details, see TControl.Loaded.

 See Also
FMX.Controls.Presentation.TPresentedControl.LoadPresentation
FMX.Controls.TControl.Loaded</docstr>
      </procedure>
      <procedure name="PaddingChanged">
        <docstr>Applies the padding to the content of the TPresentedScrollBox.</docstr>
      </procedure>
      <function name="CreateScrollContent">
        <docstr>Creates scroll content.
You can override it for creating custom content. It allows to add custom information to the content.</docstr>
      </function>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.ScrollBox.TCustomPresentedScrollBox.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoInsertObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="PaintChildren">
        <docstr>Renders the child controls.
FMX.ScrollBox.TCustomPresentedScrollBox.PaintChildren inherits from FMX.Controls.TControl.PaintChildren. All content below this line refers to FMX.Controls.TControl.PaintChildren.
Renders the child controls.
The PaintChildren method is called automatically in the process of painting of the current control. It renders child controls, if any, on the surface specified by the Canvas property. 
The effects that are applied to the control are also applied to its children.
TControl descendants can override PaintChildren to provide specific rendering of the respective controls.</docstr>
      </procedure>
      <function name="DoCalcContentBounds">
        <docstr>Calculates content bounds by building convex shell of all children controls of Content.
If ScrollBox uses Horizontal or Vertical 
ScrollDirections mode, it restricts the content size by height or width.</docstr>
      </function>
      <function name="IsAddToContent">
        <docstr>Defines, if necessary, to add AObject to the Content or not.</docstr>
      </function>
      <procedure name="ContentAddObject">
        <docstr>This method is invoked when you add a new Object into the Content children list.</docstr>
      </procedure>
      <procedure name="ContentInsertObject">
        <docstr>This method is invoked when you insert a new Object into the Content children list.</docstr>
      </procedure>
      <procedure name="ContentBeforeRemoveObject">
        <docstr>This method is invoked before removing an Object from the Content children list.</docstr>
      </procedure>
      <procedure name="ContentRemoveObject">
        <docstr>This method is invoked when you remove an Object from the Content children list.</docstr>
      </procedure>
      <function name="IsOpaque">
        <docstr>Indicates if the control should update effects when you scroll content.
Its default value is False, meaning that the control does not update effects.</docstr>
      </function>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.ScrollBox.TCustomPresentedScrollBox.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <property name="AniCalculations">
        <docstr>Returns the instance to the class that provides scrolling physics calculations.
AniCalculations is only available for style presentation. For native presentation, it returns null/nil.</docstr>
      </property>
      <procedure name="MouseWheel">
        <docstr>OnMouseWheel event dispatcher for TCustomPresentedScrollBox.
MouseWheel accepts the following parameters:

Shift: Specifies which keys are pressed when a mouse button is released. See TShiftState for possible values.
WheelDelta: The distance that the wheel rotates. WheelDelta is positive if the wheel rotates upward, negative otherwise.
Handled: Indicates whether the scroll bar was already moved. If one of the scrolls bars (vertical or horizontal) was already handled or it does not exist, MouseWheel tries to apply the action on the other scroll bar (if the other scroll bar exists).
Unlike the parent method, TControl.MouseWheel, this method also handles the mouse wheel events in design-time.</docstr>
      </procedure>
      <function name="DefineModelClass">
        <docstr>Returns a class reference to a data model of this presented control.
FMX.ScrollBox.TCustomPresentedScrollBox.DefineModelClass inherits from FMX.Controls.Presentation.TPresentedControl.DefineModelClass. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefineModelClass.
Returns a class reference to a data model of this presented control.
Returns a class reference to a data model class that the constructor of this presented control uses to create a data model for the control.
By default DefineModelClass returns TDataModel. Descendant classes reimplement DefineModelClass to determine the data model class that a descendant presented control uses for its data model.

 See Also
FMX.Controls.Model.TDataModelClass
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Presentation.Style.TStyledPresentation.DefineModelClass
Class References</docstr>
      </function>
      <procedure name="InitPresentation">
        <docstr>Sends initialization data to the presentation layer through its presentation proxy.
FMX.ScrollBox.TCustomPresentedScrollBox.InitPresentation inherits from FMX.Controls.Presentation.TPresentedControl.InitPresentation. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.InitPresentation.
Sends initialization data to the presentation layer through its presentation proxy.
After LoadPresentation creates a new presentation proxy, it calls InitPresentation.

 See Also
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Controls.Presentation.TPresentedControl.LoadPresentation</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.ScrollBox.TCustomPresentedScrollBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <procedure name="ScrollBy">
        <docstr>Changes the scroll position by the offset defined in ADX and ADY.</docstr>
      </procedure>
      <procedure name="ScrollTo">
        <docstr>Changes the scroll position to the value defined by AX and AY.
ScrollTo uses the value of the ViewportPosition property to calculate the offset and then calls ScrollBy.</docstr>
      </procedure>
      <procedure name="ScrollToTop">
        <docstr>Changes the scroll position to the top.</docstr>
      </procedure>
      <procedure name="ScrollToCenter">
        <docstr>Changes the scroll position to the center of the content size.</docstr>
      </procedure>
      <procedure name="InViewRect">
        <docstr>Scrolls the content to the rectangle defined in ARect.</docstr>
      </procedure>
      <procedure name="Sort">
        <docstr>Sorts the children in the children list using the specified sorting procedure.
FMX.ScrollBox.TCustomPresentedScrollBox.Sort inherits from FMX.Types.TFmxObject.Sort. All content below this line refers to FMX.Types.TFmxObject.Sort.
Sorts the children in the children list using the specified sorting procedure.</docstr>
      </procedure>
      <function name="GetTabList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="UpdateContentSize">
        <docstr>Recalculates content bounds of a scroll box.
This method does not calculate content bounds if AutoCalculateContentSize is False or if the state of the scroll box is csLoading or csDestroying.
See also ContentBounds.</docstr>
      </procedure>
      <procedure name="RealignContent">
        <docstr>Forces the update of the content size calculation.</docstr>
      </procedure>
      <property name="Content">
        <docstr>Container that can hold scrollable content of the scroll box.
Contains controls placed into the scroll box. Content does not contain a style object, any kind of Animation or effect objects.</docstr>
      </property>
      <property name="ContentBounds">
        <docstr>The content bounds.
This property is read-only if AutoCalculateContentSize is True. To update the content bounds when AutoCalculateContentSize is True, call UpdateContentSize.</docstr>
      </property>
      <procedure name="ClearContent">
        <docstr>Removes all controls from the content.</docstr>
      </procedure>
      <property name="Model">
        <docstr>Data model that represents the data used by the presentation of the current control.

The constructor of your presented control creates a data model. The class of the data model is the class that DefineModelClass returns.</docstr>
      </property>
      <property name="ViewportPosition">
        <docstr>Position of the view port of the ScrollBox content.
ViewportPosition is set in local coordinates of the Content.</docstr>
      </property>
      <property name="ViewportSize">
        <docstr>Size of the view port of the ScrollBox content.</docstr>
      </property>
      <property name="VScrollBar">
        <docstr>Returns the vertical scrollbar component.
VScrollBar is only available for style presentation. For native presentation, it returns null/nil.</docstr>
      </property>
      <property name="HScrollBar">
        <docstr>Returns the horizontal scrollbar component.
HScrollBar is only available for style presentation. For native presentation, it returns null/nil.</docstr>
      </property>
      <property name="ContentLayout">
        <docstr>Returns the control from style that will wrap its scrolling content.
ContentLayout is used by internal methods to get the list of components in the scrollbox and represents the parent for all of them.</docstr>
      </property>
      <property name="AutoCalculateContentSize">
        <docstr>Indicates that the size of the scrolling content is calculated automatically according to the size of the components in content.
Otherwise, the value of the ContentSize property defines the content size.</docstr>
      </property>
      <property name="AutoHide">
        <docstr>Defines that scrollbars hide automatically when you scroll. AutoHide can be used to force the scrollbars to display.</docstr>
      </property>
      <property name="Bounces">
        <docstr>Indicates if it is possible to scroll content abroad.</docstr>
      </property>
      <property name="ContentSize">
        <docstr>Current content size.</docstr>
      </property>
      <property name="DisableMouseWheel">
        <docstr>Defines that the control does not have reaction to Mouse-Wheel event.</docstr>
      </property>
      <property name="EnabledScroll">
        <docstr>Enables or disables scrolling.</docstr>
      </property>
      <property name="ScrollAnimation">
        <docstr>Enables or disables scrolling animation.</docstr>
      </property>
      <property name="ScrollDirections">
        <docstr>Defines the available scroll directions.</docstr>
      </property>
      <property name="ShowScrollBars">
        <docstr>Defines scrollbars visibility.</docstr>
      </property>
      <property name="ShowSizeGrip">
        <docstr>Shows a small control in the right-bottom corner that represents the size of the changing control.</docstr>
      </property>
      <property name="TouchTracking">
        <docstr>Defines if the control reacts to touch events.</docstr>
      </property>
      <event name="OnCalcContentBounds">
        <docstr>Event that raises after the control calculates its content size.
It is raised only when AutoCalculateContentSize is True.</docstr>
      </event>
      <event name="OnViewportPositionChange">
        <docstr>Raises when the value of ViewportPosition was changed.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.ScrollBox" name="TCustomPresentedVertScrollBox">
    <docstr></docstr>
    <members>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.ScrollBox.TCustomPresentedVertScrollBox.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.ScrollBox.TCustomPresentedVertScrollBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.ScrollBox" name="TCustomPresentedHorzScrollBox">
    <docstr></docstr>
    <members>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.ScrollBox.TCustomPresentedHorzScrollBox.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.ScrollBox.TCustomPresentedHorzScrollBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.ScrollBox" name="TCustomPresentedFramedScrollBox">
    <docstr></docstr>
    <members>
      <function name="IsOpaque">
        <docstr>Indicates if the control should update effects when you scroll content.
FMX.ScrollBox.TCustomPresentedFramedScrollBox.IsOpaque inherits from FMX.ScrollBox.TCustomPresentedScrollBox.IsOpaque. All content below this line refers to FMX.ScrollBox.TCustomPresentedScrollBox.IsOpaque.
Indicates if the control should update effects when you scroll content.
Its default value is False, meaning that the control does not update effects.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.ScrollBox" name="TCustomPresentedFramedVertScrollBox">
    <docstr></docstr>
    <members>
      <function name="IsOpaque">
        <docstr>Indicates if the control should update effects when you scroll content.
FMX.ScrollBox.TCustomPresentedFramedVertScrollBox.IsOpaque inherits from FMX.ScrollBox.TCustomPresentedScrollBox.IsOpaque. All content below this line refers to FMX.ScrollBox.TCustomPresentedScrollBox.IsOpaque.
Indicates if the control should update effects when you scroll content.
Its default value is False, meaning that the control does not update effects.</docstr>
      </function>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.ScrollBox.TCustomPresentedFramedVertScrollBox.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.BufferedLayout" name="TBufferedLayout">
    <docstr>A layout is a container for other graphical objects.
FMX.BufferedLayout.TCustomBufferedLayout inherits from FMX.Layouts.TLayout. All content below this line refers to FMX.Layouts.TLayout.
A layout is a container for other graphical objects. 
Use the layouts when you need to organize multiple graphical controls under the same parent.
For instance, you can use these layouts when you need to create rich FireMonkey applications with many graphical controls that are grouped on the same layer. You can set the visibility of all the controls on a layout at once by affecting the visibility of the layout.</docstr>
  </class>
  <class unit="FMX.ComboEdit" name="TComboEditBase">
    <docstr>The base class for edit boxes having a list of predefined choices.
TComboEditBase extends TCustomEdit defining the DropDown method.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.ComboEdit.TComboEditBase.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <procedure name="DropDown">
        <docstr>Executes internally when the edit control is left-clicked.
DropDown is overridden by edit controls that have pop-up windows that open and close when the edit control is left-clicked.
If the pop-up window is open, then DropDown closes the pop-up window. Else, it opens it.</docstr>
      </procedure>
      <procedure name="CloseDropDown">
        <docstr>Tries to close the drop-down list.
CloseDropDown sends a PM_CLOSE_DROPDOWN message to the presentation layer through its presentation proxy.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.ComboEdit" name="TCustomComboEdit">
    <docstr>The base class, implementing the basic functionality, for edit boxes having a list of predefined choices.
TCustomComboEdit extends TComboEditBase implementing the basic functionality for edit boxes having a list of predefined choices.
TCustomComboEdit is a presented control. Its data model is TComboEditModel and presentation is TStyledComboEdit.</docstr>
    <members>
      <function name="DefineModelClass">
        <docstr>Returns a class reference to a data model of this presented control.
FMX.ComboEdit.TCustomComboEdit.DefineModelClass inherits from FMX.Controls.Presentation.TPresentedControl.DefineModelClass. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefineModelClass.
Returns a class reference to a data model of this presented control.
Returns a class reference to a data model class that the constructor of this presented control uses to create a data model for the control.
By default DefineModelClass returns TDataModel. Descendant classes reimplement DefineModelClass to determine the data model class that a descendant presented control uses for its data model.

 See Also
FMX.Controls.Model.TDataModelClass
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Presentation.Style.TStyledPresentation.DefineModelClass
Class References</docstr>
      </function>
      <function name="DefinePresentationName">
        <docstr>Returns the name of the default presentation proxy that your presented control uses.
FMX.ComboEdit.TCustomComboEdit.DefinePresentationName inherits from FMX.Controls.Presentation.TPresentedControl.DefinePresentationName. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefinePresentationName.
Returns the name of the default presentation proxy that your presented control uses.
You can handle OnPresentationNameChoosing to specify a presentation proxy name to use instead of the name that DefinePresentationName returns.
DefinePresentationName  calls TPresentationProxyFactory.GeneratePresentationName and returns a generated  presentation proxy name based on the class name of the presented control and the control type (Styled or Platform) of the presentation layer. For example:



Class name

Control type

Result


TMyPresentedControl

Styled

&quot;MyPresentedControl-Styled&quot;


TMyPresentedControl

Platform

&quot;MyPresentedControl-Platform&quot;

 See Also
System.TObject.ClassName
FMX.Controls.Presentation.TPresentedControl.ControlType
FMX.Presentation.Factory.TPresentationProxyFactory.Register
FMX.Controls.Presentation.TPresentationProxy
FMX.Controls.Presentation.TPresentedControl.OnPresentationNameChoosing
FMX.Controls.Presentation.TPresentedControl.LoadPresentation</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.ComboEdit.TCustomComboEdit.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <procedure name="Clear">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="Model">
        <docstr>The data model representing the data used by the presentation of the current control.
FMX.ComboEdit.TCustomComboEdit.Model inherits from FMX.Controls.Presentation.TPresentedControl.Model. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Model.
The data model representing the data used by the presentation of the current control.
The constructor of your presented control creates a data model for your presented control. The class of the data model is the class that DefineModelClass returns.

 See Also
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Presentation
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.DefineModelClass</docstr>
      </property>
      <property name="DroppedDown">
        <docstr>Returns whether the drop-down box associated with the current TComboEdit object is visible.</docstr>
      </property>
      <property name="Count">
        <docstr>Count returns the number of items contained by the ListBox object.</docstr>
      </property>
      <property name="DropDownCount">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="DropDownKind">
        <docstr>Defines whether to use TCustomListPicker pickers providing platform-specific drop-down lists to select string items.
The TDropDownKind type is also used in the TComboEdit, 
TComboBox, and TPopupBox controls to define whether to use the TCustomListPicker picker to provide platform-specific controls to select string items from drop-down lists.</docstr>
      </property>
      <property name="ItemHeight">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ItemWidth">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Items">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ItemIndex">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ListBoxResource">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <event name="OnClosePopup">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnPopup">
        <docstr>Occurs just before the drop-drown list appears.
Write an OnPopup event handler to take specific action just before the drop-drown list appears.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.ComboEdit" name="TComboEdit">
    <docstr>An edit box with a list of predefined choices.
TComboEdit stores the predefined choices in its Items property, which can be edited at design time. 
TComboEdit encapsulates TComboEditListBox, which is displayed in the drop-down box when the right arrow icon is clicked. Although the ListBox object is fully exposed, we recommend that you use Items to access the list of items.</docstr>
  </class>
  <class unit="FMX.Grid" name="TColumn">
    <docstr></docstr>
    <members>
      <function name="GetText">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="TextStored">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetReadOnly">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetReadOnly">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Grid.TColumn.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.Grid.TColumn.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <procedure name="AncestorParentChanged">
        <docstr>Notifies its child controls that the parent of an ancestor of your control has changed.
FMX.Grid.TColumn.AncestorParentChanged inherits from FMX.Controls.TControl.AncestorParentChanged. All content below this line refers to FMX.Controls.TControl.AncestorParentChanged.
Notifies its child controls that the parent of an ancestor of your control has changed.

 See Also
FMX.Controls.TControl.ParentChanged
FMX.Controls.TControl.AncestorVisibleChanged
FMX.Controls.TControl.ChildrenAlignChanged
FMX.Controls.TControl.ClipChildrenChanged
FMX.Controls.TControl.EffectEnabledChanged
FMX.Controls.TControl.EnabledChanged
FMX.Controls.TControl.HandleSizeChanged
FMX.Controls.TControl.HitTestChanged
FMX.Controls.TControl.PaddingChanged</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Grid.TColumn.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="GetObservers">
        <docstr>Getter of Observers.
FMX.Grid.TColumn.GetObservers inherits from System.Classes.TComponent.GetObservers. All content below this line refers to System.Classes.TComponent.GetObservers.
Getter of Observers.</docstr>
      </function>
      <procedure name="EnabledChanged">
        <docstr>Executed right after the value of the Enabled property changes.
FMX.Grid.TColumn.EnabledChanged inherits from FMX.Controls.TControl.EnabledChanged. All content below this line refers to FMX.Controls.TControl.EnabledChanged.
Executed right after the value of the Enabled property changes.
The control does not execute EnabledChanged if you assign Enabled the same value that it already has.
EnabledChanged is never executed for effects, which execute EffectEnabledChanged instead.

 See Also
FMX.Controls.TControl.BeforeEffectEnabledChanged
FMX.Controls.TControl.EffectEnabledChanged
FMX.Controls.TControl.ClipChildrenChanged
FMX.Controls.TControl.HandleSizeChanged
FMX.Controls.TControl.HitTestChanged
FMX.Controls.TControl.PaddingChanged
FMX.Controls.TControl.ParentChanged
FMX.Controls.TControl.VisibleChanged
FMX.Controls.TControl.AncestorVisibleChanged
FMX.Controls.TControl.AncestorParentChanged
FMX.Controls.TControl.ChildrenAlignChanged</docstr>
      </procedure>
      <procedure name="VisibleChanged">
        <docstr>Executed right after the value of the Visible property changes.
FMX.Grid.TColumn.VisibleChanged inherits from FMX.Controls.TControl.VisibleChanged. All content below this line refers to FMX.Controls.TControl.VisibleChanged.
Executed right after the value of the Visible property changes.
The control does not execute VisibleChanged if you assign Visible the same value that it already has.

 See Also
FMX.Controls.TControl.ClipChildrenChanged
FMX.Controls.TControl.EffectEnabledChanged
FMX.Controls.TControl.EnabledChanged
FMX.Controls.TControl.HandleSizeChanged
FMX.Controls.TControl.HitTestChanged
FMX.Controls.TControl.PaddingChanged
FMX.Controls.TControl.ParentChanged
FMX.Controls.TControl.AncestorVisibleChanged
FMX.Controls.TControl.AncestorParentChanged
FMX.Controls.TControl.ChildrenAlignChanged</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.Grid.TColumn.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <function name="GetDefaultHorzAlign">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Grid.TColumn.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.Grid.TColumn.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <procedure name="BeforeDrawing">
        <docstr>This method is called before DRAW of the column.
DrawableCell  calls DrawableCell.BeforeDrawing.</docstr>
      </procedure>
      <procedure name="AfterDrawing">
        <docstr>This method is called after DRAW of the column.
DrawableCell  calls DrawableCell.AfterDrawing.</docstr>
      </procedure>
      <procedure name="DrawCell">
        <docstr>Responds when need to draw a cell.
When Model.DefaultDrawing is True, DrawableCell.DrawCell, DefaultDrawCell, and Model.DoDrawColumnCell are called.</docstr>
      </procedure>
      <procedure name="DrawBackground">
        <docstr>Draws the cell background.
FMX.Grid.TColumn.DrawBackground inherits from FMX.Grid.IDrawableCellEx.DrawBackground. All content below this line refers to FMX.Grid.IDrawableCellEx.DrawBackground.
Draws the cell background.
DrawBackground receives the following parameters:

Canvas is the canvas where DrawBackground paints the cell background.
Bounds indicates the cell boundaries.
Row is the row number.
Value is the cell value.
State is the drawing state of the cell.
DrawBackground is called before DrawCell.

 See Also
FMX.Grid.IDrawableCell.DrawCell
FMX.Grid.IDrawableCell.BeforeDrawing
FMX.Grid.IDrawableCell.AfterDrawing</docstr>
      </procedure>
      <function name="GetAbsoluteOpacity">
        <docstr>Getter function for the AbsoluteOpacity property.
FMX.Grid.TColumn.GetAbsoluteOpacity inherits from FMX.Controls.TControl.GetAbsoluteOpacity. All content below this line refers to FMX.Controls.TControl.GetAbsoluteOpacity.
Getter function for the AbsoluteOpacity property.</docstr>
      </function>
      <property name="CellObject">
        <docstr>Returns the object used to draw the cells in the column.
The instance is created when you first access this property. The class of the object being created is retrieved by TStyledGrid.GetCellClass. The class of the object is determined by the native or style control that is registered using TPresentationProxyFactory. Usually this is control that supports the IDrawableCell interface.
CellObject can return nil.</docstr>
      </property>
      <property name="DrawableCell">
        <docstr>IDrawableCell interface for the cell control, or nil if the cell control does not exist or if it does not support the IDrawableCell interface.</docstr>
      </property>
      <procedure name="ChangeOrder">
        <docstr>Notification method called after the creation order is changed.
FMX.Grid.TColumn.ChangeOrder inherits from FMX.Types.TFmxObject.ChangeOrder. All content below this line refers to FMX.Types.TFmxObject.ChangeOrder.
Notification method called after the creation order is changed. ChangeOrder is a virtual method to be implemented in subclasses to allow for changing the creation order of this FMX object.</docstr>
      </procedure>
      <function name="DoEditorModified">
        <docstr>This virtual method is called when the data is changed in the cell editor.
You should not perform this method on your own. Instead, use the EditorModified method.
True if it is possible to change the EditorState value.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Grid.TColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Grid.TColumn.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="Layout">
        <docstr>The current text layout that is used to draw text in cells.</docstr>
      </property>
      <property name="InEditMode">
        <docstr>Determines what column is in edit mode.
This property is left for compatibility.</docstr>
      </property>
      <property name="EditorState">
        <docstr>Specifies the current state of the cell editor.</docstr>
      </property>
      <procedure name="UpdateCell">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Changed">
        <docstr>This method is called when the column changes, and it notifies the model about those changes.</docstr>
      </procedure>
      <procedure name="SetBounds">
        <docstr>Sets the boundaries of the current control.
FMX.Grid.TColumn.SetBounds inherits from FMX.Controls.TControl.SetBounds. All content below this line refers to FMX.Controls.TControl.SetBounds.
Sets the boundaries of the current control.
Use SetBounds to change all of the boundary properties of the control at one time. 
X specifies the X coordinate of the Position of the control.
Y specifies the Y coordinate of the Position of the control.
AWidth specifies the value of the Width of the control.
AHeight specifies the value of the Height of the control.
The same effect can be achieved by setting the Position, Width, and Height properties separately, but SetBounds changes all properties at once, ensuring that the control will not repaint between changes.
After setting the boundary properties, SetBounds specifies to the control to maintain the alignment of the control within its parent and of its children within it. The given parameter does not necessarily reflect in the Position, Width, and Height properties. The properties can be updated when the alignment is applied.</docstr>
      </procedure>
      <property name="EffectiveVisible">
        <docstr>Indicates whether this column is visible (True) or not (False).</docstr>
      </property>
      <function name="CanEdit">
        <docstr>Returns True if the column can show a value editor or False otherwise.</docstr>
      </function>
      <function name="RefreshEditor">
        <docstr>Changes the value of the column editor (InplaceEdit) to the specified value, and returns True on success or False otherwise.
This function may return False, for example, if the target column is read-only and the editor does not support read-only values, which prevents the editor from working.</docstr>
      </function>
      <procedure name="EditorModified">
        <docstr>This method should be performed in the cell editor to notify the grid about changes.</docstr>
      </procedure>
      <function name="EditingDone">
        <docstr>Called when the user finishes using the specified column editor (InplaceEdit) on a cell.
Value contains the value defined with the column editor.
If Accept is True, EditingDone changes the value of the cell to Value and returns True on success or False otherwise.
If Accept is False, EditingDone always returns True.</docstr>
      </function>
      <function name="PostEditorValue">
        <docstr>Sends the MM_POST_EDITOR_VALUE message to the presentation.
This method is used in LiveBinding.</docstr>
      </function>
      <procedure name="EditingCancelled">
        <docstr>This virtual method is called from the EditingDone method if the parameter is False and some changes are made.
You can override this method in the heir, but you do not have to call it manually.
This method is used to interact with the LiveBinding.</docstr>
      </procedure>
      <function name="ValueIsEmpty">
        <docstr>Determines that the specified value should not be displayed in the cell and stored in the caches.</docstr>
      </function>
      <function name="ValueToString">
        <docstr>Draws the value of the column cell.
Each column type defines its own implementation of this method to convert TValue into string value.</docstr>
      </function>
      <function name="ValidChar">
        <docstr>Returns True if the specified character is a valid character for a cell of this column or False otherwise.
For example, if the column contains numeric values, only digits, sign symbols (+ and -) and digit separators (, and .) would be considered valid.</docstr>
      </function>
      <property name="Model">
        <docstr>The reference to the data model of the parent control.
Model is set when changing the parent control. If a current column does not belong to the TPresentedControl, or the model of PresentedControl does not belong to the TGridModel, then this property contains nil.</docstr>
      </property>
      <property name="PresentedControl">
        <docstr>The reference to the control using this column and the data model.</docstr>
      </property>
      <procedure name="DefaultDrawCell">
        <docstr>Draws the default cell background.
DefaultDrawCell receives the following parameters:

Canvas is the canvas where DefaultDrawCell paints the cell background.
Bounds indicates the cell boundaries.
Row is the row number.
Value is the cell value.
State is the drawing state of the cell.
DrawCell calls DefaultDrawCell if Model.DefaultDrawing is True.</docstr>
      </procedure>
      <property name="DefaultTextSettings">
        <docstr>Default text settings.</docstr>
      </property>
      <function name="RectPlaceIntoBounds">
        <docstr>Stretches and aligns the Source rectangle, preserving its rectangle proportions, to best fit into the Bounds rectangle.
RectPlaceIntoBounds calls PlaceInto to best fit the Source rectangle, preserving its rectangle proportions, into the Bounds rectangle. RectPlaceIntoBounds uses the default alignment parameters of the current column to align the stretched rectangle in the Bounds rectangle.
RectPlaceIntoBounds returns Source if any of the Bounds rectangle dimensions is zero.</docstr>
      </function>
      <property name="OriginalIndex">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="HorzAlignModified">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="HorzAlign">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Header">
        <docstr>Specifies the string in the header cell of the column.</docstr>
      </property>
      <property name="Padding">
        <docstr>The padding of any cells in this column</docstr>
      </property>
      <property name="ReadOnly">
        <docstr>Specifies whether the cells in this column can be edited or not.
Set ReadOnly to True to specify that the content of the cells can only be read.</docstr>
      </property>
      <property name="Visible">
        <docstr>Specifies whether to display this column in run-time.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Grid" name="TProgressColumn">
    <docstr>Represents a column in a grid, whose cells show progress bars.</docstr>
    <members>
      <function name="IsMaxStored">
        <docstr>Function that ensures that the value of Max is only stored in the form file if it is not the default value of the property (TProgressColumn.DefaultMax).</docstr>
      </function>
      <function name="IsMinStored">
        <docstr>Function that ensures that the value of Min is only stored in the form file if it is not the default value of the property (0).</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Grid.TProgressColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <function name="CanEdit">
        <docstr>Returns True if the column can show a value editor or False otherwise.
FMX.Grid.TProgressColumn.CanEdit inherits from FMX.Grid.TColumn.CanEdit. All content below this line refers to FMX.Grid.TColumn.CanEdit.
Returns True if the column can show a value editor or False otherwise.

 See Also
FMX.Grid.TColumn.EditingCancelled
FMX.Grid.TColumn.EditingDone
FMX.Grid.TColumn.EditorModified
FMX.Grid.TColumn.PostEditorValue
FMX.Grid.TColumn.RefreshEditor</docstr>
      </function>
      <procedure name="DefaultDrawCell">
        <docstr>Draws the default cell background.
FMX.Grid.TProgressColumn.DefaultDrawCell inherits from FMX.Grid.TColumn.DefaultDrawCell. All content below this line refers to FMX.Grid.TColumn.DefaultDrawCell.
Draws the default cell background.
DefaultDrawCell receives the following parameters:

Canvas is the canvas where DefaultDrawCell paints the cell background.
Bounds indicates the cell boundaries.
Row is the row number.
Value is the cell value.
State is the drawing state of the cell.
DrawCell calls DefaultDrawCell if Model.DefaultDrawing is True.

 See Also
FMX.Grid.TColumn.DrawCell
FMX.Grid.TColumn.BeforeDrawing
FMX.Grid.TColumn.AfterDrawing</docstr>
      </procedure>
      <property name="Max">
        <docstr>Specifies the maximum value for all the progress cells in this column.</docstr>
      </property>
      <property name="Min">
        <docstr>Specifies the minimum value for all the progress cells in this column.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Grid" name="TCheckColumn">
    <docstr>Represents a column in a grid, whose cells show check boxes.</docstr>
    <members>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
Getter of DefaultSize.
FMX.Grid.TCheckColumn.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <function name="CreateBitmap">
        <docstr>Creates a check box picture, which can be used to paint cells in the current column.
Model defines the grid model used to handle data.
Checked defines whether the rendered check box is checked.
EditorMode determines whether the check box picture is created in edit mode or not.</docstr>
      </function>
      <procedure name="DefaultDrawCell">
        <docstr>Draws the default cell background.
FMX.Grid.TCheckColumn.DefaultDrawCell inherits from FMX.Grid.TColumn.DefaultDrawCell. All content below this line refers to FMX.Grid.TColumn.DefaultDrawCell.
Draws the default cell background.
DefaultDrawCell receives the following parameters:

Canvas is the canvas where DefaultDrawCell paints the cell background.
Bounds indicates the cell boundaries.
Row is the row number.
Value is the cell value.
State is the drawing state of the cell.
DrawCell calls DefaultDrawCell if Model.DefaultDrawing is True.

 See Also
FMX.Grid.TColumn.DrawCell
FMX.Grid.TColumn.BeforeDrawing
FMX.Grid.TColumn.AfterDrawing</docstr>
      </procedure>
      <function name="ValueToString">
        <docstr>Draws the value of the column cell.
FMX.Grid.TCheckColumn.ValueToString inherits from FMX.Grid.TColumn.ValueToString. All content below this line refers to FMX.Grid.TColumn.ValueToString.
Draws the value of the column cell.
Each column type defines its own implementation of this method to convert TValue into string value.</docstr>
      </function>
      <function name="TryGetAsBoolean">
        <docstr>Tries to fill BoolValue with the specified value, and returns True on success or False if Value is not a boolean.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.Grid" name="TDateTimeColumnBase">
    <docstr>Represents a column in a TGrid grid.
FMX.Grid.TDateTimeColumnBase inherits from FMX.Grid.TColumn. All content below this line refers to FMX.Grid.TColumn.
Represents a column in a TGrid grid.
TColumn is the base class for classes declaring different types of   columns in grids:

TCheckColumn
TCurrencyColumn
TDateColumn
TGlyphColumn
TImageColumn
TPopupColumn
TProgressColumn
TStringColumn
TTimeColumn
If you need to create a new type of column, you should derive your subclass from TColumn.</docstr>
    <members>
      <function name="IsFormatStored">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Grid.TDateTimeColumnBase.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <function name="ValueToString">
        <docstr>Draws the value of the column cell.
FMX.Grid.TDateTimeColumnBase.ValueToString inherits from FMX.Grid.TColumn.ValueToString. All content below this line refers to FMX.Grid.TColumn.ValueToString.
Draws the value of the column cell.
Each column type defines its own implementation of this method to convert TValue into string value.</docstr>
      </function>
      <property name="Format">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ShowClearButton">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Grid" name="TTimeColumn">
    <docstr>Represents a column in a grid, whose cells use an editor similar to TTimeEdit  to edit cells in this column.
A really used editor depends on implementation of the styled presentation class of TCustomGrid. For example, see TStyledGrid.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Grid.TTimeColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Grid" name="TDateColumn">
    <docstr>Represents a column in a grid, whose cells use an editor similar to TDateEdit to edit cells in this column.
A really used editor depends on implementation of the styled presentation class of TCustomGrid. For example, see TStyledGrid.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates an instance of TDateColumn.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Grid" name="TPopupColumn">
    <docstr>Represents a column in a grid, whose cells shows pop-up menus.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Grid.TPopupColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Grid.TPopupColumn.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="Items">
        <docstr>Returns the items available for the pop-up column as strings.
The items of Items are displayed in a pop-up that appears when clicking one of the cells in the column. Choosing one of the items will set the item as the value of that cell.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Grid" name="TImageColumn">
    <docstr>Represents a column in a grid, whose cells show images.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Grid.TImageColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <procedure name="DefaultDrawCell">
        <docstr>Draws the default cell background.
FMX.Grid.TImageColumn.DefaultDrawCell inherits from FMX.Grid.TColumn.DefaultDrawCell. All content below this line refers to FMX.Grid.TColumn.DefaultDrawCell.
Draws the default cell background.
DefaultDrawCell receives the following parameters:

Canvas is the canvas where DefaultDrawCell paints the cell background.
Bounds indicates the cell boundaries.
Row is the row number.
Value is the cell value.
State is the drawing state of the cell.
DrawCell calls DefaultDrawCell if Model.DefaultDrawing is True.

 See Also
FMX.Grid.TColumn.DrawCell
FMX.Grid.TColumn.BeforeDrawing
FMX.Grid.TColumn.AfterDrawing</docstr>
      </procedure>
      <property name="PreviewSize">
        <docstr>Represents the maximum size of a thumbnail that can be displayed in cells of the column.
To improve performance, large pictures are reduced to the specified PreviewSize size. The obtained thumbnail is stored in internal cache and is drawn during repainting.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Grid" name="TCustomNumberColumn">
    <docstr></docstr>
    <members>
      <function name="GetDefaultHorzAlign">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Grid.TCustomNumberColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <function name="TryValueToString">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="ValueToString">
        <docstr>Draws the value of the column cell.
FMX.Grid.TCustomNumberColumn.ValueToString inherits from FMX.Grid.TColumn.ValueToString. All content below this line refers to FMX.Grid.TColumn.ValueToString.
Draws the value of the column cell.
Each column type defines its own implementation of this method to convert TValue into string value.</docstr>
      </function>
      <function name="ValidChar">
        <docstr>Returns True if the specified character is a valid character for a cell of this column or False otherwise.
FMX.Grid.TCustomNumberColumn.ValidChar inherits from FMX.Grid.TColumn.ValidChar. All content below this line refers to FMX.Grid.TColumn.ValidChar.
Returns True if the specified character is a valid character for a cell of this column or False otherwise.
For example, if the column contains numeric values, only digits, sign symbols (+ and -) and digit separators (, and .) would be considered valid.</docstr>
      </function>
      <property name="DecimalDigits">
        <docstr>The number of decimal places when displaying float numbers.</docstr>
      </property>
      <property name="ValueType">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ShowThousandSeparator">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Grid" name="TCurrencyColumn">
    <docstr></docstr>
    <members>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Grid.TCurrencyColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Grid" name="TFloatColumn">
    <docstr></docstr>
    <members>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Grid.TFloatColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Grid" name="TIntegerColumn">
    <docstr></docstr>
    <members>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Grid.TIntegerColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <function name="ValidChar">
        <docstr>Returns True if the specified character is a valid character for a cell of this column or False otherwise.
FMX.Grid.TIntegerColumn.ValidChar inherits from FMX.Grid.TColumn.ValidChar. All content below this line refers to FMX.Grid.TColumn.ValidChar.
Returns True if the specified character is a valid character for a cell of this column or False otherwise.
For example, if the column contains numeric values, only digits, sign symbols (+ and -) and digit separators (, and .) would be considered valid.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.Grid" name="TGlyphColumn">
    <docstr></docstr>
    <members>
      <procedure name="AncestorParentChanged">
        <docstr>Notifies its child controls that the parent of an ancestor of your control has changed.
Notifies its child controls that the parent of an ancestor of your control has changed.
FMX.Grid.TGlyphColumn.AncestorParentChanged inherits from FMX.Controls.TControl.AncestorParentChanged. All content below this line refers to FMX.Controls.TControl.AncestorParentChanged.
Notifies its child controls that the parent of an ancestor of your control has changed.

 See Also
FMX.Controls.TControl.ParentChanged
FMX.Controls.TControl.AncestorVisibleChanged
FMX.Controls.TControl.ChildrenAlignChanged
FMX.Controls.TControl.ClipChildrenChanged
FMX.Controls.TControl.EffectEnabledChanged
FMX.Controls.TControl.EnabledChanged
FMX.Controls.TControl.HandleSizeChanged
FMX.Controls.TControl.HitTestChanged
FMX.Controls.TControl.PaddingChanged</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
Initializes the component after the form file has been read into memory.
FMX.Grid.TGlyphColumn.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <procedure name="DoGetImageIndex">
        <docstr>Calls the OnGetImageIndex event handler and returns the image index.
DoGetImageIndex calls the OnGetImageIndex event handler (if it is set) and returns the ImageIndex index of the image corresponding to the specified Value. Index is in a list of images specified in TGrid.Images. You can override this method but you should not use it explicitly in your code. To retrieve the image index, use GetImageIndex.</docstr>
      </procedure>
      <property name="GlyphInterface">
        <docstr>Reference to a glyph interface supported by the PresentedControl using this glyph column and the current data model.</docstr>
      </property>
      <function name="GetImageIndex">
        <docstr>Returns the index of the image specified by Value.
GetImageIndex returns the index of the image corresponding to the specified Value. Index is in a list of images specified in TGrid.Images.</docstr>
      </function>
      <function name="CanEdit">
        <docstr>Returns True if the column can show a value editor or False otherwise.
FMX.Grid.TGlyphColumn.CanEdit inherits from FMX.Grid.TColumn.CanEdit. All content below this line refers to FMX.Grid.TColumn.CanEdit.
Returns True if the column can show a value editor or False otherwise.

 See Also
FMX.Grid.TColumn.EditingCancelled
FMX.Grid.TColumn.EditingDone
FMX.Grid.TColumn.EditorModified
FMX.Grid.TColumn.PostEditorValue
FMX.Grid.TColumn.RefreshEditor</docstr>
      </function>
      <procedure name="DefaultDrawCell">
        <docstr>Draws the default cell background.
FMX.Grid.TGlyphColumn.DefaultDrawCell inherits from FMX.Grid.TColumn.DefaultDrawCell. All content below this line refers to FMX.Grid.TColumn.DefaultDrawCell.
Draws the default cell background.
DefaultDrawCell receives the following parameters:

Canvas is the canvas where DefaultDrawCell paints the cell background.
Bounds indicates the cell boundaries.
Row is the row number.
Value is the cell value.
State is the drawing state of the cell.
DrawCell calls DefaultDrawCell if Model.DefaultDrawing is True.

 See Also
FMX.Grid.TColumn.DrawCell
FMX.Grid.TColumn.BeforeDrawing
FMX.Grid.TColumn.AfterDrawing</docstr>
      </procedure>
      <function name="GlyphPlaceIntoBounds">
        <docstr>Returns the rectangle in which to draw the Index image. Stretches and aligns the original rectangle of the Index image, preserving its rectangle proportions, to best fit into the Bounds rectangle.
GlyphPlaceIntoBounds implements algorithm like the following:

If the Stretch property of the current TGlyphColumn object is False, then GlyphPlaceIntoBounds retrieves the biggest rectangle from all layers of the Index image in the destination collection stretched to the Scale = 1. Then GlyphPlaceIntoBounds stretch the obtained rectangle, preserving its rectangle proportions, to best fits into the specified Bounds rectangle. Then GlyphPlaceIntoBounds aligns this rectangle in the Bounds rectangle using the default alignment parameters of the current column. GlyphPlaceIntoBounds returns the obtained rectangle.
If the Stretch property of the current TGlyphColumn object is True, then GlyphPlaceIntoBounds retrieves the biggest rectangle from all layers of the Index image in the destination collection with the  Scale used in the layer. Then GlyphPlaceIntoBounds stretch the obtained rectangle, preserving its rectangle proportions, to best fits into the specified Bounds rectangle. Then GlyphPlaceIntoBounds aligns this rectangle in the Bounds rectangle using the default alignment parameters of the current column. GlyphPlaceIntoBounds returns the obtained rectangle.</docstr>
      </function>
      <property name="Stretch">
        <docstr>Specifies whether to stretch the image shown in the glyph control.</docstr>
      </property>
      <event name="OnGetImageIndex">
        <docstr>Custom defined event handler that should return an index of the image corresponding to Value in a list of images specified in TGrid.Images.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Grid" name="TGridModel">
    <docstr></docstr>
    <members>
      <function name="GetDefaultGridOptions">
        <docstr>This virtual method returns default options of grid</docstr>
      </function>
      <function name="GetTextSettingsClass">
        <docstr>This virtual method must return the class which encapsulates the text settings</docstr>
      </function>
      <procedure name="DoTextSettingsChanged">
        <docstr>This virtual method is called after changing text settings</docstr>
      </procedure>
      <function name="StyledSettingsStored">
        <docstr>This virtual method specifies whether to save the StyledSettings value in fmx-file</docstr>
      </function>
      <function name="GetEditorValue">
        <docstr>The current value of cell editor</docstr>
      </function>
      <procedure name="DoColumnAdded">
        <docstr>This virtual method is called after new column was added</docstr>
      </procedure>
      <procedure name="DoColumnRemoved">
        <docstr>This virtual method is called after column was deleted</docstr>
      </procedure>
      <procedure name="DoRowCountChanged">
        <docstr>This virtual method is called after number of rows was changed</docstr>
      </procedure>
      <event name="OnGetValue">
        <docstr>This event handler is used to get cell data from the some custom defined source</docstr>
      </event>
      <procedure name="InvalidateContentSize">
        <docstr>This method notifies the presentation, that previously calculated content size is no longer relevant</docstr>
      </procedure>
      <procedure name="SelectionChanged">
        <docstr>This method notifies the presentation, that current row or column index is changed</docstr>
      </procedure>
      <procedure name="InsertColumn">
        <docstr>Inserting a new column before the column with the specified number (with moving to right)</docstr>
      </procedure>
      <procedure name="RemoveColumn">
        <docstr>Deleting column with the specified order number</docstr>
      </procedure>
      <procedure name="MoveColumn">
        <docstr>Changing order number and moving of the column</docstr>
      </procedure>
      <property name="RowCount">
        <docstr>The number of rows</docstr>
      </property>
      <property name="Enabled">
        <docstr>Specifies whether the presentation responds to mouse, keyboard, etc</docstr>
      </property>
      <property name="Columns[const Index]">
        <docstr>An array containing all the columns</docstr>
      </property>
      <function name="IndexOfColumn">
        <docstr>Returns the column number. If the column is not found, then -1</docstr>
      </function>
      <function name="FindNextCell">
        <docstr>This method returns a column and row of the cell that can be select after the defined cell</docstr>
      </function>
      <property name="Options">
        <docstr>This is various flags which responsible for the appearance and behavior of the grid</docstr>
      </property>
      <procedure name="ClearCache">
        <docstr>Clear internal cache of values</docstr>
      </procedure>
      <procedure name="MoveColumnInCache">
        <docstr>Moving all values of internal cache with the specified column number (from the old index to the new
           index)</docstr>
      </procedure>
      <procedure name="InsertColumnIntoCache">
        <docstr>Move to right all values of internal cache with column number that greater or equal to the specified
           column number</docstr>
      </procedure>
      <procedure name="DataChanged">
        <docstr>Removes from the cache the value of one cell and invalidates the area of the cell</docstr>
      </procedure>
      <property name="TextSettings">
        <docstr>This object provide custom text properties</docstr>
      </property>
      <property name="DefaultTextSettings">
        <docstr>This object provide default text properties (style of system defined)</docstr>
      </property>
      <property name="StyledSettings">
        <docstr>This property indicates whether the custom text settings is used or default</docstr>
      </property>
      <event name="OnHeaderClick">
        <docstr>This event can by called from presentation (depends on the implementation) after
           clicking in column header</docstr>
      </event>
      <event name="OnCellClick">
        <docstr>This event can by called from presentation (depends on the implementation) when
           clicking in grid cell after the selection was changed</docstr>
      </event>
      <event name="OnCellDblClick">
        <docstr>This event can by called from presentation (depends on the implementation) when
           double clicking in grid cell  after the selection was changed</docstr>
      </event>
      <event name="OnColumnMoved">
        <docstr>This event is called after successfully changing of column order</docstr>
      </event>
      <event name="OnDrawColumnHeader">
        <docstr>This event can by called from presentation (depends on the implementation) to
           draw header of column</docstr>
      </event>
      <event name="OnSelectCell">
        <docstr>This event is called before changing of index selected row or column</docstr>
      </event>
      <event name="OnSelChanged">
        <docstr>This event is called after successfully changing of index selected row or column</docstr>
      </event>
      <event name="OnDrawColumnBackground">
        <docstr>This event can by called from presentation (depends on the implementation) to
           draw background of cell</docstr>
      </event>
      <event name="OnDrawColumnCell">
        <docstr>This event can by called from presentation (depends on the implementation) to
           draw cell</docstr>
      </event>
      <event name="OnSetValue">
        <docstr>In this event handler you should setup value in some custom defined data after cell changing</docstr>
      </event>
      <event name="OnCreateCustomEditor">
        <docstr>This event can by called from presentation (depends on the implementation) to create the custom
           defined cell editors</docstr>
      </event>
      <event name="OnEditingDone">
        <docstr>This event can by called from presentation (depends on the implementation) to
           create the custom defined cell editors</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Grid" name="TGridValues">
    <docstr></docstr>
    <members>
      <procedure name="Clear">
        <docstr>Removing all items</docstr>
      </procedure>
      <procedure name="Reduce">
        <docstr>Removing all items except those who included in the rectangle AExcepRect</docstr>
      </procedure>
      <procedure name="RemoveCell">
        <docstr>Removing item by coordinates ACoord</docstr>
      </procedure>
      <procedure name="RemoveCells">
        <docstr>Removing all items in which the row or col is equals Index</docstr>
      </procedure>
      <procedure name="MoveCells">
        <docstr>Change index of Column or Row</docstr>
      </procedure>
      <procedure name="InsertCells">
        <docstr>Inserts one column or row with a shift of cells right or down</docstr>
      </procedure>
      <procedure name="RemoveColumn">
        <docstr>Removing all items in which the column is equals ACol</docstr>
      </procedure>
      <procedure name="RemoveRow">
        <docstr>Removing all items in which the row is equals ARow</docstr>
      </procedure>
      <procedure name="MoveColumn">
        <docstr>Change index of column</docstr>
      </procedure>
      <procedure name="MoveRow">
        <docstr>Change index of row</docstr>
      </procedure>
      <procedure name="InsertColumn">
        <docstr>Inserts one column with a shift of cells right</docstr>
      </procedure>
      <procedure name="InsertRow">
        <docstr>Inserts one row with a shift of cells down</docstr>
      </procedure>
      <function name="IsEqual">
        <docstr>Check for equality of two values. This method is called in SetCells (see Cells)</docstr>
      </function>
      <procedure name="Changed">
        <docstr>This virtual method is called after you change the property Cells. This method not is called after
           other methods (Clear, RemoveRow, etc)</docstr>
      </procedure>
      <property name="Cells[const ACol][const ARow]">
        <docstr>The values of cells</docstr>
      </property>
      <property name="Owner">
        <docstr>The value that have used in the constructor</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Grid" name="TCustomGrid">
    <docstr></docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.Grid.TCustomGrid.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.Grid.TCustomGrid.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the control after the form file has been read into memory and loads its presentation.
FMX.Grid.TCustomGrid.Loaded inherits from FMX.Controls.Presentation.TPresentedControl.Loaded. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Loaded.
Initializes the control after the form file has been read into memory and loads its presentation.
For details, see TControl.Loaded.

 See Also
FMX.Controls.Presentation.TPresentedControl.LoadPresentation
FMX.Controls.TControl.Loaded</docstr>
      </procedure>
      <procedure name="ContentAddObject">
        <docstr>This method is invoked when you add a new Object into the Content children list.
FMX.Grid.TCustomGrid.ContentAddObject inherits from FMX.ScrollBox.TCustomPresentedScrollBox.ContentAddObject. All content below this line refers to FMX.ScrollBox.TCustomPresentedScrollBox.ContentAddObject.
This method is invoked when you add a new Object into the Content children list.</docstr>
      </procedure>
      <procedure name="ContentInsertObject">
        <docstr>This method is invoked when you insert a new Object into the Content children list.
FMX.Grid.TCustomGrid.ContentInsertObject inherits from FMX.ScrollBox.TCustomPresentedScrollBox.ContentInsertObject. All content below this line refers to FMX.ScrollBox.TCustomPresentedScrollBox.ContentInsertObject.
This method is invoked when you insert a new Object into the Content children list.</docstr>
      </procedure>
      <procedure name="ContentBeforeRemoveObject">
        <docstr>This method is invoked before removing an Object from the Content children list.
FMX.Grid.TCustomGrid.ContentBeforeRemoveObject inherits from FMX.ScrollBox.TCustomPresentedScrollBox.ContentBeforeRemoveObject. All content below this line refers to FMX.ScrollBox.TCustomPresentedScrollBox.ContentBeforeRemoveObject.
This method is invoked before removing an Object from the Content children list.</docstr>
      </procedure>
      <function name="CreateScrollContent">
        <docstr>Creates scroll content.
FMX.Grid.TCustomGrid.CreateScrollContent inherits from FMX.ScrollBox.TCustomPresentedScrollBox.CreateScrollContent. All content below this line refers to FMX.ScrollBox.TCustomPresentedScrollBox.CreateScrollContent.
Creates scroll content.
You can override it for creating custom content. It allows to add custom information to the content.</docstr>
      </function>
      <function name="DefineModelClass">
        <docstr>Returns a class reference to a data model of this presented control.
FMX.Grid.TCustomGrid.DefineModelClass inherits from FMX.Controls.Presentation.TPresentedControl.DefineModelClass. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefineModelClass.
Returns a class reference to a data model of this presented control.
Returns a class reference to a data model class that the constructor of this presented control uses to create a data model for the control.
By default DefineModelClass returns TDataModel. Descendant classes reimplement DefineModelClass to determine the data model class that a descendant presented control uses for its data model.

 See Also
FMX.Controls.Model.TDataModelClass
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Presentation.Style.TStyledPresentation.DefineModelClass
Class References</docstr>
      </function>
      <procedure name="SetEnabled">
        <docstr>Setter of Enabled.
FMX.Grid.TCustomGrid.SetEnabled inherits from FMX.Controls.TControl.SetEnabled. All content below this line refers to FMX.Controls.TControl.SetEnabled.
Setter of Enabled.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.Grid.TCustomGrid.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <procedure name="DoBeginUpdate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoEndUpdate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ImagesChanged">
        <docstr>It notifies the Grid that the attached TImageList or related ImageIndex was changed. So, the Grid have to refresh all cells that use images from this ImageList.</docstr>
      </procedure>
      <function name="CanObserve">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.</docstr>
      </function>
      <procedure name="ObserverAdded">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.</docstr>
      </procedure>
      <procedure name="AfterPaint">
        <docstr>Restores Canvas properties after the painting process. 
FMX.Grid.TCustomGrid.AfterPaint inherits from FMX.Controls.TControl.AfterPaint. All content below this line refers to FMX.Controls.TControl.AfterPaint.
Restores Canvas properties after the painting process. 
As implemented in TControl, AfterPaint does nothing.
TShape descendants of TControl override AfterPaint to restore Dash and  Thickness to default values.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.Grid.TCustomGrid.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TPresentedControl.
FMX.Grid.TCustomGrid.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
Destroys this instance of TPresentedControl.

 See Also
FMX.Controls.Presentation.TPresentedControl.Create</docstr>
      </destructor>
      <procedure name="BeforeDestruction">
        <docstr>Performs any necessary actions before the first destructor is called.
Performs any necessary actions before the first destructor is called.
FMX.Grid.TCustomGrid.BeforeDestruction inherits from System.Classes.TComponent.BeforeDestruction. All content below this line refers to System.Classes.TComponent.BeforeDestruction.
Performs any necessary actions before the first destructor is called.
BeforeDestruction is called automatically immediately before the component&apos;s first destructor executes. Do not call it explicitly in your applications.
As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place.</docstr>
      </procedure>
      <procedure name="UnloadPresentation">
        <docstr>Unloads the previously-loaded presentation of your control.
FMX.Grid.TCustomGrid.UnloadPresentation inherits from FMX.Controls.Presentation.TPresentedControl.UnloadPresentation. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.UnloadPresentation.
Unloads the previously-loaded presentation of your control.

 See Also
FMX.Controls.Presentation.TPresentedControl.LoadPresentation
FMX.Controls.Presentation.TPresentedControl.ReloadPresentation</docstr>
      </procedure>
      <procedure name="ClearColumns">
        <docstr>Removes and destroys all columns.</docstr>
      </procedure>
      <function name="ColumnByIndex">
        <docstr>Returns the column with the given index.
If the column does not exist, ColumnByIndex returns nil.</docstr>
      </function>
      <function name="GetUnusedViewportWidth">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="CellByPoint">
        <docstr>Fills ACol and ARow with the column and row numbers that identify the cell located at the specified X and Y coordinates, and returns True on success or False otherwise.</docstr>
      </function>
      <function name="ColumnByPoint">
        <docstr>Returns the column at the given left and top coordinates.
If the column does not exist, ColumnByPoint returns nil.</docstr>
      </function>
      <function name="RowByPoint">
        <docstr>Returns the index of row at the given left and top coordinates.
If the row does not exist, RowByPoint returns -1, otherwise a positive numerical value is returned. Keep in mind that 0 is the first row, 1 is the second row, and so on.</docstr>
      </function>
      <function name="CellRect">
        <docstr>Returns the coordinates of the cell at the specified row and column.
ACol and ARow are 0-based. You can specify values equal to ColumnCount or RowCount to get the coordinates of an non-existent cell that is next to an existing cell.
If the specified column or row numbers are not valid, CellRect returns coordinates (-1, -1, -1, -1).</docstr>
      </function>
      <procedure name="SelectCell">
        <docstr>Selects the cell with the specified index of column and rows.
The DoSelectCell method occurs before the change and the DoSelChanged method occurs after the change.</docstr>
      </procedure>
      <procedure name="SelectColumn">
        <docstr>Selects the cell with the specified column index and old row index.</docstr>
      </procedure>
      <procedure name="SelectRow">
        <docstr>Selects the cell with the specified row index and old column index.</docstr>
      </procedure>
      <function name="CanEdit">
        <docstr>Determines whether the selected cell can be edited (True) or not (False) based on the current configuration of the corresponding column and the grid.</docstr>
      </function>
      <procedure name="SetTopLeft">
        <docstr>Changes the viewport position so that the cell at the specified column number and row number is located on the top-left corner.</docstr>
      </procedure>
      <function name="DisplayCells">
        <docstr>Determines the cells that are visible, either completely or partially, fills TopLeft with the coordinates of the top-left visible cell, fills BottomRight with the coordinates of the bottom-right visible cell, and returns True on success or False otherwise.</docstr>
      </function>
      <procedure name="ScrollToSelectedCell">
        <docstr>Changes the viewport position so that the selected cell is visible.</docstr>
      </procedure>
      <function name="TextWidthToColWidth">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="Model">
        <docstr>The data model representing the data used by the presentation of the current control.
The constructor of your presented control creates a data model for your presented control. The class of the data model is the class that DefineModelClass returns.</docstr>
      </property>
      <property name="TextSettings">
        <docstr>Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
TTextSettings type objects provide all styled text representation properties and methods to manage them.
The styled text representation properties are 
FontColor, TextAlign,
VertTextAlign,
Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
VertTextAlign properties of the control.</docstr>
      </property>
      <property name="StyledSettings">
        <docstr>Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
Text representation properties are used as parameters for drawing texts in controls.
The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
StyledSettings can contain the Family, Size, Style, FontColor, and 
Other values defined in TStyledSetting. The &quot;Relation between TStyledSetting constants and TTextSettings properties&quot; table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):

With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
VertTextAlign properties of the control.</docstr>
      </property>
      <property name="Images">
        <docstr>Specifies the list of images associated with this grid control. 
Images from the Images collection can be shown in cells of the TGlyphColumn type column.</docstr>
      </property>
      <property name="ColumnCount">
        <docstr>Specifies the number of columns in the grid.
Read ColumnCount to determine the number of entries in the Columns array.</docstr>
      </property>
      <property name="Selected">
        <docstr>Specifies the row where you are currently positioned within the grid.
Set the Selected property to any positive numerical value to make the specific row selected. Read Selected to obtain the index of the row where you are currently positioned within the grid.
The first row has an index of 0, the second one has an index of 1, and so on.</docstr>
      </property>
      <property name="TopRow">
        <docstr>Specifies the index of the first visible scrollable row in the grid.
Read TopRow to determine the index of the first row in the scrollable region that is visible. Set TopRow to scroll the rows in the grid so that the row with the TopRow index is the first row after the fixed rows.</docstr>
      </property>
      <property name="BottomRow">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="LeftColumn">
        <docstr>Number of the first column that is visible, either completely or partially, from the left-hand side of the grid.</docstr>
      </property>
      <property name="RightColumn">
        <docstr>Number of the first column that is visible, either completely or partially, from the right-hand side of the grid.</docstr>
      </property>
      <property name="ReadOnly">
        <docstr>Specifies whether the cells in this grid can be modified or not.
Use ReadOnly at run time to determine whether the cells in this grid can be edited. If ReadOnly is True, then you can only read and view the contents of the cells without the ability to affect the grid in any way.</docstr>
      </property>
      <property name="ColumnIndex">
        <docstr>Specifies the index of the column that contains the selected cell.
Use ColumnIndex at run time to determine the current column in the grid. Setting ColumnIndex moves the focus to the cell in the current row that is in the new column. The first column has an index of 0, the second column has an index of 1, and so on.</docstr>
      </property>
      <property name="VisibleColumnCount">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="VisibleRows">
        <docstr>Indicates the number of scrollable rows that are visible in the grid.
Use VisibleRows to determine the number of scrollable rows that are fully visible in the grid. VisibleRows includes any partially visible rows on the top and bottom of the grid.</docstr>
      </property>
      <property name="IsUsedInBinding">
        <docstr>This property is set by the LiveBinding.
If this property is True, you cannot change the  OnSetValue and the  OnCallbackGetValue.</docstr>
      </property>
      <property name="RowHeight">
        <docstr>Specifies the height of each row of this grid, in pixels.
Read RowHeight to determine the size of each row in the grid. If the underlying grid is too tall to appear in the control, then the user must scroll to see the entire content of the grid.</docstr>
      </property>
      <property name="RowCount">
        <docstr>Specifies the number of rows in the grid.
The value of RowCount includes the scrollable rows in the grid, but not the fixed row with the headers.

Read RowCount to determine the number of rows in the grid.
Set RowCount to add or delete rows at the bottom of the grid.</docstr>
      </property>
      <property name="Options">
        <docstr>Defines how grid controls look like and how they behave.</docstr>
      </property>
      <property name="DefaultDrawing">
        <docstr>Determines whether cells are drawn using the default drawing method (True) or using a user-defined drawing method (False).</docstr>
      </property>
      <property name="EditorMode">
        <docstr>Determines whether the grid control is in the edit mode (True) or not (False).</docstr>
      </property>
      <property name="Col">
        <docstr>The column number of the selected cell, or -1 if there is no cell selected.</docstr>
      </property>
      <property name="Row">
        <docstr>Number of the selected row.</docstr>
      </property>
      <event name="OnHeaderClick">
        <docstr>Occurs immediately when the left mouse button is clicked with the pointer over the header of a column.
Write an OnHeaderClick event handler to take specific actions when the left mouse button is clicked with the pointer over the header of a column in this grid.</docstr>
      </event>
      <event name="OnCellClick">
        <docstr>Occurs when a user releases the mouse in one of the grid cells.
This event can be called from presentation (depends on the implementation) when clicking a grid cell.</docstr>
      </event>
      <event name="OnCellDblClick">
        <docstr>Occurs when a user double-clicks one of the grid cells.
This event can be called from presentation (depends on the implementation) when double clicking a grid cell.</docstr>
      </event>
      <event name="OnColumnMoved">
        <docstr>Occurs immediately after a column is moved.
Write an OnColumnMoved event handler to take specific actions when the column in this grid is moved.</docstr>
      </event>
      <event name="OnDrawColumnHeader">
        <docstr>Occurs when the grid needs to paint a header of a column.
Write an OnDrawColumnHeader event handler to provide customized drawing for the headers of the grid.</docstr>
      </event>
      <event name="OnSelectCell">
        <docstr>Occurs immediately after a cell in a column is selected.
Write an OnSelectCell event handler to take specific actions when the cell of a column in this grid is selected.
Events occur in the following order:

OnTap
OnSelectCell
OnSelChanged</docstr>
      </event>
      <event name="OnSelChanged">
        <docstr>Occurs when the selected row in the grid changes.
Events occur in the following order:

OnTap
OnSelectCell
OnSelChanged</docstr>
      </event>
      <event name="OnDrawColumnBackground">
        <docstr>Occurs when the background of a cell needs to be drawn.
You can use this event to draw the background of cells yourself, to override the default cell background.</docstr>
      </event>
      <event name="OnDrawColumnCell">
        <docstr>Occurs when the grid needs to paint a cell.
Write an OnDrawColumnCell event handler to provide customized drawing for the data in the cells of the grid.
If the DefaultDrawing property is set to True, the cell will be drawn before the OnDrawColumnCell event. If it is set to False, the grid doesn&apos;t draw anything.
Also, in this event handler, it is possible to call the DefaultDrawCell method to process default drawing. It can be useful if DefaultDrawing is set to False and you need to draw something before the default drawing.</docstr>
      </event>
      <event name="OnCallbackGetValue">
        <docstr>Occurs immediately when you update the contents of one of the cells in this grid.  
Write an OnCallbackGetValue event handler to take specific actions when you update the contents of one of the cells in this grid.</docstr>
      </event>
      <event name="OnGetValue">
        <docstr>Occurs when the grid needs to retrieve a value from an external repository to use as the content of one of the cells in this grid.
Write an OnGetValue event handler to take specific actions when you retrieve a value from an external repository to use as the content of one of the cells in this grid.</docstr>
      </event>
      <event name="OnSetValue">
        <docstr>Occurs when you need to pass a content of one of the cells in this grid as a value to an external repository.
Write an OnSetValue event handler to take specific actions when you need to pass a content of one of the cells in this grid as a value to be set in an external repository.</docstr>
      </event>
      <event name="OnCreateCustomEditor">
        <docstr>Occurs before the creation of the editor for cells in a column.
Write an OnCreateCustomEditor event handler to take specific actions when a custom editor is created for this grid.
This event is called every time when the grid activates a cell editor. If a custom editor is not required, just do nothing in this event handler and the default editor is created.
The OnCreateCustomEditor event can by called from a presentation (depends on the implementation) to create a custom defined cell editors. Since the presentation does not know about a TCustomGrid object, the presentation calls  TGridModel.OnCreateCustomEditor from the Model. For this reason, the TCustomGrid.OnCreateCustomEditor event handler
is always the same as the TGridModel.OnCreateCustomEditor event handler of the Model.</docstr>
      </event>
      <event name="OnEditingDone">
        <docstr>Occurs immediately when you accomplish editing of any of cells in this grid.
Write an OnEditingDone event handler to take specific actions when you edit cells in this grid.
For instance, when you paste a string into one of the cells, an OnEditingDone event immediately occurs.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Grid" name="TGrid">
    <docstr></docstr>
    <members>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.Grid.TGrid.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <procedure name="DoEndUpdate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Grid" name="TStringGrid">
    <docstr></docstr>
    <members>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.Grid.TStringGrid.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <function name="DefineModelClass">
        <docstr>Returns a class reference to a data model of this presented control.
FMX.Grid.TStringGrid.DefineModelClass inherits from FMX.Controls.Presentation.TPresentedControl.DefineModelClass. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefineModelClass.
Returns a class reference to a data model of this presented control.
Returns a class reference to a data model class that the constructor of this presented control uses to create a data model for the control.
By default DefineModelClass returns TDataModel. Descendant classes reimplement DefineModelClass to determine the data model class that a descendant presented control uses for its data model.

 See Also
FMX.Controls.Model.TDataModelClass
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Presentation.Style.TStyledPresentation.DefineModelClass
Class References</docstr>
      </function>
      <property name="Model">
        <docstr>The data model representing the data used by the presentation of the current control.
The constructor of your presented control creates a data model for your presented control. The class of the data model is the class that DefineModelClass returns.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Grid" name="TColumnClasses">
    <docstr></docstr>
    <members>
      <procedure name="Register">
        <docstr>Add several classes of columns to the list of registered classes</docstr>
      </procedure>
      <procedure name="Unregister">
        <docstr>Remove several classes of columns from the list of registered classes. If some class was not
           registered then it is ignored.</docstr>
      </procedure>
      <function name="RegisteredColumns">
        <docstr>This function returns array of all registered column classes</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.ActnList" name="TCustomActionList">
    <docstr>The base class for list of actions, without the published properties.
FMX.ActnList.TCustomActionList inherits from System.Actions.TContainedActionList. All content below this line refers to System.Actions.TContainedActionList.
The base class for list of actions, without the published properties.
Implement TContainedActionList to work with common properties for all GUI application frameworks.
Actions lists the actions maintained by the action list.
The ActionCount property returns the number of actions in the list.
OnStateChange sends a notification when the State changes.</docstr>
    <members>
      <procedure name="ImagesChanged">
        <docstr>Should be called when the component needs to redraw the image.
ImagesChanged  should be called when you change the Images reference to the TCustomImageList object or the object itself.</docstr>
      </procedure>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TContainedActionList.
FMX.ActnList.TCustomActionList.Destroy inherits from System.Actions.TContainedActionList.Destroy. All content below this line refers to System.Actions.TContainedActionList.Destroy.
Destroys an instance of TContainedActionList.
This destructor is inherited from TComponent, see TComponent.Destroy for more information.

 See Also
System.Actions.TContainedActionList.Create
System.Classes.TComponent.Destroy</docstr>
      </destructor>
      <function name="DialogKey">
        <docstr>Evaluates an input key combination to determine whether it is a shortcut for one of the actions in the list.
Typically, your applications do not need to call DialogKey explicitly. When the form&apos;s KeyDown method does not evaluate a shortcut key by some other means (such as an event handler), it calls DialogKey for every associated action list until it finds an action that can handle the shortcut.
The action list&apos;s DialogKey method, in turn, checks the specified keystroke against the ShortCut property and SecondaryShortCuts properties of each action in the list. If it finds a match, it tells the action to handle the shortcut, and then returns True. If DialogKey cannot find an action to handle the shortcut, it returns False.
DialogKey has the following parameters: 



Parameter

Description


Key

Is the key code for the potential shortcut key.


Shift

Specifies the state of the Shift, Alt, and Ctrl keys that may be combined with Key.</docstr>
      </function>
      <property name="Images">
        <docstr>Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
If the TCustomImageList list is empty, then Images is nil/null.
Call ImagesChanged when Images is changed.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.ActnList" name="TActionList">
    <docstr>Maintains a list of actions that can be used by components such as controls, menu items, and tool buttons.
Use Action lists to centralize the responses to user actions. Action list components maintain a list of actions that are available to the client controls in an application. You can add action list components to your form from the Standard page of the component palette. 
TActionList lets you set up actions using the Action List editor. Double-click the action list to display the Action List editor, from which you can add, delete, and rearrange actions.
TActionList extends the TCustomActionList class redeclaring the public
Name, State, OnChange, OnExecute,
OnStateChange, and OnUpdate properties and events with the published visibility; therefore, these properties and events  can be managed in the Object Inspector at design time. 

Code Examples
FMX.ActionsDemo Sample
FMX.PhotoEditorDemo Sample</docstr>
  </class>
  <class unit="FMX.ActnList" name="TCustomAction">
    <docstr>TCustomAction is a base class for FireMonkey actions intended to be used with menu items and controls.
TCustomAction introduces support for the properties, events, and methods of menu items and controls that are clients of actions.
Most properties and events introduced in TCustomAction are public; therefore, use TCustomAction as a base class when deriving your own actions that publish specific subset of properties of associated controls. 
Actions centralize responses to user commands (user actions). An action is associated with the user interface elements (components) in an application that uses this action. Actions provide an easy way to synchronize values of properties of an action and of associated components (clients), for example, the enabled state and caption of an action and of an associated speed button and a menu item, and handle the response when the user clicks these components. Each component, which is called the client, has its properties dynamically updated by the associated action and forwards user commands to the action for a response.
The Text property can be used to set an accelerator key to the action. Notice that &amp; and _ are seen and can be used only for Windows.
At design time, you can work in the Action List editor with actions contained in an action list. The action list is a container for actions, organized into categories (File, Edit, and others).
Public properties and events of a component and control that are supported in TCustomAction, either directly or through an ancestor, are the following:

Properties: Caption, Checked, Enabled, HelpType, HelpContext, HelpKeyword, Hint, ImageIndex, ShortCut, Visible.
Events: OnHint, OnUpdate, OnExecute.
TCustomAction is the base class for TAction and TCustomViewAction.
TCustomAction acts as the base class for several predefined action classes. For predefined actions that augment the behavior of TCustomAction, see the action classes in the FMX.StdActns unit.

Code Examples
FMX.ActionsDemo Sample
FMX.KeyboardToolbar Sample
FMX.ScrollableForm Sample</docstr>
    <members>
      <procedure name="UpdateSupported">
        <docstr>UpdateSupported is called when the Supported property can be changed. 
UpdateSupported is called from Update or when the value of the 
UnsupportedArchitectures or UnsupportedPlatforms property has changed.
UpdateSupported analyzes whether the action can be supported under the current CPU architecture and OS platform with the current settings of the UnsupportedArchitectures, UnsupportedPlatforms, HideIfUnsupportedInterface, and IsSupportedInterface properties. If Supported is estimated False, then UpdateSupported sets Visible and Enabled to False, otherwise UpdateSupported restores the values of Visible and Enabled to the values that were stored before the last time when Supported became False.</docstr>
      </procedure>
      <function name="IsSupportedInterface">
        <docstr>Returns True if this action can be realized on the current platform.
As implemented in TCustomAction, IsSupportedInterface always returns True. 
IsSupportedInterface is virtual and can be overridden in descendent classes.</docstr>
      </function>
      <function name="CreateShortCutList">
        <docstr>Creates the TShortCutList object for the action.
CreateShortCutList creates an empty FireMonkey shortcut list object for the current action. 
Notice that implementations of shortcuts are FireMonkey or VCL framework-specific.</docstr>
      </function>
      <procedure name="DefineProperties">
        <docstr>Implements a method for storing an action object&apos;s unpublished data on a stream such as a form file.
By default, writing an object to a stream writes the values of all its published properties, and reading the object in reads those values and assigns them to the object&apos;s properties. Objects can also specify methods that read and write data other than published properties by overriding the DefineProperties method:

TCustomAction overrides the DefineProperties method, defined in TComponent, to define storing of the Caption and ImageIndex properties.
The System.Classes.TComponent.DefineProperties method, defined in TComponent, defines methods to store the &quot;fake&quot; Top and Left properties. These are defined so that action components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="SetTarget">
        <docstr>Sets the value of the Target property.
The protected SetTarget method is provided so that descendant classes will be able to set the value of the Target property.</docstr>
      </procedure>
      <procedure name="SetEnabled">
        <docstr>Sets the Enabled property of the action to the specified Value and propagates this Value to all clients of the action.
FMX.ActnList.TCustomAction.SetEnabled inherits from System.Actions.TContainedAction.SetEnabled. All content below this line refers to System.Actions.TContainedAction.SetEnabled.
Sets the Enabled property of the action to the specified Value and propagates this Value to all clients of the action.
The behavior of SetEnabled depends upon the State of the ActionList action list:

If the value of State is asSuspended, then SetEnabled sets to the specified Value only the Enabled property of the action.
If the value of State is asSuspendedEnabled, then SetEnabled sets to True the Enabled property of the action and of all clients of the action.
Otherwise, SetEnabled sets to the specified Value the Enabled property of the action and propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetVisible">
        <docstr>Sets the new Value of the Visible property for the action and action&apos;s clients.
FMX.ActnList.TCustomAction.SetVisible inherits from System.Actions.TContainedAction.SetVisible. All content below this line refers to System.Actions.TContainedAction.SetVisible.
Sets the new Value of the Visible property for the action and action&apos;s clients.
SetVisible always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.ActnList.TCustomAction.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <procedure name="CustomTextChanged">
        <docstr>Introduces an interface for a function that is called when the CustomText property for the action changes.
As implemented in TCustomAction, CustomTextChanged does nothing. 
Descendant classes can override CustomTextChanged to provide business functionality.
The announced purpose of this method is to update the Text property when the CustomText property is changed.</docstr>
      </procedure>
      <property name="CustomText">
        <docstr>CustomText is a user text.
Some actions can, by default, automatically set the Text property. For example, in the TFileExit standard action, the Text property has the Quit &lt;Application.Title&gt; value. To set your own value, set the value of the Text property to the value of the CustomText property.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Instantiates and initializes a FireMonkey TCustomAction object.
Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True .</docstr>
      </constructor>
      <function name="Execute">
        <docstr>Responds when a client control &quot;fires&quot;.
Execute is called automatically when a client control &quot;fires&quot; (for example, when the user clicks a button or selects a menu item).
Execute first ensures that the action is updated. Then Execute calls the inherited System.Classes.TBasicAction.Execute method. System.Classes.TBasicAction.Execute calls the OnExecute event handler, if one is assigned. Execute returns True if an event handler is called and the action is Enabled. Otherwise, Execute returns False.</docstr>
      </function>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
FMX.ActnList.TCustomAction.Update inherits from System.Classes.TBasicAction.Update. All content below this line refers to System.Classes.TBasicAction.Update.
Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
      <function name="IsDialogKey">
        <docstr>Checks whether the specified keyboard key corresponds to one of the action&apos;s shortcuts.
IsDialogKey returns True if the keyboard key specified by the combination of Key and Shift corresponds to one of the action&apos;s shortcuts. Here:

Key is a keyboard scan code. You can find constants for keyboard scan codes in the Constants section of the System.UITypes unit. These are vkXXXX constants (vkEscape, vkReturn, vkF1, and others).
Shift specifies the combination of the ALT, CTRL, SHIFT, and CMD (only Mac) keys.
The action&apos;s shortcuts are listed in the ShortCut and SecondaryShortCuts properties.</docstr>
      </function>
      <property name="Text">
        <docstr>Represents the caption of the action.
Text holds the string that is used in the same way as the Caption of the action, when it is set. The value of Text is propagated to the action&apos;s clients.
Text is the same as Caption. You can use both Text and Caption, but descendant classes should only use the published property Text, so that the Object Inspector displays only the Text property, as in most FireMonkey components. 
In the Text property you can define an accelerator key.  On Windows platforms, an accelerator key is shown as an underlined letter.  To specify an accelerator key, precede an &lt;accelerator_letter&gt; with an ampersand &amp; character.  The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save action, type &amp;Save.  On Windows platforms, accelerator keys enable the user to activate actions pressing Alt+&lt;accelerator_letter&gt; key combination.  To show a single ampersand &amp; character in a Text property specify doubled ampersand &amp;&amp; characters.  Notice that &amp; and _ are seen and can be used only under Windows.</docstr>
      </property>
      <property name="ActionList">
        <docstr>Holds the action list to which the action belongs.
FMX.ActnList.TCustomAction.ActionList inherits from System.Actions.TContainedAction.ActionList. All content below this line refers to System.Actions.TContainedAction.ActionList.
Holds the action list to which the action belongs.</docstr>
      </property>
      <property name="HideIfUnsupportedInterface">
        <docstr>Defines whether the UnSupported action can be visible and accessible. 
If HideIfUnsupportedInterface is True, then the 
IsSupportedInterface function is used for retrieving the value of the Supported property. In this case, if IsSupportedInterface returns False, then this action is always inaccessible and invisible. 
If HideIfUnsupportedInterface is False, then this action can be visible or invisible depending on other properties. In this case, descendant classes or application objects should call IsSupportedInterface to retrieve the visibility and accessibility of the action.</docstr>
      </property>
      <property name="ShortCutPressed">
        <docstr>Specifies that the action is fired by pressing a keyboard key, not by clicking with the mouse.
ShortCutPressed is a read-only property. When ShortCutPressed is True, it specifies that the action is fired by pressing a keyboard key, and not by clicking a control with the mouse.</docstr>
      </property>
      <property name="Target">
        <docstr>Defines the component for which the action is executed.
Target is a read-only property. Target defines the component for which the action is executed. It can be nil. In the case where several controls can be called with one shortcut, Target corresponds to the first matched control.</docstr>
      </property>
      <property name="UnsupportedArchitectures">
        <docstr>Defines the set of unsupported CPU architectures.
The TArchitecture type defines the arIntelX86 and arIntelX64 constants that identify the processor architectures Intel x86 and Intel x64.
Use UnsupportedArchitectures to identify sets of unsupported processor architectures.</docstr>
      </property>
      <property name="UnsupportedPlatforms">
        <docstr>Defines the set of unsupported OS platforms.
The TPlatform type defines the pfWindows, pfMacOS, pfiOS, pfAndroid,  and pfLinux constants that identify the Windows, Mac OS, Android, and other platforms.
Use UnsupportedPlatforms to identify sets of unsupported OS platforms.</docstr>
      </property>
      <property name="Supported">
        <docstr>Defines whether the action can work on the current platform and CPU architecture. 
Supported is a read-only property. Supported defines whether the action can work on the current platform and CPU architecture. The value of this property is defined by the UnsupportedArchitectures  and UnsupportedPlatforms  properties and also by the IsSupportedInterface function. If Supported is False, then this action is always inaccessible and invisible.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.ActnList" name="TCustomViewAction">
    <docstr>A base class for actions that show a specified component when executed.
Descendants of TCustomViewAction can be associated with a component that is made visible when the action executes.
TCustomViewAction extends TCustomAction declaring the component that the action shows when it executes.
TObjectViewAction extends the TCustomViewAction class that defines the FmxObject property and keeps the component value that should be the TFmxObject type object in this case. 
Descendants of TObjectViewAction are associated with the TFmxObject type component that is made visible when the action executes.  
TVirtualKeyboard and TViewAction are standard actions that descend from TObjectViewAction.
Contrary to ordinary actions (like TAction, TControlAction, TCustomValueRangeAction, and so on) TCustomViewAction (and its descendants) does not distribute changes in values of Caption, Enabled, Checked, GroupIndex, ShortCut, Visible, and OnExecute properties to the respective properties of clients linked with action links.</docstr>
    <members>
      <procedure name="Notification">
        <docstr>Responds when components are created or destroyed.
FMX.ActnList.TCustomViewAction.Notification inherits from System.Classes.TBasicAction.Notification. All content below this line refers to System.Classes.TBasicAction.Notification.
Responds when components are created or destroyed.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. 
TBasicAction overrides the System.Classes.TComponent.Notification method. Notification checks whether the component specified by AComponent is the same as the component stored in the ActionComponent property and whether it is about to be freed. If so, Notification sets the ActionComponent property to nil (Delphi) or NULL (C++).</docstr>
      </procedure>
      <procedure name="DoCreateComponent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoBeforeShow">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoAfterShow">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="ComponentText">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ComponentChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetComponent">
        <docstr>Setter for the Component property.</docstr>
      </procedure>
      <event name="OnCreateComponent">
        <docstr>Is fired when the target component is created.
Event handlers of the TOnCreateComponent type have the following parameters: 



Parameter

Description


Sender

Is the instance of the action that fired the event.


NewComponent

Returns the created component.

Only a component object of the TFmxObject type can be created in the event handler of this event. If the created component is not a descendant of TFmxObject, then an exception is raised and a new object is destroyed.</docstr>
      </event>
      <event name="OnBeforeShow">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnAfterShow">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <function name="HandlesTarget">
        <docstr>Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
FMX.ActnList.TCustomViewAction.HandlesTarget inherits from System.Classes.TBasicAction.HandlesTarget. All content below this line refers to System.Classes.TBasicAction.HandlesTarget.
Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise.</docstr>
      </function>
      <property name="Component">
        <docstr>Keeps a component that executes an action and whose image becomes visible during the action execution.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.ActnList" name="TAction">
    <docstr></docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Memo" name="TCustomMemoModel">
    <docstr></docstr>
    <members>
      <function name="DoValidating">
        <docstr>Validate inputing text. Calling before OnChangeTracking</docstr>
      </function>
      <function name="DoValidate">
        <docstr>Validate inputed text. Calling before OnChange</docstr>
      </function>
      <procedure name="DoChangeTracking">
        <docstr>Call OnChangeTracking event</docstr>
      </procedure>
      <procedure name="DoChange">
        <docstr>Call OnChange event</docstr>
      </procedure>
      <procedure name="TextSettingsChanged">
        <docstr>Method is calling when some parameter of text settings was changed</docstr>
      </procedure>
      <function name="GetTextSettingsClass">
        <docstr>Returns class type that represent used text settings. Could be overridden  in descendants to modify
          default behavior</docstr>
      </function>
      <function name="HasSelection">
        <docstr>Does memo has selected text</docstr>
      </function>
      <function name="SelectedText">
        <docstr>Returns current selected text</docstr>
      </function>
      <procedure name="Change">
        <docstr>If there were made any changes in text OnChange will be raised</docstr>
      </procedure>
      <function name="TextPosToPos">
        <docstr>Convert absolute platform-dependent position in text to platform independent value in format
          (line_number, position_in_line)</docstr>
      </function>
      <function name="PosToTextPos">
        <docstr>Convert platform-independent position to absolute platform-dependent position</docstr>
      </function>
      <procedure name="InsertAfter">
        <docstr>Insert text in memo after defined position</docstr>
      </procedure>
      <procedure name="DeleteFrom">
        <docstr>Delete fragment of the text from the memo after defined position</docstr>
      </procedure>
      <procedure name="Replace">
        <docstr>Replace fragment of text from the memo in the specifeid range.</docstr>
      </procedure>
      <function name="GetCaretPositionByPoint">
        <docstr>Returns caret position by specified hittest point.</docstr>
      </function>
      <property name="AutoSelect">
        <docstr>Select all text when control getting focus</docstr>
      </property>
      <property name="Caret">
        <docstr>Contains component that represent current caret for control</docstr>
      </property>
      <property name="CharCase">
        <docstr>Defines character case for text in component</docstr>
      </property>
      <property name="CheckSpelling">
        <docstr>Switch on/off spell checking feature</docstr>
      </property>
      <property name="DataDetectorTypes">
        <docstr>Defines the types of information that can be detected in text
          (for native presentation on iOS only)</docstr>
      </property>
      <property name="HideSelectionOnExit">
        <docstr>Do not draw selected text region when component not in focus</docstr>
      </property>
      <property name="ReadOnly">
        <docstr>Text is in read-only mode</docstr>
      </property>
      <property name="ImeMode">
        <docstr>Default IME text input mode</docstr>
      </property>
      <property name="KeyboardType">
        <docstr>Defines visual type of on-screen-keyboard</docstr>
      </property>
      <property name="Lines">
        <docstr>Lines of text</docstr>
      </property>
      <property name="MaxLength">
        <docstr>Available maximum length of text (0 - no length limitation).</docstr>
      </property>
      <property name="SelectionFill">
        <docstr>Brush that is using to draw text selection region</docstr>
      </property>
      <property name="CaretPosition">
        <docstr>Current position of cursor in the text</docstr>
      </property>
      <property name="SelStart">
        <docstr>Text selection starting position</docstr>
      </property>
      <property name="SelLength">
        <docstr>Length of selected text</docstr>
      </property>
      <property name="TextSettingsInfo">
        <docstr>Container for current text visualization attributes</docstr>
      </property>
      <event name="OnChange">
        <docstr>Event that raises when control losing focus or user pressing ENTER key (but onlt if some changes were
          made)</docstr>
      </event>
      <event name="OnChangeTracking">
        <docstr>Event that raises on any change in text</docstr>
      </event>
      <event name="OnValidating">
        <docstr>Event that raises to validate any change in text (raises before OnChangeTracking event)</docstr>
      </event>
      <event name="OnValidate">
        <docstr>Event that raises to validate changes in text (raises before OnChange event)</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Memo" name="TCustomMemo">
    <docstr></docstr>
    <members>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Memo.TCustomMemo.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="DefineModelClass">
        <docstr>Returns a class reference to a data model of this presented control.
FMX.Memo.TCustomMemo.DefineModelClass inherits from FMX.Controls.Presentation.TPresentedControl.DefineModelClass. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefineModelClass.
Returns a class reference to a data model of this presented control.
Returns a class reference to a data model class that the constructor of this presented control uses to create a data model for the control.
By default DefineModelClass returns TDataModel. Descendant classes reimplement DefineModelClass to determine the data model class that a descendant presented control uses for its data model.

 See Also
FMX.Controls.Model.TDataModelClass
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Presentation.Style.TStyledPresentation.DefineModelClass
Class References</docstr>
      </function>
      <function name="DefinePresentationName">
        <docstr>Returns the name of the default presentation proxy that your presented control uses.
FMX.Memo.TCustomMemo.DefinePresentationName inherits from FMX.Controls.Presentation.TPresentedControl.DefinePresentationName. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefinePresentationName.
Returns the name of the default presentation proxy that your presented control uses.
You can handle OnPresentationNameChoosing to specify a presentation proxy name to use instead of the name that DefinePresentationName returns.
DefinePresentationName  calls TPresentationProxyFactory.GeneratePresentationName and returns a generated  presentation proxy name based on the class name of the presented control and the control type (Styled or Platform) of the presentation layer. For example:



Class name

Control type

Result


TMyPresentedControl

Styled

&quot;MyPresentedControl-Styled&quot;


TMyPresentedControl

Platform

&quot;MyPresentedControl-Platform&quot;

 See Also
System.TObject.ClassName
FMX.Controls.Presentation.TPresentedControl.ControlType
FMX.Presentation.Factory.TPresentationProxyFactory.Register
FMX.Controls.Presentation.TPresentationProxy
FMX.Controls.Presentation.TPresentedControl.OnPresentationNameChoosing
FMX.Controls.Presentation.TPresentedControl.LoadPresentation</docstr>
      </function>
      <function name="GetData">
        <docstr>Returns the text from the memo control.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Modifies the value of the Text property.
Sets the Text property to Value.</docstr>
      </procedure>
      <procedure name="DoBeginUpdate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoEndUpdate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetCanFocus">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="CanObserve">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ObserverAdded">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.Memo.TCustomMemo.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <procedure name="ClearSelection">
        <docstr>Delete selected text</docstr>
      </procedure>
      <procedure name="DeleteSelection">
        <docstr>Removes the selected text from the memo control.
Use DeleteSelection to delete the selected text from the memo control. If the ReadOnly property is True or if no text is selected, DeleteSelection does nothing.</docstr>
      </procedure>
      <procedure name="CopyToClipboard">
        <docstr>Copies the selected text from the memo control to the system Clipboard.
Use CopyToClipboard to replace the contents of the system Clipboard with the selected text. If no text is selected, CopyToClipboard does nothing.</docstr>
      </procedure>
      <procedure name="CutToClipboard">
        <docstr>Copies the selected text to the system Clipboard and then deletes the selected text.
Use CutToClipboard to replace the contents of the system Clipboard with the selected text and then to delete the selected text from the memo control. If no text is selected, CutToClipboard does nothing.</docstr>
      </procedure>
      <procedure name="PasteFromClipboard">
        <docstr>Copies the contents of the system Clipboard to the memo control.
PasteFromClipboard copies the contents of the system Clipboard, if possible, to the memo control, at the position of the cursor. If there is text selected in the memo control, the selected text will be removed. If the content of the system Clipboard is not a string, PasteFromClipboard does nothing.</docstr>
      </procedure>
      <procedure name="SelectAll">
        <docstr>Selects all the text in the memo control.
Use SelectAll to select all the text in the memo control. If there is no text in the memo control, SelectAll does nothing.</docstr>
      </procedure>
      <procedure name="SelectWord">
        <docstr>Selects the word that contains the cursor.
In the memo&apos;s text, SelectWord selects a delimited by word dividing characters (space characters, punctuation marks, and others) substring (word) that contains the cursor. Here word dividing characters are space characters, line feeds, and punctuation marks.</docstr>
      </procedure>
      <procedure name="ResetSelection">
        <docstr>Cancel the text selection if it exists.
The ResetSelection method internally sets the SelLength property to 0.</docstr>
      </procedure>
      <procedure name="GoToTextEnd">
        <docstr>Moves the cursor to the end of the text in the memo control.</docstr>
      </procedure>
      <procedure name="GoToTextBegin">
        <docstr>Moves the cursor to the beginning of the text in the memo control.</docstr>
      </procedure>
      <procedure name="Replace">
        <docstr>Replaces the ALength number of characters, beginning from the AStartPos position, with the AStr string.
The caret is moved to the position of the last inserted character.</docstr>
      </procedure>
      <procedure name="GoToLineEnd">
        <docstr>Moves the cursor to the end of the current visual line.
When WordWrap is True, then each line (in the memo text) can be separated into several &apos;visual lines&apos;.  
GoToLineEnd moves the cursor to the end of the current (pointed by the cursor) visual line.</docstr>
      </procedure>
      <procedure name="GoToLineBegin">
        <docstr>Moves the cursor to the beginning of the current visual line.
When WordWrap is True, then each line (in the memo text) can be separated into several &apos;visual lines&apos;.    
GoToLineBegin moves the cursor to the beginning of the current (pointed by the cursor) visual line.</docstr>
      </procedure>
      <procedure name="UnDo">
        <docstr>Undoing the latest text change made in the memo control.
UnDo backs out, if possible, the latest change made to the text in the memo control. If no change has been made, UnDo does nothing.

Note: Remove TDeleteOptions.CanUndo from Options calling DeleteFrom or TInsertOptions.CanUndo from Options calling InsertAfter when modifying the text in the memo control, so that the changes cannot be backed out.</docstr>
      </procedure>
      <function name="TextPosToPos">
        <docstr>Converts APos into a Line/Pos coordinate in the memo control.
TextPosToPos returns the TCaretPosition format position of a character indicated by APos. TextPosToPos calculates the TCaretPosition.Line line number and TCaretPosition.Pos horizontal shifting, corresponding to the APos character count coordinate of a character in the text of the memo control. 
Keep in mind that APos counts end-of-line characters. 
For example, if the first line of a memo&apos;s text contains &apos;Hello&apos; and the second line contains &apos;Goodbye&apos;, then the following code:

  OldPosition.Line := 1;           //Zero-based
  OldPosition.Pos := 2;            //Zero-based
  NewPosition := TextPosToPos(PosToTextPos(OldPosition) + 2);

sets the NewPosition.Line to 1 and NewPosition.Pos to 4.
TextPosToPos internally calls Model.TextPosToPos.</docstr>
      </function>
      <function name="PosToTextPos">
        <docstr>Converts a Line/Pos coordinate of a character into a number of this character in the text of the memo.
PosToTextPos returns an integer an integer representing a position of the character specified by APosition in the memo control. The APosition position is specified in the TCaretPosition format which uses the Line number and Pos horizontal shifting of the character in the memo control. Keep in mind that PosToTextPos calculates the character number counting end-of-line characters. 
For example, if the first line of a memo&apos;s text contains &apos;Hello&apos; and the second line contains &apos;Goodbye&apos;, then the following code:

  MyPosition.Line := 1;           //Zero-based
  MyPosition.Pos := 1;            //Zero-based
  MyString := Copy(Text, PosToTextPos(MyPosition) + 1, 3);

sets MyString to &apos;odb&apos;, which are the three characters starting from the third character of the second line.
PosToTextPos internally calls Model.PosToTextPos.</docstr>
      </function>
      <procedure name="InsertAfter">
        <docstr>Inserts the AFragment string into the memo&apos;s text, at APosition.
InsertAfter inserts in the memo&apos;s text the string specified by AFragment at the position specified by APosition. Options represent a set of insert options. 

Note: InsertAfter does not insert a newline character. If the Pos field of the APosition parameter is greater than the width of the specified line, then AFragment is inserted on the next line.
Note: If in a call of  InsertAfter one removes TInsertOptions.CanUndo from Options, then the implemented changes cannot be backed out.
InsertAfter internally calls Model.InsertAfter.</docstr>
      </procedure>
      <procedure name="DeleteFrom">
        <docstr>From the memo&apos;s text, deletes the fragment of text that has the ALength number of characters and begins at APosition.
Options specifies the delete options.

Note: If in a call of  DeleteFrom, one removes TDeleteOptions.CanUndo from Options, then the implemented changes cannot be backed out.
DeleteFrom internally calls Model.DeleteFrom.</docstr>
      </procedure>
      <property name="Model">
        <docstr>Holds the data model of the memo control.</docstr>
      </property>
      <property name="Text">
        <docstr>Represents the entire text displayed in the memo control.

Note: The visibility for Text is Public. Thus, Text is not available in the Object Inspector at design time.
For manipulating the text in a TMemo, you should use FMX.Memo.TMemo.Lines, which is available at design time in the Object Inspector.</docstr>
      </property>
      <property name="AutoSelect">
        <docstr>Defines whether the system selects all the memo&apos;s text when the control receives focus.
AutoSelect defines whether the system selects all the Text included in the TCustomMemo memo when the control receives focus. If AutoSelect is True, then all text is selected when the memo receives focus. 
In TMemo, AutoSelect is set to False.</docstr>
      </property>
      <property name="Caret">
        <docstr>Provides access to the TCaret attached to the memo control.</docstr>
      </property>
      <property name="CharCase">
        <docstr>Defines the character case for the text within the memo control.
Modify the CharCase|CharCase property&apos;s value in order to change the case of the text in the memo control. 
Options are: ecNormal, ecUpperCase and ecLowerCase.</docstr>
      </property>
      <property name="CheckSpelling">
        <docstr>Defines whether the spell-checking feature of the memo control is on or off.
This property enables spell checking on the TMemo component. When set to True a red squiggly line appears underlining the words misspelled.  
The spell checking is performed by an operating system service. It is only supported on iOS and OS X.</docstr>
      </property>
      <property name="DataDetectorTypes">
        <docstr>The types of information that can be detected in the memo text.
DataDetectorTypes is used on native presentation for iOS only.</docstr>
      </property>
      <property name="HideSelectionOnExit">
        <docstr>Determines whether to cancel the visual indication of the selected text region when the memo control does not have the focus.
If HideSelectionOnExit is False, then the memo keeps highlighting the selected text using the SelectionFill brush, even when the focus moves from the memo to another control.</docstr>
      </property>
      <property name="ImeMode">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.
Specifies the TImeMode input mode for the memo control.</docstr>
      </property>
      <property name="KeyboardType">
        <docstr>Specifies the type of on-screen keyboard to be displayed for the memo control.
Use KeyboardType to specify the type of on-screen keyboard that appears for the memo when ShowVirtualKeyboard is called.</docstr>
      </property>
      <property name="Lines">
        <docstr>Provides access to the individual lines in the memo text.
The memo text can contain several line break symbols that separate the whole memo text into several lines. Depending on the current platform, a line break symbol can be a LF &apos;line feed&apos; character (MacOS) or a CRLF &apos;carriage return&apos; plus &apos;line feed&apos; pair (Windows). Lines holds the memo text separated line by line. 
When WordWrap is True then each line (specified in the Lines property) can be wrapped into several &apos;visual lines&apos; to fit to the memo width. However these several &apos;visual lines&apos; are still represented by a single string element in the Lines property. 

Notice that GoToLineBegin and GoToLineEnd move the cursor to the beginning or the end of the current (pointed by the cursor) visual line.
Lines is a TStrings object, so you can use TStrings methods to work with the Lines property. 
For example, you can count the number of lines: 

ShowMessage(&apos;The number of lines:&apos; + IntToStr(Memo1.Lines.Count));

You can add new lines: 

Memo1.Lines.Append(&apos;New text to append at the end of memo&apos;);

You can delete lines:  

Memo1.Lines.Delete(0); // Deletes the fist line from memo

You can replace a line with a new string:

Memo1.Lines[8] := &apos;Replace 9th  line with this string&apos;;

To work with all the memo&apos;s text at once, one can use the Text property.</docstr>
      </property>
      <property name="MaxLength">
        <docstr>Specifies the maximum number of characters that can be kept in the memo control.
If the text in the memo control contains more characters than the MaxLength, then the text is truncated to the MaxLength characters. 
If the memo control already contains a number of characters equal to MaxLength, then the user cannot enter any more characters. 
MaxLength counts end-of-line characters. 
If MaxLength is 0, then no explicit length limitation is set.

Note: Even when MaxLength is 0, there may be limitations imposed by a platform on the number of characters that may be entered into a memo control.</docstr>
      </property>
      <property name="ReadOnly">
        <docstr>Specifies whether the memo&apos;s text can be changed.
ReadOnly equals to True forbids any modification of the text in the memo control.</docstr>
      </property>
      <property name="CaretPosition">
        <docstr>Provides access to the current cursor position in the memo&apos;s text.
Use CaretPosition to determine the coordinates of the cursor (insertion point) in the memo control. The TCaretPosition type has Line and Pos integer fields:

Line represents the number of the line containing the cursor, indexed from zero.
Pos represents the horizontal character coordinate of the cursor, indexed from zero.
Modify the value of the CaretPosition property in order to change the position of the cursor within the memo control. In order for the cursor to be visible, the memo control must have focus.
Thus, if Line = 3 and Pos = 5, then the cursor is at the fourth line and at the sixth character from the start of the line.</docstr>
      </property>
      <property name="SelectionFill">
        <docstr>Represents the brush to draw the selected text region in the memo control.
Use SelectionFill to change the brush characteristics for the selected text region in the memo control. For example, to change the background color of the selected text region, use:

 Memo1.SelectionFill.Color := System.UIConsts.claCoral;</docstr>
      </property>
      <property name="Font">
        <docstr>Specifies the family, size, and style properties of the text font in the memo control.</docstr>
      </property>
      <property name="FontColor">
        <docstr>Specifies the font color of the text in this memo.
Use the FontColor property to read or change the font color of the text in this memo component. The default value of the FontColor property is TAlphaColorRec.Black.</docstr>
      </property>
      <property name="TextAlign">
        <docstr>Specifies the horizontal alignment of the text in the memo control.
Use the TextAlign property to change the horizontal alignment of the text in the memo control. TextAlign can be one of the Center, Leading, or Trailing values defined in TTextAlign.
When you use text representation properties stored in the 
TextSettings property, remember that TextAlign corresponds to HorzAlign.</docstr>
      </property>
      <property name="WordWrap">
        <docstr>Specifies whether to wrap the text in the memo when its length is greater than the memo width.
Set WordWrap to True to wrap the text in the memo control. Wrapping implies the division of the text string that is wider than the memo control onto several lines that fit to the memo control&apos;s width.</docstr>
      </property>
      <property name="SelStart">
        <docstr>Specifies the zero-based number of the first character selected in the memo&apos;s text.
Read SelStart to determine the number of the first selected character, where 0 indicates the first character. If there is no selected text, then SelStart returns the cursor position. Keep in mind that the SelStart character count includes end-of-line characters at the end of each line.
To select a particular range of the text, first set SelStart to position the cursor, and then set SelLength to extend the selection. The memo component must have focus (call SetFocus) before you attempt to use SelStart; otherwise the selection is invisible.</docstr>
      </property>
      <property name="SelLength">
        <docstr>Specifies the number of characters that are selected in the memo control.
Read SelLength to determine the length, in characters, of the selected text.
Set the value of the SelLength property in order to specify the length of the selected text, starting at SelStart. Keep in mind that the character count from SelLength will include end-of-line characters at the end of each line.
To select a particular range of the text, first set SelStart to position the cursor, and then set SelLength to extend the selection. The memo component must have focus (call SetFocus) before you attempt to use SelStart; otherwise the selection is invisible.

Note: Setting SelLength to a value greater than the number of characters from SelStart to the end of the text results in the selection of all characters from SelStart to the end of the text. Reading SelLength immediately after setting it to a value greater than the number of available characters returns the number of characters actually selected, not the value that was just set.</docstr>
      </property>
      <property name="SelText">
        <docstr>Represents the currently selected fragment of the memo&apos;s text.
Use SelText in order to retrieve the text that is selected, from the TCustomMemo control. If there is no selection,  SelText is an empty string. If the memo control does not have the focus, SelText represents the previous selected portion of the text.</docstr>
      </property>
      <property name="StyledSettings">
        <docstr>Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
Text representation properties are used as parameters for drawing texts in controls.
The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
StyledSettings can contain the Family, Size, Style, FontColor, and 
Other values defined in TStyledSetting. The &quot;Relation between TStyledSetting constants and TTextSettings properties&quot; table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):

With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
VertTextAlign properties of the control.</docstr>
      </property>
      <property name="TextSettings">
        <docstr>Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
TTextSettings type objects provide all styled text representation properties and methods to manage them.
The styled text representation properties are 
FontColor, TextAlign,
VertTextAlign,
Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
VertTextAlign properties of the control.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs when the focus leaves the memo or the user presses ENTER. The event occurs only when the text has changed.
OnChange is raised when the following situations occur:

Text is cleared in the memo
Text is set in the memo
The memo loses focus
The user presses the ENTER key
Write an OnChange event handler to check the modified text data.</docstr>
      </event>
      <event name="OnChangeTracking">
        <docstr>Occurs on any change in the memo&apos;s text.
Write an OnChangeTracking event handler to respond immediately to any changes made in the memo control&apos;s text. The OnChangeTracking event provides the first opportunity to respond to modifications that the user makes by typing into the memo control. 
The Text property of the memo control is already updated and reflects any changes when OnChangeTracking is raised.
The difference between OnChangeTracking and OnChange is that OnChangeTracking occurs at each modification of text in the memo control. 

Note: OnChangeTracking does not occur when only text representation characteristics are changed (for example, when changing TextAlign).</docstr>
      </event>
      <event name="OnValidating">
        <docstr>Raises to validate any change has been made in the memo&apos;s text. Occurs before the OnChangeTracking event.
In descendent classes, to change when to raise the OnValidating event, redefine the virtual  TCustomMemoModel.DoValidating method.</docstr>
      </event>
      <event name="OnValidate">
        <docstr>Raises to validate changes have been made in the memo&apos;s text when the memo has lost the focus or the user has pressed ENTER. The OnValidate event occurs before the OnChange event.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Memo" name="TMemo">
    <docstr>TMemo is a multiline text editing control, providing text scrolling.
Use TMemo to place a standard multiline edit control on a form. Multiline edit boxes allow the user to enter more than one line of text. They are appropriate for representing large amounts of text. 
The text in the memo control can be edited as a whole or line by line. 
The characteristics of the text in the memo control can be modified by using, for example, Font, FontColor, or CharCase.
To limit the changes made to the memo control, use properties such as ReadOnly, Enabled, or MaxLength.
When not in focus, TMemo does not draw a selection rectangle even though the user has selected the text. You can verify whether the text is selected by using the SelText property.

Note: When a number of lines in a control is more than can be concurrently shown in the control, then you can use a scroll bar to scroll the text in the control. Notice that on Windows the scroll bar is shown by default. However, on OS X the scroll bar is not shown by default. On OS X, the scroll bar appears when you try to scroll a text using the mouse wheel. To enforce the scroll bar to be shown by default, in the Object Inspector, select the memo control and set the AutoHide to False.</docstr>
  </class>
  <class unit="System.Actions" name="TContainedAction">
    <docstr></docstr>
    <members>
      <procedure name="ReadState">
        <docstr>Reads the state of the action.
ReadState is used internally in the actions system. It is not necessary to call it directly.
ReadState calls the inherited System.Classes.TComponent.ReadState procedure. Then 
ReadState checks whether the Parent of Reader (Reader.Parent) is an action list, then ReadState sets that the action belongs to this action list (ActionList).</docstr>
      </procedure>
      <function name="SecondaryShortCutsCreated">
        <docstr>Retrieves whether the list stored in the SecondaryShortCuts property is created.
SecondaryShortCutsCreated returns True if the SecondaryShortCuts list is created.</docstr>
      </function>
      <function name="CreateShortCutList">
        <docstr>Introduces an interface for creating the ShortCutList object for the action.
As implemented in TContainedAction, CreateShortCutList does not create any shortcut list object and just returns nil.</docstr>
      </function>
      <property name="SavedEnabledState">
        <docstr>Stores the value of the Enabled property when the action is suspended.
The System.Actions.TContainedActionList.SetState method uses SavedEnabledState internally:

When System.Actions.TContainedActionList.SetState changes State from asSuspendedEnabled to asNormal, then the value stored in SavedEnabledState is used to set the Enabled property.
When System.Actions.TContainedActionList.SetState sets State to asSuspendedEnabled, then the value of the Enabled property is saved in SavedEnabledState and Enabled is set to True.</docstr>
      </property>
      <procedure name="AssignTo">
        <docstr>Copies the properties of this action to a destination action.
Dest specifies the destination action. AssignTo ensures the correct assignment of property values.
If Dest is nil or Dest is not of the TContainedAction type, then an error is raised.</docstr>
      </procedure>
      <function name="HandleShortCut">
        <docstr>Executes the action when the user types one of its shortcuts.
HandleShortCut calls System.Classes.TBasicAction.Execute to cause the action to perform its function. HandleShortCut returns the value that System.Classes.TBasicAction.Execute returns.
Descendant classes can override HandleShortCut to respond in other ways when the user types the action&apos;s shortcut keys.</docstr>
      </function>
      <procedure name="SetAutoCheck">
        <docstr>Sets the specified Value to the AutoCheck property of the action, and propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetCaption">
        <docstr>Sets the specified Value to the Caption property of the action, and propagates this Value to all the clients of the action.</docstr>
      </procedure>
      <procedure name="SetName">
        <docstr>Sets the Name and Caption properties of the action.
SetName calls the inherited System.Classes.TComponent.SetName method to set the specified Value to the Name property of the action. If the action does not have any clients and the current values of the Name and Caption properties of the action are equal, then SetName sets Value to the Caption property of the action also. 

Warning: Using SetName to change the name of an action at run time causes any references to the old name to become undefined. Any subsequent code that uses the old name will cause an exception.</docstr>
      </procedure>
      <procedure name="SetChecked">
        <docstr>Sets the specified Value to the Checked property of the action, and propagates this Value to all clients of the action.
If the action has a GroupIndex value greater than 0, then setting Checked to True causes all other actions in the group to have their Checked property set to False.</docstr>
      </procedure>
      <procedure name="SetEnabled">
        <docstr>Sets the Enabled property of the action to the specified Value and propagates this Value to all clients of the action.
The behavior of SetEnabled depends upon the State of the ActionList action list:

If the value of State is asSuspended, then SetEnabled sets to the specified Value only the Enabled property of the action.
If the value of State is asSuspendedEnabled, then SetEnabled sets to True the Enabled property of the action and of all clients of the action.
Otherwise, SetEnabled sets to the specified Value the Enabled property of the action and propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetGroupIndex">
        <docstr>Sets the specified Value to the GroupIndex property of the action and properly handles the ON or OFF state of the Checked properties of all actions in the group specified by Value.
SetGroupIndex sets the specified Value to the GroupIndex property of the action. If the Checked property of this action is True, then SetGroupIndex sets the Checked property to False for all the other actions in the group defined by the specified Value. 
When Value is greater than 0, the group of actions with the GroupIndex property having this Value forms a group of actions that act like a group of radio buttons. When the Checked property of any action in this group is True, the Checked properties of all other actions in the group are False. That is, one and only one action in the group is checked ON at a time.

Note: All actions in a group must be listed by the same action list.</docstr>
      </procedure>
      <procedure name="SetHelpContext">
        <docstr>Sets the Help context ID for the action and action&apos;s clients.
SetHelpContext sets the new Value of the integer help context ID, stored in the HelpContext property, for the action.
SetHelpContext always propagates this Value to all clients of the action.
HelpContext is only used when htContext is selected in the HelpType property.

Note: To use Help in your application, you need to enable Help in your application.</docstr>
      </procedure>
      <procedure name="SetHelpKeyword">
        <docstr>Defines the Help keyword for the action and action&apos;s clients.
SetHelpKeyword sets the new Value of the string help keyword, stored in the HelpKeyword property, for the action.
SetHelpKeyword always propagates this Value to all clients of the action.
HelpKeyword is only used when htKeyword is selected in the HelpType property.</docstr>
      </procedure>
      <procedure name="SetHelpType">
        <docstr>Sets the HelpType property for the action and action&apos;s clients.
SetHelpType sets the new Value of the HelpType property for the action.
SetHelpType always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetHint">
        <docstr>Sets the Hint property for the action and action&apos;s clients to a new Value.
SetHint sets the new Value of the Hint property for the action. 
SetHint always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetVisible">
        <docstr>Sets the new Value of the Visible property for the action and action&apos;s clients.
SetVisible always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetShortCut">
        <docstr>Sets the new Value of the ShortCut property for the action and action&apos;s clients.
SetShortCut always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetImageIndex">
        <docstr>Sets the new Value of the ImageIndex property for the action and action&apos;s clients.
SetImageIndex always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetStatusAction">
        <docstr>Sets the new Value of the StatusAction property for the action and action&apos;s clients.
SetStatusAction always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Instantiates and initializes a TContainedAction object.
Applications do not need to call Create directly. Actions are created automatically when you choose New Action in the Action List editor. 
Create calls the inherited System.Classes.TBasicAction.Create constructor and then 
initializes the Enabled (setting it to True), Visible (setting it to True), and ImageIndex (setting it to -1) properties.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the instance of the contained action.
If the action is contained in an action list or action manager, Destroy removes the action from that list. Then it calls the inherited Destroy method.</docstr>
      </destructor>
      <function name="GetParentComponent">
        <docstr>Returns the action list containing the action.
GetParentComponent returns the action list containing the action. This action list is stored in the ActionList property. If ActionList stores nil, then GetParentComponent calls the inherited System.Classes.TComponent.GetParentComponent method.</docstr>
      </function>
      <function name="HasParent">
        <docstr>Indicates whether the action is contained in an action list.
HasParent returns True if the action is contained in an action list stored in the  ActionList property. If ActionList stores nil, then HasParent calls the inherited System.Classes.TComponent.HasParent method.</docstr>
      </function>
      <procedure name="SetParentComponent">
        <docstr>Sets the action list containing the action.
SetParentComponent sets the specified AParent action list as the action list containing the action. This action list is stored in the ActionList property.</docstr>
      </procedure>
      <property name="ActionList">
        <docstr>Holds the action list to which the action belongs.</docstr>
      </property>
      <function name="Suspended">
        <docstr>Returns True if the action list of the action is suspended.</docstr>
      </function>
      <property name="Index">
        <docstr>Specifies the index of the action in its action list.
Index indicates the position of the action in its action list. You can change the action&apos;s Index at design time using one of the IDE editors to handle actions.
The index of actions determines the order in which they appear in user interface elements such as menus and tool bars.
Index is zero-based. When Index is -1, this means that the ActionList property does not contain any list.</docstr>
      </property>
      <property name="DisableIfNoHandler">
        <docstr>Indicates whether the action&apos;s clients should be disabled if no OnExecute event handler is found.
DisableIfNoHandler defines whether to set the Enabled property of the action to False if no OnExecute event handler is set for the action. Setting Enabled to False disables all the action&apos;s clients.
See, for example, how FMX.Forms.TApplication.UpdateAction uses DisableIfNoHandler to define whether to set Enabled to False if the OnExecute event handler is not defined to the action.
For example, setting DisableIfNoHandler to False can be useful when managing submenus. In this case, pointing to a command on the main menu, which causes the submenu to open, does not need any OnExecute event handler. Then, if DisableIfNoHandler is True, this main menu command becomes disabled and the submenu cannot be opened. In such cases it can be convenient to use actions of types FMX.Controls.TControlAction and Vcl.Controls.TControlAction.  Objects of these classes have the value of DisableIfNoHandler set to False, by default.</docstr>
      </property>
      <property name="AutoCheck">
        <docstr>Controls whether the Checked property toggles when the action executes.
AutoCheck causes the Checked property to toggle when the action executes. This allows the Checked property of the action to remain in sync with the Checked property of the client (or an equivalent).
If the client has an AutoCheck property of its own, the AutoCheck property of the action is propagated to the AutoCheck property of the client.</docstr>
      </property>
      <property name="Caption">
        <docstr>Represents the caption of the action.
Caption holds the string that is used as the caption of the action, when it is set. The value of Caption can be propagated to all client controls and client menu items linked to the action.</docstr>
      </property>
      <property name="Checked">
        <docstr>Indicates whether client controls and menu items appear checked.
Checked specifies the checked state for the action. The value of Checked can be propagated to all client controls and client menu items linked to the action.

Note:  If the action has a GroupIndex value greater than 0, then setting Checked to True sets to False the Checked properties of all other actions in the GroupIndex group.
Tip: Use the AutoCheck property to ensure that the action&apos;s Checked property toggles when the action executes.</docstr>
      </property>
      <property name="Enabled">
        <docstr>Specifies the enabled state for the action.
The value of Enabled can be propagated to all client controls and client menu items linked to the action.</docstr>
      </property>
      <property name="GroupIndex">
        <docstr>Indicates a group of actions in one action list. Actions in this group act like the group of radio buttons.
The value of GroupIndex is used to define groups of actions. Actions in each group act like groups of radio buttons. When GroupIndex is greater than 0, this value identifies the group to which some actions belong. The value of GroupIndex can be propagated to all client controls and client menu items linked to the action.
When the Checked property of any action in that group is set to True, the Checked properties of all other actions in the group are set to False. That is, only one action in the group can be checked at a time.

Note:  All actions in a group must be listed by the same action list.</docstr>
      </property>
      <property name="HelpContext">
        <docstr>Keeps the integer context ID that identifies the Help topic for the action.
HelpContext specifies the integer context ID  to identify the Help topic to show when invoking Help for the action. The value of HelpContext can be propagated to all client controls and client menu items linked to the action. See also IsHelpLinked.
HelpContext is only used when htContext is selected in the HelpType property.

Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the value of the HelpContext property to invoke the online Help that shows the topic with this context ID. The target topic is uniquely identified by a HelpContext context ID value.</docstr>
      </property>
      <property name="HelpKeyword">
        <docstr>Contains the keyword string that identifies the Help topic for the action.
The value of HelpKeyword can be propagated to all client controls and client menu items linked to the action. 
HelpKeyword is only used when htKeyword is selected in the HelpType property.

Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the HelpKeyword property&apos;s value to invoke the online Help showing the topic with this keyword.</docstr>
      </property>
      <property name="HelpType">
        <docstr>Keeps whether to use the HelpContext or HelpKeyword property to identify the Help topic.
The value of HelpType can be propagated to all client controls and client menu items linked to the action. 
HelpType can keep one of the following constants:

htContext instructs to use the HelpContext property to identify the Help topic to show when invoking Help.
htKeyword instructs to use the HelpKeyword property to identify the Help topic to show when invoking Help.</docstr>
      </property>
      <property name="Hint">
        <docstr>Stores the Help hint text.
Hint holds the hint string indicating the hint text for the action.
Hint contains the text strings that appear in a pop-up box (or in a status bar) when the user moves the mouse over screen elements.
This hint string can be propagated to clients of the action to controls, menu items, and other GUI elements. 

Note: VCL controls support hint strings containing three parts that can be shown in separate locations (see Vcl.Controls.TControl.Hint).</docstr>
      </property>
      <property name="Visible">
        <docstr>Stores whether the action representation is visible.
Visible specifies the visible state for the action (True means visible, False means invisible).
This Visible value is propagated to a client of the action if IsVisibleLinked method of the action link linking the client to the action  returns True.
If the Visible of an action is False and IsVisibleLinked of an action link returns True, then the Visible of the client (a control, menu item, or others) is also set False and this client is also invisible. Typically, IsVisibleLinked of an action link returns False if the action belongs to TCustomViewAction. Otherwise, when the action belongs to TAction, then  IsVisibleLinked of an action link returns True. That is, TCustomViewAction is used when one need to provide visible representation of clients of actions that have Visible set True.</docstr>
      </property>
      <property name="ShortCut">
        <docstr>Shortcut that triggers the action.
The value of Shortcut can be propagated to all client controls and client menu items linked to the action.</docstr>
      </property>
      <property name="SecondaryShortCuts">
        <docstr>Stores shortcuts (in addition to ShortCut) for triggering the action.
Actions can execute in response to multiple shortcut key combinations. SecondaryShortCuts lists all the shortcut key combinations (other than the one specified by the ShortCut property) that can trigger the action. This lets you provide additional, secondary shortcuts.
When the user types one of the key combinations listed in SecondaryShortCuts, the action&apos;s Execute method is called.</docstr>
      </property>
      <property name="ImageIndex">
        <docstr>Stores an index in a list of images.
ImageIndex is a zero-based index in a list of images. TContainedAction does not provide the actual list of images, only implementations of actions in GUI application frameworks provide such a property. In general, this list of images contains images that are associated with controls and menu items that use this action.
The value of ImageIndex can be propagated to all client controls and client menu items linked to the action. 

Note: When ImageIndex is -1, this means that the list does not contain any images.
In typical implementations of controls, an image is drawn at the leftmost position in the control, and a control&apos;s text is drawn to the right of the image. If ImageIndex is -1, then a control does not offset the text to the right to reserve a placeholder for the image. Otherwise, if ImageIndex is not -1, then the control&apos;s text is always drawn with the offset to the right to reserve a place for drawing an image.</docstr>
      </property>
      <function name="DoHint">
        <docstr>Calls the OnHint event handler.
Typically, applications do not call the DoHint method. It is called automatically when the user pauses the mouse on one of the action&apos;s client controls or menu items. DoHint is called by the action&apos;s client when the client asks to show the hint.

DoHint checks for an OnHint event handler and passes HintStr to it, if the event handler exists. The OnHint event handler can change the specified hint string HintStr. DoHint returns True if no event handler is assigned or if OnHint returns True. DoHint can be used to determine which hint text should be shown. For example, Vcl.Controls.TControlActionLink.DoShowHint calls DoHint internally, and if DoHint returns True, then Vcl.Controls.TControlActionLink.DoShowHint appends the action&apos;s shortcut specification to the hint text to display.</docstr>
      </function>
      <event name="OnHint">
        <docstr>Occurs when the mouse pauses over a client control or menu item.
Use OnHint to override the default hint that appears when the user pauses the mouse over a client control or menu item. The OnHint event handler can change the hint that appears (by changing the string stored in the client&apos;s Hint property), or display the hint in an application-specific way.</docstr>
      </event>
      <property name="StatusAction">
        <docstr>Stores the status for an input field in an action.
StatusAction holds the status for an input field in the action, when it is set. 
The value of StatusAction  can be propagated to all client controls and client menu items linked to the action.</docstr>
      </property>
      <property name="Category">
        <docstr>Group or category where the action belongs.
IDE editors for actions group together actions that share the same category. In the VCL, if you are using an action manager, you can generate user interface elements that correspond to action categories.
Action categories group actions by similarities, usually of behavior or functionality. Standard categories are Edit, Format, Help, Windows, and others. At design time you can modify or set the Category for an action by selecting the action from the action list or object tree view, and choosing Category in the Object Inspector.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Actions" name="TContainedActionList">
    <docstr></docstr>
    <members>
      <function name="ActionsCreated">
        <docstr>Returns True if the internal list of actions of the TContainedActionList instance has been created. It returns False otherwise.
The internal list of actions is created when you create the TContainedActionList instance.</docstr>
      </function>
      <procedure name="CheckActionsCreated">
        <docstr>Raises an EActionError exception if the internal list of actions of the TContainedActionList has not been created.</docstr>
      </procedure>
      <procedure name="AddAction">
        <docstr>Adds an action to the list.
Applications cannot call this protected method. AddAction is used internally to add an action to the Actions property array.
To add an action to an action list, set the action&apos;s ActionList property.</docstr>
      </procedure>
      <procedure name="RemoveAction">
        <docstr>Removes an action from the list.
Applications cannot call this protected method. RemoveAction is used internally to remove an action from the Actions property array. RemoveAction removes the action and sets its ActionList property to nil (Delphi) or NULL (C++).
To remove an action from an action list, change the action&apos;s ActionList property.</docstr>
      </procedure>
      <procedure name="Change">
        <docstr>Triggers the OnChange event on the action list and then on all its actions.
The internal list of actions is created when you create the TContainedActionList instance.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Handles notifications about the removal of one of the actions of the list.
If AComponent is an action of the list and Operation is opRemove, the action is removed from the list.</docstr>
      </procedure>
      <procedure name="SetChildOrder">
        <docstr>Sets the order in which actions are passed to a callback by the GetChildren method.
SetChildOrder specifies the order in which the component streaming system loads and saves the action components owned by this action list. It ensures that the actions are loaded and saved in the same order that they appear in the Actions property array. You should not need to call this method directly.</docstr>
      </procedure>
      <procedure name="SetState">
        <docstr>Sets the State property for the action list. 
If Value is asSuspendedEnabled, then SetState also sets Enabled to True for all the actions in the action list. This is useful when designing in the Action Manager.
If the OnStateChange event handler is set, then SetState calls this event handler.</docstr>
      </procedure>
      <event name="OnChange">
        <docstr>Occurs when a change occurs in the action list.
Write an OnChange event handler to update your application in response to changes in the action list. Changes to the action list that trigger an OnChange event include changes to an action category or to the action list&apos;s image list.

Note:  The action list automatically informs the actions in the list when an OnChange event occurs. You need only provide an OnChange event handler for application-specific responses.
OnChange is an event handler of type TNotifyEvent.</docstr>
      </event>
      <event name="OnExecute">
        <docstr>Occurs when a client object triggers an action in the list.
Write an OnExecute event handler to respond when an action in the list fires.
When the user invokes a client object, the action list  s OnExecute event is the first event to occur in response. If the OnExecute event handler sets its Handled parameter to True, the action is considered handled, and processing stops there. This blocks the execution of any other event handlers or any built-in response by a predefined action class in response to the user action.
If the OnExecute event handler does not set its Handled parameter to True, the application  s OnActionExecute event occurs next. If the OnActionExecute event does not respond to the user input, the action object  s OnExecute event occurs. Finally, if the action does not have an OnExecute event handler, the application locates a target object and executes any predefined response implemented by the action object.</docstr>
      </event>
      <event name="OnUpdate">
        <docstr>Occurs when the application is idle so that the action list can update a specific action in the list.
Write an OnUpdate event handler to configure the properties of a specified action in the list so that it reflects current conditions.
When the application is idle, it cycles through every action in turn, giving it a chance to update itself to reflect current conditions. For each action, the first event to occur in this sequence is the action list&apos;s OnUpdate event. If the OnUpdate event handler sets its Handled parameter to True, the action is considered updated, and processing stops there. This blocks the execution of any other event handlers or any built-in response by a predefined action class.
If the OnUpdate event handler does not set its Handled parameter to True, the application&apos;s OnActionUpdate event occurs next. If the OnActionUpdate event does not update the action, the action object&apos;s OnUpdate event occurs. Finally, if the action does not have an OnUpdate event handler, the application executes any predefined update method implemented by the action object.</docstr>
      </event>
      <function name="SameCategory">
        <docstr>Returns True if the Source and Dest categories are the same. If IncludeSubCategory is True, this function also returns true if Dest is a subcategory of Source.
These are some examples of calls to this function:



Source

Dest

IncludeSubCategory

Result


File

File

True

True


File.Recent

File

True

False


File

File.Recent

True

True


File

File

False

True


File.Recent

File

False

False


File

File.Recent

False

False</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates an instance of TContainedActionList.
This creator is inherited from TComponent, see TComponent.Create for more information.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TContainedActionList.
This destructor is inherited from TComponent, see TComponent.Destroy for more information.</docstr>
      </destructor>
      <function name="ExecuteAction">
        <docstr>Generates an OnExecute event.
Typically, applications do not call the ExecuteAction method. Instead, the action indicated by the Action parameter calls ExecuteAction in response to a user command. It is possible, however, to call ExecuteAction to generate an OnExecute event even though no client control has been triggered.
ExecuteAction invokes the OnExecute event handler for the action list. It returns True if the event handler handles the action, False otherwise.</docstr>
      </function>
      <procedure name="GetChildren">
        <docstr>Calls a specified method for each child action of the action list.
GetChildren is used by the component streaming system. For each action in the action list, GetChildren calls the method passed in Proc. The actions are passed to the callback in the order that they are loaded or saved by the component streaming system.</docstr>
      </procedure>
      <function name="GetEnumerator">
        <docstr>Returns a TContainedActionList enumerator, a TActionListEnumerator reference that enumerates the actions in the list.
To process all actions, read Current from the enumerator within a   while MoveNext do   loop.</docstr>
      </function>
      <function name="UpdateAction">
        <docstr>Generates an OnUpdate event.
Typically, applications do not call the UpdateAction method. Instead, the action indicated by the Action parameter calls UpdateAction when informed by the application that it can update itself. It is possible, however, to call UpdateAction to generate an OnUpdate event even though this has not been initiated by the application.
UpdateAction invokes the OnUpdate event handler for the action list. It returns True if the event handler updates the action, False otherwise.</docstr>
      </function>
      <function name="EnumByCategory">
        <docstr>Calls the specified procedure (TEnumActionListEvent or TEnumActionListRef) once for every action of the list in the specified category.
IncludeSubCategory determines whether actions in subcategories are included (True) or not (False) in the loop of calls.
Proc, an instance of either TEnumActionListEvent or TEnumActionListRef, can set its Done argument to True to stop the loop of calls prematurely.</docstr>
      </function>
      <function name="EnumByCategory">
        <docstr>Calls the specified procedure (TEnumActionListEvent or TEnumActionListRef) once for every action of the list in the specified category.
IncludeSubCategory determines whether actions in subcategories are included (True) or not (False) in the loop of calls.
Proc, an instance of either TEnumActionListEvent or TEnumActionListRef, can set its Done argument to True to stop the loop of calls prematurely.</docstr>
      </function>
      <property name="ActionCount">
        <docstr>Indicates the number of actions in the action list.
ActionCount indicates how many actions are contained in the action list.</docstr>
      </property>
      <property name="State">
        <docstr>Indicates whether the actions in the action list respond when the user triggers a client object. 
State can be one of the constants defined in the TActionListState type: 
asNormal, asSuspended, and asSuspendedEnabled.</docstr>
      </property>
      <event name="OnStateChange">
        <docstr>Occurs after the State property&apos;s value is changed.
Write an OnStateChange event handler to respond after the State property&apos;s value is changed.</docstr>
      </event>
    </members>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TBaseObjectBindSource">
    <docstr></docstr>
    <members>
      <procedure name="UpdateAdapterChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="UpdateAdapterChanging">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetInternalAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="CheckRuntimeAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetRuntimeAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ConnectAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DisconnectAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoMemberRenamed">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoMemberRenaming">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterUpdateState">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterDataSetChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterDataSetScrolled">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterEdit">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterEditingChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterLayoutChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterUpdateRecord">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterRecordChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetActive">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="CheckAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetInternalAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetRuntimeAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetMember">
        <docstr>Returns the member for the given member name.
Data.Bind.ObjectScope.TBaseObjectBindSource.GetMember inherits from Data.Bind.Components.TBaseBindScopeComponent.GetMember. All content below this line refers to Data.Bind.Components.TBaseBindScopeComponent.GetMember.
Returns the member for the given member name.
The GetMember method returns the scope member, as a TObject, for the member name given through the AMemberName parameter. This member is later used in the generated bindings expressions.

Tip: This member object or its properties may be referenced by bindings expressions.</docstr>
      </function>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
Data.Bind.ObjectScope.TBaseObjectBindSource.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
Data.Bind.ObjectScope.TBaseObjectBindSource.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <procedure name="AddExpression">
        <docstr>Adds the given bind component to the Expressions list.
Data.Bind.ObjectScope.TBaseObjectBindSource.AddExpression inherits from Data.Bind.Components.TBaseBindScopeComponent.AddExpression. All content below this line refers to Data.Bind.Components.TBaseBindScopeComponent.AddExpression.
Adds the given bind component to the Expressions list. The binding component is given through the AExpression parameter.</docstr>
      </procedure>
      <procedure name="RemoveExpression">
        <docstr>Removes the given binding component from the Expressions list.
Data.Bind.ObjectScope.TBaseObjectBindSource.RemoveExpression inherits from Data.Bind.Components.TBaseBindScopeComponent.RemoveExpression. All content below this line refers to Data.Bind.Components.TBaseBindScopeComponent.RemoveExpression.
Removes the given binding component from the Expressions list. The binding component to be removed is given through the AExpression parameter.</docstr>
      </procedure>
      <function name="Edit">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetIsEditing">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetModified">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetIsModified">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanModify">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="UpdateRecord">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Reset">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetField">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetReadOnly">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ClearModified">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="PosChanging">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetEnumerator">
        <docstr>Returns a TComponent enumerator.
Data.Bind.ObjectScope.TBaseObjectBindSource.GetEnumerator inherits from System.Classes.TComponent.GetEnumerator. All content below this line refers to System.Classes.TComponent.GetEnumerator.
Returns a TComponent enumerator.
GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop.</docstr>
      </function>
      <function name="GetBOF">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetEOF">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetSelected">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetActive">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanModify">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanInsert">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanDelete">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetEditing">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanRefresh">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="AddActiveChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RemoveActiveChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AddEditingChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RemoveEditingChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AddDataSetScrolled">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RemoveDataSetScrolled">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AddDataSetChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RemoveDataSetChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="GetMemberNames">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetCurrentRecord">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetMemberGetter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetMemberSetter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetMemberType">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetPositionGetter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetPositionSetter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="GetRecord">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoCreateAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="GetLookupMemberNames">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetCanApplyUpdates">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanCancelUpdates">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="UpdateControlComponent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="Locate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="Lookup">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ApplyUpdates">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="CancelUpdates">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Next">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Prior">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="First">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Last">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Insert">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Delete">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Cancel">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Post">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Edit">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Refresh">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="IsValidChar">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="IsRequired">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetFormatLink">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="Eof">
        <docstr>Indicates whether the bind source adapter is positioned in the last record. 
Read Eof (end of file) to determine if ItemIndex is located in the last record. If Eof is True, the bind source has an adapter and the active record is the last one or there are no records. Eof is False if the ItemIndex is located in any other position.</docstr>
      </property>
      <property name="BOF">
        <docstr>Indicates whether the bind source adapter is positioned in the first record.
Read BOF (beginning of file) to determine if ItemIndex is located in the first record. If BOF is True, the bind source has an adapter and the active record is the first one. BOF is also True if there is no active record. BOF is False in all other cases.</docstr>
      </property>
      <property name="CanModify">
        <docstr>Specifies whether the bind source has permission to modify the data.
Check CanModify to determine if data can be edited. When CanModify is set to True, the bind source can edit the data. When CanModify is set to False, the bind source cannot edit the data.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Data.Bind.ObjectScope.TBaseObjectBindSource.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Data.Bind.ObjectScope.TBaseObjectBindSource.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="Active">
        <docstr>Specifies whether the bind source adapter is active. 
Read Active to determine whether the bind source adapter is active. By default, the Active property is set to True.
When Active is False, the bind source does not have an adapter or its adapter is not active. When Active is True, the bind source has an active adapter.</docstr>
      </property>
      <property name="AutoActivate">
        <docstr>Specifies whether the bind source is automatically activated.  Set AutoActive to True for automatic activation.</docstr>
      </property>
      <property name="ItemIndex">
        <docstr>Specifies the index of the current record. 
ItemIndex holds the index of the current record of the dataset the bind source adapter is currently on. The first item has the index 0, the second item has the index 1, and so on. If no item is selected, the value of ItemIndex is -1.</docstr>
      </property>
      <property name="Editing">
        <docstr>Indicates whether the data is in edit mode. 
Read Editing to determine whether the bind source adapter can currently edit the data. If the Editing property is True, the data provided by the bind source adapter is in editing mode. Otherwise, it is False.</docstr>
      </property>
      <event name="OnCreateAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <property name="InternalAdapter">
        <docstr>Returns the internal adapter of the bind source. 
The InternalAdapter property holds the internal adapter of the bind source. InternalAdapter uses the GetInternalAdapter method to return the internal adapter of the bind source.

Note:  The GetInternalAdapter method always returns nil. Descendant classes must override this method to return the internal adapter.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TCustomPrototypeBindSource">
    <docstr>Is a base class that implements a bind source for creating sample data.
If you want to create your own custom prototype bind source, then you should derive your class from TCustomPrototypeBindSource. When designing applications, TPrototypeBindSource is available from the Tool Palette.</docstr>
    <members>
      <function name="GetInternalAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Data.Bind.ObjectScope.TCustomPrototypeBindSource.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <property name="AutoEdit">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="AutoPost">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FieldDefs">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="RecordCount">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="DataGenerator">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Media" name="TVideoCaptureDevice">
    <docstr></docstr>
    <members>
      <procedure name="DoSetQuality">
        <docstr>Method subclasses should override to configure the desired quality.</docstr>
      </procedure>
      <function name="GetCaptureSetting">
        <docstr>Returns the current frame configuration.</docstr>
      </function>
      <function name="DoSetCaptureSetting">
        <docstr>Configures the capture frame with the given settings.</docstr>
      </function>
      <function name="DoGetAvailableCaptureSettings">
        <docstr>Returns the available capture settings.</docstr>
      </function>
      <function name="CreateCaptureSettings">
        <docstr>Returns a new capture settings configuration with given parameters.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Constructor.</docstr>
      </constructor>
      <function name="SetCaptureSetting">
        <docstr>Configures the capture frame with the given settings.</docstr>
      </function>
      <function name="GetAvailableCaptureSettings">
        <docstr>Returns the available capture settings taking in account the canvas class bitmap size limitations.</docstr>
      </function>
      <property name="AvailableCaptureSettings">
        <docstr>Returns the available capture settings using the default canvas class to keep the limitation of the
           bitmap size.</docstr>
      </property>
      <property name="CaptureSetting">
        <docstr>Current frame configuration.</docstr>
      </property>
      <property name="CaptureSettingPriority">
        <docstr>Current settings sort priority.</docstr>
      </property>
      <property name="Quality">
        <docstr>Current frame configuration.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Media" name="TCaptureDeviceManager">
    <docstr></docstr>
    <members>
      <constructor name="Create">
        <docstr>Default constructor.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Media" name="TCameraComponent">
    <docstr></docstr>
    <members>
      <procedure name="SetCaptureSettingPriority">
        <docstr>Sets the priority to sort the result of available frame settings.</docstr>
      </procedure>
      <function name="GetCaptureSettingPriority">
        <docstr>Gets the priority criteria to sort the result of available frame settings.</docstr>
      </function>
      <procedure name="DoStart">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoStop">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoSampleBufferReady">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="Device">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Media.TCameraComponent.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Media.TCameraComponent.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="SampleBufferToBitmap">
        <docstr>Displays the captured data on a bitmap. 
The SampleBufferToBitmap method displays the captured video data on a bitmap.

The ABitmap parameter is the bitmap where the image is displayed.
The ASetSize parameter specifies whether the video samples are resized to fit the current size of ABitmap, or whether ABitmap is resized to the windows sizes.</docstr>
      </procedure>
      <function name="GetCaptureSetting">
        <docstr>Getter of CaptureSetting.</docstr>
      </function>
      <function name="SetCaptureSetting">
        <docstr>Setter of CaptureSetting.</docstr>
      </function>
      <function name="GetDefaultCanvasCaptureSettings">
        <docstr>It returns the available capture settings.

Note: The returning array is sorted with the CaptureSettingPriority criteria.</docstr>
      </function>
      <function name="GetAvailableCaptureSettings">
        <docstr>Returns an array of available video capture settings.</docstr>
      </function>
      <property name="AvailableCaptureSettings">
        <docstr>Array with the available capture settings.
You can use CaptureSettingPriority to set the criterion to sort the Array.
Use the CaptureSetting property to set the capture data resolution.
See the Quality property for further details.</docstr>
      </property>
      <property name="CaptureSetting">
        <docstr>Current frame capture configuration.
Use the CaptureSetting property to set the capture data resolution from the available ones.
See the Quality property for further details.</docstr>
      </property>
      <property name="CaptureSettingPriority">
        <docstr>Priority criterion for sorting the result of the available frame settings.
See the Quality property for further details.</docstr>
      </property>
      <property name="Quality">
        <docstr>States the quality of the video capture. 
The Quality property of type TVideoCaptureQuality can take one of the following values:



Value

Meaning



PhotoQuality



The captured data has high-resolution photo quality.




HighQuality



The captured data has high resolution (depending on the device). 




MediumQuality



The captured data has medium resolution (depending on the device). 




LowQuality



The captured data has low resolution (depending on the device).




CaptureSettings



This option allows you to set a customized capture data resolution. 


By default, Quality is set to CaptureSettings and it uses the best available camera quality (best resolution and best frame rate) prioritizing first the Resolution.
For example, to change the Quality of the CameraComponent1 TCameraComponent to LowQuality, you can use the following line:


Delphi: 

CameraComponent1.Quality := TVideoCaptureQuality.LowQuality;



C++: 

CameraComponent1-&gt;Quality = TVideoCaptureQuality::LowQuality;


Setting a Custom Quality Capture Setting
By setting the Quality to TVideoCaptureQuality.CaptureSettings you can set a customized capture data resolution:

Use the AvailableCaptureSettings property to see the Array with the different supported configurations.
You can use CaptureSettingPriority to set the criterion to sort the Array of the AvailableCaptureSettings to prioritize Resolution or FrameRate when sorting the Array. See TVideoCaptureSettingPriority for further information.
Use the CaptureSetting property to set the capture data resolution from the available ones.
To set the best available capture settings prioritizing the frame rate, you could for example use the following:


Delphi: 

procedure TForm1.SetMaxFrameRateClick(Sender: TObject);
var
  LSettings: TArray&lt;TVideoCaptureSetting&gt;;
begin
  CameraComponent1.CaptureSettingPriority := TVideoCaptureSettingPriority.FrameRate;
  LSettings := CameraComponent1.AvailableCaptureSettings;
  CameraComponent1.CaptureSetting := LSettings[0];
end;



C++: 

void __fastcall TForm1::SetMaxFrameRateClick(TObject *Sender)
{
	DynamicArray&lt;TVideoCaptureSetting&gt; LSettings;
	CameraComponent1-&gt;CaptureSettingPriority = TVideoCaptureSettingPriority::FrameRate;
	LSettings = CameraComponent1-&gt;AvailableCaptureSettings;
	CameraComponent1-&gt;CaptureSetting = LSettings[0];
}


Note: When you set a specific CaptureSetting, the Quality property is automatically set to TVideoCaptureQuality.CaptureSettings.</docstr>
      </property>
      <property name="HasFlash">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="HasTorch">
        <docstr>Indicates whether the camera device has torch. 
Use the HasTorch property to see whether the camera device has torch.</docstr>
      </property>
      <property name="FlashMode">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FocusMode">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="TorchMode">
        <docstr>Selects the different modes for the torch: on, off, or auto. 
The TorchMode property can take one of three values enumerated by TTorchMode: ModeOff, ModeOn, and ModeAuto.
For example, to turn on the torch of the CameraComponent1 TCameraComponent, you can use the following line:


Delphi: 

CameraComponent.TorchMode := TTorchMode.ModeOn;



C++: 

CameraComponent-&gt;TorchMode = TTorchMode::ModeOn;


Use the HasTorch property to see whether the camera device has a torch.</docstr>
      </property>
      <property name="Active">
        <docstr>Enables and disables the camera device. 
Set the Active property to True to enable the camera device, and set Active to False to disable it.</docstr>
      </property>
      <property name="Kind">
        <docstr>Selects the kind of camera device: default, front, or back camera. 
The Kind property can take one of three values enumerated by TCameraKind: Default, FrontCamera, and BackCamera.
For example, to select the back camera of the CameraComponent1 TCameraComponent you can use the following line:


Delphi: 

CameraComponent1.Kind := TCameraKind.BackCamera;



C++: 

CameraComponent1-&gt;Kind = TCameraKind::BackCamera;</docstr>
      </property>
      <event name="OnSampleBufferReady">
        <docstr>Occurs when the sample buffer is ready. 
Write an event handler for the OnSampleBufferReady event to specify what happens when the sample buffer is ready.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Media" name="TMedia">
    <docstr>Base class to access media files.
TMedia is an abstract class that defines an interface for media files. Platform-specific subclasses provide concrete implementations for Windows and OS X platforms.
TMedia exposes media file properties such as file name, size, dimension, state, or duration. 
The supported media files formats are the native formats for each platform:

For Windows:
Audio formats: .wma, .mp3, .wav
Video formats: .avi, .wmv
For OS X:
Audio formats: .mp3
Video formats: .mov, .m4v, .mp4
Using TMediaCodecManager, it is possible to register custom media codecs to extend the audio/video feature support.
For easy access to media files, use the TMediaPlayer and TMediaPlayerControl components.</docstr>
    <members>
      <function name="GetDuration">
        <docstr>Getter function for the Duration property.</docstr>
      </function>
      <function name="GetCurrent">
        <docstr>Getter function for the CurrentTime property.</docstr>
      </function>
      <procedure name="SetCurrent">
        <docstr>Setter function for the CurrentTime property.
Value specifies the new value for CurrentTime.</docstr>
      </procedure>
      <function name="GetVideoSize">
        <docstr>Getter function for the VideoSize property.</docstr>
      </function>
      <function name="GetMediaState">
        <docstr>Getter function for the State property.</docstr>
      </function>
      <function name="GetVolume">
        <docstr>Getter function for the Volume property.</docstr>
      </function>
      <procedure name="SetVolume">
        <docstr>Setter function for the Volume property.
Value specifies the new value of Volume.</docstr>
      </procedure>
      <procedure name="UpdateMediaFromControl">
        <docstr>Updates the current Media, depending on the TMediaPlayerControl associated with it.
UpdateMediaFromControl is used to keep the current Media, which has been updated after being manipulated by the TMediaPlayerControl associated with it. 
The TMediaPlayerControl associated with the current media is specified through the Control property.</docstr>
      </procedure>
      <procedure name="DoPlay">
        <docstr>Plays the current media file.
To start playing the current media, call the Play method.</docstr>
      </procedure>
      <procedure name="DoStop">
        <docstr>Stops the current media from being played.
To stop playing the current media, call the Stop method.</docstr>
      </procedure>
      <function name="QueryInterface">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Constructs an object and initializes its data before the object is first used.
FMX.Media.TMedia.Create inherits from System.TObject.Create. All content below this line refers to System.TObject.Create.
Constructs an object and initializes its data before the object is first used.
Create constructs an object. The purpose, size, and behavior of objects differ greatly. The Create constructor defined by TObject allocates memory but does not initialize data. 
Descendant objects usually define a constructor that creates the particular kind of object and initializes its data.

Note: If an exception escapes from a constructor, the object&apos;s destructor is called to clean up the failed instance.</docstr>
      </constructor>
      <procedure name="Play">
        <docstr>Starts the playback of the current media file.
Call the Play method to playback the current media file. To pause or stop the current media file from playing, call the Stop method.</docstr>
      </procedure>
      <procedure name="Stop">
        <docstr>Stops the playback of the current media file.
Call the Stop method to stop or to pause the current played media file. To play the current media file, call the Play method.</docstr>
      </procedure>
      <property name="Control">
        <docstr>Specifies the media player control that plays the current media file.
Set Control to specify the media player control that plays the current media file.

Tip: For easy access to media files and easy playing, use the TMediaPlayer or TMediaPlayerControl visual components. Giving the name of the file to be played will automatically create the TMedia objects and set the Control to the current used media player control.</docstr>
      </property>
      <property name="FileName">
        <docstr>Specifies the name of the current used media file.
FileName specifies the name of the media file used to create the current TMedia object. FileName includes the path, name, and extension of the media file.</docstr>
      </property>
      <property name="Duration">
        <docstr>Specifies the total play time of the current media file.
Duration is measured in 100ns. To obtain s, divide Duration by MediaTimeScale.</docstr>
      </property>
      <property name="CurrentTime">
        <docstr>Specifies the current playback position.
CurrentTime is measured in 100ns. To obtain s, divide Duration by MediaTimeScale.
Set CurrentTime to control the current position to be played.</docstr>
      </property>
      <property name="VideoSize">
        <docstr>Specifies the resolution of the current video file.
VideoSize specifies the native width and height of the current media file, in pixels. 
VideoSize is a TPointF. The X coordinate of the point represents the width of the window, and the Y coordinate of the point represents the height of the window. If the media file is audio only and does not have a window to be displayed, VideoSize is (0,0).</docstr>
      </property>
      <property name="Volume">
        <docstr>Specifies the audio volume of the current media file.
Volume takes values in the range from 0 through 1. If Volume is 1, then the media file is played at the maximum native volume. If Volume is 0, then the media file is mute.</docstr>
      </property>
      <property name="State">
        <docstr>Specifies whether the current media file is playing or is stopped.
If the current media file is not assigned or supported, then State is set to Unavailable.
If the current media file is playing, then State is set to Playing, otherwise it is set to Stopped.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Media" name="TCustomMediaCodec">
    <docstr>Base class for media codecs.
TCustomMediaCodec is an abstract class that defines a media codec.
Use TMediaCodecManager to register custom media codecs to extend FireMonkey audio/video features.</docstr>
    <members>
      <function name="CreateFromFile">
        <docstr>Creates a TMedia from a specified file.
The AFileName parameter specifies the name of the file from which the TMedia is created.
Do not use CreateFromFile explicitly in applications. Use TMediaCodecManager to access and manage media codecs.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.Media" name="TMediaPlayer">
    <docstr>Nonvisual component for media file playback.
Use a TMediaPlayer component for easy access to media files. 
The currently accessed media file is specified through the Media property.
To specify the media file to be played by the current TMediaPlayer, set the FileName property. The file name must include the path of the file, so it can be localized on the memory, and the extension. 
Call the Play and Stop methods to start playing a media file, or to stop or pause a running media file. The current position is specified through the CurrentTime property. TMediaPlayer also exposes media file properties such as Duration, VideoSize, Volume or State.
TMediaPlayer can play back audio files and the audio component of a video file. To display a video file, use a TMediaPlayerControl component.  For more information, see Audio-Video in FireMonkey.

Note: In order to play an audio file using TMediaPlayer, use the appropriate format:
.wav on Windows
.caf on iOS and OS X
.3GP on Android</docstr>
    <members>
      <function name="QueryInterface">
        <docstr>Returns a reference to a specified interface if the current component supports that interface.
FMX.Media.TMediaPlayer.QueryInterface inherits from System.Classes.TComponent.QueryInterface. All content below this line refers to System.Classes.TComponent.QueryInterface.
Returns a reference to a specified interface if the current component supports that interface.
QueryInterface checks whether the component supports the interface specified by IID and, if so, returns a reference to that interface as the Obj parameter. If the component does not support the interface, the Obj parameter returns nil (Delphi) or NULL (C++).
QueryInterface returns the S_OK execution code on success. HResult type 
defines the following execution codes: S_OK, S_FALSE, E_NOINTERFACE, E_UNEXPECTED, and E_NOTIMPL.

Note: For components that act as COM object wrappers, QueryInterface calls the QueryInterface method of the internal COM object.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Media.TMediaPlayer.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Media.TMediaPlayer.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="Play">
        <docstr>Starts playing the current Media.
Call the Play method to play the current Media. If Media is not assigned, Play does nothing. 
To stop or pause the current media file from playing, call the Stop method.</docstr>
      </procedure>
      <procedure name="Stop">
        <docstr>Stops or pauses playing the current Media.
Call Stop to stop or to pause the current Media. If Media is not assigned, Stop does nothing. 
To start playing the current media file, call the Play method.</docstr>
      </procedure>
      <procedure name="Clear">
        <docstr>Clears the current media player.
Call Clear to clear the current Media attached to the media player. Clear also empties the FileName property.</docstr>
      </procedure>
      <property name="Media">
        <docstr>Specifies the current TMedia attached to this media player.
Call the Play and Stop methods to start playing, or to stop or pause the current Media file, respectively.
Media is assigned and created when the FileName property is set.
TMediaPlayer exposes the Media properties through the following properties: Duration, VideoSize, CurrentTime, Volume, and  State. 
To empty the current Media attached to the media player, call the Clear method.
If Media type is audio, then calling Play will start playing the audio file. If Media type is video, then calling Play will just play the audio component of the specified video file. To display a video file, use a TMediaPlayerControl, and link the current TMediaPlayer to it by setting the MediaPlayer property of the TMediaPlayerControl.</docstr>
      </property>
      <property name="Duration">
        <docstr>Specifies the total play time of the current media file attached to the media player.
Duration is measured in 100ns. To obtain s, divide Duration by MediaTimeScale.</docstr>
      </property>
      <property name="CurrentTime">
        <docstr>Specifies the current playback position.
CurrentTime is measured in 100ns. To obtain s, divide CurrentTime by MediaTimeScale.
Set CurrentTime to control the current position to be played.</docstr>
      </property>
      <property name="VideoSize">
        <docstr>Specifies the resolution of the current video file.
VideoSize specifies the native width and height of the current media file, in pixels. 
VideoSize is a TPointF. The X coordinate of the point represents the width of the window, and the Y coordinate of the point represents the height of the window. If the media file is audio only and does not have a window to be displayed, or if no media file is attached to the media player, then VideoSize is (0,0).</docstr>
      </property>
      <property name="Volume">
        <docstr>Specifies the audio volume of the current media file.
Volume takes values in the range from 0 through 1. If Volume is 1, then the media file is played at the maximum native volume. If Volume is 0, then the media file is mute.
If there is no media file attached to the current media player, then Volume is 1.</docstr>
      </property>
      <property name="State">
        <docstr>Specifies whether the current attached Media is playing or is stopped.
If the current media file is not assigned or supported, then State is set to Unavailable.
If the current media file is playing, then State is set to Playing, otherwise it is set to Stopped.</docstr>
      </property>
      <property name="FileName">
        <docstr>Specifies the media file name played by the current media player.
Media is assigned and created when the FileName property is set. The file name must include the path of the file, so it can be localized on the memory, and the extension. 
To empty the current Media attached to the media player, call the Clear method.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Media" name="TMediaPlayerControl">
    <docstr>Visual component to display video media files. 
TMediaPlayerControl is a native control used to display video media files at design time. It is an empty control that does not show any video data. TMediaPlayerControl can be placed anywhere on a form. To set the video to be displayed, link the current TMediaPlayerControl to a TMediaPlayer through the MediaPlayer property.</docstr>
    <members>
      <procedure name="AncestorVisibleChanged">
        <docstr>Notifies its child controls that the visibility of an ancestor of your control has changed to Visible.
FMX.Media.TMediaPlayerControl.AncestorVisibleChanged inherits from FMX.Controls.TControl.AncestorVisibleChanged. All content below this line refers to FMX.Controls.TControl.AncestorVisibleChanged.
Notifies its child controls that the visibility of an ancestor of your control has changed to Visible.

 See Also
FMX.Controls.TControl.AncestorParentChanged
FMX.Controls.TControl.ChildrenAlignChanged
FMX.Controls.TControl.ClipChildrenChanged
FMX.Controls.TControl.EffectEnabledChanged
FMX.Controls.TControl.EnabledChanged
FMX.Controls.TControl.HandleSizeChanged
FMX.Controls.TControl.HitTestChanged
FMX.Controls.TControl.PaddingChanged
FMX.Controls.TControl.ParentChanged</docstr>
      </procedure>
      <procedure name="ParentChanged">
        <docstr>Executed right after the value of the Parent property changes.
FMX.Media.TMediaPlayerControl.ParentChanged inherits from FMX.Controls.TControl.ParentChanged. All content below this line refers to FMX.Controls.TControl.ParentChanged.
Executed right after the value of the Parent property changes.
The control does not execute ParentChanged if you assign Parent the same value that it already has.

 See Also
FMX.Controls.TControl.AncestorParentChanged
FMX.Controls.TControl.ClipChildrenChanged
FMX.Controls.TControl.EffectEnabledChanged
FMX.Controls.TControl.EnabledChanged
FMX.Controls.TControl.HandleSizeChanged
FMX.Controls.TControl.HitTestChanged
FMX.Controls.TControl.PaddingChanged
FMX.Controls.TControl.VisibleChanged
FMX.Controls.TControl.AncestorVisibleChanged
FMX.Controls.TControl.ChildrenAlignChanged</docstr>
      </procedure>
      <procedure name="DoAbsoluteChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Move">
        <docstr>Updates the currently manipulated TMedia. 
Move extends the behavior inherited from TControl to update the TMedia attached to the TMediaPlayer with which the current TMediaPlayerControl is linked.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher.
Resize extends the behavior inherited from TControl to update the TMedia attached to the TMediaPlayer with which the current TMediaPlayerControl is linked.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Media.TMediaPlayerControl.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="Show">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Hide">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Media.TMediaPlayerControl.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Media.TMediaPlayerControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Media.TMediaPlayerControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="MediaPlayer">
        <docstr>Specifies the TMediaPlayer to which this TMediaPlayerControl is linked.
Set MediaPlayer to link a TMediaPlayer to this TMediaPlayerControl, so the video file attached to the media player is displayed on a form.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Media" name="TCustomMediaPlayerAction">
    <docstr></docstr>
    <members>
      <procedure name="Notification">
        <docstr>Responds when components are created or destroyed.
FMX.Media.TCustomMediaPlayerAction.Notification inherits from System.Classes.TBasicAction.Notification. All content below this line refers to System.Classes.TBasicAction.Notification.
Responds when components are created or destroyed.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. 
TBasicAction overrides the System.Classes.TComponent.Notification method. Notification checks whether the component specified by AComponent is the same as the component stored in the ActionComponent property and whether it is about to be freed. If so, Notification sets the ActionComponent property to nil (Delphi) or NULL (C++).</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Instantiates and initializes a TCustomMediaPlayerAction object.
Applications do not need to call Create directly. Actions are created automatically when you add them to a TActionList component using New &gt; New Standard Action in the Action List editor at design time.
If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.</docstr>
      </constructor>
      <function name="HandlesTarget">
        <docstr>Whether Target is appropriate for the action (True) or not (False).
HandlesTarget ignores the specified Target parameter, actually. Regardless of the specified target, HandlesTarget returns True provided that:

The platform where your application is running supports this action.
Your action does not have any event handler assigned to its OnExecute event.
You have an instance of TMediaPlayer in the MediaPlayer property of your action.</docstr>
      </function>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
FMX.Media.TCustomMediaPlayerAction.Update inherits from System.Classes.TBasicAction.Update. All content below this line refers to System.Classes.TBasicAction.Update.
Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
      <property name="MediaPlayer">
        <docstr>Instance of TMediaPlayer that is target of the action.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Media" name="TMediaPlayerStart">
    <docstr></docstr>
    <members>
      <procedure name="CustomTextChanged">
        <docstr>Updates the value of the Text property to be the value of the CustomText property or, if CustomText is an empty string, to be the default text of the action: &quot;Play&quot;.
TMediaPlayerStart calls CustomTextChanged when you change the value of the MediaPlayer property of your action, and when the action updates.</docstr>
      </procedure>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
FMX.Media.TMediaPlayerStart.Update inherits from System.Classes.TBasicAction.Update. All content below this line refers to System.Classes.TBasicAction.Update.
Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
      <procedure name="ExecuteTarget">
        <docstr>Executes the action on the media player of the MediaPlayer property. The specified Target is ignored.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Media" name="TMediaPlayerStop">
    <docstr></docstr>
    <members>
      <procedure name="CustomTextChanged">
        <docstr>Updates the value of the Text property to be the value of the CustomText property or, if CustomText is an empty string, to be the default text of the action: &quot;Stop&quot;.
TMediaPlayerStop calls CustomTextChanged when you change the value of the MediaPlayer property of your action, and when the action updates.</docstr>
      </procedure>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
FMX.Media.TMediaPlayerStop.Update inherits from System.Classes.TBasicAction.Update. All content below this line refers to System.Classes.TBasicAction.Update.
Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
      <procedure name="ExecuteTarget">
        <docstr>Executes the action on the media player of the MediaPlayer property. The specified Target is ignored.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Media" name="TMediaPlayerPlayPause">
    <docstr></docstr>
    <members>
      <procedure name="CustomTextChanged">
        <docstr>Updates the value of the Text property to be the value of the CustomText property or, if CustomText is an empty string, to be the default text of the action: &quot;Pause&quot; if the state of the media player is Playing, or &quot;Play&quot; otherwise.
TMediaPlayerPlayPause calls CustomTextChanged when you change the value of the MediaPlayer property of your action, and when the action updates.</docstr>
      </procedure>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
FMX.Media.TMediaPlayerPlayPause.Update inherits from System.Classes.TBasicAction.Update. All content below this line refers to System.Classes.TBasicAction.Update.
Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
      <procedure name="ExecuteTarget">
        <docstr>Executes the action on the media player of the MediaPlayer property. The specified Target is ignored.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Media" name="TMediaPlayerValue">
    <docstr></docstr>
    <members>
      <procedure name="Notification">
        <docstr>Responds when components are created or destroyed.
FMX.Media.TMediaPlayerValue.Notification inherits from System.Classes.TBasicAction.Notification. All content below this line refers to System.Classes.TBasicAction.Notification.
Responds when components are created or destroyed.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. 
TBasicAction overrides the System.Classes.TComponent.Notification method. Notification checks whether the component specified by AComponent is the same as the component stored in the ActionComponent property and whether it is about to be freed. If so, Notification sets the ActionComponent property to nil (Delphi) or NULL (C++).</docstr>
      </procedure>
      <function name="CreateValueRange">
        <docstr>Method inherited from TCustomValueRangeAction that TMediaPlayerValue implements to provide a custom instance of a TCustomValueRange subclass to hold the value range that the action handles.</docstr>
      </function>
      <property name="State">
        <docstr>State of the value.
The state of the value may be any of the following:

Normal, which is the default state.
ActionUpdating, the action is being updated.
ValueUpdating, the value is being updated.</docstr>
      </property>
      <procedure name="UpdateValueAction">
        <docstr>This virtual protected method is called when the value of the action must be updated after a change of the equivalent value in the media player.</docstr>
      </procedure>
      <procedure name="UpdateValuePlayer">
        <docstr>This virtual protected method is called when the equivalent value in the media player must be updated after a change of the value of the action.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TMediaPlayerValue.</docstr>
      </constructor>
      <function name="HandlesTarget">
        <docstr>Whether Target is appropriate for the action (True) or not (False).
HandlesTarget is always False.</docstr>
      </function>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
FMX.Media.TMediaPlayerValue.Update inherits from System.Classes.TBasicAction.Update. All content below this line refers to System.Classes.TBasicAction.Update.
Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
      <property name="MediaPlayer">
        <docstr>Instance of TMediaPlayer that is target of the value.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Media" name="TMediaPlayerCurrentTime">
    <docstr></docstr>
    <members>
      <function name="CreateValueRange">
        <docstr>Method inherited from TCustomValueRangeAction that TMediaPlayerValue implements to provide a custom instance of a TCustomValueRange subclass to hold the value range that the action handles.
FMX.Media.TMediaPlayerCurrentTime.CreateValueRange inherits from FMX.Media.TMediaPlayerValue.CreateValueRange. All content below this line refers to FMX.Media.TMediaPlayerValue.CreateValueRange.
Method inherited from TCustomValueRangeAction that TMediaPlayerValue implements to provide a custom instance of a TCustomValueRange subclass to hold the value range that the action handles.

 See Also
FMX.StdActns.TCustomValueRangeAction
FMX.StdActns.TCustomValueRange</docstr>
      </function>
      <procedure name="UpdateValueAction">
        <docstr>This virtual protected method is called when the value of the action must be updated after a change of the equivalent value in the media player.
FMX.Media.TMediaPlayerCurrentTime.UpdateValueAction inherits from FMX.Media.TMediaPlayerValue.UpdateValueAction. All content below this line refers to FMX.Media.TMediaPlayerValue.UpdateValueAction.
This virtual protected method is called when the value of the action must be updated after a change of the equivalent value in the media player.</docstr>
      </procedure>
      <procedure name="UpdateValuePlayer">
        <docstr>This virtual protected method is called when the equivalent value in the media player must be updated after a change of the value of the action.
FMX.Media.TMediaPlayerCurrentTime.UpdateValuePlayer inherits from FMX.Media.TMediaPlayerValue.UpdateValuePlayer. All content below this line refers to FMX.Media.TMediaPlayerValue.UpdateValuePlayer.
This virtual protected method is called when the equivalent value in the media player must be updated after a change of the value of the action.</docstr>
      </procedure>
      <procedure name="CustomTextChanged">
        <docstr>Updates the value of the Text property to be the value of the CustomText property or, if CustomText is an empty string, to be the default text of the action, which is the current time of the media player. For example: &quot;00:12:34&quot;.
If you define a value for CustomText, you may include time specifiers in your value, which TMediaPlayerCurrentTime replaces by actual time values based on the current time of the media player. For a list of time specifiers, see FormatDateTime.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Media" name="TMediaPlayerVolume">
    <docstr></docstr>
    <members>
      <function name="CreateValueRange">
        <docstr>Method inherited from TCustomValueRangeAction that TMediaPlayerValue implements to provide a custom instance of a TCustomValueRange subclass to hold the value range that the action handles.
FMX.Media.TMediaPlayerVolume.CreateValueRange inherits from FMX.Media.TMediaPlayerValue.CreateValueRange. All content below this line refers to FMX.Media.TMediaPlayerValue.CreateValueRange.
Method inherited from TCustomValueRangeAction that TMediaPlayerValue implements to provide a custom instance of a TCustomValueRange subclass to hold the value range that the action handles.

 See Also
FMX.StdActns.TCustomValueRangeAction
FMX.StdActns.TCustomValueRange</docstr>
      </function>
      <procedure name="UpdateValueAction">
        <docstr>This virtual protected method is called when the value of the action must be updated after a change of the equivalent value in the media player.
FMX.Media.TMediaPlayerVolume.UpdateValueAction inherits from FMX.Media.TMediaPlayerValue.UpdateValueAction. All content below this line refers to FMX.Media.TMediaPlayerValue.UpdateValueAction.
This virtual protected method is called when the value of the action must be updated after a change of the equivalent value in the media player.</docstr>
      </procedure>
      <procedure name="UpdateValuePlayer">
        <docstr>This virtual protected method is called when the equivalent value in the media player must be updated after a change of the value of the action.
FMX.Media.TMediaPlayerVolume.UpdateValuePlayer inherits from FMX.Media.TMediaPlayerValue.UpdateValuePlayer. All content below this line refers to FMX.Media.TMediaPlayerValue.UpdateValuePlayer.
This virtual protected method is called when the equivalent value in the media player must be updated after a change of the value of the action.</docstr>
      </procedure>
      <procedure name="CustomTextChanged">
        <docstr>Updates the value of the Text property to be the value of the CustomText property or, if CustomText is an empty string, to be the default text of the action, which is the volume of the media player in percentage. For example: &quot;74%&quot;.
If you define a value for CustomText, your string must be a format string ready for a single, floating-point value (f). For example: %f%%.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Colors" name="TColorBox">
    <docstr>Represents a rectangular-shaped color indicator.
A TColorBox is a visual component represented as a rectangular-shaped optical indicator whose color can be changed programmatically by means of the Color property, or by attaching it to one of the following color selector components:

TColorPanel
TColorQuad</docstr>
    <members>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Colors.TColorBox.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Colors.TColorBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <property name="Color">
        <docstr>Specifies the alpha color displayed by this color box.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Colors" name="TColorQuad">
    <docstr>Represents a three-color gradient color selector.
A TColorQuad component is a color selector that displays a color spectrum drawn as a three-color gradient (black, white, and a specified color) that lets you fine-tune your color selection. TColorQuad can be attached to a TColorPicker component.</docstr>
    <members>
      <procedure name="MouseMove">
        <docstr>OnMouseMove event dispatcher. 
FMX.Colors.TColorQuad.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
OnMouseMove event dispatcher. 
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.Colors.TColorQuad.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <function name="DoGetUpdateRect">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Colors.TColorQuad.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Colors.TColorQuad.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <function name="PointInObjectLocal">
        <docstr>Checks whether the point specified by local coordinates belongs to the control area.
FMX.Colors.TColorQuad.PointInObjectLocal inherits from FMX.Controls.TControl.PointInObjectLocal. All content below this line refers to FMX.Controls.TControl.PointInObjectLocal.
Checks whether the point specified by local coordinates belongs to the control area.
PointInObjectLocal returns True if the specified point belongs to the control area, and False otherwise. 
The X and Y are the local coordinates of the point to be checked (compare with PointInObject):

X is the X coordinate.
Y is the Y coordinate.
The local coordinates of the upper-left corner of the control rectangle are (0,0), and the local coordinates of the lower-right corner are (Width, Height). 
The points of the control boundary specified by BoundsRect belong to the control and PointInObjectLocal returns True for them.
If a control supports the Touch property, the control area can be optionally inflated on the values specified by the TouchTargetExpansion property. TouchTargetExpansion keeps four optional parameters representing the expansion for the four sides of the control in pixels (Bottom, Left, Right, and Top). 
The dclasses can change the &apos;control area&apos; definition. For example:

The FMX.Objects.TSelection class extends the &apos;control area&apos; definition relative to BoundsRect. FMX.Objects.TSelection.PointInObjectLocal also returns True if the point belongs to any of small rectangles of the four grip controls used to manage the selection shape. The rectangles of the grip controls are rectangles surrounding the four corners of the TSelection rectangle. The Width and Height of these rectangles are equal to 2 * GripSize. For example, the grip control&apos;s rectangle of the upper-right corner UR_Corner of TSelection is defined by the following corners:
(UR_Corner.Top - GripSize, UR_Corner.Right - GripSize)--upper-left corner of the grip.
(UR_Corner.Top + GripSize, UR_Corner.Right + GripSize)--lower-right corner of the grip.
FMX.Objects.TSelectionPoint.PointInObjectLocal returns True if the specified point belongs to the rectangle of the grip control corresponding to the TSelectionPoint object, and False otherwise.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Colors.TColorQuad.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Colors.TColorQuad.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="Alpha">
        <docstr>Specifies the alpha channel (transparency) to apply to the selected color.
Change the Alpha property to a value in the range from 0 through 1 to set the alpha channel (transparency) for the selected color.</docstr>
      </property>
      <property name="ColorBox">
        <docstr>Specifies the color box attached to this color quad component.
A color box is a visual component represented as a rectangular-shaped optical indicator that changes color according to the color selected in this color quad component.</docstr>
      </property>
      <property name="Hue">
        <docstr>Specifies the hue of the selected color, in HSL color coordinates.
Set or read Hue in conjunction with Sat and Lum in order to change or obtain the color selected in this color quad component.</docstr>
      </property>
      <property name="Lum">
        <docstr>Specifies the luminance of the selected color, in HSL color coordinates.
Set or read Lum in conjunction with Hue and Sat in order to change or obtain the color selected in this color quad component.</docstr>
      </property>
      <property name="Sat">
        <docstr>Specifies the saturation of the selected color, in HSL color coordinates.
Set or read Sat in conjunction with Hue and Lum in order to change or obtain the color selected in this color quad component.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs immediately after changing the color on this color quad component.
Write an OnChange event handler to provide additional functionality when changing the color of this color quad component.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Colors" name="TColorPicker">
    <docstr>Represents a color selector that displays the entire color spectrum.
A TColorPicker component is a color selector that displays a color spectrum and lets you pick any color by moving a dot-style selector. TColorPicker can be attached to a TColorQuad component.



Note: The TColorPicker (Delphi) example describes how to implement a color picker as shown in the image.
See Also
FMX.Colors.THueTrackBar
FMX.Colors.TColorQuad
TColorPicker (Delphi)</docstr>
    <members>
      <procedure name="MouseMove">
        <docstr>OnMouseMove event dispatcher. 
FMX.Colors.TColorPicker.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
OnMouseMove event dispatcher. 
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.Colors.TColorPicker.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <function name="GetAbsoluteRect">
        <docstr>Getter function for the AbsoluteRect property.
FMX.Colors.TColorPicker.GetAbsoluteRect inherits from FMX.Controls.TControl.GetAbsoluteRect. All content below this line refers to FMX.Controls.TControl.GetAbsoluteRect.
Getter function for the AbsoluteRect property.</docstr>
      </function>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Colors.TColorPicker.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Colors.TColorPicker.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <function name="PointInObjectLocal">
        <docstr>Checks whether the point specified by local coordinates belongs to the control area.
FMX.Colors.TColorPicker.PointInObjectLocal inherits from FMX.Controls.TControl.PointInObjectLocal. All content below this line refers to FMX.Controls.TControl.PointInObjectLocal.
Checks whether the point specified by local coordinates belongs to the control area.
PointInObjectLocal returns True if the specified point belongs to the control area, and False otherwise. 
The X and Y are the local coordinates of the point to be checked (compare with PointInObject):

X is the X coordinate.
Y is the Y coordinate.
The local coordinates of the upper-left corner of the control rectangle are (0,0), and the local coordinates of the lower-right corner are (Width, Height). 
The points of the control boundary specified by BoundsRect belong to the control and PointInObjectLocal returns True for them.
If a control supports the Touch property, the control area can be optionally inflated on the values specified by the TouchTargetExpansion property. TouchTargetExpansion keeps four optional parameters representing the expansion for the four sides of the control in pixels (Bottom, Left, Right, and Top). 
The dclasses can change the &apos;control area&apos; definition. For example:

The FMX.Objects.TSelection class extends the &apos;control area&apos; definition relative to BoundsRect. FMX.Objects.TSelection.PointInObjectLocal also returns True if the point belongs to any of small rectangles of the four grip controls used to manage the selection shape. The rectangles of the grip controls are rectangles surrounding the four corners of the TSelection rectangle. The Width and Height of these rectangles are equal to 2 * GripSize. For example, the grip control&apos;s rectangle of the upper-right corner UR_Corner of TSelection is defined by the following corners:
(UR_Corner.Top - GripSize, UR_Corner.Right - GripSize)--upper-left corner of the grip.
(UR_Corner.Top + GripSize, UR_Corner.Right + GripSize)--lower-right corner of the grip.
FMX.Objects.TSelectionPoint.PointInObjectLocal returns True if the specified point belongs to the rectangle of the grip control corresponding to the TSelectionPoint object, and False otherwise.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Colors.TColorPicker.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Colors.TColorPicker.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="Color">
        <docstr>Specifies the alpha color selected in this color picker.
Color changes in respect to the variation of the Hue property. Programmatically set Hue to a specific value, or visually move the hue selector of this color picker, at run time, to obtain the color in the Color property.</docstr>
      </property>
      <property name="ColorQuad">
        <docstr>Specifies the TColorQuad component that is attached to this color picker.
Specify a TColorQuad component that is attached to this TColorPicker. In this way, every time you change the Color in this color picker, the color quad component automatically updates to the color selected in the color picker, further allowing you to tweak the saturation and luminance.

In the picture above, a 0.5 alpha channel TColorBox component was also attached to the TColorQuad for a complete color selection application.</docstr>
      </property>
      <property name="Hue">
        <docstr>Specifies the color, by hue, from this color picker.
Hue variates from 0 to 1 and spans the entire color spectrum drawn on this color picker. Programmatically set Hue to a specific value, or visually move the hue selector of this color picker, at run time, to obtain the color in the Color property.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Colors" name="TGradientEdit">
    <docstr>Represents a gradient editor component.
A TGradientEdit component is a gradient editor that can be used to create new gradient patterns.</docstr>
    <members>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.Colors.TGradientEdit.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>OnMouseMove event dispatcher. 
FMX.Colors.TGradientEdit.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
OnMouseMove event dispatcher. 
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.Colors.TGradientEdit.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Colors.TGradientEdit.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Colors.TGradientEdit.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Colors.TGradientEdit.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Colors.TGradientEdit.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="UpdateGradient">
        <docstr>Executes each time the selected color changes in order to update the gradient.</docstr>
      </procedure>
      <property name="Gradient">
        <docstr>Specifies the color gradient this gradient edit component will use.
Set or get the Gradient property to a TGradient type in order to specify a new gradient pattern.</docstr>
      </property>
      <property name="CurrentPoint">
        <docstr>Specifies the location of the selector point over the spanning of the component, which is a gradient color selector.
When the CurrentPoint property changes, an OnSelectPoint event also occurs.</docstr>
      </property>
      <property name="ColorPicker">
        <docstr>Specifies the color picker attached to this gradient editor component.
A color picker is a visual component represented as a rectangular-shaped optical indicator that permits you to select a color from the color spectrum.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs immediately after changing the color on this component, which is a gradient color selector.
Write an OnChange event handler to provide additional functionality when changing the color of this component, which is a gradient color selector.</docstr>
      </event>
      <event name="OnSelectPoint">
        <docstr>Occurs immediately after clicking over the surface of this gradient color selector.
Write an OnSelectPoint event handler to provide additional functionality when clicking over the surface of this gradient color selector component. OnSelectPoint also occurs when setting the value of the CurrentPoint property.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Colors" name="TColorPanel">
    <docstr>Represents a color selector component complete with alpha channel selection.
A TColorPanel component is a color selector that displays a color spectrum represented as a THueTrackBar, an alpha channel track bar selector, and a color quad. These make the TColorPanel component a great color selector.
A similar color selector can be found in the drop-down mode of the TComboColorBox component.</docstr>
    <members>
      <function name="GetObservers">
        <docstr>Getter of Observers.
FMX.Colors.TColorPanel.GetObservers inherits from System.Classes.TComponent.GetObservers. All content below this line refers to System.Classes.TComponent.GetObservers.
Getter of Observers.</docstr>
      </function>
      <function name="CanObserve">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.Colors.TColorPanel.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="DoAlphaChange">
        <docstr>Executes every time the alpha channel track bar changes its value.</docstr>
      </procedure>
      <procedure name="DoHueChange">
        <docstr>Executes every time the hue track bar changes its value.</docstr>
      </procedure>
      <procedure name="DoQuadChange">
        <docstr>Executes every time the color selected by this color panel changes.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Colors.TColorPanel.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Colors.TColorPanel.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Colors.TColorPanel.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="OwnerObserves">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="Color">
        <docstr>Specifies the alpha color selected by this color panel.</docstr>
      </property>
      <property name="ColorBox">
        <docstr>Specifies the color box attached to this color panel component.
A color box is a visual component represented as a rectangular-shaped optical indicator that changes color according to the color selected in this color panel component.</docstr>
      </property>
      <property name="UseAlpha">
        <docstr>Specifies whether this color panel component will display the alpha channel track bar.
Set the UseAlpha property to True to make this color panel component display the alpha channel (transparency) track bar. Set UseAlpha to False to use solid non-alpha colors.
The default value for the UseAlpha property is True.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs immediately after changing the color of this color panel component.
Write an OnChange event handler to provide additional functionality when changing the color of this color panel component.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Colors" name="TComboColorBox">
    <docstr>Represents a combo box that allows you to select an alpha color from a color spectrum.
A TComboColorBox behaves like a standard TComboBox, with the difference that, while in drop-down mode, it displays a color spectrum represented as a THueTrackBar, an alpha channel track bar, a color quad, a HEX color value edit box, and a color box. These make the TComboColorBox a great color selector.</docstr>
    <members>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.Colors.TComboColorBox.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
FMX.Colors.TComboColorBox.SetData inherits from FMX.Types.TFmxObject.SetData. All content below this line refers to FMX.Types.TFmxObject.SetData.
Protected setter implementation for the Data property.</docstr>
      </procedure>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.Colors.TComboColorBox.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <function name="CanObserve">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.Colors.TComboColorBox.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <procedure name="DoContentPaint">
        <docstr>Executes each time the OnPaint event appears.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.Colors.TComboColorBox.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="ParentChanged">
        <docstr>Executed right after the value of the Parent property changes.
FMX.Colors.TComboColorBox.ParentChanged inherits from FMX.Controls.TControl.ParentChanged. All content below this line refers to FMX.Controls.TControl.ParentChanged.
Executed right after the value of the Parent property changes.
The control does not execute ParentChanged if you assign Parent the same value that it already has.

 See Also
FMX.Controls.TControl.AncestorParentChanged
FMX.Controls.TControl.ClipChildrenChanged
FMX.Controls.TControl.EffectEnabledChanged
FMX.Controls.TControl.EnabledChanged
FMX.Controls.TControl.HandleSizeChanged
FMX.Controls.TControl.HitTestChanged
FMX.Controls.TControl.PaddingChanged
FMX.Controls.TControl.VisibleChanged
FMX.Controls.TControl.AncestorVisibleChanged
FMX.Controls.TControl.ChildrenAlignChanged</docstr>
      </procedure>
      <procedure name="DoColorChange">
        <docstr>Executes each time the OnChange event appears.</docstr>
      </procedure>
      <procedure name="DoTextChange">
        <docstr>Executes each time the OnChange event appears.</docstr>
      </procedure>
      <procedure name="DoValidating">
        <docstr>The DoValidating method validates the Text input string.
The method tries to modify the Text input string to match a color name in case the input string is not exactly the name of a color.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Colors.TComboColorBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Colors.TComboColorBox.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="DropDown">
        <docstr>Makes this combo color box expand its color selection display.
Call DropDown in applications to make this combo color box expand its contents, allowing you to select a new color from the drop-down list.</docstr>
      </procedure>
      <property name="Color">
        <docstr>Specifies the color selected by this combo color box component.
Set or get the Color property in order to specify or obtain the alpha color selected by this combo color box component.</docstr>
      </property>
      <property name="UseAlpha">
        <docstr>Specifies whether this combo color box component will display the alpha channel track bar when in drop-down mode.
Set the UseAlpha property to True to make this combo color box display the alpha channel (transparency) track bar, when it is in drop-down mode. Set UseAlpha to False to use solid non-alpha colors.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs immediately after changing the color selected by this combo color box.
Write an OnChange event handler to provide additional functionality when changing the color specified by this combo color box.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Colors" name="TColorButton">
    <docstr>Represents a standard button that displays a color instead of a standard caption.
A TColorButton behaves like a standard TButton. It can even have a modal result, just like typical standard buttons. The only difference between a standard button and a TColorButton is that the latter does not display a standard text caption, but a color in a rectangle that fills almost completely the surface of the button.</docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.Colors.TColorButton.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.Colors.TColorButton.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.Colors.TColorButton.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TPresentedControl.
FMX.Colors.TColorButton.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
Destroys this instance of TPresentedControl.

 See Also
FMX.Controls.Presentation.TPresentedControl.Create</docstr>
      </destructor>
      <property name="Color">
        <docstr>Specifies the color this button will display. The Color property is of type TAlphaColor.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs when the Color of TColorButton is changed.
The OnChange event occurs when the button Color property is changed.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Colors" name="TColorListBox">
    <docstr>Represents a combo box that allows you to select an alpha color from a color spectrum.
A TColorListBox behaves like a standard TListBox, but instead of standard text items, it displays a list of colors under the form of small colored squares, along with the color names.
The TColorComboBox component also displays this kind of list when in drop-down mode.</docstr>
    <members>
      <function name="GetData">
        <docstr>Gets the text of the selected item.
FMX.Colors.TColorListBox.GetData inherits from FMX.ListBox.TCustomListBox.GetData. All content below this line refers to FMX.ListBox.TCustomListBox.GetData.
Gets the text of the selected item.
GetData returns the text of the item that is selected in the list box or an empty string, if no item is selected.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Sets the text of the selected item.
FMX.Colors.TColorListBox.SetData inherits from FMX.ListBox.TCustomListBox.SetData. All content below this line refers to FMX.ListBox.TCustomListBox.SetData.
Sets the text of the selected item.
If no item is selected, nothing happens.</docstr>
      </procedure>
      <procedure name="RebuildList">
        <docstr>Clears the actual items in the color list box, then rebuilds the list with the color items.</docstr>
      </procedure>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.Colors.TColorListBox.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Colors.TColorListBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Colors.TColorListBox.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="Color">
        <docstr>Specifies the alpha color that is currently selected from the list.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Colors" name="TCustomColorComboBox">
    <docstr>A TCustomComboBox is the base class for combo box components.
FMX.Colors.TCustomColorComboBox inherits from FMX.ListBox.TCustomComboBox. All content below this line refers to FMX.ListBox.TCustomComboBox.
A TCustomComboBox is the base class for combo box components.
Inherit from TCustomComboBox to create a control that represents a specialized combo box.</docstr>
    <members>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.Colors.TCustomColorComboBox.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
FMX.Colors.TCustomColorComboBox.SetData inherits from FMX.Types.TFmxObject.SetData. All content below this line refers to FMX.Types.TFmxObject.SetData.
Protected setter implementation for the Data property.</docstr>
      </procedure>
      <procedure name="RebuildList">
        <docstr>Clears the items in the color list box, then rebuilds the list with the color items.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Colors.TCustomColorComboBox.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.Colors.TCustomColorComboBox.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Colors.TCustomColorComboBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <property name="Color">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Colors" name="TColorComboBox">
    <docstr>Represents a combo box that allows you to select a color from a color palette.
A TColorComboBox behaves like a standard TComboBox, with the difference that, when in drop-down mode, it displays a list of colors from the standard Delphi palette that you can select. The colors appear in the drop-down list as small colored squares, along with their names.


Note: The number of colors in the color palette is more than can be concurrently shown in the TListBoxItem list box. You can use the scroll bar to scroll the items shown in the list box. Notice that on Windows the scroll bar is shown by default. However, on OS X the scroll bar is not shown by default. On OS X, the scroll bar appears when you try to scroll colors using the mouse wheel. To enforce the scroll bar to be shown by default,  you can use the code like following:
ColorComboBox1.ListBox.AniCalculations.AutoShowing := false;</docstr>
  </class>
  <class unit="System.Classes" name="TPersistent">
    <docstr>TPersistent is the ancestor for all objects that have assignment and streaming capabilities.
TPersistent encapsulates the behavior common to all objects that can be assigned to other objects, and that can read and write their properties to and from a form file (.xfm or .dfm file). For this purpose, TPersistent introduces methods that can be overridden to:

Define the procedure for loading and storing unpublished data to a stream.
Provide the means to assign values to properties.
Provide the means to assign the contents of one object to another.
Do not create instances of TPersistent. Use TPersistent as a base class when declaring objects that are not components, but that need to be saved to a stream or have their properties assigned to other objects.</docstr>
    <members>
      <procedure name="AssignTo">
        <docstr>Copies the properties of an object to a destination object.
Override the AssignTo method to extend the functionality of the Assign method of destination objects so that they handle newly created object classes. When defining a new object class, override the Assign method for every existing object class that should be able to copy its properties to the new class. Override the AssignTo method for every existing class to which the new class can copy.
The Assign method of TPersistent calls AssignTo if the descendant object does not succeed in copying the properties of a source object. The AssignTo method defined by TPersistent raises an EConvertError exception. 
For example, given the following code in which A and B are instance variables:

A.Assign(B); {Delphi}

A-&gt;Assign(B); // C++

if A knows how to handle B, then it does so and returns. If A doesn&apos;t know how to handle B&apos;s type, execution will trickle to the TPersistent version of Assign, which calls:

B.AssignTo(A); {Delphi}

B-&gt;AssignTo(A); // C++

If B knows how to copy to A, the assignment succeeds. Otherwise, TPersistent raises an exception.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Provides an interface for a method that reads and writes otherwise unpublished data.
Descendants of TPersistent override DefineProperties to designate a method for storing the object&apos;s unpublished data to a stream such as a form file. By default, writing an object to a stream writes the values of all its published properties, and reading the object in reads those values and assigns them to the properties. Objects can also specify methods that read and write data other than published properties by overriding the DefineProperties method.
When overriding DefineProperties, consider including some or all of the following:

A call to the inherited method
Calls to the filer object&apos;s DefineProperty method
Calls to the filer object&apos;s DefineBinaryProperty method
DefineProperties is virtual, so descendant classes can override it as necessary but are not required to do so.</docstr>
      </procedure>
      <function name="GetOwner">
        <docstr>Returns the owner of an object.
GetOwner is used by the GetNamePath method to find the owner of a persistent object. GetNamePath and GetOwner are introduced in TPersistent so descendants such as collections can appear in the Object Inspector. As implemented in TPersistent, GetOwner returns nil (Delphi) or NULL (C++). 
For TOwnedCollection, GetOwner returns the owner of the collection. For TCollectionItem collection items, GetOwner returns the collection object into which the collection item has been inserted. For TComponent, GetOwner returns the value of the Owner property.</docstr>
      </function>
      <destructor name="Destroy">
        <docstr>Destroys the TPersistent instance and frees its memory.
Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy.</docstr>
      </destructor>
      <procedure name="Assign">
        <docstr>Copies the contents of another similar object.
Assign copies properties and other attributes of the specified Source object to the current object. The standard form of a call to Assign is:

Destination.Assign(Source); {Delphi}

Destination-&gt;Assign(Source); // C++

which tells the current object to copy the contents of the Source object to itself.
Most objects override Assign to handle the assignment of properties from similar objects. When overriding Assign, call the inherited method if the destination object cannot handle the assignment of properties from the class of the Source parameter.
If no overridden Assign method can handle the assignment of properties from Source, the method implemented in TPersistent calls the source object&apos;s AssignTo method. This allows the source object to handle the assignment. If the Source object is nil (Delphi) or NULL (C++), Assign raises an EConvertError exception.
In general, the statement

Destination := Source; {Delphi}

Destination = Source; // C++

is not the same as the statement

Destination.Assign(Source); {Delphi}

Destination-&gt;Assign(Source); // C++

The assignment operator makes Destination reference the same object as Source, whereas the Assign method copies the contents of the object referenced by Source into the object referenced by Destination.

Note: The types of some properties are also objects. If these properties have written methods that use Assign to set the value of the property, then in these cases the assignment operator does the same thing as the Assign method.</docstr>
      </procedure>
      <function name="GetNamePath">
        <docstr>Returns the name of the object as it appears in the Object Inspector.
GetNamePath is for internal use only. It determines the text that the Object Inspector displays for the name of the object being edited. GetNamePath is introduced in TPersistent so descendants such as collections can appear in the Object Inspector. Do not call GetNamePath directly.
For components, GetNamePath returns the component name. For TCollectionItem objects it returns the name of the hosting component, the name of the property, and the index into the collection surrounded by brackets.</docstr>
      </function>
    </members>
  </class>
  <class unit="System.Classes" name="TCollection">
    <docstr>TCollection is a container for TCollectionItem objects.
Each TCollection holds a group of TCollectionItem descendants. TCollection maintains an index of the collection items in its Items array. The Count property contains the number of items in the collection. Use the Add and Delete methods to add items to the collection and delete items from the collection.
Objects descended from TCollection can contain objects descended from TCollectionItem. Thus, for each TCollection descendant, there is a corresponding TCollectionItem descendant. 
The following table lists some typical descendants of TCollection with the corresponding TCollectionItem descendant and the component that uses each pair:



TCollection descendant

TCollectionItem descendant

Component



TBitmapLinks



TBitmapLink



TCustomStyleObject




TAggregates



TAggregate



TClientDataSet




TCookieCollection



TCookie



TWebResponse




TCoolBands



TCoolBand



TCoolBar




TDBGridColumns



TColumn



TDBGrid




TDependencies



TDependency



TService




THeaderSections



THeaderSection



THeaderControl




TListColumns



TListColumn



TListView




TParams



TParam



many datasets




TStatusPanels



TStatusPanel



TStatusBar


The controls that use TCollection and TCollectionItem descendants have a published property that holds a collection. (For example, the Panels property of TStatusBar holds a TStatusPanels.) A standard property editor, referred to generically as the Collection editor, can be invoked from the Object Inspector to edit the items in the collection. 

Note: When writing a TCollection descendant that is used by another control, be sure to override the protected GetOwner method of the collection so that the descendant class instances can appear in the Object Inspector.
Note: TCollection has the TOwnedCollection descendant that maintains information about its owner. TOwnedCollection implements the GetOwner method. Therefore, classes derived from TOwnedCollection do not need to add anything in order to appear in the Object Inspector.</docstr>
    <members>
      <procedure name="Added">
        <docstr>Warning: Added is deprecated.  


Responds when items are added to the collection.
Applications cannot call the protected Added method. It is called automatically immediately after items are added to the collection.
Item is the item that was just added to the collection.
Added is a deprecated method. Descendent classes should override the Notify method instead when responding to changes in the list of items.</docstr>
      </procedure>
      <procedure name="Deleting">
        <docstr>Warning: Deleting is deprecated.  


Responds when items are deleted from the collection.
Applications cannot call the protected Deleting method. The Delete method calls Deleting immediately before it removes an item from the collection.
Item is the item that is about to be removed.
Deleting is a deprecated method. Descendent classes should override the Notify method instead when responding to changes in the list of items.</docstr>
      </procedure>
      <property name="NextID">
        <docstr>Specifies a unique ID that can be assigned to the next added collection item.
TCollection uses NextID internally to assign unique identifiers to collection items. When a new item is added to the collection, its ID property is given the value of NextID and NextID is incremented.</docstr>
      </property>
      <procedure name="Notify">
        <docstr>Responds when items are added to or removed from the collection.
Notify is called automatically when the items in the collection change.
Item is the item that was just added to or that is about to be removed from the collection.
Action indicates whether the item was added, is about to be extracted or is about to be deleted.
As implemented in TCollection, Notify calls Added when Action is cnAdded and calls Deleting when Action is cnDeleting. TCollection ignores the cnExtracting action. Descendant classes can override Notify to modify this behavior.</docstr>
      </procedure>
      <function name="GetAttrCount">
        <docstr>Returns the number of custom attributes associated with items in the collection.
TCollection descendants can associate user-defined attributes with the items in the collection. Each attribute has a name and, for each item in the collection, a value that is a string. GetAttrCount returns the number of distinct attributes assigned to each item in the collection.
As implemented in TCollection, GetAttrCount always returns 0, because TCollection defines no custom attributes.</docstr>
      </function>
      <function name="GetAttr">
        <docstr>Returns the name of a custom attribute that can be retrieved using the GetItemAttr method.
TCollection descendants can associate user-defined attributes with the items in the collection. Each attribute has a name and, for each item in the collection, a value that is a string. The GetAttr method returns the name of an attribute.
Index identifies the attribute whose name is requested. This is a value between 0 and n-1, where n is the value returned by GetAttrCount.
As implemented by TCollection, GetAttr always returns an empty string, because TCollection defines no custom attributes.</docstr>
      </function>
      <function name="GetItemAttr">
        <docstr>Returns the value of a custom attribute assigned to one of the collection&apos;s items.
TCollection descendants can associate user-defined attributes with the items in the collection. Each attribute has a name and -- for each item in the collection -- a value, which is a string. GetItemAttr returns the value of one of these attributes for a specified item in the collection.
Index identifies which of the attribute&apos;s values is desired. This is a value between 0 and n-1, where n is the value returned by GetAttrCount.
ItemIndex identifies the item whose attribute value is desired. This is an index into the Items property array.
As implemented in TCollection, GetItemAttr always returns an empty string, because TCollection defines no custom attributes.</docstr>
      </function>
      <procedure name="Changed">
        <docstr>Responds when the collection or any of its items changes.
Changed is called automatically when items in the collection change or when the EndUpdate method signals that an update is complete. It checks the value of UpdateCount, and if it is 0, calls the Update method, which performs any necessary updates.
When writing a TCollection descendant, there is no need to call Changed. Instead, bracket any changes by calls to BeginUpdate and EndUpdate.</docstr>
      </procedure>
      <function name="GetItem">
        <docstr>Returns a specified item in the collection.
GetItem is the protected read implementation of the Items property.</docstr>
      </function>
      <procedure name="SetItem">
        <docstr>Copies the properties of another item to a specified item in the collection.
SetItem is the protected write implementation of the Items property. It calls the Assign method of the item specified by Index, so that the properties of the item specified by Value are copied to that item.</docstr>
      </procedure>
      <procedure name="SetItemName">
        <docstr>Initializes the name of a newly inserted collection item.
The Insert method calls SetItemName to initialize the Name property of items when it inserts them into the collection.
As implemented in TCollection, SetItemName does nothing. Some TCollection descendants override this method to provide collection items with default names.</docstr>
      </procedure>
      <procedure name="Update">
        <docstr>Updates the collection to reflect changes to its items.
Override Update in a descendent class to make any necessary changes when the items in the collection change. This method is called automatically when an update is complete.
Item identifies the item that changed. If the Item parameter is nil (Delphi) or NULL (C++), then the change affects more than one item in the collection.
As implemented in TCollection, Update does nothing. Descendent classes override this method to make any necessary adjustments.</docstr>
      </procedure>
      <property name="PropName">
        <docstr>Specifies the name of the property that the collection implements.
The GetNamePath method uses this protected property to assemble the name of the collection as it appears in the Object Inspector. It identifies the name of the property in the object returned by the protected GetOwner method that is implemented using this collection object.</docstr>
      </property>
      <property name="UpdateCount">
        <docstr>Counts the number of times BeginUpdate was called without a corresponding call to EndUpdate.
UpdateCount keeps track of calls to BeginUpdate and EndUpdate so that they can be nested. Every call to BeginUpdate increments UpdateCount. Every call to EndUpdate decrements it. When UpdateCount returns to 0, the collection updates itself to reflect all changes that occurred since the first call to BeginUpdate.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Creates and initializes a collection.
Call Create to instantiate a TCollection object at run time. Typically, TCollection descendants are created by a component that uses the collection to implement a property.
ItemClass identifies the TCollectionItem descendants that must be used to represent the items in the collection. The Add method uses this class to create items of the appropriate type.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the collection and each item in it.
Destroy uses the Clear method to free each item referenced in the Items array, then destroys the collection itself.</docstr>
      </destructor>
      <function name="Owner">
        <docstr>Returns the Owner of the collection.
Call Owner to obtain a reference to the object that owns this collection. Typically, the owner uses the collection to implement one of its properties.</docstr>
      </function>
      <function name="Add">
        <docstr>Creates a new TCollectionItem instance and adds it to the Items array.
Call Add to create an item in the collection. The new item is placed at the end of the Items array.
Add returns the new collection item.</docstr>
      </function>
      <procedure name="Assign">
        <docstr>Copies the contents of the Source collection to the current object.
Use Assign to copy the contents of one TCollection instance to another. The Assign method deletes all items from the destination collection (the object where it is executed), then adds a copy of each item in the source collection&apos;s Items array.
Source is another object (typically another collection) that contains the items that replace this collection&apos;s items.</docstr>
      </procedure>
      <procedure name="BeginUpdate">
        <docstr>Signals the start of an update operation.
Call BeginUpdate before starting an operation that performs changes to TCollection. After completing all the changes, call EndUpdate to signal the end of the operation. Every call to BeginUpdate must be matched by a corresponding call to the EndUpdate method. 
For example, the method is used to suspend screen repainting until changes to a component that involves TCollection are completed.</docstr>
      </procedure>
      <procedure name="Clear">
        <docstr>Deletes all items from the collection.
Clear empties the Items array and destroys each TCollectionItem.</docstr>
      </procedure>
      <procedure name="ClearAndResetID">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Delete">
        <docstr>Deletes a single item from the collection.
Delete removes the specified collection item, moving up any items that come after that item in the Items property array.
Index identifies the item to delete. This is the index of the item in the Items property array. 0 specifies the first item, 1 specifies the second item, and so on.</docstr>
      </procedure>
      <procedure name="EndUpdate">
        <docstr>Signals the end of an update operation.
Call EndUpdate after completing an operation that was preceded by a call to the BeginUpdate method. Every call to BeginUpdate must be matched by a corresponding call to the EndUpdate method.
For example, use EndUpdate to re-enable screen repainting that was turned off with the BeginUpdate method for the components that involve TCollection.</docstr>
      </procedure>
      <procedure name="Sort">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="FindItemID">
        <docstr>Returns the item with the specified ID.
The FindItemID method returns the item in the collection whose ID property is passed to it as a parameter. If no item has the specified ID, FindItemID returns nil (Delphi) or NULL (C++).</docstr>
      </function>
      <function name="GetEnumerator">
        <docstr>Returns a TCollection enumerator.
GetEnumerator returns a TCollectionEnumerator reference, which enumerates all items in the collection. 
To do so, call the TCollectionEnumerator GetCurrent method within a While MoveNext do loop.</docstr>
      </function>
      <function name="GetNamePath">
        <docstr>Returns a string used by the Object Inspector.
If the collection has no owner, GetNamePath returns the name of the collection&apos;s actual (runtime) type. If the collection is owned, GetNamePath returns the owner&apos;s name followed, if applicable, by a dot and the name of the owner&apos;s property that holds the collection. For example, GetNamePath might return &quot;TreeView1.Items&quot;.

Note:  For a collection to have an owner, it must override the GetOwner method.</docstr>
      </function>
      <function name="Insert">
        <docstr>Creates a new TCollectionItem instance and adds it to the Items array.
Call Insert to add a new item at a specified position in the collection. Existing items (starting from the specified position) are moved up in the Items array.
Insert returns the new collection item.</docstr>
      </function>
      <property name="Capacity">
        <docstr>Provides access to the internal TList.Capacity property.
The Capacity property specifies the allocated size of the array of pointers maintained by the TList object. This value is set to the number of pointers the list will need to contain.</docstr>
      </property>
      <property name="Count">
        <docstr>Returns the number of items in the collection.
Count contains the number of items in the Items array. Since Items is indexed starting with 0, the value of Count is always one greater than the index of the last member of Items.</docstr>
      </property>
      <property name="ItemClass">
        <docstr>Indicates the class to which the collection&apos;s items belong.
ItemClass is the class (descended from TCollectionItem) to which the items in the collection belong. For example, in an instance of the TCollection descendant THeaderSections, the value of the ItemClass property is THeaderSection.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TStrings">
    <docstr>TStrings is the base class for objects that represent a list of strings.
Derive a class from TStrings to store and manipulate a list of strings. TStrings contains abstract or, in C++ terminology, pure virtual methods and should not be directly instantiated.
Descendants of TStrings can represent several individual strings, such as the individual lines that appear in a list box. Some objects use descendants of TStrings to represent one long body of text so that it can be manipulated in smaller chunks.
TStrings introduces many properties and methods to:

Add or delete strings at specified positions in the list.
Rearrange the strings in the list.
Access the string at a particular location.
Read the strings from or write the strings to a file or stream.
Associate an object with each string in the list.
Store and retrieve strings as name-value pairs.
For an explanation of name-value pairs, refer to the NameValueSeparator property.</docstr>
    <members>
      <procedure name="DefineProperties">
        <docstr>Reads and writes the Strings property as if it were published.
TStrings overrides DefineProperties so that the strings in the list can be loaded and saved with a form file as if the Strings property were published.</docstr>
      </procedure>
      <procedure name="Error">
        <docstr>Raises an EStringListError exception.
TStrings calls Error internally to raise an EStringListError exception when it encounters a problem.
Msg specifies the string with a single format specifier for an integer, that appears in the exception message box. It can be either a string, or a pointer to a record structure that indicates the module and resource identifier for a string.
Data is an integer value that is inserted into Msg.</docstr>
      </procedure>
      <procedure name="Error">
        <docstr>Raises an EStringListError exception.
TStrings calls Error internally to raise an EStringListError exception when it encounters a problem.
Msg specifies the string with a single format specifier for an integer, that appears in the exception message box. It can be either a string, or a pointer to a record structure that indicates the module and resource identifier for a string.
Data is an integer value that is inserted into Msg.</docstr>
      </procedure>
      <function name="ExtractName">
        <docstr>Returns the name portion of a string that is a name value pair.
TStrings calls ExtractName internally to parse strings that are name-value pairs and return the name portion.
S is the string to parse. If the string S:

Is a name-value pair, ExtractName returns the name portion.
Is not a name-value pair, ExtractName returns:
The entire string S when AllNames is True.
An empty string when AllNames is False.
Note: If AllNames is not specified is False by default.</docstr>
      </function>
      <function name="ExtractName">
        <docstr>Returns the name portion of a string that is a name value pair.
TStrings calls ExtractName internally to parse strings that are name-value pairs and return the name portion.
S is the string to parse. If the string S:

Is a name-value pair, ExtractName returns the name portion.
Is not a name-value pair, ExtractName returns:
The entire string S when AllNames is True.
An empty string when AllNames is False.
Note: If AllNames is not specified is False by default.</docstr>
      </function>
      <function name="Get">
        <docstr>Returns a string given its index.
Get is the protected read implementation of the Strings property.
In TStrings Get is abstract or, in C++ terminology, pure virtual, meaning it has no implementation. Descendant classes must override this method to return the string with the specified index.</docstr>
      </function>
      <function name="GetCapacity">
        <docstr>Returns the currently allocated size of the list of strings.
GetCapacity is the protected read implementation of the Capacity property. In TStrings, GetCapacity returns the value of the Count property. Descendants of TStrings can override this property to let a string list allocate memory for entries that have not been added to the list.</docstr>
      </function>
      <function name="GetCount">
        <docstr>Returns the number of strings in the list
GetCount is the protected read implementation of the Count property.
In TStrings GetCount is abstract or, in C++ terminology, pure virtual, meaning it has no implementation. Descendant classes must override this method to return the number of strings that have been added to the list.</docstr>
      </function>
      <function name="GetObject">
        <docstr>Returns the object associated with the string at a specified index.
GetObject is the protected read implementation of the Objects property.
Index is the index of the string with which the object is associated.
In TStrings, GetObject always returns nil (Delphi) or NULL (C++). This provides a default implementation for descendants that do not support associating objects with the strings in the list. Descendants that support this feature override GetObject to return the specified object.</docstr>
      </function>
      <function name="GetTextStr">
        <docstr>Returns the value of the Text property.
GetTextStr is the protected read implementation of the Text property. It returns a string that lists all the strings in the list, with individual strings separated by the string terminator characters LineBreak. By default, LineBreak is a carriage return and a line feed (#13#10) characters on Windows operating systems and a carriage return (#13) character on the macOS operating system.</docstr>
      </function>
      <procedure name="Put">
        <docstr>Changes the value of the string with a specified index.
Put is the protected write implementation of the Strings property.
Put changes the value of the string with the index specified by Index to S. Put does not change the object at the specified position. That is, any object associated with the previous string becomes associated with the new string.</docstr>
      </procedure>
      <procedure name="PutObject">
        <docstr>Changes the object associated with the string at a specified index.
PutObject is the protected write implementation of the Objects property.
As implemented in TStrings, PutObject does nothing. This provides a default implementation for descendants that do not support associating objects with the strings in the list. Descendants that support this feature override PutObject to change the specified object.</docstr>
      </procedure>
      <procedure name="SetCapacity">
        <docstr>Changes the amount of memory allocated to hold strings in the list.
SetCapacity is the protected write implementation of the Capacity property.
NewCapacity is the number of strings the list can hold after the capacity has changed.
In TStrings, the SetCapacity method does nothing. Descendent classes must override this method to change the number of strings that the list can hold. 

Note: For descendent classes that implement SetCapacity, assigning a value smaller than Count removes strings from the end of the list. Assigning a value greater than Count allocates space for more strings to be added.</docstr>
      </procedure>
      <procedure name="SetEncoding">
        <docstr>Protected setter of the Encoding property.
If Value is one of standard encoding values, SetEncoding sets the Encoding property to Value. Otherwise, SetEncoding sets the Encoding property to default.
Internally, Assign and LoadFromStream call SetEncoding.</docstr>
      </procedure>
      <procedure name="SetTextStr">
        <docstr>Sets the Text property.
GetTextStr is the protected write implementation of the Text property. It replaces the list with the strings specified by the Value parameter. SetTextStr adds strings one at a time to the list, using the carriage returns or linefeed characters in Value as delimiters indicating when to add a new string.</docstr>
      </procedure>
      <procedure name="SetUpdateState">
        <docstr>Performs internal adjustments before or after a series of updates.
SetUpdateState is called at the beginning or end of a series of updates. When the BeginUpdate method is first called and the TStrings object is not already in the middle of an update, TStrings calls SetUpdateState internally, with Updating set to true. When the EndUpdate method is called and it cancels out the last unmatched call to BeginUpdate, TStrings calls SetUpdateState internally, with Updating set to false.
As implemented in TStrings, SetUpdateState does nothing. Descendant classes can override this method to optimize the response to updates.</docstr>
      </procedure>
      <function name="CompareStrings">
        <docstr>Compares two strings.
TStrings uses CompareStrings internally to compare the values of strings that appear in the list. For example, the IndexOf and IndexOfName methods use CompareStrings to compare a specified string with the strings in the list.
S1 and S2 are the strings to compare.
CompareStrings returns a value less than 0 if S1 &lt; S2, 0 if S1 == S2, and a value greater than 0 if S1 &gt; S2.
As implemented in TStrings, CompareStrings uses the global AnsiCompareText function, which compares strings case insensitively. Some descendant classes override this method to change the way strings are compared (for example, to introduce case sensitivity).</docstr>
      </function>
      <property name="UpdateCount">
        <docstr>Indicates the number of calls to BeginUpdate that have not been matched by a call to EndUpdate.
TStrings uses UpdateCount to keep track of calls to the BeginUpdate and EndUpdate methods. Every time a call is made to BeginUpdate, TStrings increments the value of UpdateCount. Every call to EndUpdate causes TStrings to decrement UpdateCount.
When UpdateCount changes from 0 to 1, TStrings calls the SetUpdateState method with a parameter of true. When UpdateCount changes from 1 to 0, TStrings calls the SetUpdateState method with a parameter of false. This allows descendant classes to perform optimizations when handling multiple updates.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Creates an instance of a TStrings object.
Do not call the Create method for TStrings directly. TStrings is an abstract class and its constructor should only be called as an inherited method from the constructor of a derived class.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the TStrings instance and frees its memory.
Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy.</docstr>
      </destructor>
      <function name="Add">
        <docstr>Adds a string at the end of the list.
Call Add to add a string to the end of the list. Add returns the index of the new string.</docstr>
      </function>
      <function name="AddPair">
        <docstr>Adds name-value pairs to the list of strings using fluent-style coding.
AddPair adds name-value pairs using the current NameValueSeparator. You can also use AddPair to add name-value pairs and the corresponding AObject.
TStrings returns a reference to the string list, allowing to populate the list using the fluent-style coding.</docstr>
      </function>
      <function name="AddPair">
        <docstr>Adds name-value pairs to the list of strings using fluent-style coding.
AddPair adds name-value pairs using the current NameValueSeparator. You can also use AddPair to add name-value pairs and the corresponding AObject.
TStrings returns a reference to the string list, allowing to populate the list using the fluent-style coding.</docstr>
      </function>
      <function name="AddObject">
        <docstr>Adds a string to the list, and associates an object with the string.
Call AddObject to add a string and its associated object to the list. AddObject returns the index of the new string and object.

Note:  The TStrings object does not own the objects you add this way. Objects added to the TStrings object still exist even if the TStrings instance is destroyed. They must be explicitly destroyed by the application.</docstr>
      </function>
      <procedure name="Append">
        <docstr>Adds a string to the list.
Append is the same as the Add method, except that it does not return a value. Use Append when there is no need to know the index of the string after it has been added, or with descendants of TStrings for which the index returned is not meaningful. 
For example, the TStrings descendant used by memo objects uses an index to determine where to insert a string, but the inserted string does not necessarily end up as a single string in the list. Part of the inserted text may become part of the previous string, and part may be broken off into a subsequent string. The index returned by Add is not meaningful in this case. 
Use Append rather than Add as a parameter for a function requiring a TGetStrProc.</docstr>
      </procedure>
      <procedure name="AddStrings">
        <docstr>Adds the specified strings (and objects) to the current TStrings object.
AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised.</docstr>
      </procedure>
      <procedure name="AddStrings">
        <docstr>Adds the specified strings (and objects) to the current TStrings object.
AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised.</docstr>
      </procedure>
      <procedure name="AddStrings">
        <docstr>Adds the specified strings (and objects) to the current TStrings object.
AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised.</docstr>
      </procedure>
      <procedure name="Assign">
        <docstr>Sets the strings in the Strings array, possibly associated Objects, and some other properties of the current TStrings object, from the Source object.
Use Assign to set the properties of the TStrings object from the Source object. If Source is of the TStrings type, Assign copies the following properties:

Strings
Objects
DefaultEncoding
Encoding
LineBreak
Delimiter
QuoteChar
NameValueSeparator
Options
If Source is not of the TStrings type, the inherited Assign will set the value of the string array from any object that supports TStrings in its AssignTo method.</docstr>
      </procedure>
      <procedure name="SetStrings">
        <docstr>Sets the strings from another TStrings object to the list of strings.
Use SetStrings to assign the value of the TStrings object from another TStrings object (Source).

Note: SetStrings is similar to Assign, but Assign also copies multiple additional properties.</docstr>
      </procedure>
      <procedure name="BeginUpdate">
        <docstr>Enables the TStrings object to track when the list of strings is changing.
BeginUpdate is called automatically by any property or method that changes the list of strings. Once the changes are complete, the property or method calls EndUpdate. Call BeginUpdate before directly modifying the strings in the list, and EndUpdate after. When implementing properties or methods that change the list in descendants of TStrings, call BeginUpdate before the changes are made, and EndUpdate when the changes are complete.
TStrings simply keeps track of when the list of strings is being changed. Some descendants of TStrings use this information to perform certain actions, such as telling a control to repaint, when updates are complete.</docstr>
      </procedure>
      <procedure name="Clear">
        <docstr>Introduces an abstract (Delphi) or pure virtual (C++) method to empty the list and any associated objects.
Descendants of TStrings implement a Clear method to delete all the strings in the list, and to remove any references to associated objects.</docstr>
      </procedure>
      <procedure name="Delete">
        <docstr>Introduces an abstract (Delphi) or pure virtual (C++) method to delete a specified string from the list.
Descendants of TStrings implement a Delete method to remove a specified string from the list. If an object is associated with the string, the reference to the object is removed as well. Index gives the position of the string, where 0 is the first string, 1 is the second string, and so on.</docstr>
      </procedure>
      <procedure name="EndUpdate">
        <docstr>Enables the TStrings object to keep track of when the list of strings has finished changing.
EndUpdate is called automatically by any property or method that changes the list of strings. Call BeginUpdate before directly modifying the strings in the list, and EndUpdate after. When implementing properties or methods that change the list in descendants of TStrings, call BeginUpdate before the changes are made, and EndUpdate when the changes are complete.
TStrings simply keeps track of when the list of strings is being changed. Some descendants of TStrings use this information to perform certain actions, such as telling a control to repaint, when updates are complete.</docstr>
      </procedure>
      <function name="Equals">
        <docstr>Compares the list of strings to the list from another TStrings object and returns true if the two lists match.
Call Equals to compare the lists in two TStrings objects. Equals compares only the strings, not any references to associated objects. Equals returns true if the lists for both TStrings objects have the same number of strings and the strings in each list match. Equals returns false if the lists are different in length, if they contain different strings, or if the order of the strings in the two lists differ.

Note:  The Equals method uses an overridden Get method to perform the compare, thus it does not provide a context-insensitive option.</docstr>
      </function>
      <procedure name="Exchange">
        <docstr>Swaps the position of two strings in the list.
Call Exchange to rearrange the strings in the list. The strings are specified by their index values in the Index1 and Index2 parameters. Indexes are zero-based, so the first string in the list has an index value of 0, the second has an index value of 1, and so on.
If either string has an associated object, Exchange changes the position of the object as well.</docstr>
      </procedure>
      <function name="GetEnumerator">
        <docstr>Returns a TStrings enumerator.
GetEnumerator returns a TStringsEnumerator reference, which enumerates the strings in a TStrings object. 
To process all these strings, call the TStringsEnumerator GetCurrent method within a While MoveNext do loop.</docstr>
      </function>
      <function name="GetText">
        <docstr>Allocates a text buffer and fills it with the value of the Text property.
Call GetText to obtain a dynamically allocated character buffer containing all of the strings in the list. Individual strings are separated by a carriage return (#13) on the OS X operating system, or by a carriage return and a line feed (#13#10) on Windows operating systems. The caller is responsible for freeing the returned value using the StrDispose procedure.</docstr>
      </function>
      <function name="IndexOf">
        <docstr>Returns the position of a string in the list.
Call IndexOf to obtain the position of the first occurrence of the S string. IndexOf is not case-sensitive; this means that the given string may differ in case from the string in the list. For example:

String1 := MyStrings.Items.IndexOf(&apos;My First String&apos;);

is equivalent to

String1 := MyStrings.Items.IndexOf(&apos;My FIRST String&apos;);

IndexOf returns the 0-based index of the string. Thus, if S matches the first string in the list, IndexOf returns 0, if S is the second string, IndexOf returns 1, and so on. If the string is not in the string list, IndexOf returns -1. 

Note: If the string appears in the list more than once, IndexOf returns the position of the first occurrence.</docstr>
      </function>
      <function name="IndexOfName">
        <docstr>Returns the position of the first name-value pair with the specified name.
Call IndexOfName to locate the first occurrence of a name-value pair where the name part is equal to the Name parameter or differs only in case. IndexOfName returns the 0-based index of the string. If no string in the list has the indicated name, IndexOfName returns -1.

Note:  If there is more than one name-value pair with a name portion matching the Name parameter, IndexOfName returns the position of the first such string.</docstr>
      </function>
      <function name="IndexOfObject">
        <docstr>Returns the index of the first string in the list associated with a given object.
Call IndexOfObject to locate the first string in the list associated with the object AObject. Specify the object you want to locate as the value of the AObject parameter. IndexOfObject returns the 0-based index of the string and object. If the object is not associated with any of the strings, IndexOfObject returns -1.</docstr>
      </function>
      <procedure name="Insert">
        <docstr>Introduces abstract (Delphi) or pure virtual (C++) method to insert a string at a specified position.
Descendants of TStrings implement an Insert method to add the string S to the list at the position specified by Index. If Index is 0, the string is inserted at the beginning of the list. If Index is 1, the string is put in the second position of the list, and so on.
All methods that add strings to the list use the Insert method to add the string.
If the string has an associated object, use the InsertObject method instead.</docstr>
      </procedure>
      <procedure name="InsertObject">
        <docstr>Inserts a string into the list at the specified position, and associates it with an object.
Call InsertObject to insert the string S into the list at the position identified by Index, and associate it with the object AObject. If Index is 0, the string is inserted at the beginning of the list. If Index is 1, the string is put in the second position of the list, and so on.</docstr>
      </procedure>
      <procedure name="LoadFromFile">
        <docstr>Fills the string list with the lines of text in a specified file.
LoadFromFile fills the string list of the TStrings object from the file specified by FileName. LoadFromFile first clears any strings already in the list. Lines in the file are separated by a carriage return and a line feed (#13#10) on Windows operating systems and a carriage return (#13) on the OS X operating system. Each line in the file is then appended in the list as a string.
If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromFile then saves the value of the encoding in the Encoding property, to be used if the file is saved.

Note: LoadFromFile uses the Add method to add the strings that are read from the file.
If the specified file is not found, an EFOpenError is raised.</docstr>
      </procedure>
      <procedure name="LoadFromFile">
        <docstr>Fills the string list with the lines of text in a specified file.
LoadFromFile fills the string list of the TStrings object from the file specified by FileName. LoadFromFile first clears any strings already in the list. Lines in the file are separated by a carriage return and a line feed (#13#10) on Windows operating systems and a carriage return (#13) on the OS X operating system. Each line in the file is then appended in the list as a string.
If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromFile then saves the value of the encoding in the Encoding property, to be used if the file is saved.

Note: LoadFromFile uses the Add method to add the strings that are read from the file.
If the specified file is not found, an EFOpenError is raised.</docstr>
      </procedure>
      <procedure name="LoadFromStream">
        <docstr>Fills the list with lines of text read from a stream.
LoadFromStream fills the string list of the TStrings object from the stream specified by Stream. The text read from the stream is parsed into strings separated by a carriage return and a line feed (#13#10) characters on Windows operating systems and a carriage return (#13) character on the macOS operating system. Thus, LoadFromStream reads the value of the Text property.
If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromStream then saves the value of the encoding in the Encoding property, to be used if the stream is saved.
If the stream is a file stream, LoadFromStream does the same thing as LoadFromFile, except that LoadFromFile creates and destroys the file stream.</docstr>
      </procedure>
      <procedure name="LoadFromStream">
        <docstr>Fills the list with lines of text read from a stream.
LoadFromStream fills the string list of the TStrings object from the stream specified by Stream. The text read from the stream is parsed into strings separated by a carriage return and a line feed (#13#10) characters on Windows operating systems and a carriage return (#13) character on the macOS operating system. Thus, LoadFromStream reads the value of the Text property.
If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromStream then saves the value of the encoding in the Encoding property, to be used if the stream is saved.
If the stream is a file stream, LoadFromStream does the same thing as LoadFromFile, except that LoadFromFile creates and destroys the file stream.</docstr>
      </procedure>
      <procedure name="Move">
        <docstr>Changes the position of a string in the list.
Use Move to move the string at position CurIndex so that it occupies the position NewIndex. The positions are specified as 0-based indexes. For example, the following lines of code move the string in the first position to the last position:
For Delphi:

MyStringsObject.Move(0, MyStringsObject.Count - 1);

For C++: 

MyStringsObject-&gt;Move(0, MyStringsObject-&gt;Count - 1);

If the string has an associated object, the object remains associated with the string in its new position.</docstr>
      </procedure>
      <procedure name="SaveToFile">
        <docstr>Saves the strings in the current object to the specified FileName file.
SaveToFile does the same thing as SaveToStream when it writes to a file stream, except that SaveToFile creates and destroys the file stream.
Each string from the list is written to a separate line in the file.
If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property.</docstr>
      </procedure>
      <procedure name="SaveToFile">
        <docstr>Saves the strings in the current object to the specified FileName file.
SaveToFile does the same thing as SaveToStream when it writes to a file stream, except that SaveToFile creates and destroys the file stream.
Each string from the list is written to a separate line in the file.
If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property.</docstr>
      </procedure>
      <procedure name="SaveToStream">
        <docstr>Writes the  value of the Text property to the Stream stream.
SaveToStream gets all strings from the current TStrings object and combines them into the single string containing these strings delimited by LineBreak sequence. Then SaveToStream encodes this string using the specified Encoding. Then SaveToStream writes the encoded string into the specified Stream stream.
If WriteBOM is True then SaveToStream first gets the preamble of the specified Encoding or of the DefaultEncoding (if Encoding = nil)  and writes the preamble bytes into the stream before the main string.
If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property. 

Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on macOS, it is just a line feed (#10).
Note:  If TrailingLineBreak is True, then SaveToStream writes a finishing line break LineBreak after the last string.
If the stream is a file stream, SaveToStream does the same thing as SaveToFile, except that SaveToFile creates and destroys the file stream.</docstr>
      </procedure>
      <procedure name="SaveToStream">
        <docstr>Writes the  value of the Text property to the Stream stream.
SaveToStream gets all strings from the current TStrings object and combines them into the single string containing these strings delimited by LineBreak sequence. Then SaveToStream encodes this string using the specified Encoding. Then SaveToStream writes the encoded string into the specified Stream stream.
If WriteBOM is True then SaveToStream first gets the preamble of the specified Encoding or of the DefaultEncoding (if Encoding = nil)  and writes the preamble bytes into the stream before the main string.
If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property. 

Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on macOS, it is just a line feed (#10).
Note:  If TrailingLineBreak is True, then SaveToStream writes a finishing line break LineBreak after the last string.
If the stream is a file stream, SaveToStream does the same thing as SaveToFile, except that SaveToFile creates and destroys the file stream.</docstr>
      </procedure>
      <procedure name="SetText">
        <docstr>Sets the Text property.
Call SetText to replace the list with the strings specified by the Text parameter. SetText adds strings one at a time to the list, using the carriage returns or linefeed characters in Text as delimiters indicating when to add a new string.</docstr>
      </procedure>
      <function name="ToStringArray">
        <docstr>Converts a TStrings descendant to a string array.
 
Use ToStringArray to obtain an array of strings for each string in the list.</docstr>
      </function>
      <function name="ToObjectArray">
        <docstr>Returns the TObject array associated with Strings.
 
Use ToObjectArray to obtain the array of TObject associated with Strings.

Note: TStrings is an abstract class and this method has no effect. Descendent classes can associate objects with strings.
Note:  The TStrings object does not own the objects in the Objects array. Objects added to the Objects array still exist even if the TStrings object is destroyed. They must be explicitly destroyed by the application.</docstr>
      </function>
      <property name="Updating">
        <docstr>Indicates whether or not the list of strings is in the middle of an update.</docstr>
      </property>
      <property name="Capacity">
        <docstr>Indicates the number of strings the TStrings object can hold.
Read Capacity to determine the currently allocated size of the string list. For the TStrings object, reading Capacity returns the Count property, and setting Capacity does nothing. Descendants of TStrings can override this property to allow a string list to allocate memory for entries that have not been added to the list.</docstr>
      </property>
      <property name="CommaText">
        <docstr>Lists the strings in the TStrings object in a single comma-delimited string.
Use CommaText to get or set all the strings in the TStrings object in a single comma-delimited string. The single comma-delimited string format is also known as the system data format (SDF).
When retrieving CommaText, any string in the list that include spaces, commas or double quotes will be contained in double quotes, and any double quotes in a string will be repeated. For example, if the list contains the following strings:

Stri,ng1
Stri&quot;ng2
String 3
String4

CommaText will return: 

&quot;Stri,ng1&quot;,&quot;Stri&quot;&quot;ng2&quot;,&quot;String 3&quot;,String4

When assigning CommaText, the value is parsed as SDF formatted text. For SDF format, strings are separated by commas or spaces, and optionally enclosed in double quotes. Double quote marks that are part of the string are repeated to distinguish them from the quotes that surround the string. Spaces and commas that are not contained within double quote marks are delimiters. Two commas next to each other will indicate an empty string, but spaces that appear next to another delimiter are ignored. For example, suppose CommaText is set to:

&quot;Stri,ng 1&quot;,&quot;Stri&quot;&quot;ng 2&quot;,String 3,String4

The list will then contain:

Stri,ng 1
Stri&quot;ng 2
String
3
String4

Note: CommaText is the same as the DelimitedText property with a delimiter of &apos;,&apos; and a quote character of &apos;&quot;&apos;.
Including a trailing comma in the source string causes a blank item to be included in the string list. For example, if CommaText is set to

&quot;String1,String2,String3, &quot;

the string list will contain

String1
String2
String3
&lt;Blank&gt;</docstr>
      </property>
      <property name="Count">
        <docstr>Introduces an abstract property to represent the number of strings in the list.
Descendants of TStrings implement a Count property to indicate the number of strings in the list.
Use the Count property when iterating over all the strings in the list, or when trying to locate the position of a string relative to the last string in the list.</docstr>
      </property>
      <property name="DefaultEncoding">
        <docstr>The default encoding for the current object.
DefaultEncoding is used when the nil encoding is specified in a call to LoadFromStream or SaveToStream. 
By default, DefaultEncoding is set to Default. The user can change DefaultEncoding if another default encoding is desired for LoadFromStream or SaveToStream.</docstr>
      </property>
      <property name="Delimiter">
        <docstr>Specifies the delimiter used by the DelimitedText property.
Use Delimiter to get or set the delimiter used by the DelimitedText property. DelimitedText represents all of the strings in the TStrings object as a single string, with individual strings separated by the character that is the value of Delimiter.
The default delimiter is represented by comma (,).</docstr>
      </property>
      <property name="DelimitedText">
        <docstr>Represents all the strings in the TStrings object as a single delimited string.
Use DelimitedText to get or set all the strings in the TStrings object in a single string, separated by the character specified by the Delimiter property. 
When retrieving DelimitedText, any string in the list that includes spaces or the delimiter and quotation marks characters specified in the Delimiter and QuoteChar properties will be surrounded (before and after) by the quotation mark character (QuoteChar). In addition, any QuoteChar character contained in an individual string will be repeated. 
When retrieving DelimitedText, the resulting value delimits individual strings in two ways: each string is surrounded (before and after) by the quotation marks character specified by the QuoteChar property. In addition, individual strings are separated by the character specified by the Delimiter property. 
When assigning DelimitedText, individual strings must be separated using Delimiter marks, and optionally enclosed in QuoteChar characters. 
When assigning DelimitedText, the value is parsed as SDF formatted text. For SDF format, strings are separated by Delimiter characters or spaces, and optionally enclosed in QuoteChar characters. QuoteChar marks that are part of the string are repeated to distinguish them from the QuoteChar characters that surround the string. Spaces and Delimiter characters that are not contained within QuoteChar marks are delimiters. Two Delimiter characters next to each other will indicate an empty string, but spaces that appear next to another Delimiter character are ignored. 
If StrictDelimiter is set to False, the space character is also interpreted as a delimiter, regardless of the value of Delimiter. This is not true when the space character occurs between quotation marks. 

Note: CommaText is the same as the DelimitedText property when Delimiter is &apos;,&apos; and QuoteChar is &apos;&quot;&apos;. Including a trailing Delimiter in the source string causes a blank item to be included in the string list.</docstr>
      </property>
      <property name="Encoding">
        <docstr>Character encoding determined during reading from a stream or file.
Encoding is a read-only property that contains the value of the character encoding detected when the LoadFromStream or LoadFromFile methods are called. If a file or stream does not contain a BOM (the encoding value cannot be detected) then Encoding is set to the value specified in the DefaultEncoding property.
Encoding is used in the SaveToStream and SaveToFile methods.</docstr>
      </property>
      <property name="LineBreak">
        <docstr>Defines line-break characters.
The LineBreak property is used internally in TStrings to set the string terminator characters. Set or read the LineBreak property to determine the string terminator characters in multistring output operations. 
For example, the GetText method returns a long string containing all TStrings strings, each of which is terminated by the LineBreak value.

Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on Android, Linux, macOS and iOS it is just a line feed (#10).</docstr>
      </property>
      <property name="KeyNames[Index]">
        <docstr>When the list of strings includes strings that are name-value pairs or just names,
              read Keys to access the name part of a string. If the string is not a name-value
              pair, Keys returns full string. Assigning Keys will write new name for name-value
              pair. This is in contrast to Names property.</docstr>
      </property>
      <property name="QuoteChar">
        <docstr>Specifies the quote character used by the DelimitedText property.
Use QuoteChar to get or set the quote character that is used to enclose individual strings in the DelimitedText property.
When QuoteChar is set to the null character, then DelimitedText does the following: 

At reading, does not return quoted list items.
At assigning, does not check an assigning value for quote char.
That is, you can set QuoteChar to the null character to disable quoting in DelimitedText. To set the QuoteChar to the null character, do the following:


Delphi:

MyStringList.QuoteChar := #0;



C++:

MyStringList-&gt;QuoteChar = &apos;\0&apos;;</docstr>
      </property>
      <property name="NameValueSeparator">
        <docstr>Indicates the character used to separate names from values.
Strings that contain the NameValueSeparator character are considered name-value pairs. NameValueSeparator defaults to the equal sign (=). TStrings defines various methods for accessing names and values and for searching for specific names.
Strings that are name-value pairs consist of a name part, the separator character, and a value part. Any spaces around the separator character are part of the name or value. This convention corresponds to the format used in many initialization files. For example:

DisplayGrid=1
SnapToGrid=1
GridSizeX=8
GridSizeY=8</docstr>
      </property>
      <property name="StrictDelimiter">
        <docstr>Determines how the Delimiter property is used.
If StrictDelimiter is True, individual strings in DelimitedText are only separated by Delimiter or quoted between  QuoteChar. If StrictDelimiter is False, spaces and non-printable character are also used as delimiters.

Tip: You can set QuoteChar to the null character (#0 in Delphi, &apos;\0&apos; in C++) if you do not want quoted strings to be extracted as if they where surrounded by Delimiter.</docstr>
      </property>
      <property name="Text">
        <docstr>Lists the strings in the TStrings object as a single string with the individual strings delimited by carriage returns and line feeds.
Use Text to get or set all the strings in the TStrings object in a single string delimited by carriage return, line feed pairs.
When setting Text, the value will be parsed and separated into substrings whenever the LineBreak value is encountered. For backward compatibility, on POSIX, if the LineBreak separator is LF, then LF, CR, or CRLF are treated as separators. On Windows if the LineBreak separator is CRLF, then LF, CR, or CRLF are treated as separators. 
If the strings in the list contain carriage return or linefeed characters, a less ambiguous format for the strings is available through the CommaText or DelimitedText property.</docstr>
      </property>
      <property name="StringsAdapter">
        <docstr>Implements an IStringsAdapter interface for the TStrings object.

StringsAdapter specifies the attached TStringsAdapter when it is used in OLE applications.

Note: To create a StringsAdapter you can use GetOleStrings and SetOleStrings instead of creating an instance of TStringsAdapter. StringsAdapter is used internally with OLE applications.</docstr>
      </property>
      <property name="WriteBOM">
        <docstr>Will cause SaveToStream and SaveToFile to write a BOM.
Set WriteBOM to True to cause SaveToStream to write a BOM (byte-order mark) to the stream and to cause SaveToFile to write a BOM to the file.</docstr>
      </property>
      <property name="TrailingLineBreak">
        <docstr>Determines whether to add a line Break after the last line of the Text property or not.
Use TrailingLineBreak to add a finishing line break to Text. Set TrailingLineBreak to True to add a  line Break after the last line of Text. Set TrailingLineBreak to False to finish Text without a  line Break. Default is True.</docstr>
      </property>
      <property name="UseLocale">
        <docstr>Determines the implementation that the list of strings must use for string comparison.
Set UseLocale to True to use AnsiCompareStr and AnsiCompareText to compare strings.
Set UseLocale to False to use CompareStr and CompareText. Default is True.</docstr>
      </property>
      <property name="Options">
        <docstr>Controls a set of boolean properties of TStrings.
Use Options to specify the value of the following boolean properties of the list of strings:



Option

Property


soStrictDelimiter

StrictDelimiter


soWriteBOM

WriteBOM


soTrailingLineBreak

TrailingLineBreak


soUseLocale

UseLocale</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TStringList">
    <docstr></docstr>
    <members>
      <constructor name="Create">
        <docstr>This constructor creates new string list with specified QuoteChar
              and Delimiter property values.</docstr>
      </constructor>
      <constructor name="Create">
        <docstr>This constructor creates new string list with specified QuoteChar,
              Delimiter and Options property values.</docstr>
      </constructor>
      <constructor name="Create">
        <docstr>This constructor creates new string list with specified Duplicates,
              Sorted and CaseSensitive property values.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="System.Classes" name="TBufferedFileStream">
    <docstr></docstr>
    <members>
      <procedure name="SyncBuffer">
        <docstr>SyncBuffer writes buffered and not yet written data to the file.
              When ReRead is True, then buffer will be repopulated from the file.
              When ReRead is False, then buffer will be emptied, so next read or
              write operation will repopulate buffer.</docstr>
      </procedure>
      <procedure name="FlushBuffer">
        <docstr>FlushBuffer writes buffered and not yet written data to the file.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="System.Classes" name="TThread">
    <docstr></docstr>
    <members>
      <procedure name="ForceQueue">
        <docstr>Queue the method to delay its  synchronous execution. Unlike the Queue method, this will queue it even
              if the caller is in the main thread.</docstr>
      </procedure>
      <procedure name="ForceQueue">
        <docstr>Queue the procedure to delay its synchronous execution. Unlike the Queue method, this will queue it even
              if the caller is in the main thread.</docstr>
      </procedure>
      <function name="IsTimeout">
        <docstr>Returns True if after AStartTime the specified ATimeout is passed.
              When ATimeout &lt;= 0, then timeout is inifinite and function always returns False.</docstr>
      </function>
      <property name="Current">
        <docstr>The currently executing thread. This is the same as TThread.CurrentThread.</docstr>
      </property>
      <property name="CurrentThread">
        <docstr>The currently executing thread. This is the same as TThread.Current.
              Please use TThread.Current, which is more clear and less redundant.</docstr>
      </property>
      <property name="ProcessorCount">
        <docstr>The number of processor cores on which this application is running. This will include virtual
              &quot;Hyper-threading&quot; cores on many modern Intel CPUs. It is ultimately based on what the underlying
              operating system reports.</docstr>
      </property>
      <property name="IsSingleProcessor">
        <docstr>Simple Boolean property to quickly determine wether running on a single CPU based system.</docstr>
      </property>
      <property name="OnSynchronize">
        <docstr>Event handler, which is called before each Synchronize or Queue call.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TBaseAsyncResult">
    <docstr></docstr>
    <members>
      <field name="FInvokingException">
        <docstr>This field will hold the acquired exception instance raised from the execution of the async method call.
              It will be re-raised in the context of the invoking thread when the corresponding EndXXXX method is called.</docstr>
      </field>
      <procedure name="AsyncDispatch">
        <docstr>Override this method to dispatch the actual asynchronous procedure call. Descendants will use whatever context
              or other state information contained in the instance to pass along to the procedure or function.</docstr>
      </procedure>
      <procedure name="Complete">
        <docstr>Override this method to perform any extra state or signaling required by the descendant. The descendant must
              call this inherited method in order to properly set the completion and possibly signal the FAsyncHandle if
              previously created. Failure to call this method can result in a dead lock or hang.</docstr>
      </procedure>
      <procedure name="DoAsyncDispatch">
        <docstr>Calls the actual target asynchronous method within the context of however it is scheduled. This could be
              in the context of the main or GUI thread, or within a background thread. This depends on the implementation
              of a specific asynchronous BeginXXXX method call.</docstr>
      </procedure>
      <procedure name="Schedule">
        <docstr>Override this method to schedule the asynchronous procedure call in the manner specific to
              a given instance, component or class. By default, this will schedule the async procedure onto
              the main thread or execute the procedure synchronously if already on the main thread.
              Other classes may schedule the procedure call into a separate thread or thread pool.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>This constructor must be called from a descendent protected constructor.</docstr>
      </constructor>
      <property name="Context">
        <docstr>Opaque user-supplied context. This context is available via the IAsyncResult.GetAsyncContext and descendents
              if this class.</docstr>
      </property>
      <function name="DoCancel">
        <docstr>Returns true if the operation can be cancelled. When cancelling the async operation, do any additional processing.</docstr>
      </function>
      <constructor name="Create">
        <docstr>This constructor should never be called directly. Only descendents should be constructed using the
              protected Create constructor above. Calling this constructor will raise an exception.</docstr>
      </constructor>
      <function name="Cancel">
        <docstr>Cancels the async operation. Returns True when the asynchronous operation can be cancelled.</docstr>
      </function>
      <function name="Invoke">
        <docstr>This method must be called prior in order to return itself as an IAsyncResult and actually schedule/invoke the
              async call.</docstr>
      </function>
      <procedure name="WaitForCompletion">
        <docstr>As long as the rules for only ever accessing this object through the IAsynsResult interface, this method
              should only ever be called by a given &quot;EndInvoke&quot; method by casting the IAsyncResult interface instance
              back to a specific descendant instance of this class. Never call this method directly outside the context
              of an &quot;EndInvoke&quot; style method.</docstr>
      </procedure>
      <procedure name="Dispatch">
        <docstr>This method is called from VCL.TControl (and possibly other similar) descendants in order to call the
              asynchronous procedure/function as a result of a posted Window message.</docstr>
      </procedure>
      <property name="IsCancelled">
        <docstr>Set to True when the asynchronous call has been cancelled.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TComponent">
    <docstr>TComponent is the common ancestor of all component classes.
TComponent is the base class for all components. Components are persistent objects that have the following capabilities:

IDE integration. The ability to appear on an IDE palette and be manipulated in a Form Designer.
Ownership. The ability to manage other components. If component A owns component B, then A is responsible for destroying B when A is destroyed.
Streaming and filing. Enhancements of the persistence features inherited from TPersistent.
COM support. Components can be converted into ActiveX controls or other COM objects using wizards provided with Windows products. Components can serve as wrappers for COM objects.
Note: COM features are present in all implementations of TComponent, including those provided for compatibility with OS X. However, COM features are Windows only and cannot be used in multi-device (cross-platform) applications.
TComponent does not provide any user interface or display features. These features are provided by two classes that directly descend from TComponent:

TControl, in the FMX.Types unit, is the base class for visual components in applications built with the FireMonkey (FMX) framework.
TControl, in the Vcl.Controls unit, is the base class for visual components in Windows-only (VCL) applications.
Note: Only the FMX.Types unit and other FireMonkey-specific units can be used with OS X applications. That is, you cannot use VCL units in multi-device applications.
Components that can be visible at run time are sometimes called visual components. Other components, which are never visible at run time, are sometimes called non-visual components. However it is more common to refer to visual components as controls and non-visual components simply as components.
Do not create instances of TComponent. Use TComponent as a base class when declaring non-visual components that can appear on the component palette and be used in the Form Designer. Properties and methods of TComponent provide basic behavior that descendant classes inherit as well as behavior that components can override to customize their behavior.</docstr>
    <members>
      <procedure name="AsyncSchedule">
        <docstr>Schedules asynch method calls.
By default, AsyncSchedule uses Queue in order to queue the asynch method call with the main thread.
Override AsyncSchedule in descendant components in order to modify the management of the asynchronous scheduling.</docstr>
      </procedure>
      <procedure name="ChangeName">
        <docstr>Sets the private, internal storage for the Name property to the string passed in NewName.
Do not use ChangeName directly in an application. Instead, use the Name property.

Note: The property setter for Name -- SetName-- uses ChangeName to change the component&apos;s name. ChangeName is not virtual; do not override it.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="GetChildren">
        <docstr>Enumerates all child components.
GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
GetChildren expects a TGetChildProc routine that receives all enumerated components. 
Root represents the owner of the components that will be enumerated.
This method does nothing in TComponent and is expected to be overridden in descendants.</docstr>
      </procedure>
      <function name="GetChildOwner">
        <docstr>Returns the owner of a child component being read from a stream.
GetChildOwner is used internally by the component streaming system. It is rarely necessary to call it directly.
In TComponent, GetChildOwner always returns nil (Delphi) or NULL (C++), indicating that the owner is the root component currently being read (usually a form or data module). The Owner of a component is responsible for destroying it.</docstr>
      </function>
      <function name="GetChildParent">
        <docstr>Returns the parent or, if there is no parent, returns the owner of a child component being read from a stream.
GetChildParent is used internally in the component streaming system. It is not necessary to call it directly.
As implemented in TComponent, GetChildParent returns Self (Delphi) or this (C++). If GetChildParent returns nil (Delphi) or NULL (C++), the parent is assumed to be the root component currently being read (usually a form).</docstr>
      </function>
      <function name="GetOwner">
        <docstr>Returns the owner of a component.
GetOwner is called by GetNamePath to find the owner of a component. GetNamePath and GetOwner are introduced in TPersistent so descendants such as collections can appear in the Object Inspector. For TComponent, GetOwner returns the value of the Owner property.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="GetDeltaStreams">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ReadState">
        <docstr>Reads the state of the component.
ReadState is used internally in the component streaming system. It is not necessary to call it directly. 
ReadState expects a TReader object, which is used for reading the state of the component.</docstr>
      </procedure>
      <function name="CanObserve">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ObserverAdded">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetObservers">
        <docstr>Getter of Observers.</docstr>
      </function>
      <procedure name="SetAncestor">
        <docstr>Clears or sets csAncestor state in the component&apos;s ComponentState property.
SetAncestor is used internally in the component streaming system. It is not necessary to call it directly. 
If Value is set to True, the csAncestor flag is included into the component state; otherwise, it is excluded.</docstr>
      </procedure>
      <procedure name="SetDesigning">
        <docstr>Ensures that components inserted at design time have their design-mode flag set.
SetDesigning is used internally by the Form designer. Do not call SetDesigning directly.
SetDesigning sets the csDesigning flag in the ComponentState property if Value is True; otherwise, it removes csDesigning. 
If the SetChildren parameter is True, SetDesigning then calls the SetDesigning methods of any owned components, passing Value, so that the owned components&apos; ComponentState properties are synchronized with the owner&apos;s.
The InsertComponent and RemoveComponent methods call SetDesigning for inserted or removed components to ensure that their design-mode flags are set properly.</docstr>
      </procedure>
      <procedure name="SetInline">
        <docstr>Sets the csInline bit of the component&apos;s ComponentState property.
SetInline is used internally to indicate whether the component can act as a root component in the designer but also be embedded in a form.
SetInline sets the csInline flag in the ComponentState property if Value is True; otherwise, it removes csInline.</docstr>
      </procedure>
      <procedure name="SetDesignInstance">
        <docstr>Ensures that components inserted at design time have their design-mode flag set.
SetDesignInstance is used internally by the Form designer to identify objects that act as a design surface. Do not call SetDesignInstance directly.
SetDesignInstance sets the csDesignInstance flag in the ComponentState property if Value is 
True; otherwise, it removes csDesignInstance.</docstr>
      </procedure>
      <procedure name="SetName">
        <docstr>Sets the value of the Name property.
SetName is the virtual property setter for the Name property. It calls the ChangeName method, which performs the actual name change.
ChangeName is not virtual; override SetName instead when modifying the behavior of the Name property.

Warning: Using SetName to change the name of a component at run time causes any references to the old name to become undefined. Any subsequent code that uses the old name will cause an exception.</docstr>
      </procedure>
      <procedure name="SetChildOrder">
        <docstr>Sets the visual ordering of a child control.
SetChildOrder is used internally in the component streaming system. It is not necessary to call it directly. 
Derived classes override this method to actually implement the ordering. TWinControl uses this ordering information to Z-align the controls.</docstr>
      </procedure>
      <procedure name="SetParentComponent">
        <docstr>Sets the parent component.
SetParentComponent is used internally in the component streaming system. It is not necessary to call it directly. 
Derived classes override this method to implement proper handling for parenting.</docstr>
      </procedure>
      <procedure name="Updating">
        <docstr>Sets the csUpdating state in the component&apos;s ComponentState property.
Do not call Updating directly. It is used internally to indicate that the component is about to be updated. A call to Updating, which sets the csUpdating flag, is always followed by a call to Updated, which clears the flag.</docstr>
      </procedure>
      <procedure name="Updated">
        <docstr>Clears the csUpdating state in the component&apos;s ComponentState property when the component finishes updating.
Do not call Updated directly. It is used internally to clear the csUpdating flag of the ComponentState property. A call to Updated always follows a call to Updating, which sets the flag.</docstr>
      </procedure>
      <procedure name="UpdateRegistry">
        <docstr>Provides the interface for a method that adds type library and version information to the Registry on components that implement COM interfaces.
Do not call UpdateRegistry directly. It is for internal use only.</docstr>
      </procedure>
      <procedure name="ValidateRename">
        <docstr>Ensures that renaming an owned component does not create a name conflict.
ValidateRename checks whether a component can rename one of its owned components, passed in AComponent, from its current name (CurName) to the string passed in NewName. If AComponent is nil (Delphi) or NULL (C++) or NewName is already the name of a component in the Components list, ValidateRename raises an EComponentError exception.
ValidateRename is used internally when the Name property is modified. It is not necessary to call it directly.</docstr>
      </procedure>
      <procedure name="ValidateContainer">
        <docstr>Determines whether an object can be inserted into a container.
ValidateContainer is called by a component when it is about to be inserted into a container object. By default, ValidateContainer calls the ValidateInsert method of the component specified by the AComponent parameter. 
Descendent components can override ValidateContainer to disallow a component from being inserted into specific containers. To disallow an insertion, raise an exception in the derived method.</docstr>
      </procedure>
      <procedure name="ValidateInsert">
        <docstr>Provides the interface for a method that validates a child component before it is inserted.
ValidateInsert does nothing in TComponent. Descendent classes can override it to disallow a component from accepting an object as a child. By default, ValidateInsert allows any object to be inserted into the component. 
If a component needs to validate only certain objects, descendent classes can override ValidateInsert to filter out those objects. To disallow an insertion, raise an exception in the derived method.</docstr>
      </procedure>
      <procedure name="WriteState">
        <docstr>Writes the state of the component.
WriteState is used internally in the component streaming system. It is not necessary to call it directly. 
This method expects a TWriter object that is used for storing the state of the component.</docstr>
      </procedure>
      <procedure name="RemoveFreeNotifications">
        <docstr>Notifies all owned components of the owner component&apos;s imminent destruction.
The RemoveFreeNotifications method notifies all owned components of the owner component&apos;s imminent destruction. RemoveFreeNotifications is called automatically when the component is destroyed.</docstr>
      </procedure>
      <function name="QueryInterface">
        <docstr>Returns a reference to a specified interface if the current component supports that interface.
QueryInterface checks whether the component supports the interface specified by IID and, if so, returns a reference to that interface as the Obj parameter. If the component does not support the interface, the Obj parameter returns nil (Delphi) or NULL (C++).
QueryInterface returns the S_OK execution code on success. HResult type 
defines the following execution codes: S_OK, S_FALSE, E_NOINTERFACE, E_UNEXPECTED, and E_NOTIMPL.

Note: For components that act as COM object wrappers, QueryInterface calls the QueryInterface method of the internal COM object.</docstr>
      </function>
      <function name="_AddRef">
        <docstr>Called when an application uses a component interface.
_AddRef is a basic implementation of the IInterface method, _AddRef.

Note: If the component is a wrapper for a COM object, _AddRef calls the _AddRef method of that COM object, and returns the resulting reference count.
In all other cases, _AddRef simply returns 1 and takes no action. This allows the component to implement interfaces where reference counting is not required. More sophisticated components should override _AddRef to implement reference counting.</docstr>
      </function>
      <function name="_Release">
        <docstr>Called when an application releases a component interface.
_Release is a basic implementation of the IInterface method, _Release.
_Release returns the resulting value of the reference count for the component&apos;s interface.

Note: In all other cases, _Release simply returns 1 and takes no action. This allows the component to implement interfaces where reference counting is not required. More sophisticated components should override _Release to implement reference counting.</docstr>
      </function>
      <function name="GetTypeInfoCount">
        <docstr>Returns the number of type information interfaces that an object provides (either 0 or 1).
GetTypeInfoCount implements the IDispatch interface GetTypeInfoCount method. For components that support interfaces, GetTypeInfoCount calls this method for the interface supported by the component. The Count parameter points to a location that receives the number of type information interfaces provided by the object. If the object provides type information, this number is 1; otherwise the number is 0.</docstr>
      </function>
      <function name="GetTypeInfo">
        <docstr>Retrieves the type information for an object.
GetTypeInfo implements the IDispatch interface GetTypeInfo method. For components that support interfaces, GetTypeInfo calls the GetTypeInfo method for the interface supported by the component, passing it the specified parameters. Use the returned value to get the type information for an interface implemented by the component.</docstr>
      </function>
      <function name="GetIDsOfNames">
        <docstr>Maps a single member and an optional set of argument names to a corresponding set of integer dispatch identifiers (dispIDs).
GetIDsOfNames implements the IDispatch interface GetIDsOfNames method. For components that support interfaces, GetIDsOfNames calls this method for the interface supported by the component, passing the specified parameters. The returned value can be used on subsequent calls to the Invoke method.</docstr>
      </function>
      <function name="Invoke">
        <docstr>Provides access to Automation properties and methods when the component wraps an Automation object.
Invoke is the standard mechanism for accessing the exposed properties and methods of an Automation object. For components that wrap the IDispatch interface of an Automation object, Invoke calls the Invoke method for the interface supported by the component, passing it the parameters specified by the function.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="BeforeDestruction">
        <docstr>Performs any necessary actions before the first destructor is called.
BeforeDestruction is called automatically immediately before the component&apos;s first destructor executes. Do not call it explicitly in your applications.
As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place.</docstr>
      </procedure>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <procedure name="EndInvoke">
        <docstr>Blocks the caller until the specified ASyncResult completes.
Returns the result from the method that BeginInvoke asynchronously executes. This result is immediately returned after the given IAsyncResult finishes. 
EndInvoke raises any exception that may occur while the asynchronous method executes.</docstr>
      </procedure>
      <function name="EndInvoke">
        <docstr>Blocks the caller until the specified ASyncResult completes.
Returns the result from the method that BeginInvoke asynchronously executes. This result is immediately returned after the given IAsyncResult finishes. 
EndInvoke raises any exception that may occur while the asynchronous method executes.</docstr>
      </function>
      <function name="EndFunctionInvoke">
        <docstr>Blocks the caller until the specified ASyncResult completes.
Returns the result from the method that BeginInvoke asynchronously executes. This result is immediately returned after the given IAsyncResult finishes. The result type corresponds to a TObject class type.
EndInvoke raises any exception that may occur while the asynchronous method executes.</docstr>
      </function>
      <procedure name="DestroyComponents">
        <docstr>Destroys all owned components.
DestroyComponents iterates through the components owned by the component, removing each from the list of owned components and destroying it.
It is not necessary to call DestroyComponents directly. DestroyComponents is automatically called when the component is destroyed.</docstr>
      </procedure>
      <procedure name="Destroying">
        <docstr>Indicates that the component and its owned components are about to be destroyed.
Destroying sets the csDestroying flag in the ComponentState property. It then calls the Destroying method for each owned component so that its csDestroying flag is also set. If csDestroying is already set, Destroying does nothing.
It is not necessary to call Destroying directly. Destroying is automatically called when the component is destroyed.</docstr>
      </procedure>
      <function name="ExecuteAction">
        <docstr>Executes an action.
ExecuteAction executes an action for the component. Action is a TBasicAction or any descendant of TBasicAction. 
ExecuteAction first checks whether the provided action is compatible with the component and then executes the action. The return value is a Boolean. A value of True is returned if the action was executed; otherwise, False is returned. 
Derived classes can override this method to implement a distinct way of handling actions.</docstr>
      </function>
      <function name="FindComponent">
        <docstr>Indicates whether a given component is owned by the component.
FindComponent returns the component in the Components property array with the name that matches the string in the AName parameter. Use FindComponent to determine whether a given component is owned by another.
Component name matches are not case sensitive.</docstr>
      </function>
      <procedure name="FreeNotification">
        <docstr>Ensures that AComponent is notified that the component is going to be destroyed.
Use FreeNotification to register AComponent as a component that should be notified when the component is about to be destroyed. It is only necessary to register components this way when they are in a different form or have a different owner. For example, if AComponent is in another form and uses the component to implement a property, it must call FreeNotification so that its Notification method is called when the component is destroyed.
For components with the same owner, the Notification method is called automatically when an application explicitly frees the component. This notification is not sent out when components are freed implicitly, because the Owner is already being freed.</docstr>
      </procedure>
      <procedure name="RemoveFreeNotification">
        <docstr>Disables the destruction notification that was enabled by FreeNotification.
RemoveFreeNotification removes the component specified by the AComponent parameter from the internal list of objects to be notified that the component is about to be destroyed. AComponent is added to this list by a previous call to the FreeNotification method.
Most applications have no need to call RemoveFreeNotification. It is used by TComponent to detect loops where two components are notifying each other of their impending destruction.</docstr>
      </procedure>
      <procedure name="FreeOnRelease">
        <docstr>Frees the interface reference for components that were created from COM classes.
FreeOnRelease is called when an interface implemented by the component is released. FreeOnRelease is used internally and calls the corresponding interface method. It should not be necessary to call FreeOnRelease directly.</docstr>
      </procedure>
      <function name="GetEnumerator">
        <docstr>Returns a TComponent enumerator.
GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop.</docstr>
      </function>
      <function name="GetParentComponent">
        <docstr>Returns the containing component.
GetParentComponent returns a reference to the component that contains the current component, or nil if there is no container. Use HasParent to determine whether a component has a containing component. 
For example, a button on a panel on a form returns the panel, the panel returns the form, and the form returns nil.</docstr>
      </function>
      <function name="GetNamePath">
        <docstr>Returns a string used by the Object Inspector.
GetNamePath is used to determine the text to display in the Object Inspector for the name of the object being edited. GetNamePath is introduced in TPersistent so descendants such as collections can appear in the Object Inspector. TComponent overrides GetNamePath to return the component&apos;s name. Do not call GetNamePath directly.</docstr>
      </function>
      <function name="HasParent">
        <docstr>Verifies whether the component has a parent.
Call HasParent to determine whether a specific component has a parent. 
Derived classes override this method to implement proper handling for parenting.
Use GetParentComponent to retrieve the component reference.</docstr>
      </function>
      <procedure name="InsertComponent">
        <docstr>Establishes the component as the owner of a specified component.
InsertComponent adds the component passed in the AComponent parameter to the end of the Components array property. The inserted component must have no name (no specified Name property value), or the name must be unique among all others in the Components list.
When the owning component is destroyed, AComponent is also destroyed.
Components are automatically inserted and removed when visually manipulating them in the form designer. Use InsertComponent when manually adding components to another Owner component&apos;s Components list.</docstr>
      </procedure>
      <procedure name="RemoveComponent">
        <docstr>Removes a specified component specified from the component&apos;s Components list.
Components are automatically inserted and removed when visually manipulating them in the form designer. Use RemoveComponent to programmatically delete the component specified by AComponent from its Owner component.</docstr>
      </procedure>
      <procedure name="SetSubComponent">
        <docstr>Identifies whether the component is a subcomponent.
Call SetSubComponent to indicate whether this component is a subcomponent. A subcomponent is a component whose Owner is a component other than the form or data module in which it resides. Unless such a component calls SetSubComponent with IsSubComponent set to True, its published properties will not be saved to the form file.
IsSubComponent indicates whether the component is a subcomponent (True) or not (False).
SetSubComponent is called at design time:

Either from the constructor of a component that always acts as a subcomponent. In this case, the component calls its own SetSubComponent method from the constructor with IsSubComponent set to True.
Or immediately after constructing an instance of the subcomponent. In this case, the Owner calls the SetSubComponent method of a component it has just instantiated, with IsSubComponent set to True.</docstr>
      </procedure>
      <function name="SafeCallException">
        <docstr>Handles exceptions in methods declared using the safecall calling convention.
SafeCallException handles exceptions in methods that use the safecall calling convention. Some classes that implement interfaces override this method to handle errors that might occur. TComponent calls the implementation of this method for the interface supported by the component, if it exists. If the component does not support interfaces, this method calls the SafeCallException method inherited from TObject, which returns E_UNEXPECTED. This is a default return value that is appropriate for classes that do not support any interfaces.</docstr>
      </function>
      <function name="UpdateAction">
        <docstr>Updates the state of an action.
UpdateAction is used to update the state of an action. Action is a TBasicAction or any descendant. 
UpdateAction first checks whether the provided action is compatible with the component and then updates it. The return value is a Boolean. A value of True is returned if the action was updated, and a value of False, otherwise. 
Derived classes can override this method to implement a distinct way of handling action updates.</docstr>
      </function>
      <function name="IsImplementorOf">
        <docstr>Indicates whether the component implements a specified interface.
Call IsImplementorOf to determine whether the component (or, if the component aggregates its interface with other components, whether the controlling component) supports the interface specified by I. IsImplementorOf is similar to the QueryInterface method, but it can handle a request for a nil (Delphi) or NULL (C++) interface, and it does not return an interface pointer.
The streaming system that loads and saves components uses IsImplementorOf to resolve property values that are interfaces.</docstr>
      </function>
      <function name="ReferenceInterface">
        <docstr>Establishes or removes internal links that cause this component to be notified when the implementer of a specified interface is destroyed.
Component writers use ReferenceInterface to ensure that properties whose values are interfaces are informed when the objects that implement those interfaces are destroyed. This notification must be in place for a property whose value is an interface to be saved with the component in a form file (that is, for such a property to persist as a published property).
I is an interface pointer that is the value of the published property of interest.
Operation indicates whether the notification link to the implementer of the interface should be established (opInsert) or removed (opRemove).
ReferenceInterface returns True if it is successful in establishing or removing the notification link. If ReferenceInterface returns False when called with Operation set to opInsert, the specified interface cannot be stored as the value of a published property.

Note: A result of False does not necessarily indicate an error, merely that the interface cannot be stored by the property streaming system. For example, ReferenceInterface returns False when the specified interface employs true reference counting, independent of component lifetimes.</docstr>
      </function>
      <property name="ComObject">
        <docstr>Specifies the interface reference implemented by the component.
Use ComObject to assign a COM interface implemented by a component to an interface reference. This property is used by components that support COM interfaces. 
If the component is not a wrapper for a COM component, trying to read ComObject causes TComponent to raise an EComponentError exception.</docstr>
      </property>
      <property name="ComponentCount">
        <docstr>Indicates the number of components owned by the component.
Use the ComponentCount property to determine the number of components owned by a component, for example, when iterating through the components list to perform an action on all owned components. The ComponentCount property equals the number of items in the components list. This value is one more than the highest Components index, because the first components index is 0.</docstr>
      </property>
      <property name="ComponentIndex">
        <docstr>Indicates the position of the component in its owner&apos;s Components property array.
Use ComponentIndex when iterating through the Components list of the component&apos;s owner to perform an action on owned components. It can be used in conjunction with ComponentCount. ComponentIndex is used internally for iterative assignment procedures. 

Note:  The first component in the list has a ComponentIndex value of 0, the second has a value of 1, and so on. Therefore, when using ComponentIndex with ComponentCount, note that ComponentCount is always 1 more than the highest Components index.</docstr>
      </property>
      <property name="ComponentState">
        <docstr>Describes the current state of the component, indicating when a component needs to avoid certain actions.
ComponentState is a set of constants defined in the TComponentState type.
Components use the ComponentState property to detect states in which certain kinds of actions are allowed or disallowed. For example, if a component needs to avoid certain behaviors at design time that it performs at run time, it can check for the csDesigning flag. 
ComponentState is read-only and its flags are set automatically when appropriate.</docstr>
      </property>
      <property name="ComponentStyle">
        <docstr>Governs the behavior of the component.
ComponentStyle governs how the component interacts with the streaming system and the Object Inspector. ComponentStyle is a read-only property. Typically, the value of the various component style flags are part of a component definition, specified in a component constructor. The one exception to this is the csSubComponent style, which can be set by calling the SetSubComponent method.</docstr>
      </property>
      <property name="DesignInfo">
        <docstr>Contains information used by the Form designer.
DesignInfo is used internally. Do not use this property in applications.</docstr>
      </property>
      <property name="Owner">
        <docstr>Indicates the component that is responsible for streaming and freeing this component.
Use Owner to find the owner of a component. The Owner of a component is responsible for two things:
The memory for the owned component is freed when its owner&apos;s memory is freed. This means that when a form is destroyed, all the components on the form are also destroyed.
The Owner is responsible for loading and saving the published properties of its owned controls.
By default, a form owns all components that are on it. In turn, the form is owned by the application. Thus, when the application shuts down and its memory is freed, the memory for all forms (and all their owned components) is also freed. When a form is loaded into memory, it loads all of the components that are on it.
The owner of a component is determined by the parameter passed to the constructor when the component is created. For components created in the form designer, the form is automatically assigned as the Owner.

Warning: If a component has an Owner other than a form or data module, it will not be saved or loaded with its Owner unless you identify it as a subcomponent. To identify a component as a subcomponent, call the SetSubComponent method.</docstr>
      </property>
      <property name="VCLComObject">
        <docstr>Represents information used internally by components that support COM.
VCLComObject is for internal use only.</docstr>
      </property>
      <property name="Observers">
        <docstr>Indicates the TObservers object added to the TComponent.
Observers is a read-only property that returns the TObservers added to the TComponent, in order to use the notifications provided by the observers either with LiveBindings or for the developers&apos; own purposes.</docstr>
      </property>
      <property name="Name">
        <docstr>Specifies the name of the component as referenced in code.
Use Name to change the name of a component to reflect its purpose in the current application. By default, the IDE assigns sequential names based on the type of the component, such as &apos;Button1&apos;, &apos;Button2&apos;, and so on.
Use Name to refer to the component in code.

Warning: Changing Name at run time causes any references to the old name to become undefined. Any subsequent code that uses the old name will cause an exception.</docstr>
      </property>
      <property name="Tag">
        <docstr>Stores a NativeInt integral value as a part of a component.
Tag has no predefined meaning. The Tag property can store any additional integer value for the convenience of developers. Often, Tag stores a pointer. A Tag value can be typecast to the appropriate pointer type. Notice that on 64-bit platforms, all  pointer types are 8 bytes in size, while on 32-bit platforms, pointer types are 4 bytes. These pointer sizes correspond to sizes of NativeInt integral values on 64-bit and 32-bit platforms.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TBasicAction">
    <docstr>TBasicAction is the ancestor class for all action objects.
TBasicAction introduces the fundamental behavior for an action. Descendants of TBasicAction add functionality for containment in an action list, for being categorized, and for specializing their behavior tailored to particular clients such as controls or menu items. Use TBasicAction if you want to create an action for an object that is neither a menu item nor a control.</docstr>
    <members>
      <procedure name="Change">
        <docstr>Generates an OnChange event.
Change is called automatically when the action&apos;s properties change. This method calls the OnChange event handler, if one is assigned.</docstr>
      </procedure>
      <procedure name="SetOnExecute">
        <docstr>Assigns an OnExecute event handler for the action and for all clients.
SetOnExecute is the property write method for the OnExecute event. 
In addition to assigning the specified Value event handler to the OnExecute event, SetOnExecute propagates the assignment of this event handler to all clients linked to the action and generates an OnChange event.</docstr>
      </procedure>
      <event name="OnChange">
        <docstr>Occurs when one of the action&apos;s properties changes.
Applications cannot use the protected OnChange event. It is used internally to manage the relationship between the properties of the action and the corresponding properties of the action&apos;s clients.
Component writers can use OnChange in descendent objects to respond when the action&apos;s properties change.</docstr>
      </event>
      <procedure name="Notification">
        <docstr>Responds when components are created or destroyed.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. 
TBasicAction overrides the System.Classes.TComponent.Notification method. Notification checks whether the component specified by AComponent is the same as the component stored in the ActionComponent property and whether it is about to be freed. If so, Notification sets the ActionComponent property to nil (Delphi) or NULL (C++).</docstr>
      </procedure>
      <property name="ClientCount">
        <docstr>Stores the number of elements in the Clients list of action links associated with the action.</docstr>
      </property>
      <procedure name="RegisterChanges">
        <docstr>Associates the action with an action link.
RegisterChanges is called when the action and action link are connected, for example, when a new action link is set to an action. Value is the action link with which the action associates itself. The link is added to the action&apos;s client list.</docstr>
      </procedure>
      <procedure name="UnRegisterChanges">
        <docstr>Breaks the association between the action and the action link.
UnRegisterChanges is called when the action and the action link should no longer be associated. UnRegisterChanges is called, for example, in the action destructor or when the action link is unassociated from the action. Value is the action link with which the association is broken.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Instantiates and initializes a TBasicAction object.
Applications do not need to instantiate TBasicAction directly. Actions are created automatically when you choose New Action in the Action List editor.
If you want to create an action at run time, you should call the Create constructor of a FireMonkey action (FMX.ActnList.TAction) or VCL action (Vcl.ActnList.TAction), or any of their subclasses. The Create constructors assign a TActionList component to the ActionList property of the created action.
Create calls the inherited constructor and then creates a list of clients of the created action.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of an instance of a TBasicAction object.
You do not need to call the destructor for an action. An action is a component and is automatically destroyed by its owner, which was passed to the constructor when it is created. If you must destroy an action manually, call Free instead, which safely invokes the destructor.</docstr>
      </destructor>
      <function name="Suspended">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="HandlesTarget">
        <docstr>Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise.</docstr>
      </function>
      <procedure name="UpdateTarget">
        <docstr>Introduces an interface for a method of notifying a client when the action updates itself.
UpdateTarget does nothing in TBasicAction. UpdateTarget was introduced in TBasicAction so that descendants can override it to correspondingly update a target when the action updates.</docstr>
      </procedure>
      <procedure name="ExecuteTarget">
        <docstr>Introduces an interface for invoking an action on a target client component or control.
ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard.</docstr>
      </procedure>
      <function name="Execute">
        <docstr>Generates an OnExecute event.
Execute calls the OnExecute event handler, if one is assigned. Execute returns True if an event handler is called, False otherwise.</docstr>
      </function>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
      <property name="ActionComponent">
        <docstr>Stores the client component that caused this action to execute.
Use ActionComponent to discern which client component caused this action to execute. For example, examine ActionComponent from an OnExecute event handler if you need to know what user action triggered this action.
When the user clicks a client control, that client sets ActionComponent before calling the action&apos;s Execute method. After the action executes, the action resets ActionComponent to nil (Delphi) or NULL (C++).</docstr>
      </property>
      <event name="OnExecute">
        <docstr>Occurs when the execute event, of a client linked to the action, fires.
Write an OnExecute event handler when you want to respond when the user triggers the client object&apos;s default event (typically an OnClick event).
For most target clients, OnExecute is associated with the OnClick event. The Click method triggers the associated Action if EnableExecuteAction is True and the OnClick event handler is not assigned (or is equal to Action.OnExecute).
OnExecute is called in the Execute method. 
OnExecute also occurs when the user types the shortcut (or one of the secondary shortcuts) associated with the action or its client.

Warning:  If you assign an OnExecute event handler to a predefined action, the default behavior of that action will not occur.</docstr>
      </event>
      <event name="OnUpdate">
        <docstr>Occurs when the application is idle or when the action list updates.
Write an OnUpdate event handler to execute centralized code while an application is idle. For example, actions may want to update enabling and disabling, or checking and unchecking of client targets.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Edit" name="TCustomEditModel">
    <docstr></docstr>
    <members>
      <function name="DoValidating">
        <docstr>Validate inputing text. Calling before OnChangeTracking</docstr>
      </function>
      <property name="Validating">
        <docstr>This property indicates that the control is in validate value mode. See DoValidate, Change</docstr>
      </property>
      <procedure name="SetTextWithoutValidation">
        <docstr>Set text in model without text validation and sending notification to presenter</docstr>
      </procedure>
      <function name="GetCaretPositionByPoint">
        <docstr>Returns caret position by specified hittest point.</docstr>
      </function>
      <property name="ReadOnly">
        <docstr>Text control is in read-only mode</docstr>
      </property>
      <property name="CharCase">
        <docstr>Defines character case for text in component</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Edit" name="TCustomEdit">
    <docstr>TCustomEdit is the base class from which all FireMonkey edit boxes and memo controls are derived.
TCustomEdit encapsulates the behavior common to all components for editing text by introducing methods and properties that provide:

Basic text editing functions such as selecting text, modifying selected text, and case conversions.
Ability to respond to changes in the contents of the text.
Access control of the text for making it read-only or introducing a password character to hide the actual value.
When not in focus, TCustomEdit does not draw a selection rectangle even though the user has selected the text. You can verify whether the text is selected by using the SelText property.
Do not create instances of TCustomEdit. Use TCustomEdit as a base class when declaring control objects that permit the user to enter or modify text. Properties and methods of TCustomEdit provide basic behavior that descendant classes inherit, as well as behavior that components can override to customize their behavior.</docstr>
    <members>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.Edit.TCustomEdit.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
FMX.Edit.TCustomEdit.SetData inherits from FMX.Types.TFmxObject.SetData. All content below this line refers to FMX.Types.TFmxObject.SetData.
Protected setter implementation for the Data property.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the control after the form file has been read into memory and loads its presentation.
FMX.Edit.TCustomEdit.Loaded inherits from FMX.Controls.Presentation.TPresentedControl.Loaded. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Loaded.
Initializes the control after the form file has been read into memory and loads its presentation.
For details, see TControl.Loaded.

 See Also
FMX.Controls.Presentation.TPresentedControl.LoadPresentation
FMX.Controls.TControl.Loaded</docstr>
      </procedure>
      <function name="GetText">
        <docstr>Protected getter implementation for the Text property.</docstr>
      </function>
      <procedure name="SetText">
        <docstr>Protected setter implementation for the Text property.</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds a child object to the edit control.
If AObject is a TEditButton, it is added to the buttons associated with the edit control.</docstr>
      </procedure>
      <procedure name="DoInsertObject">
        <docstr>Adds a child object at the specified index.
If the AObject is a TEditButton, it is inserted into the TCustomEdit.ButtonsContent at the specified Index.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetImeMode">
        <docstr>Protected getter implementation for the ImeMode property.</docstr>
      </function>
      <procedure name="SetImeMode">
        <docstr>Protected setter implementation for the ImeMode property.</docstr>
      </procedure>
      <procedure name="SetInputSupport">
        <docstr>Sets the value of the InputSupport property.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Edit.TCustomEdit.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Gets the default size of the control.
Returns a TSizeF with the default values of Width and Height.</docstr>
      </function>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.Edit.TCustomEdit.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <procedure name="RealignButtonsContainer">
        <docstr>Realigns the edit buttons container within the edit control.</docstr>
      </procedure>
      <function name="CanObserve">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.</docstr>
      </function>
      <procedure name="ObserverAdded">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.</docstr>
      </procedure>
      <procedure name="ObserverToggle">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.</docstr>
      </procedure>
      <procedure name="SetTextSettings">
        <docstr>Sets a new value for the text settings in the TextSettingsInfo property of the TCustomEditModel.</docstr>
      </procedure>
      <procedure name="SetStyledSettings">
        <docstr>Setter method for the StyledSettings property.</docstr>
      </procedure>
      <function name="StyledSettingsStored">
        <docstr>Indicates whether the set of styled text representation properties stored in StyledSettings differs from the default set for this control.
StyledSettingsStored returns True when the set of styled text representation properties stored in 
StyledSettings differs from the default set of styled text representation properties for this control.</docstr>
      </function>
      <procedure name="SetKeyboardType">
        <docstr>Protected setter implementation for the KeyboardType property.</docstr>
      </procedure>
      <function name="GetKeyboardType">
        <docstr>Protected getter implementation for the KeyboardType property.</docstr>
      </function>
      <procedure name="SetReturnKeyType">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetReturnKeyType">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="InputSupport">
        <docstr>Specifies whether the edit control accepts any sort of input from the user.
If InputSupport is False, no interaction with the control is provided, including editing, selection and focus.</docstr>
      </property>
      <function name="GetItemsCount">
        <docstr>Returns the number of TEditButton objects associated with the edit control.</docstr>
      </function>
      <function name="GetItem">
        <docstr>Returns the edit button with the specified index.
GetItem returns the TEditButton associated with the edit control, at the position specified by AIndex.</docstr>
      </function>
      <procedure name="ButtonsChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="DefineModelClass">
        <docstr>Returns a class reference to a data model of this presented control.
FMX.Edit.TCustomEdit.DefineModelClass inherits from FMX.Controls.Presentation.TPresentedControl.DefineModelClass. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefineModelClass.
Returns a class reference to a data model of this presented control.
Returns a class reference to a data model class that the constructor of this presented control uses to create a data model for the control.
By default DefineModelClass returns TDataModel. Descendant classes reimplement DefineModelClass to determine the data model class that a descendant presented control uses for its data model.

 See Also
FMX.Controls.Model.TDataModelClass
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Presentation.Style.TStyledPresentation.DefineModelClass
Class References</docstr>
      </function>
      <function name="DefinePresentationName">
        <docstr>Returns the name of the default presentation proxy that your presented control uses.
FMX.Edit.TCustomEdit.DefinePresentationName inherits from FMX.Controls.Presentation.TPresentedControl.DefinePresentationName. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefinePresentationName.
Returns the name of the default presentation proxy that your presented control uses.
You can handle OnPresentationNameChoosing to specify a presentation proxy name to use instead of the name that DefinePresentationName returns.
DefinePresentationName  calls TPresentationProxyFactory.GeneratePresentationName and returns a generated  presentation proxy name based on the class name of the presented control and the control type (Styled or Platform) of the presentation layer. For example:



Class name

Control type

Result


TMyPresentedControl

Styled

&quot;MyPresentedControl-Styled&quot;


TMyPresentedControl

Platform

&quot;MyPresentedControl-Platform&quot;

 See Also
System.TObject.ClassName
FMX.Controls.Presentation.TPresentedControl.ControlType
FMX.Presentation.Factory.TPresentationProxyFactory.Register
FMX.Controls.Presentation.TPresentationProxy
FMX.Controls.Presentation.TPresentedControl.OnPresentationNameChoosing
FMX.Controls.Presentation.TPresentedControl.LoadPresentation</docstr>
      </function>
      <property name="Model">
        <docstr>The data model representing the data used by the presentation of the current control.
FMX.Edit.TCustomEdit.Model inherits from FMX.Controls.Presentation.TPresentedControl.Model. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Model.
The data model representing the data used by the presentation of the current control.
The constructor of your presented control creates a data model for your presented control. The class of the data model is the class that DefineModelClass returns.

 See Also
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Presentation
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.DefineModelClass</docstr>
      </property>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.Edit.TCustomEdit.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TPresentedControl.
FMX.Edit.TCustomEdit.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
Destroys this instance of TPresentedControl.

 See Also
FMX.Controls.Presentation.TPresentedControl.Create</docstr>
      </destructor>
      <procedure name="DeleteSelection">
        <docstr>Removes the selected text from the edit control.
Use DeleteSelection to delete the selected text from the edit control. If no text is selected, DeleteSelection does nothing. If all the text is selected, DeleteSelection clears all the text.</docstr>
      </procedure>
      <procedure name="CopyToClipboard">
        <docstr>Copies the selected text in the edit control to the Clipboard, in plain text format.
Use CopyToClipboard to replace the contents of the Clipboard with the selected text. CopyToClipboard does not clear the Clipboard if no text is selected. If no text is selected, CopyToClipboard does nothing.</docstr>
      </procedure>
      <procedure name="CutToClipboard">
        <docstr>Copies the selected text to the Clipboard, in plain text format, and then deletes the selection.
Use CutToClipboard to replace the contents of the Clipboard with the selected text while clearing the selected text. If no text is selected, CutToClipboard does nothing.</docstr>
      </procedure>
      <procedure name="PasteFromClipboard">
        <docstr>Pastes the plain text contents of the Clipboard text into the edit control.
Use PasteFromClipboard to paste the plain text contents held by the Clipboard into the edit control. If the Clipboard does not have a plain text content, PasteFromClipboard does nothing. PasteFromClipboard does not clear the contents of this edit control.</docstr>
      </procedure>
      <procedure name="SelectAll">
        <docstr>Selects all the characters of the displayed Text at once.
Equivalent to the CTRL+A key combination on Windows, or Command+A on OS X.
SelectAll does not change the current CaretPosition.</docstr>
      </procedure>
      <procedure name="SelectWord">
        <docstr>SelectWord assigns to the FMX.Edit.TCustomEdit.SelLength property the length of the first word found if this exists. 
If several words exist in the text, the procedure SelectWord checks if the cursor position is the start position of a word. If not, it searches for the closest word from the left of cursor position.</docstr>
      </procedure>
      <procedure name="ResetSelection">
        <docstr>Resets the selection from an edit box.
ResetSelection sets the CaretPosition property with the start position of the selection and resets the value of the SelLength property to 0. If no text is selected, the ResetSelection property does nothing.</docstr>
      </procedure>
      <procedure name="GoToTextEnd">
        <docstr>Moves the cursor to the end of the text in the edit control.</docstr>
      </procedure>
      <procedure name="GoToTextBegin">
        <docstr>Moves the cursor to the beginning of the text in the edit control.</docstr>
      </procedure>
      <procedure name="Replace">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="HasSelection">
        <docstr>Returns true if any selection exists in the edit box, false otherwise.
Use HasSelection in order to check if any part of the text is selected.</docstr>
      </function>
      <property name="ButtonsContent">
        <docstr>Returns the control that contains the edit buttons associated with the edit control.</docstr>
      </property>
      <property name="Caret">
        <docstr>Represents the caret of the control.
Caret is of type TCaret.</docstr>
      </property>
      <property name="CaretPosition">
        <docstr>Provides access to the caret position in this edit control.
Use CaretPosition to determine the position of the cursor in the edit control.
CaretPosition indicates the horizontal character coordinate of the cursor, indexed from zero.
Modify the value of the CaretPosition property to change the position of the cursor within the edit control. For the cursor to be visible, the edit control must have focus.
For example, if CaretPosition is set to 4, then the cursor is at the fifth character. If the length of text in the edit control is shorter than 5, the cursor moves to the end of the string.</docstr>
      </property>
      <property name="TextContentRect">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="CheckSpelling">
        <docstr>Defines whether the spell-checking feature of the edit control is on or off.
This property enables spell checking on the TEdit component. When set to True a red squiggly line appears underlining the words misspelled.  
The spell checking is performed by an operating system service. It is only supported on iOS and OS X.</docstr>
      </property>
      <property name="DefaultTextSettings">
        <docstr>Stores a TTextSettings type object keeping the default values of the text representation properties.
DefaultTextSettings is initialized in Create with the following values: 

Font.Size := 11 ;          // depends on the platform     
Font.Family = &apos;Tahoma&apos;;    // depends on the platform
Font.Style := [] ;
FontColor := TAlphaColorRec.Black;
TextAlign := TTextAlign.Leading;
VertTextAlign := TTextAlign.Center;

The ApplyStyle method might load from a style the values of the following 
DefaultTextSettings properties: FontColor, Font, 
TextAlign, and VertTextAlign.</docstr>
      </property>
      <property name="Font">
        <docstr>Specifies the font to use when rendering the text.
Set Font to specify the font to use when rendering the text. To change to a new font, specify a new TFont object. To modify a font, change the value of the Family, Size, or Style of the TFont object.</docstr>
      </property>
      <property name="FontColor">
        <docstr>Specifies the color of the text in the edit control.</docstr>
      </property>
      <property name="FilterChar">
        <docstr>Specifies which characters are allowed to be typed into this edit control.
The FilterChar property specifies a string containing individual characters that are allowed to be typed into this edit control.
For instance, if you set FilterChar to &apos;123abc&apos;, then only the a, b, and c letters and the 1, 2, and 3 numerals are allowed to be typed into this edit control. All other characters are ignored. However, note that the uppercase version of a, b, and c are not allowed by this filter string. If you want to add uppercase variants, then FilterChar should be set to &apos;123abcABC&apos;.
To allow for all characters, set FilterChar to an empty string (&apos;&apos;).</docstr>
      </property>
      <property name="ImeMode">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.</docstr>
      </property>
      <property name="KeyboardType">
        <docstr>Determines the type of the virtual keyboard.
Set KeyboardType to determine the type of virtual keyboard this edit is to use. Possible values for the KeyboardType property are Alphabet, Default, EmailAddress, NamePhonePad, and so on (values are selectable in the Object Inspector and are described in FMX.Types.TVirtualKeyboardType). 
Keyboard types are illustrated in the Mobile Tutorial: Using the Web Browser Component (iOS and Android).

Note: On Android, the Alphabet keyboard type has no word completion or word suggestions. The keyboard looks the same as the Default keyboard, but without suggestions.</docstr>
      </property>
      <property name="KillFocusByReturn">
        <docstr>Specifies whether to hide the virtual keyboard by clicking the Return key.
When KillFocusByReturn is True, clicking the Return key hides the virtual keyboard.</docstr>
      </property>
      <property name="MaxLength">
        <docstr>Specifies the maximum length of the text entered in this edit control.
Set the MaxLength property in order to limit the maximum length of the text held by this edit control. For instance, if you want to be able to input strings of maximum 5 characters, set MaxLength to 5.
Note that setting MaxLength to a value lower than the length of the actual display text does not affect the display. It only limits the number of characters while typing.</docstr>
      </property>
      <property name="Password">
        <docstr>Specifies whether this edit control shows its characters or not.
Set the Password property to True to make this edit control hide its characters for password-like input. Set Password to False to make this edit control show all its characters.</docstr>
      </property>
      <property name="ReadOnly">
        <docstr>Determines whether you can change the text of this edit control.
To prevent the contents of the edit control from being edited, set the ReadOnly property to True. Set ReadOnly to False to allow the contents of the edit control to be edited.
Setting ReadOnly to True ensures that the text is not altered, while still allowing you to select text. The selected text can then be manipulated by the application, or copied to the Clipboard.</docstr>
      </property>
      <property name="ReturnKeyType">
        <docstr>Indicates the type of action that the edit control performs when you are editing the text of the control and you press the return key on the virtual keyboard. The run-time platform uses this value to determine the type of return button that it displays on the virtual keyboard for the edit control.
The value of ReturnKeyType does not affect the actual action that the edit control performs when you press the return key. To define that action, use the OnKeyUp event.

Platform Support
This property only has effect on Android and iOS.</docstr>
      </property>
      <property name="ResultingTextSettings">
        <docstr>Keeps final values of text representation properties. These values are really used to draw texts in a control. 
ResultingTextSettings keeps a TTextSettings object that manages the final values of the text representation properties. These values are really used to draw texts in a control. 
To obtain values stored in ResultingTextSettings, a control uses the StyledSettings property. For example, if StyledSettings contains the TStyledSetting.Family value, then the TFont.Family value is taken from the DefaultTextSettings. (That is the font family name defined in the loaded style is used. The font family name defined by the programmer in the Object Editor is ignored.) Oppositely, if StyledSettings does not contain TStyledSetting.Family, then the font family name defined by the programmer in the Object Editor is used and the font family name defined in the loaded style is ignored.
The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
RecalculateTextSettings updates the ResultingTextSettings.</docstr>
      </property>
      <property name="SelectionFill">
        <docstr>Specifies the color and pattern used to fill the font of the selected text or to stroke the outline of it.
Read the SelectionFill property to get a TBrush object with the color and pattern used to fill the font of selected text displayed, or to stroke the outline of it.</docstr>
      </property>
      <property name="SelStart">
        <docstr>Specifies the position of the first selected character in the text.
Read SelStart to determine the position of the first selected character, where 0 indicates the first character. If there is no selected text, SelStart indicates the position of the cursor. Set SelStart to remove the current selection and to position the cursor just before the indicated character.
To select a particular range of the text, first set SelStart to position the cursor, and then set SelLength to extend the selection.</docstr>
      </property>
      <property name="SelLength">
        <docstr>Specifies the number of characters that are selected.
Read SelLength to determine the length, in bytes, of the selected text. This is the same as the number of characters, unless you are using a multibyte character set. Set SelLength to change the selection to consist of the first SelLength bytes starting at SelStart.

Tip: Setting SelLength to a value greater than the number of characters from SelStart to the end of the text results in the selection of all characters from SelStart to the end of the text. Reading SelLength immediately after setting it to a value greater than the number of available characters returns the number of characters actually selected, not the value that was just set.</docstr>
      </property>
      <property name="SelText">
        <docstr>Specifies the selected portion of the edit control&apos;s text.
Read SelText to determine the value of the selected text. Set SelText to replace the selected text with a new string. If there is no selection, but the edit control has focus, set SelText to insert a new string into the text, at the cursor.</docstr>
      </property>
      <property name="StyledSettings">
        <docstr>Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
Text representation properties are used as parameters for drawing texts in controls.
The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
StyledSettings can contain the Family, Size, Style, FontColor, and 
Other values defined in TStyledSetting. The &quot;Relation between TStyledSetting constants and TTextSettings properties&quot; table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):

With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
VertTextAlign properties of the control.</docstr>
      </property>
      <property name="Text">
        <docstr>Contains the text displayed by this edit control.
Use the Text property to read the text of this edit control or to specify a new string to be displayed.</docstr>
      </property>
      <property name="TextAlign">
        <docstr>Specifies how the text will be displayed in terms of horizontal alignment.
The TextAlign property specifies how this edit control  displays the text in terms of horizontal alignment. TextAlign can have one of the following, defined in TTextAlign, values:

Center (default) aligns the text at the middle of the edit control.
Leading aligns the text at the leftmost position inside the edit control.
Trailing aligns the text at the rightmost position inside the edit control.
When you use text representation properties stored in ITextSettings.TextSettings, remember that TextAlign corresponds to HorzAlign.</docstr>
      </property>
      <property name="TextSettings">
        <docstr>Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
TTextSettings type objects provide all styled text representation properties and methods to manage them.
The styled text representation properties are 
FontColor, TextAlign,
VertTextAlign,
Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
VertTextAlign properties of the control.</docstr>
      </property>
      <property name="TextPrompt">
        <docstr>A hint or message to be displayed when the Text property is empty.
Use TextPrompt to cue the user about the kind of entry that is expected in the text field. The TextPrompt is grayed (like a watermark), cannot be scrolled at run time, and is cleared from the entry field as soon as the user begins to type into the edit field.
The following image contains a design-time preview of setting the TextPrompt property:</docstr>
      </property>
      <property name="Typing">
        <docstr>Specifies whether the user is typing something in this edit control.
The Typing property is True if the user is typing something into this edit control, False otherwise.
When any printable character is typed, the Typing property is set to True. A printable character is any character that is not a control character.
When the ENTER key is pressed, the Typing property is set to False.</docstr>
      </property>
      <property name="VertTextAlign">
        <docstr>Specifies how the text will be displayed in terms of vertical alignment.
The VertTextAlign property specifies how the TCustomEdit control displays the text in terms of vertical alignment. VertTextAlign can have one of the following values (defined in TTextAlign):

Center (default)--aligns the text on a vertical axis, at the middle of the TCustomEdit object.
Leading--aligns the text on a vertical axis, at the topmost position inside the TCustomEdit object.
Trailing--aligns the text on a vertical axis, at the bottommost position inside the TCustomEdit object.
When you use text representation properties stored in ITextSettings.TextSettings, remember that VertTextAlign corresponds to VertAlign.</docstr>
      </property>
      <property name="CharCase">
        <docstr>It defines whether to implement the UPPER or lower case conversion to the memo&apos;s text.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs when the text for the edit control may have changed.
Write an OnChange event handler to take specific action whenever the text for the edit control may have changed. The Text property of the edit control will already have been updated to reflect any changes.

Tip: OnChange does not occur after individual characters have been typed, but only after the user presses the ENTER key or the focus leaves the control. An event that responds to individual character changes is OnChangeTracking.</docstr>
      </event>
      <event name="OnChangeTracking">
        <docstr>Occurs when typing individual characters into the edit control.
Write an OnChangeTracking event handler to take specific action whenever you set the text for the edit control or type individual characters in it. The Text property of the edit control will already have been updated to reflect any changes. This event provides the first opportunity to respond to modifications the user brought to the text of the edit control.

Tip: There is also an OnChange event that does not occur after individual characters have been typed, but only after the user presses the ENTER key or the focus leaves the control. For responding to individual character changes, use only the OnChangeTracking event.</docstr>
      </event>
      <event name="OnTyping">
        <docstr>Occurs when you are typing into this edit control.
Write an OnTyping event handler to take specific action whenever you type into this edit control. While you type in characters, the Typing property is also set to True.</docstr>
      </event>
      <event name="OnValidating">
        <docstr>Occurs when you are entering symbols or when focus shifts away from this edit control.
Write an OnValidating event handler to immediately validate any edits while the user is entering information into the edit control. The OnValidating event handler can verify the supplied text and, if it is not acceptable, return an error or warning message.

Example
To clarify, consider the following scenario: an application provides a text edit box designed to enter an email address. If the user enters the blank  character or the &quot;@.&quot; substring, the OnValidating event handler displays the exclamation icon next to the edit control. This icon informs the user that the current symbols are not acceptable for the email address.


Note:  Initially, the exclamation icon is invisible. The OnValidating event handler sets the TImage.Visible property to True, if an input error occurs.



For this scenario, you can implement the following OnValidating event handlers:


Delphi:

procedure TForm1.Edit1Validating(Sender: TObject; var Text: string);
begin
  Image1.Visible := Text.Contains(&apos; &apos;) or Text.Contains(&apos;@.&apos;);
end;



C++Builder: 

void __fastcall TForm1::Edit1Validating(TObject *Sender, UnicodeString &amp;Text) {
	Image1-&gt;Visible = ContainsStr(Text, &quot; &quot;) || ContainsStr(Text, &quot;@.&quot;);
}



Note:  To process the user&apos;s input, these code snippets use: 

For C++Builder: the System.StrUtils.ContainsStr routine.
For Delphi: the System.SysUtils.TStringHelper.Contains methode.</docstr>
      </event>
      <event name="OnValidate">
        <docstr>Occurs after the user presses the ENTER key or the focus leaves the control. 

Write an OnValidate event handler to validate any edits the user enters in the edit control before the text has changed. 
The OnValidate event handler can verify the supplied text and, if it is not acceptable, return an error or warning message.

Code Snippets
To clarify, consider the following scenario: an application provides a text edit box designed to enter a user email address from the mycompany.com domain, such as John.Doe@mycompany.com. If the user enters a text that does not end with the &quot;mydomain.com&quot; substring, the application displays an error message in the edit control.
In this scenario, you can implement the following OnValidate event handlers:


Delphi:

procedure TForm1.Edit1Validate(Sender: TObject; var Text: string);
begin
  if not EndsText(&apos;mycompany.com&apos;, Text) then
      Text := &apos;Invalid email!&apos;
end;



C++Builder: 

void __fastcall TForm1::Edit1Validate(TObject *Sender, UnicodeString &amp;Text)
{
	if (!EndsText(&quot;mycompany.com&quot;, Text))  {     Text = &quot;Invalid email!&quot;;

	}
}



Note:  These code snippets use the System.StrUtils.EndsText routine.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Edit" name="TEdit">
    <docstr>General-purpose FireMonkey edit box.
TEdit extends the functionality of TCustomEdit by publishing a set of properties to the Object Inspector so you can customize the look and feel of this edit box.
For using TEdit in a Metro application, see 
Creating Metropolis UI Edit Buttons with Embedded Glyphs.
When not in focus, TEdit does not draw a selection rectangle even though the user has selected the text. You can verify whether the text is selected by using the SelText property.

Note: For a multiline edit control, use FMX.Memo.TMemo.</docstr>
    <members>
      <property name="MaxLength">
        <docstr>Maxmimum length of text that can be input in the edit field.</docstr>
      </property>
      <property name="FilterChar">
        <docstr>Defines characters which can be input in the edit field. All characters not in FilterChar will be
          ignored. Empty FilterChar value means no filtering.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Styles" name="TStyleDescription">
    <docstr></docstr>
    <members>
      <field name="Properties">
        <docstr>List of published properties used in streaming</docstr>
      </field>
      <field name="PlatformTargets">
        <docstr>Target&apos;s names that used in style file</docstr>
      </field>
      <field name="PlatformNames">
        <docstr>Platform&apos;s names that used at framework</docstr>
      </field>
      <function name="SupportsPlatform">
        <docstr>Allows to check style for fitting for specified Platform</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.Styles" name="TStyleStreaming">
    <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
    <members>
      <function name="DefaultIsSupportedPlatformTarget">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SaveToStream">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="TryLoadStyleDescription">
        <docstr>This method tries to parse the style file and read the style description.
The TStyleDescription object specified by Description should be destroyed by the caller.</docstr>
      </function>
      <function name="LoadFromFile">
        <docstr>Loads a style from the specified file.
LoadFromFile returns a style object that can be set as the active style using the SetStyle method.
Note that LoadFromFile does not automatically switch to the loaded style. To do that, call the SetStyleFromFile method.</docstr>
      </function>
      <function name="LoadFromStream">
        <docstr>Loads a style from the specified stream.
LoadFromStream returns a style object that can be set as the active style using the SetStyle method.
Note that LoadFromStream does not automatically switch to the loaded style. To do that, call the SetStyleFromFile method.</docstr>
      </function>
      <function name="LoadFromResource">
        <docstr>Loads a style from the specified resource.
LoadFromResource returns a style object that can be set as the active style using the SetStyle method.
Note that LoadFromResource does not automatically switch to the loaded style. To do that, call the SetStyleFromFile method. 



Parameter

Meaning


Instance

The instance handle of the loaded resource.


ResourceName

The string associated with the resource.


ResourceType

A string that identifies the type of resource.</docstr>
      </function>
      <function name="CanLoadFromFile">
        <docstr>Loads a style from the specified file without raising an exception.
CanLoadFromFile searches for the style specified by FileName.
CanLoadFromFile returns True if the style is successfully loaded, and False otherwise.</docstr>
      </function>
      <function name="CanLoadFromStream">
        <docstr>Loads a style from the specified stream without raising an exception.
CanLoadFromStream searches for the style specified by AStream.
CanLoadFromStream returns True if the style is successfully loaded, and False otherwise.</docstr>
      </function>
      <function name="CanLoadFromResource">
        <docstr>Loads a style from the specified resource without raising an exception.
In the first signature CanLoadFromResource searches for the specified ResourceName with type ResourceType in the instace handle indicated by Instance.
In the second signature CanLoadFromResource internally calls EnumModules in order to search for ResourceName in all modules of the application. 
CanLoadFromResource returns True if the style is successfully loaded, and False otherwise.</docstr>
      </function>
      <function name="CanLoadFromResource">
        <docstr>Loads a style from the specified resource without raising an exception.
In the first signature CanLoadFromResource searches for the specified ResourceName with type ResourceType in the instace handle indicated by Instance.
In the second signature CanLoadFromResource internally calls EnumModules in order to search for ResourceName in all modules of the application. 
CanLoadFromResource returns True if the style is successfully loaded, and False otherwise.</docstr>
      </function>
      <function name="SameStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetDefaultContainerClass">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetSupportedPlatformHook">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Styles" name="TStyleManager">
    <docstr>TStyleManager handles styles-related operations.
Use TStyleManager to:

Set and retrieve the active style.
Load styles from files or streams.</docstr>
    <members>
      <procedure name="RemoveStyleFromGlobalPool">
        <docstr>Removes the specified Style from the pool of styles.</docstr>
      </procedure>
      <procedure name="UpdateScenes">
        <docstr>Updates the style for all the registered scenes.</docstr>
      </procedure>
      <procedure name="EnumStyleResources">
        <docstr>Enumetates all the registered style resource objects.</docstr>
      </procedure>
      <function name="GetStyleResource">
        <docstr>Gets the style resource object.
GetStyleResource returns the style resource if it exits in cache. Otherwise it loads the style resource.
ResourceName specifies the style resource as per name.</docstr>
      </function>
      <procedure name="RegisterPlatformStyleResource">
        <docstr>Registers the style resource for the specified platform.

ResourceName specifies the resource style.
APlatform specifies the target platform.</docstr>
      </procedure>
      <procedure name="RegisterPlatformStyleSelection">
        <docstr>Registers the style resource specified by selection.

APlatform specifies the target platform.
ASelection specifies the style selection with type TPlatformStyleSelectionProc.</docstr>
      </procedure>
      <function name="ActiveStyle">
        <docstr>Returns the style that is currently set.</docstr>
      </function>
      <function name="ActiveStyleForScene">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetStyle">
        <docstr>Sets the active style to the instance specified by the Style parameter.
To set the active style to the native system style, for example Windows theme, pass nil as the Style parameter.

Note: If you call the SetStyle function in the initialization section of a unit on the main project file, before Application.Initialize, then it is applied to all forms.</docstr>
      </procedure>
      <procedure name="SetStyle">
        <docstr>Sets the active style to the instance specified by the Style parameter.
To set the active style to the native system style, for example Windows theme, pass nil as the Style parameter.

Note: If you call the SetStyle function in the initialization section of a unit on the main project file, before Application.Initialize, then it is applied to all forms.</docstr>
      </procedure>
      <function name="SetStyleFromFile">
        <docstr>Sets the style specified by FileName as the active style.
Do not place multiple lines calling SetStyleFromFile in a project, because you can have only one active style in the style manager.
You can call SetStyleFromFile either in the project source code (before calling Application.Initialize) or in the initialization section of one of the form units:

If you call SetStyleFromFile in a form, the style is reapplied.
If you call SetStyleFromFile before the form is created, the custom style fully replaces the platform style.
Example
This Delphi code demonstrates how to use the StyleManager:


Delphi:

procedure TForm1.FormCreate(Sender: TObject);
  var
    od : TOpenDialog;
  begin
    od := nil;
    try
    od := TOpenDialog.Create(self);
    od.Filter := &apos;Style Files|*.style&apos;;
    if od.Execute() then
      TStyleManager.SetStyleFromFile(od.FileName);
  finally
    od.Free();
  end;
end;</docstr>
      </function>
      <function name="SetStyleFromFile">
        <docstr>Sets the style specified by FileName as the active style.
Do not place multiple lines calling SetStyleFromFile in a project, because you can have only one active style in the style manager.
You can call SetStyleFromFile either in the project source code (before calling Application.Initialize) or in the initialization section of one of the form units:

If you call SetStyleFromFile in a form, the style is reapplied.
If you call SetStyleFromFile before the form is created, the custom style fully replaces the platform style.
Example
This Delphi code demonstrates how to use the StyleManager:


Delphi:

procedure TForm1.FormCreate(Sender: TObject);
  var
    od : TOpenDialog;
  begin
    od := nil;
    try
    od := TOpenDialog.Create(self);
    od.Filter := &apos;Style Files|*.style&apos;;
    if od.Execute() then
      TStyleManager.SetStyleFromFile(od.FileName);
  finally
    od.Free();
  end;
end;</docstr>
      </function>
      <function name="TrySetStyleFromResource">
        <docstr>Loads the style from ResourceName and sets the style as the active style.
TrySetStyleFromResource sets the style without raising exceptions.</docstr>
      </function>
      <procedure name="UnInitialize">
        <docstr>Uninitializes data about styles.

Note: This function is reserved for internal use only. Do not call it directly.</docstr>
      </procedure>
      <function name="FindStyleDescriptor">
        <docstr>Returns the style description of the specified style.
FindStyleDescriptor returns the TStyleDescription object associated with the style specified by AObject, if such a description is set.
You can set the style description fields using the Tools &gt; Bitmap Style Designer dialog.</docstr>
      </function>
      <function name="GetStyleDescriptionForControl">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.Objects" name="TShape">
    <docstr>The base class for 2D graphic primitives--TLines, TRectangles, TPaths, and others. All these primitives inherit TControl and can be used in styles to construct controls. 
TShape is the ancestor class to most other classes defined in the Objects unit. It defines the common behavior--methods and properties--for 2D graphic primitives. TShape objects cannot be used as stand-alone 2D components.</docstr>
    <members>
      <procedure name="Painting">
        <docstr>Calls the inherited Painting method, which calls the event handler of the OnPainting event. Then Painting initializes the fill and stroke properties of the current canvas.
Painting initializes the Fill and Stroke properties of the current canvas with values defined for the proper properties of the shape object.</docstr>
      </procedure>
      <procedure name="FillChanged">
        <docstr>Forces the shape to repaint its image on the screen.
FillChanged is the event handler of the FMX.Graphics.TBrush.OnChanged event of the Fill property.</docstr>
      </procedure>
      <procedure name="StrokeChanged">
        <docstr>Forces the shape to repaint its image on the screen.
StrokeChanged is the event handler of the FMX.Graphics.TBrush.OnChanged event of the Stroke property.</docstr>
      </procedure>
      <function name="GetShapeRect">
        <docstr>Retrieves the ShapeRect rectangle for drawing the shape.</docstr>
      </function>
      <function name="DoGetUpdateRect">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates an instance of TShape with the specified component as owner.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the object instance and frees its memory.
Do not call Destroy directly in an application. Call Free instead. Free verifies that the object instance is not nil before calling Destroy.</docstr>
      </destructor>
      <property name="Fill">
        <docstr>Determines the color and pattern used to fill the shape background.
The value of Fill is an FMX.Graphics.TBrush object. It can define the gradient, brush pattern, brush color, opacity, and other parameters to fill the shape background.</docstr>
      </property>
      <property name="Stroke">
        <docstr>Determines the color and pattern of the drawing pen used to draw lines and shape contours of the graphical primitives.
The value of Stroke is an FMX.Graphics.TStrokeBrush object. To customize the outline pen, change the Thickness, Cap, Dash, and Join properties of the TStrokeBrush object.</docstr>
      </property>
      <property name="ShapeRect">
        <docstr>Specifies the rectangle for drawing the shape.
The coordinates of the upper-left corner of the rectangle are (0,0), and the coordinates of the lower-right corner are (Width, Height).</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Objects" name="TLine">
    <docstr>TLine defines 2D lines. It inherits TControl and can be used in styles to construct controls.
The end points of the line to draw are defined by the following properties of the TLine object:

The shape rectangle and the LineType define the straight-line segment to draw:
LineType defines the orientation of the line segment.
The intersection points of this line segment with the local rectangle define the end points of the straight-line segment.
RotationCenter defines the rotation axis and RotationAngle defines the rotation angle on which the straight-line segment is rotated to obtain the line to draw.
Note: Scaling not only scales the line length proportionally to scaling the factors. It also changes the thickness of the stroke that draws the line. That change is proportional to the scaling factor for each axis.
The parent TControl draws TLine with the Paint method. 
To draw TLine, the Paint method uses the drawing pen with the Stroke property defined for the TLine object.</docstr>
    <members>
      <function name="DoGetUpdateRect">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="IsControlRectEmpty">
        <docstr>Returns True if the control rect is empty.
FMX.Objects.TLine.IsControlRectEmpty inherits from FMX.Controls.TControl.IsControlRectEmpty. All content below this line refers to FMX.Controls.TControl.IsControlRectEmpty.
Returns True if the control rect is empty.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates an instance of TShape with the specified component as owner.
FMX.Objects.TLine.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
Creates an instance of TShape with the specified component as owner.</docstr>
      </constructor>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TLine.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <property name="LineLocation">
        <docstr>Specifes the way a line is drawn.
The available values are:

Boundary: Default. If you increase the thickness of a Boundary line, the line grows inside and outside of the control symmetrically. The central point of the growth depends on the TLineType. If TLineType is Diagonal, the line goes from the top-left corner to the bottom-right corner. If the thickness of the line is greater than the size of the control, a Boundary line may grow beyond the control.
Inner: If you increase the thickness of an Inner line, the line grows inside the control. If the thickness of the line is greater than the size of the control, an Inner line may grow beyond the control.
InnerWithin: If you increase the thickness of an InnerWithin line, the line grows inside the control. The thickness of an InnerWithin line is limited by the size of the control (it never grows beyond the control).</docstr>
      </property>
      <property name="LineType">
        <docstr>Specifies how to place the line inside the shape rectangle.
The LineType value should be one of the constants defined in the TLineType type: Diagonal, Top, or Left.
The default is Diagonal.
The TLineType type defines the following constants:



Constant

Meaning



Diagonal



 Draw the line as the diagonal of the shape rectangle.




Top



 Draw the line as the top side (width) of the shape rectangle.




Bottom



 Draw the line as the bottom side (width) of the shape rectangle.




Left



 Draw the line as the left side (height) of the shape rectangle.




Right



 Draw the line as the right side (height) of the shape rectangle.</docstr>
      </property>
      <property name="ShortenLine">
        <docstr>Indicates whether to shorten the line.
If True, the width of the line is reduced symmetrically by half of the thickness, while the value of Width stays the same.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Objects" name="TRectangle">
    <docstr>TRectangle defines 2D rectangles with customized corners. It inherits TControl and can be used in styles to construct controls.
The CornerType, XRadius, and YRadius properties define how to customize shapes of rectangle corners:


Corners specifies which corners to be customized.
Notice that, if Corners is an empty set or any of the XRadius or YRadius properties is zero, then no corner shape customization is used.
The rectangle size and position are defined by the following properties of the TRectangle object:

The shape rectangle ShapeRect defines the initial size and position of the rectangle.
You can use the rotation axis RotationCenter and rotation angle RotationAngle of the TRectangle object to rotate and move the rectangle.
You can use the scaling factors of the TRectangle object to proportionally scale rectangle coordinates along local coordinate axes. Scaling moves the rectangle and changes its size.
Note: Scaling not only scales the shape of an object proportionally to the scaling factors. It also changes the thickness of the stroke that draws the contour proportionally to the scaling factor for each axis.
TRectangle draws the contour and fills the background with the Paint method. Paint uses the drawing pen and brush with the properties, color, and opacity defined by the Stroke and Fill properties.</docstr>
    <members>
      <procedure name="SetXRadius">
        <docstr>Setter for the XRadius property.</docstr>
      </procedure>
      <procedure name="SetYRadius">
        <docstr>Setter for the YRadius property.</docstr>
      </procedure>
      <procedure name="SetCorners">
        <docstr>Setter for the Corners property.
Value is a set of constants defined in TCorner: TopLeft, TopRight, BottomLeft, and BottomRight.</docstr>
      </procedure>
      <procedure name="SetCornerType">
        <docstr>Setter for the CornerType property.
Value should be one of the constants defined in TCornerType: Round, Bevel, InnerRound, and InnerLine.</docstr>
      </procedure>
      <procedure name="SetSides">
        <docstr>Setter for the Sides property.
Value is a set of constants defined in TSide: Top, Left, Bottom, and Right.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TRectangle.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TShape with the specified component as owner.
FMX.Objects.TRectangle.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
Creates an instance of TShape with the specified component as owner.</docstr>
      </constructor>
      <property name="Corners">
        <docstr>Specifies shapes of which corners in the TRectangle rectangle object are customized according to the CornerType, XRadius, and YRadius properties.
By default, all four corners are customized. 
Corners can contain a set of constants defined in the TCorner type: TopLeft, TopRight, BottomLeft, and BottomRight. Use the AllCorners constant to select all corners. 
If Corners is an empty set or any of the XRadius and YRadius properties is zero, then no corner shape customization is used.</docstr>
      </property>
      <property name="CornerType">
        <docstr>Specifies the type of the corner shape&apos;s customization in the rectangle.
Values of CornerType are defined in TCornerType. These Round, Bevel, InnerRound, and InnerLine values define the following types of corner shape customizations: 


CornerType applies to corners specified in the Corners set.
XRadius and YRadius specify the distance from a corner to the start point of the corner shape customization, on the horizontal and vertical sides. 

Note: If Corners is an empty set or any of the XRadius and YRadius properties is zero, then no corner shape customization is used.</docstr>
      </property>
      <property name="Sides">
        <docstr>Specifies which sides of the TRectangle rectangle to display.
A side is a rectangle boundary between two adjacent corners or end points of corner customizations. End points of corner customizations are defined by XRadius and YRadius. A corner customization applies to corners included into the Corners set.
By default, all sides of the rectangle are displayed.
Sides can contain a set of constants defined in TSide: Top, Left, Bottom, and Right. 
Use the AllSides constant to select all sides.
If Sides is empty, then no side is displayed.</docstr>
      </property>
      <property name="XRadius">
        <docstr>Specifies the distance from a corner to the start point of the corner shape customization, on the horizontal sides of TRectangle.
During design time, the maximum possible value of XRadius is limited by the half of the smallest side.
If XRadius=0, then no corner shape customization is used.</docstr>
      </property>
      <property name="YRadius">
        <docstr>Specifies the distance from a corner to the start point of the corner shape customization, on the vertical sides of TRectangle.
During design time, the maximum possible value of YRadius is limited by the half of the smallest side.
If YRadius=0, then no corner shape customization is used.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Objects" name="TCaretRectangle">
    <docstr>TCaretRectangle is a TRectangle descendant that can additionally hold caret (cursor) information.</docstr>
    <members>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Objects.TCaretRectangle.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <function name="DefaultWidth">
        <docstr>Represents the default width for the caret of this TCaretRectangle.</docstr>
      </function>
      <function name="DefaultColor">
        <docstr>Represents the default color of the caret.
Use DefaultColor to retrieve the default color for the caret of this TCaretRectangle.</docstr>
      </function>
      <function name="UseFontColor">
        <docstr>Specifies whether the caret color of this TCaretRectangle is specified.
This information is retrieved from the system information.</docstr>
      </function>
      <function name="DefaultInterval">
        <docstr>Represents the default interval of time, in milliseconds, at which the caret flashes.
The default interval of time is 500 milliseconds.</docstr>
      </function>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.Objects.TCaretRectangle.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates an instance of TShape with the specified component as owner.
FMX.Objects.TCaretRectangle.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
Creates an instance of TShape with the specified component as owner.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the object instance and frees its memory.
FMX.Objects.TCaretRectangle.Destroy inherits from FMX.Objects.TShape.Destroy. All content below this line refers to FMX.Objects.TShape.Destroy.
Destroys the object instance and frees its memory.
Do not call Destroy directly in an application. Call Free instead. Free verifies that the object instance is not nil before calling Destroy.</docstr>
      </destructor>
      <procedure name="UpdateState">
        <docstr>Updates the state of this TCaretRectangle.</docstr>
      </procedure>
      <property name="Caret">
        <docstr>Caret is a TCustomCaret that describes the caret of this TCaretRectangle.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Objects" name="TRoundRect">
    <docstr>TRoundRect defines 2D rectangles with rounded corners. It inherits TControl and can be used in styles to construct controls.
The rectangle size and position are defined by the bounding rectangle of the TRoundRect object. You can use the scaling factors Scale of the TRoundRect object to proportionally change rectangle coordinates along local coordinate axes. This will move the rectangle and change its shape. The rotation axis RotationCenter and rotation angle RotationAngle of the TRoundRect object can be used to rotate the rectangle.

Note: Scaling not only scales the shape of an object proportionally to the scaling factors. It also changes the thickness of the stroke that draws the contour proportionally to the scaling factor for each axis.
The Corners property defines which rectangle corners are to be rounded. The Radius of the rounding is defined by the following formula:

Radius := Min(RectHeight(GetShapeRect),RectWidth(GetShapeRect)) / 2;  

TRoundRect draws the contour and fills the shape background with the Paint method. 
Paint draws the contour and fills the background using the drawing pen and brush with the properties, color, and opacity defined by the Stroke and Fill properties of the TRoundRect object.</docstr>
    <members>
      <procedure name="SetCorners">
        <docstr>Setter for the Corners property.
Value is a set of constants defined in TCorner: TopLeft, TopRight, BottomLeft, and BottomRight.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TRoundRect.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TShape with the specified component as owner.
FMX.Objects.TRoundRect.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
Creates an instance of TShape with the specified component as owner.</docstr>
      </constructor>
      <property name="Corners">
        <docstr>Specifies which corners in the TRoundRect object are to be rounded.
The rounding radius is equal to the half of the smallest side.
By default, all four corners are rounded.
Corners is a set of TCorner values that specify which of the corners are rounded. 
If Corners is an empty set, then no corner is rounded. 
Use the AllCorners constant to select all corners.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Objects" name="TCalloutRectangle">
    <docstr>A rectangle with a triangular &quot;peak&quot; on one of four sides, used primarily to render a TCalloutPanel.
Because TCalloutRectangle inherits from TRectangle, TCalloutRectangle provides all the properties (Corners, CornerType, Sides, XRadius, YRadius, and others) and methods to define the shape of the rectangle itself.  
A call-out often takes the form of a pull-quote, in which a particular snippet of text in a document is duplicated to attract attention: in a larger size, with a different typeface, in a colored box, with stylized quote marks, and so on. With illustrations, boxed text will refer to different elements of interest, and each box will be drawn with extra lines that point to its element.
TCalloutRectangle is a rectangle with an isosceles triangle on one of its four sides, used to point at something else. The triangle is included in the bounding rectangle of the object: the longer its length, the shorter the rectangle shape will be, and vice versa. Keeping the rectangle the same size while changing the length of the triangle requires changing the height or width of the object, depending on which side the triangle appears.</docstr>
    <members>
      <procedure name="RebuildPaths">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetXRadius">
        <docstr>Setter for the XRadius property.
FMX.Objects.TCalloutRectangle.SetXRadius inherits from FMX.Objects.TRectangle.SetXRadius. All content below this line refers to FMX.Objects.TRectangle.SetXRadius.
Setter for the XRadius property.</docstr>
      </procedure>
      <procedure name="SetYRadius">
        <docstr>Setter for the YRadius property.
FMX.Objects.TCalloutRectangle.SetYRadius inherits from FMX.Objects.TRectangle.SetYRadius. All content below this line refers to FMX.Objects.TRectangle.SetYRadius.
Setter for the YRadius property.</docstr>
      </procedure>
      <procedure name="SetCorners">
        <docstr>Setter for the Corners property.
FMX.Objects.TCalloutRectangle.SetCorners inherits from FMX.Objects.TRectangle.SetCorners. All content below this line refers to FMX.Objects.TRectangle.SetCorners.
Setter for the Corners property.
Value is a set of constants defined in TCorner: TopLeft, TopRight, BottomLeft, and BottomRight.</docstr>
      </procedure>
      <procedure name="SetCornerType">
        <docstr>Setter for the CornerType property.
FMX.Objects.TCalloutRectangle.SetCornerType inherits from FMX.Objects.TRectangle.SetCornerType. All content below this line refers to FMX.Objects.TRectangle.SetCornerType.
Setter for the CornerType property.
Value should be one of the constants defined in TCornerType: Round, Bevel, InnerRound, and InnerLine.</docstr>
      </procedure>
      <procedure name="SetSides">
        <docstr>Setter for the Sides property.
FMX.Objects.TCalloutRectangle.SetSides inherits from FMX.Objects.TRectangle.SetSides. All content below this line refers to FMX.Objects.TRectangle.SetSides.
Setter for the Sides property.
Value is a set of constants defined in TSide: Top, Left, Bottom, and Right.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.Objects.TCalloutRectangle.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.Objects.TCalloutRectangle.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <function name="GetCalloutRectangleRect">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="AddCalloutToPath">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AddRoundCornerToPath">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AddRectCornerToPath">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="CreatePath">
        <docstr>Generates the contour of TCalloutRectangle.
CreatePath uses parameters of the current TCalloutRectangle object to generate a series of connected curves and lines (in the FMX.Graphics.TPathData type) that form the TCalloutRectangle contour to draw.</docstr>
      </procedure>
      <procedure name="CreateFillPath">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TCalloutRectangle.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TShape with the specified component as owner.
FMX.Objects.TCalloutRectangle.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
Creates an instance of TShape with the specified component as owner.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the object instance and frees its memory.
FMX.Objects.TCalloutRectangle.Destroy inherits from FMX.Objects.TShape.Destroy. All content below this line refers to FMX.Objects.TShape.Destroy.
Destroys the object instance and frees its memory.
Do not call Destroy directly in an application. Call Free instead. Free verifies that the object instance is not nil before calling Destroy.</docstr>
      </destructor>
      <property name="CalloutWidth">
        <docstr>The width of the callout pointer.
TCalloutRectangle renders its callout pointer as an isosceles triangle on one of its sides. 
CalloutWidth is the length of the base of the triangle.</docstr>
      </property>
      <property name="CalloutLength">
        <docstr>The length of the callout pointer.
TCalloutRectangle renders the callout pointer as an isosceles triangle on one of its sides. CalloutLength is the height of this triangle. The triangle is included in the bounding rectangle ShapeRect of the TCalloutRectangle object; therefore, the longer CalloutLength is, the smaller the height (or width) of the callout rectangle itself is, and vice versa. Keeping the bounding rectangle the same size while changing the length of the triangle CalloutLength requires changing the height or width of the callout rectangle TCalloutRectangle itself, depending on which side the triangle appears.</docstr>
      </property>
      <property name="CalloutPosition">
        <docstr>Specifies the side of the rectangle where the callout pointer appears.
TCalloutRectangle renders its callout pointer as an isosceles triangle on one of its four sides.
Set CalloutPosition to one of the Top, Left, Bottom, or Right constants predefined in TCalloutPosition to define the side on which the callout pointer should appear.
By default, the callout pointer appears on the top side CalloutPosition = Top.</docstr>
      </property>
      <property name="CalloutOffset">
        <docstr>The position of the callout pointer, relative to the center or edges of the side on which it appears.
TCalloutRectangle renders the callout pointer as an isosceles triangle on one of its sides. The CalloutPosition defines the side on which the triangle appears.
CalloutOffset is the triangle offset implemented according to the following conditions:

If CalloutOffset is zero, then the triangle is centered on the specified side.
If CalloutOffset is positive, then the closest point of the callout pointer to a corner of the triangle has the CalloutOffset offset on the following sides:
Top--offset to the right from the upper-left corner.
Left--offset to the bottom from the upper-left corner.
Right--offset to the bottom from the upper-right corner.
Bottom--offset to the right from the lower-left corner.
If CalloutOffset is negative, then the closest point of the callout pointer to a corner of the triangle has the CalloutOffset offset on the following sides:
Top--offset to the left from the upper-right corner.
Left--offset to the top from the lower-left corner.
Right--offset to the top from the lower-right corner.
Bottom--offset to the left from the lower-right corner.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Objects" name="TEllipse">
    <docstr>TEllipse defines 2D ellipses. It inherits TControl and can be used in styles to construct controls.
The following TEllipse properties define the ellipse shape and position:

Initially the ellipse is inscribed into the bounding rectangle ShapeRect of the TEllipse object.
Then the rotation axis RotationCenter is moved along the local coordinate axes proportionally to the Scale factors.
Then this ellipse is rotated around the obtained pivot on the RotationAngle angle.
Note: Scaling not only scales the shape of an object proportionally to the scaling factors. It also changes the thickness of the stroke that draws the contour proportionally to the scaling factor for each axis.
TEllipse draws the contour and fills the background with the Paint method. 
Paint draws the contour and fills the background using the drawing pen and brush with the properties, color, and opacity defined by the Stroke and Fill properties of the TEllipse object.</docstr>
    <members>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TEllipse.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <function name="PointInObjectLocal">
        <docstr>Checks whether the point specified by local coordinates belongs to the control area.
FMX.Objects.TEllipse.PointInObjectLocal inherits from FMX.Controls.TControl.PointInObjectLocal. All content below this line refers to FMX.Controls.TControl.PointInObjectLocal.
Checks whether the point specified by local coordinates belongs to the control area.
PointInObjectLocal returns True if the specified point belongs to the control area, and False otherwise. 
The X and Y are the local coordinates of the point to be checked (compare with PointInObject):

X is the X coordinate.
Y is the Y coordinate.
The local coordinates of the upper-left corner of the control rectangle are (0,0), and the local coordinates of the lower-right corner are (Width, Height). 
The points of the control boundary specified by BoundsRect belong to the control and PointInObjectLocal returns True for them.
If a control supports the Touch property, the control area can be optionally inflated on the values specified by the TouchTargetExpansion property. TouchTargetExpansion keeps four optional parameters representing the expansion for the four sides of the control in pixels (Bottom, Left, Right, and Top). 
The dclasses can change the &apos;control area&apos; definition. For example:

The FMX.Objects.TSelection class extends the &apos;control area&apos; definition relative to BoundsRect. FMX.Objects.TSelection.PointInObjectLocal also returns True if the point belongs to any of small rectangles of the four grip controls used to manage the selection shape. The rectangles of the grip controls are rectangles surrounding the four corners of the TSelection rectangle. The Width and Height of these rectangles are equal to 2 * GripSize. For example, the grip control&apos;s rectangle of the upper-right corner UR_Corner of TSelection is defined by the following corners:
(UR_Corner.Top - GripSize, UR_Corner.Right - GripSize)--upper-left corner of the grip.
(UR_Corner.Top + GripSize, UR_Corner.Right + GripSize)--lower-right corner of the grip.
FMX.Objects.TSelectionPoint.PointInObjectLocal returns True if the specified point belongs to the rectangle of the grip control corresponding to the TSelectionPoint object, and False otherwise.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.Objects" name="TCircle">
    <docstr>TCircle defines 2D circles. It inherits TControl and can be used in styles to construct controls.
The following TCircle properties define the circle size and position:

The bounding rectangle ShapeRect of TCircle defines the bounding square for the circle:
The length of the bounding square sides equals to Min(Width, Height) of the ShapeRect bounding rectangle.
The bounding square center coincides with the center of the bounding rectangle.
The TCircle shape is inscribed into the obtained bounding square.
You can use the Scale scaling factors of the TCircle object to proportionally scale circle coordinates along local coordinate axes. Scaling moves the circle and changes its size.
You can use the rotation axis RotationCenter and rotation angle RotationAngle of the TCircle object to modify the circle shape and position.
TCircle draws the contour and fills the shape background with the Paint method. 
Paint draws the contour and fills the background using the drawing pen and brush with the properties, color, and opacity defined by the Stroke and Fill properties of the TCircle object.</docstr>
    <members>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TCircle.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Objects" name="TPie">
    <docstr>TPie defines 2D pies. 
TPie is drawn as part of TEllipse. It inherits TControl and can be used in styles to construct controls.
The TPie object is the part of the TEllipse object enclosed between radiuses with the StartAngle and EndAngle angles.
The ShapeRect bounding rectangle, scaling factors specified by Scale, RotationCenter rotation axis, and RotationAngle rotation angle of the TEllipse object should be used to define the general size, shape, and position of TPie.
TPie draws the contour and fills the shape background with the Paint method. 
Paint draws the contour using the drawing pen with the properties, color, and opacity defined by the Stroke property of the TPie object.
Paint fills the background using the drawing brush with the properties, color, and opacity defined by the current Fill property of the TPie object.</docstr>
    <members>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TPie.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <function name="PointInObject">
        <docstr>Checks whether the point, specified by the absolute coordinates, belongs to the control area.
FMX.Objects.TPie.PointInObject inherits from FMX.Controls.TControl.PointInObject. All content below this line refers to FMX.Controls.TControl.PointInObject.
Checks whether the point, specified by the absolute coordinates, belongs to the control area.
PointInObject returns True if the specified point belongs to the control area, and False otherwise. 
The X and Y are the absolute coordinates (relative to the main form) of the point to be checked (compare with PointInObjectLocal):

X is the X coordinate.
Y is the Y coordinate.
The points of the control boundary specified by BoundsRect belong to the control and PointInObject returns True for them.

Note: PointInObject simply converts absolute coordinates of the point to local coordinates and calls PointInObjectLocal.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates an instance of TShape with the specified component as owner.
FMX.Objects.TPie.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
Creates an instance of TShape with the specified component as owner.</docstr>
      </constructor>
      <property name="StartAngle">
        <docstr>Specifies the start angle for this pie object.
The StartAngle start angle is measured clockwise from the x-axis. 
Use StartAngle in conjunction with EndAngle to specify how to draw and fill this pie.
Notice that FMX.Controls.TControl.RotationAngle rotates the x-axis.</docstr>
      </property>
      <property name="EndAngle">
        <docstr>Specifies the end angle for this pie object.
The EndAngle end angle is measured clockwise from the StartAngle start angle. 
Use EndAngle in conjunction with StartAngle to specify how to draw and fill this pie.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Objects" name="TArc">
    <docstr>TArc defines 2D arcs. 
TArc is drawn as part of TEllipse&apos;s contour. It inherits TControl and can be used in styles to construct controls.
The TArc object is the part of the TEllipse&apos;s contour enclosed between radiuses with the StartAngle and EndAngle angles.
To define the general size, shape, and position of TArc, use the ShapeRect bounding rectangle, the scaling factors specified by  Scale, the RotationCenter rotation axis, and the RotationAngle rotation angle of the TEllipse object.
TArc draws the contour and fills the shape background with the Paint method. 
The Paint method draws the TArc contour using the drawing pen having the Stroke property of the TArc object.</docstr>
    <members>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TArc.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TShape with the specified component as owner.
FMX.Objects.TArc.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
Creates an instance of TShape with the specified component as owner.</docstr>
      </constructor>
      <property name="StartAngle">
        <docstr>Specifies the start angle for this arc object.
The StartAngle start angle is measured clockwise from the x-axis. 
Use StartAngle in conjunction with EndAngle to specify how to draw this arc.
Notice that FMX.Controls.TControl.RotationAngle rotates the x-axis.</docstr>
      </property>
      <property name="EndAngle">
        <docstr>Specifies the end angle for this arc object.
The EndAngle end angle is measured clockwise from the StartAngle start angle. 
Use EndAngle in conjunction with StartAngle to specify how to draw this arc.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Objects" name="TCustomPath">
    <docstr>TCustomPath is the base class for all 2D path-type shapes representing groups of connected curves and lines.
TCustomPath renders the path Data graphics with the Paint method. Paint scales and positions the path graphics according to the WrapMode parameter. Paint draws the path contour and fills the background using the drawing pen and brush with the properties, color, and opacity defined by the Stroke and Fill properties of the TCustomPath object.</docstr>
    <members>
      <procedure name="StrokeChanged">
        <docstr>Forces the shape to repaint its image on the screen.
FMX.Objects.TCustomPath.StrokeChanged inherits from FMX.Objects.TShape.StrokeChanged. All content below this line refers to FMX.Objects.TShape.StrokeChanged.
Forces the shape to repaint its image on the screen.
StrokeChanged is the event handler of the FMX.Graphics.TBrush.OnChanged event of the Stroke property.</docstr>
      </procedure>
      <procedure name="DoChanged">
        <docstr>Forces the repainting of the TCustomPath image on the screen.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TCustomPath.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>Resize is called when TCustomPath is resized. 
Resize calls the inherited FMX.Controls.TControl.Resize method and then sets that the TCustomPath image needs to be updated.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Makes required initializations by calling the inherited TControl.Loaded procedure and then sets that the TCustomPath image needs to be updated. 
For additional details, see TControl.Loaded and TComponent.Loaded.</docstr>
      </procedure>
      <procedure name="UpdateCurrent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TShape with the specified component as owner.
FMX.Objects.TCustomPath.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
Creates an instance of TShape with the specified component as owner.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the object instance and frees its memory.
FMX.Objects.TCustomPath.Destroy inherits from FMX.Objects.TShape.Destroy. All content below this line refers to FMX.Objects.TShape.Destroy.
Destroys the object instance and frees its memory.
Do not call Destroy directly in an application. Call Free instead. Free verifies that the object instance is not nil before calling Destroy.</docstr>
      </destructor>
      <function name="PointInObject">
        <docstr>Checks whether the specified point belongs to the path Data of the TCustomPath object.
PointInObject calls the FMX.Graphics.TCanvas.PtInPath method of the TCanvas object to check whether the specified point belongs to the path Data of the TCustomPath object.
X and Y are absolute pixel coordinates of the point to be checked:

X is the x-coordinate.
Y is the y-coordinate.</docstr>
      </function>
      <property name="Data">
        <docstr>Specifies the SVG data used to build graphic shapes.
The Data property supports only a comma-separated list of instructions defined for the d attribute of the path element in SVG 1.0. 
In SVG 1.0, the d attribute contains the moveto, line, curve, arc, and closepath instructions. All instructions are expressed as one character (for example, a moveto is expressed as an M).
For more information, see Scalable Vector Graphics (SVG) 1.0 Specification.

Example
To clarify, consider the following code snippets that specify the SVG instructions at run time:


Delphi:

Path1.Data.Data := &apos;M 1,0, L 2,1, L 1,2, L 0,1, L 1,0&apos;;


C++Builder:


Path1-&gt;Data-&gt;Data = &quot;M 1,0, L 2,1, L 1,2, L 0,1, L 1,0&quot;;


An application that uses the above mentioned SVG instructions displays a rhomb:</docstr>
      </property>
      <property name="WrapMode">
        <docstr>Specifies whether and how to resize, replicate, and position the graphical path representation for painting the area.
The WrapMode property should be one of the constants defined in the TPathWrapMode type: 

Stretch--stretches the path representation to fill the entire area. Default.
Original--keeps the original path size.
Fit--resizes the path representation (keeping proportions) to best fit the area.
Tile--renders the path representation repeatedly to tile the area.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Objects" name="TPath">
    <docstr>TPath defines 2D path-type shapes representing groups of connected curves and lines.</docstr>
  </class>
  <class unit="FMX.Objects" name="TText">
    <docstr>TText defines 2D text objects. It inherits TControl and can be used in styles to construct controls.
TText implements the ITextSettings interface. Therefore, TText objects provide all declared in ITextSettings methods and properties to manage the text appearance parameters declared in TTextSettings.</docstr>
    <members>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Objects.TText.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="FontChanged">
        <docstr>Computes the size of the TText control, based on the font used, then re-renders it with the new dimensions.
The FontChanged method recalculates the physical dimensions (height and width) of the TText control according to the font used to display the text, and re-renders it with the new dimensions.
FontChanged is used internally for auto-sizing purposes. For more information on how to make TText auto-resize according to its display text, refer to the AutoSize API help topic.</docstr>
      </procedure>
      <function name="ConvertText">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="SupportsPaintStage">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetTextSettingsClass">
        <docstr>Returns the class type that instance represents the used text settings.
GetTextSettingsClass returns the TTextSettingsClass class reference to the TTextSettingsClass class (or its descendant). An instance of such class provides Font, FontColor, HorzAlign, VertAlign, Trimming, WordWrap, and other text representation properties of a control. Some of these properties can be declared as published to be editable in the Object Inspector.
You can override the method in descendant classes to modify the default behavior.</docstr>
      </function>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TText.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <function name="GetData">
        <docstr>Getter method for the Text property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Setter method for the Text property.</docstr>
      </procedure>
      <procedure name="DoRealign">
        <docstr>Computes the new size of the TText control and re-renders it with the new dimensions.</docstr>
      </procedure>
      <procedure name="AdjustSize">
        <docstr>Computes the new size of the TText control and re-renders it with the new dimensions.
The AdjustSize method recalculates the physical dimensions (height and width) of the TText control according to the text it displays, and re-renders it with the new dimensions.
AdjustSize is used internally for auto-sizing purposes. For more information on how to make TText auto-resize according to its display text, refer to the AutoSize API help topic.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.Objects.TText.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.Objects.TText.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <property name="Layout">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <procedure name="UpdateDefaultTextSettings">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="SaveState">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="RestoreState">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="RemoveAcceleratorKeyInfo">
        <docstr>Removes the accelerator keys drawing information.</docstr>
      </procedure>
      <property name="AcceleratorKeyInfo">
        <docstr>Indicates the accelerator keys drawing information.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Objects.TText.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Objects.TText.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="AfterConstruction">
        <docstr>Responds after the last constructor has executed.
FMX.Objects.TText.AfterConstruction inherits from System.TObject.AfterConstruction. All content below this line refers to System.TObject.AfterConstruction.
Responds after the last constructor has executed.
AfterConstruction is called automatically after the object&apos;s last constructor has executed. Do not call it explicitly in your applications. 
The AfterConstruction method implemented in TObject does nothing. Override this method when creating a class that performs an action after the object is created. For example, TCustomForm overrides AfterConstruction to generate an OnCreate event.</docstr>
      </procedure>
      <procedure name="SetBounds">
        <docstr>Sets the boundaries of the current control.
FMX.Objects.TText.SetBounds inherits from FMX.Controls.TControl.SetBounds. All content below this line refers to FMX.Controls.TControl.SetBounds.
Sets the boundaries of the current control.
Use SetBounds to change all of the boundary properties of the control at one time. 
X specifies the X coordinate of the Position of the control.
Y specifies the Y coordinate of the Position of the control.
AWidth specifies the value of the Width of the control.
AHeight specifies the value of the Height of the control.
The same effect can be achieved by setting the Position, Width, and Height properties separately, but SetBounds changes all properties at once, ensuring that the control will not repaint between changes.
After setting the boundary properties, SetBounds specifies to the control to maintain the alignment of the control within its parent and of its children within it. The given parameter does not necessarily reflect in the Position, Width, and Height properties. The properties can be updated when the alignment is applied.</docstr>
      </procedure>
      <property name="Font">
        <docstr>Specifies the attributes of text written on or in the control.
To change to a new font, specify a new TFont object. To modify a font, change the value of the Family, Size, or Style of the TFont object.</docstr>
      </property>
      <property name="Color">
        <docstr>Specifies the color of the Text.
Use Color to set and get the color used to display Text within TText.</docstr>
      </property>
      <property name="HorzTextAlign">
        <docstr>Specifies how the text will be displayed in terms of horizontal alignment.
The HorzTextAlign property specifies how the TText control will display the text in terms of horizontal alignment. HorzTextAlign can have one of the following values:

Center (default)--aligns the text on a horizontal axis, at the middle of the TText control.
Leading--aligns the text on a horizontal axis, at the topmost position inside the TText control.
Trailing--aligns the text on a horizontal axis, at the bottommost position inside the TText control.</docstr>
      </property>
      <property name="Trimming">
        <docstr>Specifies the behavior of the text, when it overflows the area for drawing the text.
Trimming may take the following values defined in the TTextTrimming type: None, Character, and Word.
If the value of this property is not None and the text does not fit in the drawing area, then it is trimmed to fit the area and an ellipsis sign is printed after the trimmed text.

Note: For Android and iOS platforms, Trimming works only when WordWrap = False.</docstr>
      </property>
      <property name="VertTextAlign">
        <docstr>Specifies how the text will be displayed in terms of vertical alignment.
The VertTextAlign property specifies how the TText control will display the text in terms of vertical alignment. VertTextAlign can have one of the following values:

Center (default)--aligns the text on a vertical axis, at the middle of the TText control.
Leading--aligns the text on a vertical axis, at the topmost position inside the TText control.
Trailing--aligns the text on a vertical axis, at the bottommost position inside the TText control.</docstr>
      </property>
      <property name="WordWrap">
        <docstr>Specifies whether the text inside the TText control wraps when it is longer than the width of the control.
Set WordWrap to True to allow the TText control to display multiple lines of text. When WordWrap is True, text that is too long to fit in the TText control wraps at the right margin and continues in additional lines.
Set WordWrap to False for the text to span onto a single line of the TText control. However, in this case, the text that is too long to fit in the TText control appears truncated.</docstr>
      </property>
      <property name="AutoSize">
        <docstr>Specifies whether TText control is auto-sized based on the length of the text.
Set the AutoSize property to True to automatically resize the TText control according to the length of the Text.
Set the AutoSize property to False to lock autoresize of the TText control.

Tip:  The size of the TText control readjusts when the Font property changes.
When both AutoSize and WordWrap are set to True, the height of the TText control increases to show the full text, while the width does not change.
When AutoSize is set to True and WordWrap is False the width of the TText control changes to display the text in one line, while the height does not change.</docstr>
      </property>
      <property name="Stretch">
        <docstr>Specifies whether the text in the control will be displayed as stretched over the entire client area.
Set the Stretch property to True to display the text stretched over the entire client area of the TText control. Set the Stretch property to False to display the text normally, without the stretch effect. The default value for the Stretch property is False.

Tip: Setting the Stretch property to True cancels the effect of the WordWrap property.</docstr>
      </property>
      <property name="Text">
        <docstr>Specifies the text that will be displayed in the TText control.
The Text property sets or reads the text that is displayed by the TText control. Text is a string.</docstr>
      </property>
      <property name="TextSettings">
        <docstr>Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
TTextSettings type objects provide all styled text representation properties and methods to manage them.
The styled text representation properties are 
FontColor, TextAlign,
VertTextAlign,
Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
VertTextAlign properties of the control.</docstr>
      </property>
      <property name="PrefixStyle">
        <docstr>It determines the way to portray a single character, such as &quot;&amp;&quot;.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Objects" name="TImage">
    <docstr>TImage defines 2D image components. It inherits TControl and can be used in styles to construct controls.
Use TImage to display a graphical image on a control.
Use the MultiResBitmap property to specify the multi-resolution set of bitmaps the most appropriate of which will be displayed as the picture on this TImage control. The TImage control shows the bitmap item with the scale best matching to the device resolution. See in the Bitmap property which algorithm is used to define the most appropriate bitmap item.
You can find the list of supported picture formats in TBitmapCodecManager.
Use the WrapMode property to specify whether and how to resize, replicate, and position the bitmap image for rendering the TImage surface. 
Notice that if any BitmapMargins is defined, then WrapMode is ignored.</docstr>
    <members>
      <procedure name="DoChanged">
        <docstr>Forces the current TImage control to repaint its image on the screen and update the effects of the control and of the control&apos;s parent.
DoChanged is called every time the current TImage control is changed.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TImage.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="DrawWithMargins">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="ItemForCurrentScale">
        <docstr>Tries to find the item in MultiResBitmap that has the most suitable scale. 
If the IncludeEmpty parameter is True, the returned item can be empty. Otherwise, the returned item cannot be empty. Empty items are ignored.
If the search is successful, ItemForCurrentScale returns the TCustomBitmapItem, otherwise  ItemForCurrentScale returns nil.</docstr>
      </function>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
If the Data property is empty, GetData returns the value of the Bitmap property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
Additionally, if Value is a TPersistent descendant, the Bitmap property is also set to Value.</docstr>
      </procedure>
      <function name="CreateMultiResBitmap">
        <docstr>Creates the MultiResBitmap multi-resolution bitmap image of the TFixedMultiResBitmap type that will be used by this TImage component to display a picture.</docstr>
      </function>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Objects.TImage.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="MultiResBitmapStored">
        <docstr>Retrieves whether some properties of  MultiResBitmap are stored.</docstr>
      </function>
      <function name="CanObserve">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Objects.TImage.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Objects.TImage.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="DrawBitmap">
        <docstr>Draws a TBitmap image after scaling it to a specified area of the TCanvas.
Use this method to display a whole bitmap image into a specified area of the TCanvas. To display a specified area of the bitmap image, use the FMX.Graphics.TCanvas.DrawBitmap method.

Parameters
This method defines the following parameters:

Canvas: specifies a canvas.
ARect: specifies the rectangle area of Canvas to be drawn.
ABitmap: specifies a TBitmap image.
AOpacity: specifies the transparency to be applied to the ABitmap.
Notes
When using the  DrawBitmap method, pay attention to the following:

When drawing a bitmap image, this method uses the following properties of TImage:
FMX.Objects.TImage.BitmapMargins: Specifies the margins of the bitmap image to draw.
FMX.Objects.TImage.WrapMode: Specifies whether and how to resize, replicate, and position the bitmap image.
It is recommended to use this method within the onPaint event handlers, such as FMX.Controls.TControl.OnPaint or FMX.Forms.TCustomForm.OnPaint.</docstr>
      </procedure>
      <property name="Bitmap">
        <docstr>Specifies the bitmap picture that will be displayed by this TImage component.
Set the Bitmap property to the bitmap picture that you want to be displayed by this TImage component. Reading Bitmap provides a TBitmap image that you can assign to other TImage components or you can save to a stream or a file.
The Bitmap getter retrieves the Bitmap image from the appropriate bitmap item of the multi-resolution bitmap stored in MultiResBitmap. When you set a new value to the bitmap, the Bitmap setter saves this bitmap in this bitmap item of the MultiResBitmap multi-resolution bitmap. If you change this bitmap item in MultiResBitmap by any way, this will change the Bitmap image. For example, you can edit MultiResBitmap in the MultiResBitmap Editor from the Object Inspector. 
For a list of image formats supported by this component, please refer to the TBitmapCodecManager API help topic.
You can also assign an image programmatically, as exemplified in the following code snippet:

  Image1.Bitmap.LoadFromFile(&apos;MyImage.jpg&apos;);

Note: The Bitmap getter uses the following algorithm to retrieve the Bitmap property&apos;s value:
Using the GetSceneScale function for the Scene in which the control is drawn, the Bitmap getter retrieves the Scale for the current device. If Scene is not defined, then the 1.0 value for Scale is accepted.
If MultiResBitmap is assigned, then the getter gets the Bitmap from the bitmap item having the scale best matching to the obtained Scale (not including empty bitmap items.)
If the getter does not find any not empty bitmap item, then the getter tries to retrieve an empty bitmap item having the scale exactly matching to the obtained Scale.
If the getter cannot find an empty bitmap item having the obtained Scale, then the getter creates a new bitmap item with the obtained Scale and returns the bitmap from the created bitmap item.
If the obtained Scale &lt;= 0 or MultiResBitmap is not assigned, the exception is raised.</docstr>
      </property>
      <property name="MultiResBitmap">
        <docstr>Keeps the   TFixedMultiResBitmap multi-resolution bitmap.</docstr>
      </property>
      <property name="BitmapMargins">
        <docstr>Specifies the margins of the bitmap displayed by this TImage component.
Set or read the BitmapMargins property in order to affect the margins of the image that is displayed by this TImage component.</docstr>
      </property>
      <property name="DisableInterpolation">
        <docstr>Enables or disables the interpolation of the bitmap image displayed by this TImage component.
The DisableInterpolation property specifies whether the interpolation is used while rendering the bitmap image displayed by this TImage component. By default, DisableInterpolation is set to False.
The following picture shows the same image rendered once with DisableInterpolation set to False and once with DisableInterpolation set to True.</docstr>
      </property>
      <property name="MarginWrapMode">
        <docstr>Specifies how the margins of the Bitmap are resized, replicated, and positioned.
Use MarginWrapMode property to set and get how the margins of the Bitmap are displayed within the TImage. By default the margins are stretched to fill the entire TImage. To see the possible values of MarginWrapMode, go to TImageWrapMode.
If BitmapMargins property is not set, then MarginWrapMode has no effect over the image.</docstr>
      </property>
      <property name="WrapMode">
        <docstr>Specifies whether and how to resize, replicate, and position the bitmap image for rendering the TImage surface.
The WrapMode property should be one of the constants defined in the TImageWrapMode type:

Original displays the image with its original dimensions.
Fit provides the best fit, keeping image proportions (the ratio between the width and height) for the TImage rectangle. If needed, the image is scaled down or stretched to best fit the rectangle area. This is the default option.
Stretch stretches the image to fill the entire rectangle of the TImage component.
Tile tiles the TImage image to cover the entire rectangle of the TImage component.
Center centers the image to the rectangle of the TImage component. The image is never resized, regardless the size of the rectangle of the TImage component.
Place fits the image into the TImage rectangle. If the width or height of the image is greater than the corresponding dimension of the TImage rectangle, then the image is scaled down keeping image proportions (the ratio between the width and height) to fit in the TImage rectangle. The obtained image is centered in the TImage rectangle.  Place only makes images smaller, never larger.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Objects" name="TPaintBox">
    <docstr>TPaintBox defines a 2D image component providing a canvas that an application can use for rendering an image. It inherits TControl and can be used in styles to construct controls.
Unlike TImage, which displays a picture that is stored in a file, TPaintBox requires an application to draw the image directly on a canvas. Use the OnPaint event handler to draw on the paint box&apos;s FMX.Graphics.TCanvas, the drawing surface of the paint box.</docstr>
    <members>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TPaintBox.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Objects.TPaintBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Objects.TPaintBox.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <event name="OnPaint">
        <docstr>Occurs when the control is redrawn. 
FMX.Objects.TPaintBox.OnPaint inherits from FMX.Controls.TControl.OnPaint. All content below this line refers to FMX.Controls.TControl.OnPaint.
Occurs when the control is redrawn. 
OnPaint also occurs when DoPaint is called.
Write an event handler for OnPaint to change the way the control renders itself.

Tip:  Notice that calling BeginScene in the OnPaint event handlers has no effect, because BeginScene is called before the OnPaint event handler runs. This guarantees that painting always occurs in OnPaint without requiring extra and probably unexpected code to allow drawing to have an effect.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Objects" name="TSelection">
    <docstr>TSelection defines 2D rectangle object that can be moved and resized. It inherits TControl and can be used in styles to construct controls.
You can use scaling factors Scale of the TSelection object to proportionally change coordinates of a selection object&apos;s rectangle along local coordinate axes. Scaling moves the selection rectangle and change its size. The rotation axis RotationCenter and rotation angle RotationAngle of the selection object can also be used to modify the selection rectangle&apos;s size and position.
The Paint method renders the TSelection image. Paint internally defines the properties of the drawing pen to draw the selection contour and the brush to fill the background depending on whether the control is enabled, the zone is hot, and other conditions. 
To resize the TSelection rectangle you can use four grip controls. Grip controls appear as small circles at the selection rectangle corners when the mouse pointer hovers over the grip controls.</docstr>
    <members>
      <function name="DoGetUpdateRect">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TSelection.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="DrawHandle">
        <docstr>It draws a grip handle.</docstr>
      </procedure>
      <procedure name="DrawFrame">
        <docstr>It draws a frame rectangle.</docstr>
      </procedure>
      <function name="PointInObjectLocal">
        <docstr>Checks whether the point specified by local coordinates belongs to the control area.
FMX.Objects.TSelection.PointInObjectLocal inherits from FMX.Controls.TControl.PointInObjectLocal. All content below this line refers to FMX.Controls.TControl.PointInObjectLocal.
Checks whether the point specified by local coordinates belongs to the control area.
PointInObjectLocal returns True if the specified point belongs to the control area, and False otherwise. 
The X and Y are the local coordinates of the point to be checked (compare with PointInObject):

X is the X coordinate.
Y is the Y coordinate.
The local coordinates of the upper-left corner of the control rectangle are (0,0), and the local coordinates of the lower-right corner are (Width, Height). 
The points of the control boundary specified by BoundsRect belong to the control and PointInObjectLocal returns True for them.
If a control supports the Touch property, the control area can be optionally inflated on the values specified by the TouchTargetExpansion property. TouchTargetExpansion keeps four optional parameters representing the expansion for the four sides of the control in pixels (Bottom, Left, Right, and Top). 
The dclasses can change the &apos;control area&apos; definition. For example:

The FMX.Objects.TSelection class extends the &apos;control area&apos; definition relative to BoundsRect. FMX.Objects.TSelection.PointInObjectLocal also returns True if the point belongs to any of small rectangles of the four grip controls used to manage the selection shape. The rectangles of the grip controls are rectangles surrounding the four corners of the TSelection rectangle. The Width and Height of these rectangles are equal to 2 * GripSize. For example, the grip control&apos;s rectangle of the upper-right corner UR_Corner of TSelection is defined by the following corners:
(UR_Corner.Top - GripSize, UR_Corner.Right - GripSize)--upper-left corner of the grip.
(UR_Corner.Top + GripSize, UR_Corner.Right + GripSize)--lower-right corner of the grip.
FMX.Objects.TSelectionPoint.PointInObjectLocal returns True if the specified point belongs to the rectangle of the grip control corresponding to the TSelectionPoint object, and False otherwise.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Objects.TSelection.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Objects.TSelection.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="MouseDown">
        <docstr>Handles the pressing of a mouse button inside the TSelection object. 
MouseDown calls  FMX.Controls.TControl.MouseDown, checks whether any of the grip controls (small circles in the selection rectangular corners) are pointed to resize the selection shape and activate resizing by moving this control or activates moving of the TSelection object by moving the mouse pointer. 
MouseDown has the following parameters:  

Button--belongs to the TMouseButton type and specifies the pressed mouse button: mbLeft--left, mbRight--right, or mbMiddle--middle.
Shift--belongs to the TShiftState type and passes additional information such as: whether shift keys (ssShift--SHIFT, ssCtrl--CTRL, or ssAlt--ALT) were pressed when the mouse button was clicked; whether the mouse button was double-clicked (ssDouble).
X and Y--are the local pixel coordinates of the mouse pointer within the TSelection object.
The TForm form, owner of the TSelection object, calls MouseDown in response to mouse-down messages.
Override the public MouseDown method to provide a customized response when a mouse button is pressed when the mouse pointer is over the TSelection object.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>Handles moving of the mouse pointer over a TSelection object.
As the mouse pointer moves over a TSelection object, this method is called repeatedly. It is called each time with the new mouse pointer coordinates that reflect the continuous path of the mouse pointer.

Parameters
MouseMove has the following parameters:  

Shift--belongs to the TShiftState type and passes additional information, such as: which mouse button was pressed (ssLeft--left, ssRight--right) or whether shift keys (ssShift--SHIFT, ssCtrl--CTRL, or ssAlt--ALT) were pressed when the mouse button was clicked.
X and Y--are the local pixel coordinates of the mouse pointer within the TSelection object.
Functionality
MouseMove executes the following operations:

MouseMove calls the inherited FMX.Controls.TControl.MouseMove method. Then:
If the mouse button is not pressed down:
Check whether the mouse pointer hovers over a grip control:
When the mouse pointer moves over a grip control--shows the resizing arrow on the grip control over which the mouse pointer is moving.
When the mouse pointer moves outside a grip control--clears the resizing arrows, if any.
Force repaint of the selection shape.
If the left mouse button is pressed inside the TSelection object:
Moves the shape of the TSelection object on the vector with the start point having the coordinates where the mouse button was pressed and the end point having the current coordinates of the mouse.
If ParentBounds is True, the TSelection object shape is moved inside the boundaries of the parent control.
If ParentBounds is False, the TSelection object shape is moved inside the boundaries of the current TCanvas object.
Calls the customer event handler of the OnTrack event.
If the left mouse button is pressed down on one of the grip controls of the TSelection object:
The shape of the TSelection object is resized to reflect the moving of the selected grip control.
If ParentBounds is True, the TSelection object shape is resized to fit the boundaries of the parent control.
If ParentBounds is False, the TSelection object shape is resized to fit the boundaries of the current TCanvas object.
If Proportional is True, the object shape is resized keeping the Width/Height proportion.
Call the customer event handler of the OnTrack event.
Force the repaint of the selection shape.

Override the public MouseMove method to provide a customized response when the mouse pointer is moved over the TSelection object.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>Handles the release of a mouse button pressed inside the TSelection object. 
MouseUp calls the inherited FMX.Controls.TControl.MouseUp. If the TSelection object is being moved or resized by the mouse, MouseUp calls the OnChange event handler, and then stops moving or resizing by the mouse.   
MouseUp has the following parameters:  

Button--belongs to the TMouseButton type and specifies the pressed mouse button: mbLeft--left, mbRight--right, or mbMiddle--middle.
Shift--belongs to the TShiftState type and passes additional information, such as whether shift keys (ssShift--SHIFT, ssCtrl--CTRL, or ssAlt--ALT) were down when the pressed mouse button was released.
X and Y--are the local pixel coordinates of the mouse pointer within the TSelection object.
The TForm form (owner of the TSelection object) calls MouseUp in response to mouse-up messages.
Override the public MouseUp method to provide a customized response if the mouse button is released when the mouse pointer is over the TSelection object.</docstr>
      </procedure>
      <procedure name="DoMouseLeave">
        <docstr>DoMouseLeave is called automatically when the mouse pointer leaves the TSelection object. 
DoMouseLeave of the TSelection object calls the inherited FMX.Controls.TControl.DoMouseLeave method which starts animation by calling StartTriggerAnimation, applies effects by calling ApplyTriggerEffect, and calls the FMX.Controls.TControl.OnMouseLeave event handler. Then DoMouseLeave frees the grip controls. Finally, DoMouseLeave initializes the TSelection shape repaint operation.
Override the protected DoMouseLeave method to provide other responses when the mouse pointer leaves the TSelection object.</docstr>
      </procedure>
      <property name="HotHandle">
        <docstr>It grips the handle where the mouse is hovered.</docstr>
      </property>
      <property name="Color">
        <docstr>Selection frame and handle&apos;s border color.</docstr>
      </property>
      <property name="GripSize">
        <docstr>Defines the size of the grip controls used to resize the TSelection object.</docstr>
      </property>
      <property name="HideSelection">
        <docstr>Defines whether to hide the selection rectangle when the TSelection object is not selected.
When HideSelection is True and the TSelection object is not selected, the rectangle and grip controls are invisible. 

See also
FMX.Objects.TSelection.GripSize</docstr>
      </property>
      <property name="MinSize">
        <docstr>Defines the minimum possible values for the width and height of the TSelection object.</docstr>
      </property>
      <property name="ParentBounds">
        <docstr>Defines whether the shape of the TSelection object should be inside the boundaries of the parent control.
When ParentBounds is True, the shape of the TSelection object cannot be moved outside the boundaries of the parent control.</docstr>
      </property>
      <property name="Proportional">
        <docstr>Defines whether the width/height proportion should be kept during the resizing of the TSelection object.</docstr>
      </property>
      <property name="ShowHandles">
        <docstr>It indicates the visibility of the handles.</docstr>
      </property>
      <event name="OnChange">
        <docstr>The event handler of the OnChange event is called from the MouseUp method whenever the shape of a TSelection object changes.
Write a custom OnChange event handler to perform a specific action when the TSelection object changes.</docstr>
      </event>
      <event name="OnTrack">
        <docstr>The event handler of the OnTrack event is called cyclically from the MouseMove method while the TSelection object is in the process of moving or resizing.
Write a custom OnTrack event handler to perform a specific action when TSelection is in the process of moving or resizing.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Objects" name="TSelectionPoint">
    <docstr>TSelectionPoint defines a 2D point object that can be moved. It inherits TControl and can be used in styles to create controls.
The TSelectionPoint class implements operations of moving of a 2D point object with a mouse or another pointing device. 
The behavior of selection point objects depends upon the existence of a corresponding style-resource in an application style book: 

When an application style book does not contain a style-resource for selection points:
A selection point in this application is drawn as a circle having a radius equal to GripSize.
The used GripSize is truncated to 1&lt;= GripSize&lt;=20.
A selection point is drawn as a white circle having the blue circumference.
When a selection point is selected, its circle is shown red.
To select a selection point, place the mouse pointer over the circle shape or the  bounds rectangle of the selection point (having the Width and Height dimensions).
When an application style book contains a style-resource for selection points, then all selection point properties are loaded from the style-resource; property values are set in the Form Designer or are ignored programmatically. On some platforms, selection points use predefined platform-specific values. For example, on some mobile platforms GripSize is 16 or 17 and this value cannot be changed programmatically.
Notice that the GripCenter property has the following implementation. The X and Y values of GripCenter define an offset between the mouse pointer position and the shown selection point when the pressed mouse pointer is moved.  
You can use scaling factors Scale of the TSelectionPoint object to proportionally change a selection point and a grip sizes along coordinate axes. The rotation axis RotationCenter and rotation angle RotationAngle of the selection point object can also be used to modify the position of the selection point.</docstr>
    <members>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Objects.TSelectionPoint.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="SetHeight">
        <docstr>Setter function for the Height property.
Value specifies the new value of the Height property.
If no style is applied to the TSelectionPoint object, then SetHeight sets Height = 2*GripSize. The specified Value is ignored.</docstr>
      </procedure>
      <procedure name="SetWidth">
        <docstr>Setter function for the Width property.
Value specifies the new value of the Width property.
If no style is applied to the TSelectionPoint object, then SetWidth sets Width = 2*GripSize. The specified Value is ignored.</docstr>
      </procedure>
      <function name="DoGetUpdateRect">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="DoMouseEnter">
        <docstr>DoMouseEnter is called when the mouse pointer enters the TSelectionPoint object. 
DoMouseEnter calls the inherited FMX.Controls.TControl.DoMouseEnter method and then initializes repainting of the TSelectionPoint shape.
Override the protected DoMouseEnter method to provide other responses when the mouse pointer enters the TSelectionPoint object.</docstr>
      </procedure>
      <procedure name="DoMouseLeave">
        <docstr>DoMouseLeave is called when the mouse pointer leaves the TSelectionPoint object. 
DoMouseLeave calls the inherited FMX.Controls.TControl.DoMouseLeave method and then initializes repainting of the TSelectionPoint shape.
Override the protected DoMouseLeave method to provide other responses when the mouse pointer leaves the TSelectionPoint object.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>Handles the pressing of a mouse button on the TSelectionPoint object. 
MouseDown calls the FMX.Controls.TControl.OnMouseDown event handler and sets that the left mouse button is pressed.
MouseDown has the following parameters:  

Button--belongs to the TMouseButton type and specifies the pressed mouse button: mbLeft--left, mbRight--right, or mbMiddle--middle.
Shift--belongs to the TShiftState type and passes additional information, such as whether shift keys (ssShift--SHIFT, ssCtrl--CTRL, or ssAlt--ALT) were pressed when the mouse button was clicked, or whether the mouse button was double-clicked (ssDouble).
X and Y--are the local pixel coordinates of the mouse pointer within the TSelectionPoint object.
The TForm form (owner of the TSelectionPoint object) calls MouseDown in response to mouse-down messages.
Override the public MouseDown method to provide a customized response when a mouse button is pressed when the mouse pointer is over the TSelectionPoint object.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>Handles moving of the mouse pointer over a TSelectionPoint object.
As the mouse pointer moves over a TSelectionPoint object, this method is called repeatedly. Each time it is called with the new mouse pointer coordinates that reflect the continuous path of the mouse pointer.
MouseMove has the following parameters:  

Shift--belongs to the TShiftState type; it can pass additional information.
X and Y--are the local pixel coordinates of the mouse pointer within the parent control.
The MouseMove method has the following implementation:

MouseMove calls the inherited FMX.Controls.TControl.MouseMove method.
If the TSelectionPoint object is pressed with the left mouse button, the TSelectionPoint is dragged by the mouse pointer:
If ParentBounds is True and the parent is a control, the TSelectionPoint object is moved only inside the boundaries of the parent control.
If ParentBounds is True and the parent is not a control, the TSelectionPoint object is moved inside the boundaries of the current TCanvas object.
If ParentBounds is False, the TSelectionPoint object is moved to the specified X and Y coordinates.
Then, it calls the customer event handler of the OnTrack event.
Override the public MouseMove method to provide a customized response when the mouse pointer is moved over the TSelectionPoint object.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>Handles release of the left mouse button pressed inside the TSelectionPoint object. 
MouseUp calls the FMX.Controls.TControl.OnMouseUp and the OnChange event handlers, and releases mouse capturing from the TSelectionPoint object.
MouseUp has the following parameters:  

Button--belongs to the TMouseButton type and specifies the pressed mouse button: mbLeft--left, mbRight--right, or mbMiddle--middle.
Shift--belongs to the [[System.Classes.TShiftState|TShiftState] type and passes additional information, such as whether shift keys (ssShift--SHIFT, ssCtrl--CTRL, or ssAlt--ALT) were down when the pressed mouse button was released.
X and Y--are the local pixel coordinates of the mouse pointer within the TSelectionPoint object.
The TForm form, owner of the TSelectionPoint object, calls MouseUp in response to mouse-up messages.
Override the public MouseUp method to provide a customized response when the mouse button is released while the mouse pointer is over the TSelectionPoint object.</docstr>
      </procedure>
      <procedure name="DoChangeTracking">
        <docstr>OnTrack event dispatcher.
DoChangeTracking is automatically called when the mouse is moved while the left mouse button is pressed.
DoChangeTracking fires an OnTrack event.</docstr>
      </procedure>
      <procedure name="DoChange">
        <docstr>OnChange event dispatcher.
DoChange is automatically called when the left mouse button is released.
DoChange fires an OnChange event.</docstr>
      </procedure>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.Objects.TSelectionPoint.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.Objects.TSelectionPoint.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Objects.TSelectionPoint.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Objects.TSelectionPoint.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <function name="PointInObjectLocal">
        <docstr>Checks whether the point specified by local coordinates belongs to the control area.
FMX.Objects.TSelectionPoint.PointInObjectLocal inherits from FMX.Controls.TControl.PointInObjectLocal. All content below this line refers to FMX.Controls.TControl.PointInObjectLocal.
Checks whether the point specified by local coordinates belongs to the control area.
PointInObjectLocal returns True if the specified point belongs to the control area, and False otherwise. 
The X and Y are the local coordinates of the point to be checked (compare with PointInObject):

X is the X coordinate.
Y is the Y coordinate.
The local coordinates of the upper-left corner of the control rectangle are (0,0), and the local coordinates of the lower-right corner are (Width, Height). 
The points of the control boundary specified by BoundsRect belong to the control and PointInObjectLocal returns True for them.
If a control supports the Touch property, the control area can be optionally inflated on the values specified by the TouchTargetExpansion property. TouchTargetExpansion keeps four optional parameters representing the expansion for the four sides of the control in pixels (Bottom, Left, Right, and Top). 
The dclasses can change the &apos;control area&apos; definition. For example:

The FMX.Objects.TSelection class extends the &apos;control area&apos; definition relative to BoundsRect. FMX.Objects.TSelection.PointInObjectLocal also returns True if the point belongs to any of small rectangles of the four grip controls used to manage the selection shape. The rectangles of the grip controls are rectangles surrounding the four corners of the TSelection rectangle. The Width and Height of these rectangles are equal to 2 * GripSize. For example, the grip control&apos;s rectangle of the upper-right corner UR_Corner of TSelection is defined by the following corners:
(UR_Corner.Top - GripSize, UR_Corner.Right - GripSize)--upper-left corner of the grip.
(UR_Corner.Top + GripSize, UR_Corner.Right + GripSize)--lower-right corner of the grip.
FMX.Objects.TSelectionPoint.PointInObjectLocal returns True if the specified point belongs to the rectangle of the grip control corresponding to the TSelectionPoint object, and False otherwise.</docstr>
      </function>
      <property name="GripSize">
        <docstr>Defines the radius of the shown selection point object.
When an application style book does not contain a style-resource for selection points, a selection point in this application is drawn as a circle having radius equal to GripSize. The used GripSize is truncated to 1&lt;= GripSize&lt;=20. When an application style book contains a style-resource for selection points, then all selection point properties are loaded from the style-resource; property values set in the Form Designer or programmatically are ignored. Under some platforms, selection points use predefined platform-specific values. For example, on some mobile platforms GripSize is 16 or 17 and this value cannot be changed programmatically.</docstr>
      </property>
      <property name="GripCenter">
        <docstr>Defines an offset between the position of the mouse pointer and the shown selection point object when the pressed mouse pointer is moved.
The X and Y values of GripCenter define an offset between the mouse pointer position and the shown selection point object when the pressed mouse pointer is moved.
By default, X and Y equal 0.</docstr>
      </property>
      <property name="ParentBounds">
        <docstr>Defines whether the shape of the TSelectionPoint object should be within the boundaries of the parent control.
When ParentBounds is True, the shape of the TSelectionPoint object cannot be moved outside the boundaries of the parent control.</docstr>
      </property>
      <event name="OnChange">
        <docstr>The event handler of the OnChange event is called from the MouseUp method whenever the TSelection object changes.
Write a custom OnChange event handler to perform a specific action when the TSelectionPoint object changes.</docstr>
      </event>
      <event name="OnTrack">
        <docstr>The event handler of the OnTrack event is called cyclically from the MouseMove method while the TSelectionPoint object is being moved.
Write a custom OnTrack event handler to perform a specific action while the TSelectionPoint object is being moved.</docstr>
      </event>
    </members>
  </class>
  <class unit="System" name="TObject">
    <docstr>TObject is the ultimate ancestor of all objects and components.
TObject encapsulates fundamental behavior common to objects by introducing methods that:

Create, maintain, and destroy instances of the object by allocating, initializing, and freeing required memory.
Respond when object instances are created or destroyed.
Return class-type and instance information on an object and runtime type information (RTTI) about its published properties.
Support message handling.
Support interfaces implemented by the object.
Use TObject as an immediate base class when declaring simple objects that do not need to persist (are not saved and reloaded) and that do not need to be assigned to other objects. 
Much of the capability of objects is established by methods that TObject introduces. Many of these methods are used internally by IDEs and are not intended for users to call directly. Others are overridden in descendant objects that have more complex behavior. 
Although TObject is the based object of a component framework, not all objects are components. All component classes descend from TComponent. 

Note: TObject is never directly instantiated. Although it does not use programming language features that prevent instantiation, TObject is an abstract class.</docstr>
  </class>
  <class unit="System" name="HFAAttribute">
    <docstr></docstr>
    <members>
      <field name="FElementType">
        <docstr>Internal use only</docstr>
      </field>
      <field name="FElementCount">
        <docstr>Internal use only</docstr>
      </field>
      <property name="ElementType">
        <docstr>TypeInfo of element type</docstr>
      </property>
      <property name="ElementCount">
        <docstr>Number of element type</docstr>
      </property>
    </members>
  </class>
  <class unit="System" name="AlignAttribute">
    <docstr></docstr>
    <members>
      <field name="FAlign">
        <docstr>Internal use only</docstr>
      </field>
      <property name="Align">
        <docstr>Alignment in bytes</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Layouts" name="TLayout">
    <docstr>A layout is a container for other graphical objects. 
Use the layouts when you need to organize multiple graphical controls under the same parent.
For instance, you can use these layouts when you need to create rich FireMonkey applications with many graphical controls that are grouped on the same layer. You can set the visibility of all the controls on a layout at once by affecting the visibility of the layout.</docstr>
    <members>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Layouts.TLayout.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Layouts.TLayout.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.Layouts" name="TScaledLayout">
    <docstr>A FireMonkey scaled layout is a wrapper over TControl and acts like a layer for other objects with the possibility of scaling its content according to the physical dimensions of the layout.
A scaled layout is a container for other graphical objects that can scale its contents as shown in the following image.

The label and the button are scaled according to the dimensions of the form that contains the layer aligned as the client so that the layer occupies the entire surface.</docstr>
    <members>
      <procedure name="DoRealign">
        <docstr>Performs the alignment of a FireMonkey control.
FMX.Layouts.TScaledLayout.DoRealign inherits from FMX.Controls.TControl.DoRealign. All content below this line refers to FMX.Controls.TControl.DoRealign.
Performs the alignment of a FireMonkey control.

 See Also
FMX.Types.AlignObjects</docstr>
      </procedure>
      <function name="GetChildrenMatrix">
        <docstr>Returns the children transformation matrix.
FMX.Layouts.TScaledLayout.GetChildrenMatrix inherits from FMX.Controls.TControl.GetChildrenMatrix. All content below this line refers to FMX.Controls.TControl.GetChildrenMatrix.
Returns the children transformation matrix.
The AbsoluteMatrix is calculated as:

  AbsoluteMatrix = (LocalMatrix * Parent.GetChildrenMatrix) * Parent.AbsoluteMatrix

TScaledLayout overrides GetChildrenMatrix to prescale layout contents.</docstr>
      </function>
      <procedure name="SetHeight">
        <docstr>Setter function for the Height property.
FMX.Layouts.TScaledLayout.SetHeight inherits from FMX.Controls.TControl.SetHeight. All content below this line refers to FMX.Controls.TControl.SetHeight.
Setter function for the Height property. Value specifies the new value of the Height property.</docstr>
      </procedure>
      <procedure name="SetWidth">
        <docstr>Setter function for the Width property.
FMX.Layouts.TScaledLayout.SetWidth inherits from FMX.Controls.TControl.SetWidth. All content below this line refers to FMX.Controls.TControl.SetWidth.
Setter function for the Width property. Value specifies the new value of the Width property.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Layouts.TScaledLayout.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Layouts.TScaledLayout.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Layouts.TScaledLayout.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="OriginalWidth">
        <docstr>Specifies the original width of the scaled layout control. The original width represents the unscaled X dimension of the scaled layout control.</docstr>
      </property>
      <property name="OriginalHeight">
        <docstr>Specifies the original height of the scaled layout control. The original height represents the unscaled Y dimension of the scaled layout control.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Layouts" name="TScrollContent">
    <docstr></docstr>
    <members>
      <property name="IsContentChanged">
        <docstr>This flag is set in the method ContentChanged. Used to optimize ScrollBox</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Layouts" name="TCustomScrollBox">
    <docstr>The base class for controls representing a scrolling area (scroll box).
One use of a scroll box is to group multiple graphical controls (such as buttons, list boxes, edit boxes, radio buttons, and so on) under the same scrollable parent (the scroll box itself). In this way, a smaller form can contain a lot of graphical objects organized in a scrollable manner in order to occupy less space on a graphical user interface (GUI).
Another use of scroll boxes is to create multiple scrolling areas (views) in a form. Views are common in commercial word-processor, spreadsheet, and project management applications.

Note: Do not anchor the children of a scroll layout (TScrollBox, TVertScrollBox, TFramedScrollBox, and so on) to the right and bottom edges. If the Anchors property of a scroll layout child is set to akBottom, akRight, or both, the child will continue to stretch to keep constant the distance to the layout edges when the layout content size is being calculated. The children of a scroll layout should be anchored only to the left and top edges.
Note: When the size of the area occupied by the Content of a scroll box exceeds the control Size, and, therefore,  all Content cannot be shown in the control at one moment, then you can use scroll bars to scroll the Content in the control. Notice that on Windows the scroll bar is shown by default. However, on OS X the scroll bar is not shown by default. On OS X, the scroll bar appears when you try to scroll the Content using the mouse wheel. To enforce the scroll bar to be shown by default, you can use the code like following:
ScrollBox1.AniCalculations.AutoShowing := false;</docstr>
    <members>
      <procedure name="AniMouseDown">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AniMouseMove">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AniMouseUp">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetScrollingBehaviours">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.Layouts.TCustomScrollBox.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <procedure name="PaddingChanged">
        <docstr>Applies the padding to the content of the TScrollBox.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Layouts.TCustomScrollBox.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.Layouts.TCustomScrollBox.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoRealign">
        <docstr>Performs the realignment of the children controls of the TScrollBox object within the object.  
It is called internally every time visual properties of TScrollBox are changed. 
The children are realigned taking into account their alignment properties, margins, and padding. 
DoRealign calls the inherited TControl.DoRealign and then executes the realignment during the inertial scrolling.</docstr>
      </procedure>
      <function name="IsAddToContent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ContentAddObject">
        <docstr>Virtual method to be implemented in subclasses to provide further functionality when adding AObject to the scroll box. In TScrollBox, ContentAddObject has no implementation.</docstr>
      </procedure>
      <procedure name="ContentInsertObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ContentBeforeRemoveObject">
        <docstr>Virtual method to be implemented in subclasses to provide further functionality right before removing AObject from the scroll box. In TScrollBox, ContentBeforeRemoveObject has no implementation.</docstr>
      </procedure>
      <procedure name="ContentRemoveObject">
        <docstr>Virtual method to be implemented in subclasses to provide further functionality right after removing AObject from the scroll box. In TScrollBox, ContentRemoveObject has no implementation.</docstr>
      </procedure>
      <procedure name="HScrollChange">
        <docstr>Internally called when the horizontal scroll bar changes position. Do not call HScrollChange in applications.</docstr>
      </procedure>
      <procedure name="VScrollChange">
        <docstr>Internally called when the vertical scroll bar changes position. Do not call VScrollChange in applications.</docstr>
      </procedure>
      <procedure name="ViewportPositionChange">
        <docstr>Executed when the viewport position changes.
ViewportPositionChange receives the following parameters:

OldViewportPosition is the value that the ViewportPosition property had before it changed.
NewViewportPosition is the new value of the ViewportPosition property.
ContentSizeChanged indicates whether the size of the content of the viewport has changed as well (True) or not (False).
ViewportPositionChange calls the handler of the OnViewportPositionChange event.</docstr>
      </procedure>
      <procedure name="CMGesture">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Painting">
        <docstr>OnPainting event dispatcher. 
FMX.Layouts.TCustomScrollBox.Painting inherits from FMX.Controls.TControl.Painting. All content below this line refers to FMX.Controls.TControl.Painting.
OnPainting event dispatcher. 
Painting defines the drawing area of the control by intersecting Canvas with ClipRect if ClipChildren is True and dispatches the OnPainting event.
It is always called internally before DoPaint. 
The Painting method can be overridden by derived controls to establish control-specific rendering conditions.</docstr>
      </procedure>
      <procedure name="AfterPaint">
        <docstr>Restores Canvas properties after the painting process. 
FMX.Layouts.TCustomScrollBox.AfterPaint inherits from FMX.Controls.TControl.AfterPaint. All content below this line refers to FMX.Controls.TControl.AfterPaint.
Restores Canvas properties after the painting process. 
As implemented in TControl, AfterPaint does nothing.
TShape descendants of TControl override AfterPaint to restore Dash and  Thickness to default values.</docstr>
      </procedure>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.Layouts.TCustomScrollBox.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.Layouts.TCustomScrollBox.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <function name="IsOpaque">
        <docstr>Indicates if the control should update effects when you scroll content.
Its default value is False, meaning that the control does not update effects.
In the TFramedScrollBox and TFramedVertScrollBox classes IsOpaque returns True.</docstr>
      </function>
      <function name="ContentRect">
        <docstr>Returns the rectangle that defines the scrolling area. The result value is of type TRectF.</docstr>
      </function>
      <function name="VScrollBarValue">
        <docstr>Returns the position of the vertical scroll bar.
VScrollBarValue returns a value of 0 if the vertical scroll bar is not required by this scroll box or it is not visible.</docstr>
      </function>
      <function name="HScrollBarValue">
        <docstr>Returns the position of the horizontal scroll bar.
HScrollBarValue returns a value of 0 if the horizontal scroll bar is not required by this scroll box or it is not visible.</docstr>
      </function>
      <function name="CreateScrollContent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="CreateAniCalculations">
        <docstr>Constructs a TScrollCalculations type object in which you can set properties and calculate parameters of the inertial scrolling.
CreateAniCalculations calls the TScrollCalculations.Create constructor to create a TScrollCalculations object. The created object is kept in the AniCalculations property of the current TScrollBox instance. Using this TScrollCalculations object you can set the Animation, DecelerationRate, BoundsAnimation, AutoShowing, and Shown properties of inertial scrolling. 
TScrollCalculations is the descendant of the TAniCalculations class, which provides methods to calculate parameters of the inertial scrolling. 
UpdateAniCalculations calls CreateAniCalculations to create a TScrollCalculations object and then calls 
DoUpdateAniCalculations to set the default inertial scrolling properties under the current platform.</docstr>
      </function>
      <procedure name="DoUpdateAniCalculations">
        <docstr>Sets the default inertial scrolling properties for the current platform.
DoUpdateAniCalculations is called from UpdateAniCalculations to set the default values to the Animation, 
TouchTracking, BoundsAnimation, and AutoShowing properties of the inertial scrolling under the current platform. DoUpdateAniCalculations sets the properties of the TScrollCalculations object kept in the AniCalculations property.</docstr>
      </procedure>
      <procedure name="UpdateAniCalculations">
        <docstr>Initializes the inertial scrolling and sets its properties.
UpdateAniCalculations calls 
CreateAniCalculations to create a TScrollCalculations object handling calculations of the inertial scrolling and calls DoUpdateAniCalculations to update the 
TouchTracking, BoundsAnimation, and AutoShowing properties of the inertial scrolling.</docstr>
      </procedure>
      <function name="DoCalcContentBounds">
        <docstr>Calculates the ContentBounds rectangle bounding all controls in the scrolling region.
DoRealign calls DoCalcContentBounds to calculate the ContentBounds rectangle. If the OnCalcContentBounds event handler is defined, then DoRealign calls this event handler and  passes into it the calculated content bounding rectangle for additional calculations.</docstr>
      </function>
      <procedure name="DoRealignContent">
        <docstr>Changes the bounding rectangle of the content of the control to the specified rectangle, and realigns its child controls accordingly.</docstr>
      </procedure>
      <function name="GetContentBounds">
        <docstr>Returns the boundaries of the rectangle that defines the scrolling area. The result value is of type TRectF.</docstr>
      </function>
      <procedure name="MouseDown">
        <docstr>Internally executed while a mouse button is pressed over the surface of this scroll box.
You can call MouseDown programmatically in applications to simulate a mouse button down event over this scroll box.
The Button parameter specifies the mouse button that has just been pressed (for instance, TMouseButton.mbLeft).
The Shift parameter specifies the keyboard state (for instance the CTRL key pressed at the same time with the mouse click).
The X and Y parameters specify the position of the mouse cursor on the screen.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>Internally executed while the mouse is moved over the surface of this scroll box.
You can call MouseMove programmatically in applications to simulate a mouse move event over this scroll box.
The Shift parameter specifies the keyboard state (for instance, the CTRL key pressed at the same time with the mouse click).
The X and Y parameters specify the position of the mouse cursor on the screen.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>Internally executed while a mouse button is released over the surface of this scroll box.
You can call MouseUp programmatically in applications to simulate a mouse button up event over this scroll box.
The Button parameter specifies the mouse button that has just been released (for instance, TMouseButton.mbLeft).
The Shift parameter specifies the keyboard state (for instance, the CTRL key pressed at the same time with the mouse click).
The X and Y parameters specify the position of the mouse cursor on the screen.</docstr>
      </procedure>
      <procedure name="DoMouseLeave">
        <docstr>OnMouseLeave event dispatcher.
FMX.Layouts.TCustomScrollBox.DoMouseLeave inherits from FMX.Controls.TControl.DoMouseLeave. All content below this line refers to FMX.Controls.TControl.DoMouseLeave.
OnMouseLeave event dispatcher.
DoMouseLeave is called automatically when the mouse pointer leaves the control&apos;s area.
DoMouseLeave starts the animation by calling StartTriggerAnimation and applies effects by calling ApplyTriggerEffect to background the control. 
Override the protected DoMouseLeave method to provide other responses when the mouse pointer leaves the control&apos;s area.</docstr>
      </procedure>
      <procedure name="MouseWheel">
        <docstr>Internally executed while the mouse wheel is used over the surface of this scroll box.
You can call MouseWheel programmatically in applications to simulate a mouse wheel spin event over this scroll box.
The Shift parameter specifies the keyboard state (for instance, the CTRL key pressed at the same time with the mouse click).
The WheelDelta parameter specifies the position of the mouse wheel.
The Handled parameter specifies whether the mouse wheel events are handled by this scroll box control.</docstr>
      </procedure>
      <property name="ContentLayout">
        <docstr>Protected read-only property that specifies the content layout of this scroll box.</docstr>
      </property>
      <property name="Content">
        <docstr>Keeps an object that represents a scrollable content.
A TScrollBox object uses a TScrollContent object in order to provide an area onto which you can place any other graphical components. Content keeps this TScrollContent object.</docstr>
      </property>
      <property name="HScrollAlign">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="VScrollAlign">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="HScrollMargins">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="VScrollMargins">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="InInternalAlign">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="HScrollBar">
        <docstr>Specifies the horizontal scroll bar attached to this scroll box.
Read the HScrollBar read-only property to obtain the horizontal scroll bar object attached to this scroll box component.</docstr>
      </property>
      <property name="VScrollBar">
        <docstr>Specifies the vertical scroll bar attached to this scroll box.
Read the VScrollBar read-only property to obtain the vertical scroll bar object attached to this scroll box component.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Layouts.TCustomScrollBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Layouts.TCustomScrollBox.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="AniCalculations">
        <docstr>Allows you to set various parameters that control the inertial scrolling effect animation.
AniCalculations keeps a TScrollCalculations object created by CreateAniCalculations. Using properties of this object you can programmatically set values for inertial scrolling properties in order to emulate on the current platform the inertial scrolling behavior typical for other platforms. For example, you can select the emulation of the iOS scrolling behavior under Windows and vice-versa.
TScrollCalculations is the descendant of the TAniCalculations class, which provides methods to calculate parameters of the inertial scrolling.
By using AniCalculations you can set:

Whether the scrolling is animated (via the TAniCalculations.Animation property).
The deceleration rate of the inertial scrolling (via the TAniCalculations.DecelerationRate property).
Whether the inertial scrolling is bound to the area (via the TAniCalculations.BoundsAnimation property).
Whether the scrolling bars appear automatically when the scroll action is initiated (via the TAniCalculations.AutoShowing property).
Whether the scrolling bars are hidden automatically when they are not needed (via the TAniCalculations.Shown property).
other properties of the TScrollCalculations object.</docstr>
      </property>
      <property name="ViewportPosition">
        <docstr>Coordinates of the origin of the scrolling viewport specified as the offset from the origin of the content layout of this scroll box.
Coordinates are specified as the TPointF point defining the origin of the scrolling viewport in relation to the origin of the content layout of this scroll box.
A scrolling viewport (or viewport) is a rectangle bounding all controls placed on the content layout of this scroll box.</docstr>
      </property>
      <procedure name="Sort">
        <docstr>Sorts components of the layout based on the comparison function Compare. 
TFmxObjectSortCompare is declared as:

TFmxObjectSortCompare = function(item1, item2: TFmxObject): Integer;</docstr>
      </procedure>
      <procedure name="Center">
        <docstr>Scrolls to the center of the TScrollBox control.
Center only has an effect if the scroll box actually has content beyond the display area and the scroll bars are needed to scroll to view all the content held by this scroll box.</docstr>
      </procedure>
      <procedure name="ScrollBy">
        <docstr>Scrolls the view according to the given Dx and Dy offsets (relative to the current position) in the TScrollBox control. 
The Dx and Dy parameters specify offsets to the values of the horizontal and  vertical scroll bars assigned to the TScrollBox control. This means that the Dx parameter is the change in pixels horizontally (along the X axis), and the Dy parameter is the change in pixels vertically (along the Y axis). 
ScrollBy has the effect of scrolling the view, in the TScrollBox control, to the new coordinates defined by the new values of the horizontal and  vertical scroll bars. These new values are obtained from the current values of the vertical and horizontal scroll bars by decreasing them by Dx and Dy pixels, respectively. For example, if Dx is a negative value, ScrollBy scrolls the view to the left; if  Dx is a positive value, ScrollBy scrolls the view to the right.
ScrollBy only has an effect if the scroll box actually has content beyond the display area, and the scroll bars are needed to view more of the content.</docstr>
      </procedure>
      <procedure name="InViewRect">
        <docstr>Internally used.</docstr>
      </procedure>
      <function name="ClientWidth">
        <docstr>ClientWidth specifies the width of the components content (in dp). Use it to read or change the width of the component.

Note: ClientWidth is the components width without decoration. The components could be scrollbars and paddings.</docstr>
      </function>
      <function name="ClientHeight">
        <docstr>ClientHeight specifies the height of the components content (in dp). Use it to read or change the height of the component.

Note:  ClientHeight is the components height without decoration. The components could be scrollbars and paddings.</docstr>
      </function>
      <function name="GetTabList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="ContentBounds">
        <docstr>Keeps a rectangle bounding all controls in the content of this scroll box.
DoRealign calls DoCalcContentBounds to calculate the ContentBounds rectangle. If the OnCalcContentBounds event handler is defined, then DoRealign calls this event handler and  passes into it the calculated content bounding rectangle for additional calculations.
The ContentBounds property is read-only. If the value returned by ContentBounds needs to be changed, you need to override DoCalcContentBounds or to assign the OnCalcContentBounds event handler.</docstr>
      </property>
      <procedure name="InvalidateContentSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RealignContent">
        <docstr>Realigns the children controls of this scroll box in the scrolling area of this scroll box. 
RealignContent can be overridden in subclasses to allow further functionality when performing the alignment of the objects inside the ContentBounds scrolling area of this scroll box.</docstr>
      </procedure>
      <property name="AutoHide">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="DisableMouseWheel">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ShowScrollBars">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ShowSizeGrip">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <event name="OnViewportPositionChange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnHScrollChange">
        <docstr>Raises when the horizontal scrollbar value was changed.
When the scroll position is changing at the ViewportPosition change, this event does not raise.</docstr>
      </event>
      <event name="OnVScrollChange">
        <docstr>Raises when the vertical scrollbar value was changed.
When the scroll position is changing at the ViewportPosition change, this event does not raise.</docstr>
      </event>
      <event name="OnCalcContentBounds">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Layouts" name="TScrollBox">
    <docstr>Extends TCustomScrollBox declaring published properties.
TScrollBox extends TCustomScrollBox declaring published properties. TScrollBox does not extend the base class with any new functionality.
In difference to TFramedScrollBox, TScrollBox does not draw the edges (top, left, bottom, and right) and does not fill the control rectangle with any special color. Therefore, by default TScrollBox is not highlighted from the background of a parent control.</docstr>
    <members>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Layouts.TScrollBox.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Layouts" name="TVertScrollBox">
    <docstr>Represents a TScrollBox restricted to vertical scrolling.</docstr>
    <members>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.Layouts.TVertScrollBox.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <function name="DoCalcContentBounds">
        <docstr>Calculates the ContentBounds rectangle bounding all controls in the scrolling region.
FMX.Layouts.TVertScrollBox.DoCalcContentBounds inherits from FMX.Layouts.TCustomScrollBox.DoCalcContentBounds. All content below this line refers to FMX.Layouts.TCustomScrollBox.DoCalcContentBounds.
Calculates the ContentBounds rectangle bounding all controls in the scrolling region.
DoRealign calls DoCalcContentBounds to calculate the ContentBounds rectangle. If the OnCalcContentBounds event handler is defined, then DoRealign calls this event handler and  passes into it the calculated content bounding rectangle for additional calculations.</docstr>
      </function>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Layouts.TVertScrollBox.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="DoUpdateAniCalculations">
        <docstr>Sets the default inertial scrolling properties for the current platform.
DoUpdateAniCalculations calls the inherited TCustomScrollBox.DoUpdateAniCalculations to set the default values to the Animation, TouchTracking, 
BoundsAnimation,  and AutoShowing properties of the inertial scrolling under the current platform. In the TVertScrollBox class, DoUpdateAniCalculations permits only vertical TouchTracking if vertical touch tracking is supported under the current platform. DoUpdateAniCalculations sets the properties of the TScrollCalculations object kept in the AniCalculations property.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Layouts" name="THorzScrollBox">
    <docstr>Represents a TScrollBox  restricted to horizontal scrolling.</docstr>
    <members>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.Layouts.THorzScrollBox.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <function name="DoCalcContentBounds">
        <docstr>Calculates the ContentBounds rectangle bounding all controls in the scrolling region.
FMX.Layouts.THorzScrollBox.DoCalcContentBounds inherits from FMX.Layouts.TCustomScrollBox.DoCalcContentBounds. All content below this line refers to FMX.Layouts.TCustomScrollBox.DoCalcContentBounds.
Calculates the ContentBounds rectangle bounding all controls in the scrolling region.
DoRealign calls DoCalcContentBounds to calculate the ContentBounds rectangle. If the OnCalcContentBounds event handler is defined, then DoRealign calls this event handler and  passes into it the calculated content bounding rectangle for additional calculations.</docstr>
      </function>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Layouts.THorzScrollBox.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="DoUpdateAniCalculations">
        <docstr>Sets the default inertial scrolling properties for the current platform.
DoUpdateAniCalculations calls the inherited TCustomScrollBox.DoUpdateAniCalculations to set the default values to the Animation, TouchTracking, 
BoundsAnimation, and AutoShowing properties of the inertial scrolling under the current platform. In the THorzScrollBox class, DoUpdateAniCalculations permits only horizontal TouchTracking if horizontal touch tracking is supported under the current platform. DoUpdateAniCalculations sets the properties of the TScrollCalculations object kept in the AniCalculations property.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Layouts" name="TFramedScrollBox">
    <docstr>Extends TCustomScrollBox declaring published properties.
TFramedScrollBox extends TCustomScrollBox declaring published properties. TFramedScrollBox does not extend the base class with any new functionality.
In difference to TScrollBox, TFramedScrollBox draws the edges (top, left, bottom, and right) and fills the control rectangle with some special color. Therefore, TFramedScrollBox scroll boxes are highlighted from the background of a parent control.</docstr>
    <members>
      <function name="IsOpaque">
        <docstr>Indicates if the control should update effects when you scroll content.
FMX.Layouts.TFramedScrollBox.IsOpaque inherits from FMX.Layouts.TCustomScrollBox.IsOpaque. All content below this line refers to FMX.Layouts.TCustomScrollBox.IsOpaque.
Indicates if the control should update effects when you scroll content.
Its default value is False, meaning that the control does not update effects.
In the TFramedScrollBox and TFramedVertScrollBox classes IsOpaque returns True.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.Layouts" name="TFramedVertScrollBox">
    <docstr>Represents a TFramedScrollBox with an applied framedscrollboxstyle style lookup.</docstr>
    <members>
      <function name="IsOpaque">
        <docstr>Indicates if the control should update effects when you scroll content.
FMX.Layouts.TFramedVertScrollBox.IsOpaque inherits from FMX.Layouts.TCustomScrollBox.IsOpaque. All content below this line refers to FMX.Layouts.TCustomScrollBox.IsOpaque.
Indicates if the control should update effects when you scroll content.
Its default value is False, meaning that the control does not update effects.
In the TFramedScrollBox and TFramedVertScrollBox classes IsOpaque returns True.</docstr>
      </function>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.Layouts.TFramedVertScrollBox.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.Layouts" name="TGridLayout">
    <docstr>A control that arranges child controls in a grid of equally sized cells.
A TGridLayout grid layout is a container for graphical objects that can arrange the objects it contains in a grid, as shown in the following image:


The children of a TGridLayout are resized to fit the sizes specified through the ItemHeight and ItemWidth properties. If the orientation is set to Horizontal, the child controls of a TGridLayout are lined one by one until the width of the layout is exceeded when a new line is added to the grid. If the orientation is set to Vertical, the child controls of a TGridLayout are positioned one under another until the height of the layout is exceeded when a new column is added to the grid. 
However, you can customize sizes of child controls using the Margins properties of child controls. For example, the following image demonstrates the usage of different margins for Button5, Button6, Button7, and Button8 child controls: 


Here we set:

The Top and Bottom margins for Button5.
The Left margin for Button6.
All four Top, Left, Right, and Bottom margins for Button7.
The Top and Left margins for Button8.
Look how child controls are resized and positioned inside the respective grid cells.

Note: The Align property of the controls within a TGridLayout is ignored. The Position, Height, and Width properties for child controls are automatically set, and explicitly changing their values has no effect.</docstr>
    <members>
      <procedure name="DoRealign">
        <docstr>Performs the alignment of a FireMonkey control.
FMX.Layouts.TGridLayout.DoRealign inherits from FMX.Controls.TControl.DoRealign. All content below this line refers to FMX.Controls.TControl.DoRealign.
Performs the alignment of a FireMonkey control.

 See Also
FMX.Types.AlignObjects</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.Layouts.TGridLayout.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Layouts.TGridLayout.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Layouts.TGridLayout.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <property name="ItemHeight">
        <docstr>Specifies the height of each cell that holds an item in a grid layout control.
Use ItemHeight in combination with ItemWidth in order to change the aspect ratio of the graphical objects that are part of this grid layout.</docstr>
      </property>
      <property name="ItemWidth">
        <docstr>Specifies the width of each cell that holds an item in a grid layout control.
Use ItemWidth in combination with ItemHeight in order to change the aspect ratio of the graphical objects that are part of this grid layout.</docstr>
      </property>
      <property name="Orientation">
        <docstr>Specifies the orientation of the graphical controls that are part of this grid.
The Orientation property can be set to either Horizontal or Vertical in order to change the grid&apos;s orientation (and the position of the graphical objects in this grid) to either horizontal (left to right) or vertical (top to bottom).</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Layouts" name="TGridPanelLayout">
    <docstr>Implements a grid panel layout control in which each component is placed within a cell on a grid panel.
In a TGridPanelLayout layout, you specify the number of rows and columns on the grid panel, then each component is placed into the next available cell in the grid panel, regardless of where you place it with the mouse. If each grid panel layout&apos;s cell already contains a control and you add more controls, the location for the new controls is determined by the ExpandStyle property. For example, using the default AddRows value of the ExpandStyle property, a new row is added to the grid panel, and each cell in this row can contain a new control. 
TGridPanelLayout layouts provide the following behavior:

You can explicitly set the Height,  Width, Align, and Anchors properties of child controls to manually resize and align child controls placed inside cells on a TGridPanelLayout layout:

You can specify that a child control can span on several merged cells. For example, look at the following figure:

Here, the B4 button spans on two cells in the rightmost column, the B5 button occupies four cells in two rows and two columns and the B8 button occupies three cells in the bottom row.
To specify that a child control can span on several cells you can use the following trick:

In the Structure view, locate the desired TGridPanelLayout layout node.
Under this node, locate the respective Control Collection node.
Among control items in this Control Collection, select the control item associated with the desired child control. The Object Inspector shows the properties of this control item.
In the ColumnSpan property, type the number of cells that can be occupied be the control item in the respective column (specified in the Column property).
In the RowSpan property, type the number of cells that can be occupied by the control item in the respective row (specified in the Row property).</docstr>
    <members>
      <procedure name="DoRealign">
        <docstr>Performs the alignment of a FireMonkey control.
FMX.Layouts.TGridPanelLayout.DoRealign inherits from FMX.Controls.TControl.DoRealign. All content below this line refers to FMX.Controls.TControl.DoRealign.
Performs the alignment of a FireMonkey control.

 See Also
FMX.Types.AlignObjects</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.Layouts.TGridPanelLayout.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="AutoAddColumn">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="AutoAddRow">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="RemoveEmptyAutoAddColumns">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RemoveEmptyAutoAddRows">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="CellToCellIndex">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="CellIndexToCell">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoPaint">
        <docstr>Processes the painting of the control. 
FMX.Layouts.TGridPanelLayout.DoPaint inherits from FMX.Controls.TControl.DoPaint. All content below this line refers to FMX.Controls.TControl.DoPaint.
Processes the painting of the control. 
This method is called internally from PaintTo and PaintChildren. DoPaint defines the drawing area by clipping the Canvas to the areas occupied by the control and its children, paints the children and then the control itself. The call to DoPaint is always preceded by a call to Painting and succeeded by a call to AfterPaint.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.Layouts.TGridPanelLayout.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Layouts.TGridPanelLayout.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.Layouts.TGridPanelLayout.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <function name="IsColumnEmpty">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="IsRowEmpty">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="UpdateControlsColumn">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="UpdateControlsRow">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="CellCount">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ColumnCollection">
        <docstr>Keeps the TColumnCollection column collection in the TGridPanelLayout grid panel layout. 
The Count property of ColumnCollection defines the number of columns in TGridPanelLayout.</docstr>
      </property>
      <property name="ControlCollection">
        <docstr>Keeps the TControlCollection control collection of TControlItem control items.
Use ControlCollection to add, remove, or access control items in the collection of controls in a TGridPanelLayout grid panel layout. Each control item is identified by its Row and Column properties.</docstr>
      </property>
      <property name="ExpandStyle">
        <docstr>Specifies whether to add a row or column to a filled grid panel layout to accommodate additional controls.
The meanings of the options are:



Value

Meaning



AddRows



TGridPanelLayout is expanded vertically -- only rows are added.




AddColumns



TGridPanelLayout is expanded horizontally -- only columns are added.




FixedSize



TGridPanelLayout has a fixed number of rows and columns given by the Count property of both the ColumnCollection and RowCollection collections.


The property is used when a new control is added to the  ControlCollection using 
AddControl with the AColumn and ARow parameters set to -1. For example:

GridPanelLayout1.ControlCollection.AddControl(AControl,-1,-1);

where AControl is the control to add to the GridPanelLayout1 grid panel layout.</docstr>
      </property>
      <property name="RowCollection">
        <docstr>Keeps the TRowCollection row collection in the TGridPanelLayout grid panel layout. 
The Count property of RowCollection defines the number of rows in TGridPanelLayout.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Layouts" name="TFlowLayout">
    <docstr>A control that arranges its child controls as if they were words in a paragraph.
The children of a TFlowLayout are lined one by one. When the Width of the layout is exceeded, the remaining child controls are wrapped to the next line and so on until all of the controls are placed. To add a line break, like in a normal text, add a TFlowLayoutBreak to the current TFlowLayout. 
The direction of the controls flow can be from left to right or from right to left. To change the direction, set the FlowDirection property. Changing the direction does not change the line of the control, only the order of the controls on each line.
The distance between controls from the same line and the distance between lines can be customized by setting the HorizontalGap and VerticalGap properties.
The TFlowLayout children can be aligned as words in a paragraph: left, right, center, or justified. The alignment can be customized through the Justify property. The alignment of the last line within the layout is treated separately, and can be set through the JustifyLastLine property. If there is a single line, Justify has no effect, the line is treated as a last line, and is aligned according to JustifyLastLine.

Note: The Align property of the controls within a TFlowLayout is ignored. The Position property for child controls is automatically set, and explicitly changing its value has no effect. 
The TFlowLayout can be used to obtain this kind of results:</docstr>
    <members>
      <procedure name="DoRealign">
        <docstr>Performs the alignment of a FireMonkey control.
FMX.Layouts.TFlowLayout.DoRealign inherits from FMX.Controls.TControl.DoRealign. All content below this line refers to FMX.Controls.TControl.DoRealign.
Performs the alignment of a FireMonkey control.

 See Also
FMX.Types.AlignObjects</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.Layouts.TFlowLayout.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.Layouts.TFlowLayout.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="SetJustify">
        <docstr>Setter function for the Justify property. Value specifies the new value of the Justify property.</docstr>
      </procedure>
      <procedure name="SetJustifyLast">
        <docstr>Setter function for the JustifyLastLine property. Value specifies the new value of the JustifyLastLine property.</docstr>
      </procedure>
      <procedure name="SetFlowDirection">
        <docstr>Setter function for the FlowDirection property. Value specifies the new value of the FlowDirection property.</docstr>
      </procedure>
      <procedure name="SetHGap">
        <docstr>Setter function for the HorizontalGap property. Value specifies the new value of the HorizontalGap property.</docstr>
      </procedure>
      <procedure name="SetVGap">
        <docstr>Setter function for the VerticalGap property. Value specifies the new value of the VerticalGap property.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.Layouts.TFlowLayout.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <property name="Justify">
        <docstr>Specifies the justification of all the lines within TFlowLayout, except the last line.
If there is a single line, Justify has no effect, the line is treated as a last line, and is aligned according to JustifyLastLine.</docstr>
      </property>
      <property name="JustifyLastLine">
        <docstr>Specifies the justification of the last line of a TFlowLayout. 
If there is a single line, Justify has no effect, the line is treated as a last line, and is aligned according to JustifyLastLine.</docstr>
      </property>
      <property name="FlowDirection">
        <docstr>Specifies the direction in which the controls are arranged within the TFlowLayout lines.
The direction of the controls flow can be from left to right or from right to left. Changing the direction does not change the line of the control, only the order of the controls on each line. 



Value

Result



LeftToRight








RightToLeft</docstr>
      </property>
      <property name="HorizontalGap">
        <docstr>Specifies the minimum distance between two adjacent child controls of a TFlowLayout.
If HorizontalGap has a negative value, the child controls are overlapped following the direction specified by the FlowDirection property.



Gap and direction

Result



Positive Gap 








Negative Gap; Direction=LeftToRight








Negative Gap; Direction=RightToLeft</docstr>
      </property>
      <property name="VerticalGap">
        <docstr>Specifies the minimum distance between two adjacent lines of a TFlowLayout.
If the VerticalGap has a negative value, the lines are overlapped.



Gap

Result



Positive Gap 








Negative Gap</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Dialogs" name="TOpenDialog">
    <docstr>TOpenDialog is a class used to display a file-selection dialog.
Use TOpenDialog to display a dialog box for selecting and opening files. 
When the user clicks the Open button, the dialog closes and the selected files are stored in the Files property.

Note: The dialog does not appear at run time until it is activated by a call to the Execute method.</docstr>
    <members>
      <function name="DoCanClose">
        <docstr>OnCanClose event dispatcher.
DoCanClose is called automatically when the user closes the dialog. 
DoCanClose returns True (by default) to allow closing the dialog or False to prevent the dialog from closing. 
DoCanClose executes the handler of the OnCanClose event if defined and allows you to set the CanClose parameter of the OnCanClose event handler to True or False. DoCanClose returns the value that CanClose has after the event handler finishes.</docstr>
      </function>
      <procedure name="DoSelectionChange">
        <docstr>OnSelectionChange event dispatcher.
DoSelectionChange is called automatically whenever the file selection is changed. 
DoSelectionChange executes the handler of the OnSelectionChange event if defined.</docstr>
      </procedure>
      <procedure name="DoFolderChange">
        <docstr>OnFolderChange event dispatcher.
DoFolderChange is called automatically when the directory whose contents are displayed in the dialog changes. 
DoFolderChange executes the handler of the OnFolderChange event if defined.</docstr>
      </procedure>
      <procedure name="DoTypeChange">
        <docstr>OnTypeChange event dispatcher.
DoTypeChange is called automatically when the selection from the type combo box in the dialog is changed.
DoTypeChange executes the handler of the OnTypeChange event if defined.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Dialogs.TOpenDialog.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="DoExecute">
        <docstr>Displays the dialog box.
FMX.Dialogs.TOpenDialog.DoExecute inherits from FMX.Dialogs.TCommonDialog.DoExecute. All content below this line refers to FMX.Dialogs.TCommonDialog.DoExecute.
Displays the dialog box.
For TCommonDialog, DoExecute does nothing.  
TCommonDialog descendants override the DoExecute method in order to properly display the required dialog box. DoExecute returns a Boolean value, usually True if the user has clicked OK, and False otherwise.

Note: DoExecute is a protected method for TCommonDialog descendants; therefore, to display the dialog box, call Execute instead.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates and initializes a TOpenDialog instance.
Create generates a TOpenDialog instance, but the new dialog does not appear on the form at runtime until the Execute method is called.
AOwner is the component that is responsible for freeing the TOpenDialog instance. It becomes the value of the Owner property.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the TOpenDialog object and frees its memory.
Do not call Destroy directly in an application. Call Free instead. Free calls Destroy if the TOpenDialog reference is not nil.</docstr>
      </destructor>
      <property name="Files">
        <docstr>Represents the list containing the absolute paths of the selected files.
Files represents a string list that contains the absolute path of each selected file. 

Note: In order for the user to select multiple files, set the ofAllowMultiSelect flag in Options.</docstr>
      </property>
      <property name="HistoryList">
        <docstr>Maintains a list of the previously selected files. Obsolete property.
HistoryList is maintained for compatibility with older versions of TOpenDialog. It is not used.</docstr>
      </property>
      <property name="DefaultExt">
        <docstr>Specifies a default file extension.
DefaultExt specifies a file extension that is appended automatically to the selected file name, unless the selected file name already includes a registered extension.
Extensions longer than three characters are not supported. Do not include the period (.) that separates the file name from the extension.</docstr>
      </property>
      <property name="FileName">
        <docstr>Indicates the absolute path for the last file selected.
The FileName represents the absolute (full) path of the file most recently selected from the dialog. The value of FileName is the same as the first item in the Files property.</docstr>
      </property>
      <property name="Filter">
        <docstr>Represents the file masks (filters) of the dialog.
The file-selection dialog includes a drop-down list of file types on the left of the &apos;File Name:&apos; edit box. When the user picks a file type from the list, only files of the selected type are displayed in the dialog. You can select only one filter at a time.
In order for Filter to work properly, the assigned string must be formatted as follows: 
&apos;&lt;first displayed name&gt;|&lt;first file extension&gt;|&lt;second displayed name&gt;|&lt;second file extension&gt;|...|&lt;n-th displayed name&gt;|&lt;n-th file extension&gt;&apos;
For example, the next code sample will add filters for text and executable files:

  OpenDialog1.Filter:=&apos;Applications (*.exe)|*.EXE|Text files (*.txt)|*.TXT&apos;;</docstr>
      </property>
      <property name="FilterIndex">
        <docstr>Determines which filter is selected by default when the dialog opens.
FilterIndex determines which of the file types in Filter is selected by default when the dialog opens. Set FilterIndex to 1 to choose the first file type in the list as default, 2 to choose the second file type as the default, and so on. If the value of FilterIndex is out of range, the last file type listed in Filter is selected by default.</docstr>
      </property>
      <property name="InitialDir">
        <docstr>Determines which directory is selected by default when the dialog opens.
InitialDir determines the default directory displayed in the file-selection dialog when it opens.
If no value is assigned to InitialDir, or the specified directory does not exist, the initial directory is controlled by a special registry key assigned to your application.

Note: For Windows, the registry key can be found at HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedMRU\.</docstr>
      </property>
      <property name="Options">
        <docstr>Determines the appearance and behavior of the file-selection dialog.
Use the Options property to customize the appearance and functionality of the dialog.</docstr>
      </property>
      <property name="OptionsEx">
        <docstr>Augments the Options property with additional flags that determine the appearance and behavior of the file selection dialog.
Use the OptionsEx property to further customize the file open dialog beyond the options covered by the Options property.</docstr>
      </property>
      <property name="Title">
        <docstr>Specifies the text displayed in the dialog&apos;s title bar.
Use Title to set the text that appears in the file-selection dialog&apos;s title bar. If no value is assigned to Title, the dialog&apos;s title is &quot;Open&quot;.</docstr>
      </property>
      <event name="OnCanClose">
        <docstr>Occurs when the user tries to close the dialog.
Write an OnCanClose event handler to provide custom validation of the value of FileName. File selection dialogs provide a number of built-in validations, such as checking for invalid characters, prompting for confirmation before overwriting, checking whether a file or path exists, and so on. These validations can be specified using the Options property. However, applications can provide additional validation of file names in an OnCanClose event handler. 
Set the CanClose parameter to False to prevent the dialog from closing. The OnCanClose event handler is responsible for telling the user why the dialog doesn&apos;t close.</docstr>
      </event>
      <event name="OnFolderChange">
        <docstr>Occurs when the current work directory from the dialog is changed.
The OnFolderChange event occurs when the user changes the directory whose contents are displayed in the dialog. This can happen when the user double-clicks a directory, clicks the Up arrow, or uses the list box at the top of the dialog to navigate through the directory structure.</docstr>
      </event>
      <event name="OnSelectionChange">
        <docstr>Occurs when file names displayed in the dialog are changed.
The OnSelectionChange event occurs whenever the file selection is changed. This can include opening the file-selection dialog box, highlighting a file or directory, selecting a new filter, selecting a new directory, or creating a new folder.
The currently selected file is stored in the FileName and Files properties. Files is used for multiple file selection.
The Sender parameter is an instance of the TOpenDialog.</docstr>
      </event>
      <event name="OnTypeChange">
        <docstr>Occurs when the selection from the type combo box in the dialog is changed.
The OnTypeChange event occurs when the user selects a new filter from the Type combo box at the bottom of the dialog. This includes the moment when the TOpenDialog is displayed.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.SearchBox" name="TSearchBox">
    <docstr>A search edit control.
TSearchBox is an edit control that provides search capabilities such as filtering the result in the parent.</docstr>
    <members>
      <function name="DefinePresentationName">
        <docstr>Returns the name of the default presentation proxy that your presented control uses.
FMX.SearchBox.TSearchBox.DefinePresentationName inherits from FMX.Controls.Presentation.TPresentedControl.DefinePresentationName. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefinePresentationName.
Returns the name of the default presentation proxy that your presented control uses.
You can handle OnPresentationNameChoosing to specify a presentation proxy name to use instead of the name that DefinePresentationName returns.
DefinePresentationName  calls TPresentationProxyFactory.GeneratePresentationName and returns a generated  presentation proxy name based on the class name of the presented control and the control type (Styled or Platform) of the presentation layer. For example:



Class name

Control type

Result


TMyPresentedControl

Styled

&quot;MyPresentedControl-Styled&quot;


TMyPresentedControl

Platform

&quot;MyPresentedControl-Platform&quot;

 See Also
System.TObject.ClassName
FMX.Controls.Presentation.TPresentedControl.ControlType
FMX.Presentation.Factory.TPresentationProxyFactory.Register
FMX.Controls.Presentation.TPresentationProxy
FMX.Controls.Presentation.TPresentedControl.OnPresentationNameChoosing
FMX.Controls.Presentation.TPresentedControl.LoadPresentation</docstr>
      </function>
      <function name="DefineModelClass">
        <docstr>Returns a class reference to a data model of this presented control.
FMX.SearchBox.TSearchBox.DefineModelClass inherits from FMX.Controls.Presentation.TPresentedControl.DefineModelClass. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefineModelClass.
Returns a class reference to a data model of this presented control.
Returns a class reference to a data model class that the constructor of this presented control uses to create a data model for the control.
By default DefineModelClass returns TDataModel. Descendant classes reimplement DefineModelClass to determine the data model class that a descendant presented control uses for its data model.

 See Also
FMX.Controls.Model.TDataModelClass
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Presentation.Style.TStyledPresentation.DefineModelClass
Class References</docstr>
      </function>
      <procedure name="ParentChanged">
        <docstr>Sends a PM_REFRESH_PARENT message to the presentation layer through its presentation proxy when the parent of this control changes.
FMX.SearchBox.TSearchBox.ParentChanged inherits from FMX.Controls.Presentation.TPresentedControl.ParentChanged. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.ParentChanged.
Sends a PM_REFRESH_PARENT message to the presentation layer through its presentation proxy when the parent of this control changes.

 See Also
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Controls.TControl.ParentChanged
FMX.Controls.Presentation.TPresentedControl.AncestorParentChanged</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.SearchBox.TSearchBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <property name="Model">
        <docstr>The data model representing the data used by the presentation of the current control.
FMX.SearchBox.TSearchBox.Model inherits from FMX.Controls.Presentation.TPresentedControl.Model. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Model.
The data model representing the data used by the presentation of the current control.
The constructor of your presented control creates a data model for your presented control. The class of the data model is the class that DefineModelClass returns.

 See Also
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Presentation
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.DefineModelClass</docstr>
      </property>
      <event name="OnFilter">
        <docstr>Event handler for setting the custom filter on the text of TSearchBox.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.Types" name="TWindowHandle">
    <docstr></docstr>
    <members>
      <function name="GetScale">
        <docstr>Returns window scale factor.</docstr>
      </function>
      <function name="IsScaleInteger">
        <docstr>Returns True if Scale is integer value.</docstr>
      </function>
      <property name="Scale">
        <docstr>Window scale factor.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Types" name="TBounds">
    <docstr>Specifies the bounds for a control.
TBounds is used in the Margins and Padding properties of TControl and its descendants. TBounds help define the relative position between components on a form, and between the edges of the form and the component. For example, when you set the left bound for a component to 10 pixels, the component will not come closer than 10 pixels to the edge of the container, or to another component on the left edge. The number of pixels by which two components are separated is the sum of the pixels of both components.
You can define the amount of margin that should surround the component on the Top, Left, Bottom, or Right by changing the pixel value for the Margins and Padding  properties in the Object Inspector.
Margins and Padding depend on the Align property. To see the effect, set the Margins property on a parent control and set the Align property for the child control to vaClient.</docstr>
    <members>
      <procedure name="DefineProperties">
        <docstr>Reads and writes otherwise unpublished data the same as a property.</docstr>
      </procedure>
      <procedure name="DoChange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Constructs a TBounds object and initializes its data before the object is first used.</docstr>
      </constructor>
      <procedure name="Assign">
        <docstr>Copies the contents of another similar object to the current instance.</docstr>
      </procedure>
      <function name="Equals">
        <docstr>Checks whether the current instance and the Obj parameter are equal.
FMX.Types.TBounds.Equals inherits from System.TObject.Equals. All content below this line refers to System.TObject.Equals.
Checks whether the current instance and the Obj parameter are equal.
The function has one Obj parameter of the TObject type.
By default, the Equals method shows whether the addresses corresponding to the current object and the Obj object are identical. The method returns a boolean value that represents the equality between the two addresses. 


Note: Equals is supposed to be overridden in user-derived classes, to provide consumer objects with an equality determining function. 
For example, in the FMX.Types.TBounds class, Equals also returns True if the Rect properties of the current object and of the Obj object are equal. In the FMX.StdActns.TBaseValueRange class, Equals also returns True if all the properties of the current object and of the Obj object are equal.</docstr>
      </function>
      <function name="PaddingRect">
        <docstr>Returns a rectangle defined by the current Rect property and the R parameter.
The PaddingRect function returns a rectangle calculated by adding the Left and Top values and subtracting the Right and Bottom values of the current Rect to or from the corresponding values of the specified R rectangle.
For example, if the current Rect is (10, 20, 50, 30) and R is (20, 10, 40, 50), the result of PaddingRect is (30, 30, -10, 20). See also Padding.</docstr>
      </function>
      <function name="MarginRect">
        <docstr>Returns a rectangle defined by the current Rect property and the R parameter.
The MarginRect function returns a rectangle calculated by adding the Left and Top values and subtracting the Right and Bottom values of the current Rect to or from the corresponding values of the R rectangle.
For example, if the current Rect is (10, 20, 50, 30) and R is (20, 10, 40, 50), the result of MarginRect is (30, 30, -10, 20). See also Margins.</docstr>
      </function>
      <function name="Width">
        <docstr>Returns the width of the Rect, as the difference between the Right and Left values.</docstr>
      </function>
      <function name="Height">
        <docstr>Returns the height of the Rect, as the difference between the Bottom and Top values.</docstr>
      </function>
      <property name="Rect">
        <docstr>Specifies the bounds as a rectangle.
Use the Rect property to set and get the margins.</docstr>
      </property>
      <property name="DefaultValue">
        <docstr>Specifies the default value for the margins.
DefaultValue is automatically set when creating the TBounds instance.</docstr>
      </property>
      <function name="Empty">
        <docstr>Returns True if either the Width or Height of the Rect are empty, and False otherwise.</docstr>
      </function>
      <function name="MarginEmpty">
        <docstr>Returns True when the Left, Right, Top, and Bottom properties are simultaneously 0.</docstr>
      </function>
      <function name="ToString">
        <docstr>Returns a string containing the class name.
FMX.Types.TBounds.ToString inherits from System.TObject.ToString. All content below this line refers to System.TObject.ToString.
Returns a string containing the class name.
By default, the ToString returns a string containing the class name of the instance that is being called. 
For example, calling ToString on a TButton instance returns a string containing &quot;TButton&quot;. 

Note: ToString is intended to be overridden in user-derived classes, to provide consumer objects with a string representation.</docstr>
      </function>
      <property name="Left">
        <docstr>Specifies the left edge of the margin.
Use the Left property to set and get the left edge of the margin.</docstr>
      </property>
      <property name="Top">
        <docstr>Specifies the top edge of the margin.
Use the Top property to set and get the top edge of the margin.</docstr>
      </property>
      <property name="Right">
        <docstr>Specifies the right edge of the margin.
Use the Right property to set and get the right edge of the margin.</docstr>
      </property>
      <property name="Bottom">
        <docstr>Specifies the bottom edge of the margin.
Use the Bottom property to set and get the bottom edge of the margin.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Types" name="TPosition">
    <docstr>Used for specifying a control&apos;s position inside a form.
A TPosition object is used for representing the position of a control inside its parent, or anywhere related X and Y values are needed. The position can be specified through the X and Y values, as a Point.</docstr>
    <members>
      <procedure name="DefineProperties">
        <docstr>Provides methods to read and write unpublished data.
DefineProperties is implemented so that the position is written as a single string in the .fmx, not as separate X and Y values.
DefineProperties uses the methods of the filer passed as the Filer parameter to assign methods that can load and save the Point property.
Override DefineProperties to persist unpublished properties. Call the DefineBinaryProperty or DefineProperty method of the Filer parameter to assign methods that load or save property values.

Note: When overriding this method, call the parent class&apos; DefineProperties method first.</docstr>
      </procedure>
      <procedure name="ReadPoint">
        <docstr>Reads the coordinates of a point from the given Reader.
ReadPoint transforms the string data from the TReader given as a parameter into TPointF properties and assigns them to the Point property.</docstr>
      </procedure>
      <procedure name="WritePoint">
        <docstr>Writes the properties of the current Point into the given TWriter object.
WritePoint transforms the properties of Point into a string and writes the result in the TWriter given as a parameter.</docstr>
      </procedure>
      <procedure name="DoChange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates and initializes a TPosition instance.
Create generates a new TPosition instance. Create requires a default TPointF value as a DefaultValue for the position. The DefaultValue is usually (0,0), but can have other values also. If the position is the same as the default value, it is not stored in the .fmx file.</docstr>
      </constructor>
      <procedure name="Assign">
        <docstr>Copies the contents of another similar object to the current one.
Assign copies the properties from another TPosition instance.</docstr>
      </procedure>
      <procedure name="SetPointNoChange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="Empty">
        <docstr>Returns True if the components are the default ones, False otherwise.
Empty returns True if the X and Y coordinates are both the same as described by the DefaultValue property, False otherwise.</docstr>
      </function>
      <procedure name="Reflect">
        <docstr>Returns the reflection of the current vector across a specified line.
Use the Reflect function to obtain the reflection of the current position across the perpendicular on the point given as parameter.</docstr>
      </procedure>
      <property name="Point">
        <docstr>Specifies the coordinates of the current object as a point.
Use the Point property to specify the coordinates of a TPosition object as a point.</docstr>
      </property>
      <property name="StoreAsInt">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="DefaultValue">
        <docstr>Specifies the default coordinates of the current object.
Use the DefaultValue property to receive the default coordinates of a TPosition object.</docstr>
      </property>
      <property name="X">
        <docstr>Specifies the horizontal coordinate of the object.
Use the X property to receive or to set the horizontal coordinate of the current TPosition object.</docstr>
      </property>
      <property name="Y">
        <docstr>Specifies the vertical coordinate of the object.
Use the Y property to receive or to set the vertical coordinate of the current TPosition object.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Types" name="TControlSize">
    <docstr>Used for storing the size of FireMonkey components.
A TControlSize object is used for managing the size of the component. This can be specified through the Size, Width, Height, and PlatformDefault attributes.</docstr>
    <members>
      <procedure name="DoChange">
        <docstr>Dispatcher of the OnChange event.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TControlSize.</docstr>
      </constructor>
      <procedure name="Assign">
        <docstr>Copies the contents of another similar object.
FMX.Types.TControlSize.Assign inherits from System.Classes.TPersistent.Assign. All content below this line refers to System.Classes.TPersistent.Assign.
Copies the contents of another similar object.
Assign copies properties and other attributes of the specified Source object to the current object. The standard form of a call to Assign is:

Destination.Assign(Source); {Delphi}

Destination-&gt;Assign(Source); // C++

which tells the current object to copy the contents of the Source object to itself.
Most objects override Assign to handle the assignment of properties from similar objects. When overriding Assign, call the inherited method if the destination object cannot handle the assignment of properties from the class of the Source parameter.
If no overridden Assign method can handle the assignment of properties from Source, the method implemented in TPersistent calls the source object&apos;s AssignTo method. This allows the source object to handle the assignment. If the Source object is nil (Delphi) or NULL (C++), Assign raises an EConvertError exception.
In general, the statement

Destination := Source; {Delphi}

Destination = Source; // C++

is not the same as the statement

Destination.Assign(Source); {Delphi}

Destination-&gt;Assign(Source); // C++

The assignment operator makes Destination reference the same object as Source, whereas the Assign method copies the contents of the object referenced by Source into the object referenced by Destination.

Note: The types of some properties are also objects. If these properties have written methods that use Assign to set the value of the property, then in these cases the assignment operator does the same thing as the Assign method.</docstr>
      </procedure>
      <procedure name="SetPlatformDefaultWithoutNotification">
        <docstr>Sets the value of the PlatformDefault property without triggering the OnChange notification. This method should be used only in cases where the OnChange notification is triggered by some other mechanism.</docstr>
      </procedure>
      <procedure name="SetSizeWithoutNotification">
        <docstr>Sets the Size property to the height and width values of TSizeF and the PlatformDefault property to False. 
These changes do not cause any notification. You can change instead the Size and PlatformDefault properties directly, what calls the OnChange event.
This method should be used only in cases where the OnChange notification is triggered by some other mechanism.</docstr>
      </procedure>
      <property name="DefaultValue">
        <docstr>Represents the default values of the TControlSize Height, Width, and PlatformDefault variables.</docstr>
      </property>
      <property name="Size">
        <docstr>Sets or gets the width and height of a control as a &lt;TSizeF&gt; record.
Using this method to set the Width and Height allows both dimensions to be updated while triggering only one OnChange notification. 

Note: Setting this property will set PlatformDefault to False.</docstr>
      </property>
      <property name="Width">
        <docstr>Describes the width of a TControlSize.
Use this property to set or get the width for a TControlSize.</docstr>
      </property>
      <property name="Height">
        <docstr>Describes the height of a TControlSize.
Use this property to set or get the height for a TControlSize.</docstr>
      </property>
      <property name="PlatformDefault">
        <docstr>When this property is set to True, the size and width of the control are set automatically based on pre-defined sizes for the active platform.
Explicitly setting the Width or Height properties  automatically sets the PlatformDefault setting to False.

Note: Changing the value of PlatformDefault  triggers an OnChange notification.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Types" name="TCustomCaret">
    <docstr></docstr>
    <members>
      <procedure name="Hide">
        <docstr>hide the caret</docstr>
      </procedure>
      <procedure name="Show">
        <docstr>if possible (CanShow = True and Visible = True), the caret show.</docstr>
      </procedure>
      <property name="Pos">
        <docstr>This method is performed after changing the Displayed</docstr>
      </property>
      <procedure name="UpdateFlasher">
        <docstr>The update of the &quot;Flasher&quot;, if UpdateCount = 0.</docstr>
      </procedure>
      <property name="Visible">
        <docstr>This property controls the visibility of a caret, for the control in which the input focus.</docstr>
      </property>
      <function name="CanShow">
        <docstr>The function returns true, if the control is visible, enabled,
             has the input focus and it in an active form</docstr>
      </function>
      <property name="Displayed">
        <docstr>This property is set to True, after the successful execution of
             method Show, and is set to False after method Hide</docstr>
      </property>
      <property name="TemporarilyHidden">
        <docstr>If this property is &apos;true&apos;, the blinking control is invisible
             and does not take values of Visible, Displayed.
             When you change the properties, methods DoShow, DoHide, DoDisplayChanged not met.</docstr>
      </property>
      <property name="Flasher">
        <docstr>Blinking visual component is displayed.
             Usually this line, having a thickness of one or two pixels.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Types" name="TStyleIndexer">
    <docstr></docstr>
    <members>
      <procedure name="NeedRebuild">
        <docstr>Marks index for lazy update.</docstr>
      </procedure>
      <procedure name="RebuildIfNeeded">
        <docstr>Updates index, if it&apos;s required only.</docstr>
      </procedure>
      <procedure name="Clear">
        <docstr>Clears index.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.Types" name="TFmxObject">
    <docstr>The base class for FireMonkey components.
TFmxObject extends TComponent to provide low-level functionality to FireMonkey components, including:

Creating, destroying, and releasing objects
Cloning, storing, and loading objects from a stream
Child object manipulations (add, remove, search)
Free notifications
Support for FireMonkey styles
Support for FireMonkey animations</docstr>
    <members>
      <function name="CreateChildrenList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ResetChildrenIndicesSpan">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ResetChildrenIndices">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetBackIndex">
        <docstr>Returns the first item in the children list. This value is usually 0, but for styled objects, which have a style as the first object in the children list, this value is 1.</docstr>
      </function>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.Types.TFmxObject.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="IgnoreBindingName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="GetChildren">
        <docstr>Enumerates all child components.
FMX.Types.TFmxObject.GetChildren inherits from System.Classes.TComponent.GetChildren. All content below this line refers to System.Classes.TComponent.GetChildren.
Enumerates all child components.
GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
GetChildren expects a TGetChildProc routine that receives all enumerated components. 
Root represents the owner of the components that will be enumerated.
This method does nothing in TComponent and is expected to be overridden in descendants.</docstr>
      </procedure>
      <procedure name="SetParentComponent">
        <docstr>Sets the parent component.
FMX.Types.TFmxObject.SetParentComponent inherits from System.Classes.TComponent.SetParentComponent. All content below this line refers to System.Classes.TComponent.SetParentComponent.
Sets the parent component.
SetParentComponent is used internally in the component streaming system. It is not necessary to call it directly. 
Derived classes override this method to implement proper handling for parenting.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.Types.TFmxObject.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <function name="GetActionLinkClass">
        <docstr>Returns the associated action link class.
Returns the class reference for the TActionLink class or for one of its descendants. 
In TFmxObject, GetActionLinkClass always returns nil.
In descendant classes, GetActionLinkClass should return the appropriate class type for the action link used with the class object. When a control object of the descendant from the TFmxObject class tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass. If GetActionLinkClass returns a non-nil value, then the action object is assigned to Action. If the control object does not support actions, then GetActionLinkClass should return nil. In this case, attempting to set a value to the Action property raises the following exception:  

StrEActionNoSuported = &apos;Class %s does not support the action&apos;</docstr>
      </function>
      <procedure name="InitiateAction">
        <docstr>Calls the action link&apos;s Update method if the control is associated with an action link. Override it to customize the way the styled control initiates its associated action.</docstr>
      </procedure>
      <procedure name="DoActionChange">
        <docstr>TBasicAction.OnChange event dispatcher.
DoActionChange is called when a TBasicAction.OnChange event occurs. 
Do not call DoActionChange explicitly in an application. It is for internal use.</docstr>
      </procedure>
      <procedure name="ActionChange">
        <docstr>Specifies the behavior of a TFmxObject object when Action changes. 
By default, ActionChange does nothing. 
In descendant classes, for example in descendants of TControl, to customize the behavior of a control when Action changes, override TControl.ActionChange. 
Do not call ActionChange explicitly in an application. It is for internal use.</docstr>
      </procedure>
      <procedure name="DoActionClientChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="ActionLink">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Action">
        <docstr>Specifies the action associated with the control.
Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 

StrEActionNoSuported = &apos;Class %s does not support the action&apos;</docstr>
      </property>
      <property name="StyleIndexer">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <function name="GetParentComponent">
        <docstr>Returns the containing component.
FMX.Types.TFmxObject.GetParentComponent inherits from System.Classes.TComponent.GetParentComponent. All content below this line refers to System.Classes.TComponent.GetParentComponent.
Returns the containing component.
GetParentComponent returns a reference to the component that contains the current component, or nil if there is no container. Use HasParent to determine whether a component has a containing component. 
For example, a button on a panel on a form returns the panel, the panel returns the form, and the form returns nil.</docstr>
      </function>
      <function name="HasParent">
        <docstr>Verifies whether the component has a parent.
FMX.Types.TFmxObject.HasParent inherits from System.Classes.TComponent.HasParent. All content below this line refers to System.Classes.TComponent.HasParent.
Verifies whether the component has a parent.
Call HasParent to determine whether a specific component has a parent. 
Derived classes override this method to implement proper handling for parenting.
Use GetParentComponent to retrieve the component reference.</docstr>
      </function>
      <procedure name="AddToResourcePool">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RemoveFromResourcePool">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetParent">
        <docstr>Protected setter implementation for the Parent property.</docstr>
      </procedure>
      <procedure name="DoRootChanging">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRootChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ParentChanged">
        <docstr>Notification method called after the parent is changed. ParentChanged is a virtual method to be implemented in subclasses to allow for changing the parent of this FMX object.</docstr>
      </procedure>
      <procedure name="ChangeOrder">
        <docstr>Notification method called after the creation order is changed. ChangeOrder is a virtual method to be implemented in subclasses to allow for changing the creation order of this FMX object.</docstr>
      </procedure>
      <procedure name="ChangeChildren">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="DoInsertObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRemoveObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoDeleteChildren">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="SearchInto">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="FreeNotification">
        <docstr>Ensures that AComponent is notified that the component is going to be destroyed.
FMX.Types.TFmxObject.FreeNotification inherits from System.Classes.TComponent.FreeNotification. All content below this line refers to System.Classes.TComponent.FreeNotification.
Ensures that AComponent is notified that the component is going to be destroyed.
Use FreeNotification to register AComponent as a component that should be notified when the component is about to be destroyed. It is only necessary to register components this way when they are in a different form or have a different owner. For example, if AComponent is in another form and uses the component to implement a property, it must call FreeNotification so that its Notification method is called when the component is destroyed.
For components with the same owner, the Notification method is called automatically when an application explicitly frees the component. This notification is not sent out when components are freed implicitly, because the Owner is already being freed.</docstr>
      </procedure>
      <function name="SupportsPlatformService">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.</docstr>
      </procedure>
      <procedure name="IgnoreIntegerValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="IgnoreFloatValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="IgnoreBooleanValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="IgnoreIdentValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
FMX.Types.TFmxObject.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
FMX.Types.TFmxObject.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="BeforeDestruction">
        <docstr>Performs any necessary actions before the first destructor is called.
FMX.Types.TFmxObject.BeforeDestruction inherits from System.Classes.TComponent.BeforeDestruction. All content below this line refers to System.Classes.TComponent.BeforeDestruction.
Performs any necessary actions before the first destructor is called.
BeforeDestruction is called automatically immediately before the component&apos;s first destructor executes. Do not call it explicitly in your applications.
As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place.</docstr>
      </procedure>
      <procedure name="Release">
        <docstr>Warning: Release is deprecated.  


Marks this TFmxObject object  for delayed deletion.</docstr>
      </procedure>
      <procedure name="SetRoot">
        <docstr>Sets the Root property of each child in the children list.</docstr>
      </procedure>
      <procedure name="SetDesign">
        <docstr>Sets the csDesigning in TComponentState. Used internally by the IDE.</docstr>
      </procedure>
      <function name="Clone">
        <docstr>Returns a new cloned instance of this FMX object.
Clone internally creates and returns a new FMX object that is an exact copy of this object.

Note: The class you want to clone must be registered and be a descendant of TFmxObject. Use RegisterClass or RegisterFMXClasses for your components.</docstr>
      </function>
      <procedure name="AddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
AddObject internally calls DoAddObject that implements all business functionality of AddObject.
AddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). AddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then AddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object.</docstr>
      </procedure>
      <procedure name="InsertObject">
        <docstr>Adds the object provided in the parameter to the FChildren TList of this object (self), at the specified position (index).
The InsertObject method is similar to the AddObject method, except that InsertObject inserts the given object to the given position specified by the Index parameter.</docstr>
      </procedure>
      <procedure name="RemoveObject">
        <docstr>Removes a children object from its parent. Calling RemoveObject is equivalent to setting Parent to nil.
RemoveObject has two overloaded methods. The first one removes the object specified through the AObject parameter, which is of type TFmxObject. The second one removes the object whose index is specified through the Index parameter.

Tip: If you want to use RemoveObject on an object, that object must have been added to the children list through the AddObject method.</docstr>
      </procedure>
      <procedure name="RemoveObject">
        <docstr>Removes a children object from its parent. Calling RemoveObject is equivalent to setting Parent to nil.
RemoveObject has two overloaded methods. The first one removes the object specified through the AObject parameter, which is of type TFmxObject. The second one removes the object whose index is specified through the Index parameter.

Tip: If you want to use RemoveObject on an object, that object must have been added to the children list through the AddObject method.</docstr>
      </procedure>
      <function name="ContainsObject">
        <docstr>Returns True if the specified object is a direct child.
ContainsObject returns True if the specified object (AObject) is a direct child of this TFmxObject (self). It returns False otherwise.
Unlike IsChild, ContainsObject only returns True when passed a direct child of this object as AObject. For example, if A is a direct child of this object, and B is a direct child of A, ContainsObject returns True when passed A as AObject, but it returns False when passed B.</docstr>
      </function>
      <procedure name="Exchange">
        <docstr>Exchanges two objects from the children list. Exchange exchanges AObject1 with AObject2.</docstr>
      </procedure>
      <procedure name="DeleteChildren">
        <docstr>Deletes all the children of this FMX object.
DeleteChildren checks whether Children is assigned (children are present) and, if so, it deletes all of them. DeleteChildren also sets Children to nil.</docstr>
      </procedure>
      <function name="IsChild">
        <docstr>Returns True if the specified object is a child.
IsChild returns True if the specified object (AObject) is a child of this TFmxObject (self) or any of its children, grand-children, etc. It returns False otherwise.
Unlike ContainsObject, IsChild not only returns True when passed a direct child of this object as AObject, but also when the specified object is a grand-child, grand-grand-child, and so on of this object. For example, if A is a direct child of this object, and B is a direct child of A, IsChild returns True both when passed A as AObject and when passed B.</docstr>
      </function>
      <procedure name="BringChildToFront">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SendChildToBack">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="BringToFront">
        <docstr>Brings this FMX visual object on top of other overlapping visual controls that are on the same form.
You can call BringToFront at run time as in the following code snippet:

  Label1.BringToFront;

or, at design time, by right-clicking the FMX visual control and selecting Control &gt; Bring to Front from the pop-up menu.</docstr>
      </procedure>
      <procedure name="SendToBack">
        <docstr>Sends this FMX visual object to the background letting other overlapping visual controls that are on the same form to be on top of it.
You can call SendToBack at run time as in the following code snippet:

  Label1.SendToBack;

or, at design time by right-clicking the FMX visual control and selecting  Control &gt; Send To Back from the pop-up menu.</docstr>
      </procedure>
      <procedure name="AddObjectsToList">
        <docstr>Adds the children of this object to the given list.
The AddObjectsToList method adds all objects that are owned by this object (stored in the Children field) and all of the objects owned by them to the TList provided in the AList parameter.</docstr>
      </procedure>
      <procedure name="Sort">
        <docstr>Sorts the children in the children list using the specified sorting procedure.</docstr>
      </procedure>
      <procedure name="EnumObjects">
        <docstr>Loops through the children of this object, and runs the specified procedure once per object as the first parameter in each call.</docstr>
      </procedure>
      <procedure name="StopPropertyAnimation">
        <docstr>Stops the animation of the specified property of this FMX object.
StopPropertyAnimation iterates through all the children of this FMX object and, if one of them is of type TFloatAnimation or TColorAnimation and is assigned to the specified property (APropertyName), stops the animation.</docstr>
      </procedure>
      <procedure name="AddFreeNotify">
        <docstr>Adds AObject to the list of objects to be notified when this TFmxObject is destroyed.
The AObject parameter can be any object that implements the IFreeNotification interface, such as a TBrushResource, or a TBrushBitmap.</docstr>
      </procedure>
      <procedure name="RemoveFreeNotify">
        <docstr>Removes the given object from the free notifications list.
The RemoveFreeNotify method removes the object specified through the AObject parameter, which is of type TFmxObject.

Tip: If you want to use RemoveFreeNotify on an object, that object must have been added to the free notifications list using the AddFreeNotify method.</docstr>
      </procedure>
      <function name="FindStyleResource">
        <docstr>Returns the style resource object with the specified (AStyleLookup).
If AStyleLookup is empty, FindStyleResource returns nil. If no resource object is linked directly to the control, FindStyleResource looks for the styles of the control&apos;s children. If no resource object is found, it returns nil.
Clone determines whether the returned style resource object should be the original style object (False) or a copy of the original (True).</docstr>
      </function>
      <property name="Root">
        <docstr>Specifies the root parent of this object.
The Root property is a link to the root parent of this object.
By default, the root object is the youngest parent in the hierarchy of the object parents, which supports the IRoot interface. If no parent supports IRoot, then Root = nil.
Notice that a Root object provides the Focused, Hovered, and Captured properties. Therefore, among the Children of the Root object, at each moment, there can only be one:

Focused control.
Control that has captured the mouse.
Control over which the mouse is hovering.</docstr>
      </property>
      <property name="Stored">
        <docstr>Specifies whether this object is stored in the .XFM file.
Set the Stored property to True to store the object in the .XFM file. Otherwise, set Stored to False.</docstr>
      </property>
      <property name="TagObject">
        <docstr>Custom property that stores any object value.</docstr>
      </property>
      <property name="TagFloat">
        <docstr>Custom property that stores any floating-point value.</docstr>
      </property>
      <property name="TagString">
        <docstr>Custom property that stores any string value.</docstr>
      </property>
      <property name="ChildrenCount">
        <docstr>Read-only property that specifies the number of children in the children list.</docstr>
      </property>
      <property name="Children">
        <docstr>Stores an array of children attached to this parent component.
Use the Children property to access each of the children attached to this parent component.</docstr>
      </property>
      <property name="Data">
        <docstr>Stores a Tvalue, which is a data structure that can store different kinds of data types.
Data has no predefined meaning. Although Data is used for LiveBinding, any succesor override this behavior. Then, the behaviour of Data is based on the type of its value.

Note: Do not use this member. It is for internal use only.</docstr>
      </property>
      <property name="Parent">
        <docstr>Specifies the parent component of this FMX object.

Tip: You cannot set the parent of this component as the component itself (Self (Delphi) or this (C++Builder)).</docstr>
      </property>
      <property name="Index">
        <docstr>Specifies the index of the child object in the children array attached to this object.</docstr>
      </property>
      <property name="ActionClient">
        <docstr>Specifies whether the component object has an associated action.
If ActionClient is True, this component object is the client of an associated action. 
If ActionClient is False, this component object is not the client of an action. 
This property can be checked before calling GetActionLinkClass.</docstr>
      </property>
      <property name="StyleName">
        <docstr>Specifies the style name for this FMX component.
Read or set the StyleName property to obtain or to set the name of the style for this FireMonkey component. For instance, a TRectangle object can have StyleName set to &apos;backgroundstyle&apos; or &apos;panelstyle&apos;.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Types" name="TCustomPopupMenu">
    <docstr>Represents a pop-up menu attachable to graphical controls that support pop-up menus.
The TTextService virtual abstract class represents a pop-up context menu that can be attached to any FireMonkey graphical control that support pop-up menus, such as TImageControl, TPanel, and so on.</docstr>
    <members>
      <procedure name="DoPopup">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <event name="OnPopup">
        <docstr>Occurs just before the pop-up menu appears.
Write an OnPopup event handler to take specific action just before the pop-up menu appears. For example, use an OnPopup event handler to set the Checked, Enabled, or Visible property of individual items in the menu so that they are appropriate to the PopupComponent.</docstr>
      </event>
      <procedure name="Popup">
        <docstr>Displays the pop-up menu onscreen.
TCustomPopupMenu descendants implement Popup so that it brings up the pop-up menu onscreen. The menu appears at the screen coordinates indicated by the values (in pixels) of X and Y.</docstr>
      </procedure>
      <property name="PopupComponent">
        <docstr>Specifies the control for which the current object is a context menu.
Set the PopupComponent value to a control so that the current object will be a context menu for that control. The context menu for a control will appear when you right-click that control.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.Types" name="Log">
    <docstr></docstr>
    <members>
      <property name="Logger">
        <docstr>Referece to the logger service.</docstr>
      </property>
      <procedure name="d">
        <docstr>Log a debug message. Same arguments as Format.</docstr>
      </procedure>
      <procedure name="d">
        <docstr>Log a simple debug message.</docstr>
      </procedure>
      <procedure name="d">
        <docstr>Log a debug message with Tag, object data of Instance, Method that invokes the logger and message Msg.</docstr>
      </procedure>
      <procedure name="d">
        <docstr>Log a debug message with Tag, object data of Instance and a message Msg</docstr>
      </procedure>
      <procedure name="TimeStamp">
        <docstr>Log a time stamp with message Msg</docstr>
      </procedure>
      <function name="Trace">
        <docstr>Perform a timed execution of Func and print execution times, return function result.
           Proc receives a parameter TLogToken which can be used to mark specific points where timestamps should be taken
           in addition to complete procedure time.</docstr>
      </function>
      <function name="Trace">
        <docstr>A convenience variant of Trace&lt;TResult&gt; when token is not needed.</docstr>
      </function>
      <procedure name="Trace">
        <docstr>A convenience variant of Trace&lt;TResult&gt; for procedures.</docstr>
      </procedure>
      <procedure name="Trace">
        <docstr>A convenience variant of Trace&lt;TResult&gt; for procedures when token is not needed.</docstr>
      </procedure>
      <function name="ObjToString">
        <docstr>Get a basic string representation of an object, consisting of ClassName and its pointer</docstr>
      </function>
      <function name="ArrayToString">
        <docstr>Get a string representation of array using MakeStr function to convert individual elements.</docstr>
      </function>
      <function name="ArrayToString">
        <docstr>Get a string representation of array using TObject.ToString to convert individual elements.</docstr>
      </function>
      <procedure name="DumpFmxObject">
        <docstr>Dump complete TFmxObject with all its children.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.StdActns" name="THintAction">
    <docstr></docstr>
    <members>
      <constructor name="Create">
        <docstr>Instantiates and initializes a FireMonkey TCustomAction object.
FMX.StdActns.THintAction.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
Instantiates and initializes a FireMonkey TCustomAction object.
Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True .</docstr>
      </constructor>
      <function name="Execute">
        <docstr>Responds when a client control &quot;fires&quot;.
FMX.StdActns.THintAction.Execute inherits from FMX.ActnList.TCustomAction.Execute. All content below this line refers to FMX.ActnList.TCustomAction.Execute.
Responds when a client control &quot;fires&quot;.
Execute is called automatically when a client control &quot;fires&quot; (for example, when the user clicks a button or selects a menu item).
Execute first ensures that the action is updated. Then Execute calls the inherited System.Classes.TBasicAction.Execute method. System.Classes.TBasicAction.Execute calls the OnExecute event handler, if one is assigned. Execute returns True if an event handler is called and the action is Enabled. Otherwise, Execute returns False.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.StdActns" name="TSysCommonAction">
    <docstr>A base class for standard actions that provides system functionality.
TSysCommonAction extends the TCustomAction class redeclaring properties and events, used in system actions, with the published visibility. 
These are the following: CustomText,  Enabled,  HelpContext,  HelpKeyword,  HelpType,  Hint,  SecondaryShortCuts,  ShortCut,  Visible,  UnsupportedArchitectures,  OnCanActionExec,  OnUpdate.
The published scope of properties and events provides the possibility to use the Object Inspector for editing values of these properties and defining event handlers at design time.
Standard actions descending from TSysCommonAction are the following:

TFileExit
TWindowClose
TFileHideApp
TFileHideAppOthers.</docstr>
    <members>
      <function name="GetDefaultText">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="CanActionExec">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
FMX.StdActns.TSysCommonAction.Update inherits from System.Classes.TBasicAction.Update. All content below this line refers to System.Classes.TBasicAction.Update.
Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
      <event name="OnCanActionExec">
        <docstr>The event handler of this event can be used for confirmation that the user really wants to accomplish an action.
In descendant classes, the OnCanActionExec event handler can be used to get the user confirmation about executing the corresponding action. For example, in TFileExit, the event handler of this event can be used for confirmation that the user really wants to close an application. You can analyze the value of the ShortCutPressed property to define whether the event is activated by pressing a keyboard key or by mouse clicking.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.StdActns" name="TFileExit">
    <docstr>The standard action for shutting down the current application.
Add TFileExit to an action list to let users shut down the application using a menu, control, toolbar button, or shortcut. Clients (controls, menu commands, toolbar buttons) linked to this action cause the application to shut down. 
TFileExit is not immediate, it calls the method like Terminate that closes the main form. 
The default ShortCut for TFileExit is CMD+Q.</docstr>
    <members>
      <function name="IsSupportedInterface">
        <docstr>Returns True if this action can be realized on the current platform.
FMX.StdActns.TFileExit.IsSupportedInterface inherits from FMX.ActnList.TCustomAction.IsSupportedInterface. All content below this line refers to FMX.ActnList.TCustomAction.IsSupportedInterface.
Returns True if this action can be realized on the current platform.
As implemented in TCustomAction, IsSupportedInterface always returns True. 
IsSupportedInterface is virtual and can be overridden in descendent classes.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Instantiates and initializes a FireMonkey TCustomAction object.
FMX.StdActns.TFileExit.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
Instantiates and initializes a FireMonkey TCustomAction object.
Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True .</docstr>
      </constructor>
      <function name="HandlesTarget">
        <docstr>Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
FMX.StdActns.TFileExit.HandlesTarget inherits from System.Classes.TBasicAction.HandlesTarget. All content below this line refers to System.Classes.TBasicAction.HandlesTarget.
Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise.</docstr>
      </function>
      <procedure name="ExecuteTarget">
        <docstr>Introduces an interface for invoking an action on a target client component or control.
FMX.StdActns.TFileExit.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
Introduces an interface for invoking an action on a target client component or control.
ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard.</docstr>
      </procedure>
      <procedure name="CustomTextChanged">
        <docstr>Introduces an interface for a function that is called when the CustomText property for the action changes.
FMX.StdActns.TFileExit.CustomTextChanged inherits from FMX.ActnList.TCustomAction.CustomTextChanged. All content below this line refers to FMX.ActnList.TCustomAction.CustomTextChanged.
Introduces an interface for a function that is called when the CustomText property for the action changes.
As implemented in TCustomAction, CustomTextChanged does nothing. 
Descendant classes can override CustomTextChanged to provide business functionality.
The announced purpose of this method is to update the Text property when the CustomText property is changed.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="FMX.StdActns" name="TWindowClose">
    <docstr>The standard action for closing an active modeless form. 
TWindowClose is not immediate, it calls the Close method that closes the active modeless form. 
The default ShortCut for TWindowClose is CMD+W.</docstr>
    <members>
      <function name="HandlesTarget">
        <docstr>Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
FMX.StdActns.TWindowClose.HandlesTarget inherits from System.Classes.TBasicAction.HandlesTarget. All content below this line refers to System.Classes.TBasicAction.HandlesTarget.
Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise.</docstr>
      </function>
      <procedure name="ExecuteTarget">
        <docstr>Introduces an interface for invoking an action on a target client component or control.
FMX.StdActns.TWindowClose.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
Introduces an interface for invoking an action on a target client component or control.
ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard.</docstr>
      </procedure>
      <procedure name="CustomTextChanged">
        <docstr>Introduces an interface for a function that is called when the CustomText property for the action changes.
FMX.StdActns.TWindowClose.CustomTextChanged inherits from FMX.ActnList.TCustomAction.CustomTextChanged. All content below this line refers to FMX.ActnList.TCustomAction.CustomTextChanged.
Introduces an interface for a function that is called when the CustomText property for the action changes.
As implemented in TCustomAction, CustomTextChanged does nothing. 
Descendant classes can override CustomTextChanged to provide business functionality.
The announced purpose of this method is to update the Text property when the CustomText property is changed.</docstr>
      </procedure>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
FMX.StdActns.TWindowClose.Update inherits from System.Classes.TBasicAction.Update. All content below this line refers to System.Classes.TBasicAction.Update.
Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Instantiates and initializes a FireMonkey TCustomAction object.
FMX.StdActns.TWindowClose.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
Instantiates and initializes a FireMonkey TCustomAction object.
Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True .</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.StdActns" name="TFileHideApp">
    <docstr>The standard action for hiding and showing (if hidden) a running macOS application. 
TFileHideApp hides all windows of the receiver application, and the next application in line is activated. If the windows of the receiver application are hidden, then TFileHideApp restores the hidden windows to the screen and makes the receiver active.
The default ShortCut for TFileHideApp is CMD+H.

In the current version, TFileHideApp is implemented only for macOS.</docstr>
    <members>
      <function name="IsSupportedInterface">
        <docstr>Returns True if this action can be realized on the current platform.
FMX.StdActns.TFileHideApp.IsSupportedInterface inherits from FMX.ActnList.TCustomAction.IsSupportedInterface. All content below this line refers to FMX.ActnList.TCustomAction.IsSupportedInterface.
Returns True if this action can be realized on the current platform.
As implemented in TCustomAction, IsSupportedInterface always returns True. 
IsSupportedInterface is virtual and can be overridden in descendent classes.</docstr>
      </function>
      <function name="HandlesTarget">
        <docstr>Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
FMX.StdActns.TFileHideApp.HandlesTarget inherits from System.Classes.TBasicAction.HandlesTarget. All content below this line refers to System.Classes.TBasicAction.HandlesTarget.
Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise.</docstr>
      </function>
      <procedure name="ExecuteTarget">
        <docstr>Introduces an interface for invoking an action on a target client component or control.
FMX.StdActns.TFileHideApp.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
Introduces an interface for invoking an action on a target client component or control.
ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard.</docstr>
      </procedure>
      <procedure name="CustomTextChanged">
        <docstr>Introduces an interface for a function that is called when the CustomText property for the action changes.
FMX.StdActns.TFileHideApp.CustomTextChanged inherits from FMX.ActnList.TCustomAction.CustomTextChanged. All content below this line refers to FMX.ActnList.TCustomAction.CustomTextChanged.
Introduces an interface for a function that is called when the CustomText property for the action changes.
As implemented in TCustomAction, CustomTextChanged does nothing. 
Descendant classes can override CustomTextChanged to provide business functionality.
The announced purpose of this method is to update the Text property when the CustomText property is changed.</docstr>
      </procedure>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
FMX.StdActns.TFileHideApp.Update inherits from System.Classes.TBasicAction.Update. All content below this line refers to System.Classes.TBasicAction.Update.
Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Instantiates and initializes a FireMonkey TCustomAction object.
FMX.StdActns.TFileHideApp.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
Instantiates and initializes a FireMonkey TCustomAction object.
Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True .</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.StdActns" name="TFileHideAppOthers">
    <docstr>The standard action for hiding all macOS applications, except the receiver.
The default ShortCut for TFileHideApp is ALT+CMD+H.

In the current version, TFileHideAppOthers is implemented only for macOS.</docstr>
    <members>
      <procedure name="ExecuteTarget">
        <docstr>Introduces an interface for invoking an action on a target client component or control.
FMX.StdActns.TFileHideAppOthers.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
Introduces an interface for invoking an action on a target client component or control.
ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard.</docstr>
      </procedure>
      <procedure name="CustomTextChanged">
        <docstr>Introduces an interface for a function that is called when the CustomText property for the action changes.
FMX.StdActns.TFileHideAppOthers.CustomTextChanged inherits from FMX.ActnList.TCustomAction.CustomTextChanged. All content below this line refers to FMX.ActnList.TCustomAction.CustomTextChanged.
Introduces an interface for a function that is called when the CustomText property for the action changes.
As implemented in TCustomAction, CustomTextChanged does nothing. 
Descendant classes can override CustomTextChanged to provide business functionality.
The announced purpose of this method is to update the Text property when the CustomText property is changed.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Instantiates and initializes a FireMonkey TCustomAction object.
FMX.StdActns.TFileHideAppOthers.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
Instantiates and initializes a FireMonkey TCustomAction object.
Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True .</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.StdActns" name="TObjectViewAction">
    <docstr>A base class for actions that show a specified component when executed.
FMX.StdActns.TObjectViewAction inherits from FMX.ActnList.TCustomViewAction. All content below this line refers to FMX.ActnList.TCustomViewAction.
A base class for actions that show a specified component when executed.
Descendants of TCustomViewAction can be associated with a component that is made visible when the action executes.
TCustomViewAction extends TCustomAction declaring the component that the action shows when it executes.
TObjectViewAction extends the TCustomViewAction class that defines the FmxObject property and keeps the component value that should be the TFmxObject type object in this case. 
Descendants of TObjectViewAction are associated with the TFmxObject type component that is made visible when the action executes.  
TVirtualKeyboard and TViewAction are standard actions that descend from TObjectViewAction.
Contrary to ordinary actions (like TAction, TControlAction, TCustomValueRangeAction, and so on) TCustomViewAction (and its descendants) does not distribute changes in values of Caption, Enabled, Checked, GroupIndex, ShortCut, Visible, and OnExecute properties to the respective properties of clients linked with action links. 

 See Also
FMX.ActnList.TCustomViewAction.Component
FMX.Types.TFmxObject
FMX.StdActns.TObjectViewAction
FMX.ActnList.TActionLink
System.Actions.TContainedAction.Caption
System.Actions.TContainedAction.Enabled
System.Actions.TContainedAction.Checked
System.Actions.TContainedAction.GroupIndex
System.Actions.TContainedAction.ShortCut
System.Actions.TContainedAction.Visible
System.Classes.TBasicAction.OnExecute</docstr>
    <members>
      <procedure name="SetComponent">
        <docstr>Setter for the Component property.
FMX.StdActns.TObjectViewAction.SetComponent inherits from FMX.ActnList.TCustomViewAction.SetComponent. All content below this line refers to FMX.ActnList.TCustomViewAction.SetComponent.
Setter for the Component property.</docstr>
      </procedure>
      <function name="ComponentText">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="DoCreateComponent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="FmxObject">
        <docstr>Keeps an FMX object (of the component) that executes an action and whose image becomes visible during the execution of the action.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdActns" name="TVirtualKeyboard">
    <docstr>Shows a component stored in the FmxObject property and shows the on-screen virtual keyboard over the surface of this component.
TVirtualKeyboard standard action is executed by clients (controls, menu commands, toolbar buttons) linked to this action, and it shows the component stored in the FmxObject property. TVirtualKeyboard shows the on-screen virtual keyboard over the surface of the shown component. 
TVirtualKeyboard extends TCustomViewAction by redeclaring some public properties and events as having published visibility, which makes them editable in the Object Inspector. 
The following properties are the most important: Enabled, FmxObject, ImageIndex, SecondaryShortCuts, ShortCut, Text, ShortCut, and Visible. 
Contrary to ordinary actions (like TAction, TControlAction, TCustomValueRangeAction, and so on) TVirtualKeyboard, as a descendant of TCustomViewAction, does not distribute changes of Visible, Enabled, Checked, GroupIndex, and OnExecute to the linked clients. 
Virtual keyboard components are supported by so-called Platform Services. Therefore, this standard action might not be supported for some platforms. For more information, see UnsupportedArchitectures and UnsupportedPlatforms. 
To display the on-screen keyboard provided by the TVirtualKeyboard component, do the following:

Add a TActionList and a TButton to the form.
Double-click the TActionList to open the Action List editor.
Click the arrowhead beside the  icon, select New Standard Action &gt; Edit &gt; TVirtualKeyboard, and then click OK.
In the Object Inspector, set the Action property of the TButton to be the TVirtualKeyboard you just added to the TActionList.
Run the project.
The type of the TVirtualKeyboard is set by the KeyboardType property.

Code Examples
FMX.ScrollableForm Sample
FMX.KeyboardTypes Sample
FMX.KeyboardToolbar Sample</docstr>
    <members>
      <function name="IsSupportedInterface">
        <docstr>Returns True if this action can be realized on the current platform.
FMX.StdActns.TVirtualKeyboard.IsSupportedInterface inherits from FMX.ActnList.TCustomAction.IsSupportedInterface. All content below this line refers to FMX.ActnList.TCustomAction.IsSupportedInterface.
Returns True if this action can be realized on the current platform.
As implemented in TCustomAction, IsSupportedInterface always returns True. 
IsSupportedInterface is virtual and can be overridden in descendent classes.</docstr>
      </function>
      <procedure name="ExecuteTarget">
        <docstr>Introduces an interface for invoking an action on a target client component or control.
FMX.StdActns.TVirtualKeyboard.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
Introduces an interface for invoking an action on a target client component or control.
ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard.</docstr>
      </procedure>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
FMX.StdActns.TVirtualKeyboard.Update inherits from System.Classes.TBasicAction.Update. All content below this line refers to System.Classes.TBasicAction.Update.
Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.StdActns" name="TViewAction">
    <docstr>Shows a component stored in the FmxObject property.
TViewAction standard action is executed by clients (controls, menu commands, toolbar buttons) linked to this action and it shows the TFmxObject type component stored in the FmxObject property. 
TViewAction extends TCustomViewAction by redeclaring some public properties and events as having published visibility, which makes them editable in the Object Inspector. 
The following properties are the most important: Enabled, FmxObject, ImageIndex, SecondaryShortCuts, ShortCut, Text, ShortCut, and Visible.  
Contrary to ordinary actions (like TAction, TControlAction, TCustomValueRangeAction, and so on) TViewAction, as the TCustomViewAction descendant, does not distribute changes in Visible, Enabled, Checked, GroupIndex, and OnExecute to the linked clients.</docstr>
    <members>
      <procedure name="SetComponent">
        <docstr>Setter for the Component property.
FMX.StdActns.TViewAction.SetComponent inherits from FMX.ActnList.TCustomViewAction.SetComponent. All content below this line refers to FMX.ActnList.TCustomViewAction.SetComponent.
Setter for the Component property.</docstr>
      </procedure>
      <procedure name="ExecuteTarget">
        <docstr>Introduces an interface for invoking an action on a target client component or control.
FMX.StdActns.TViewAction.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
Introduces an interface for invoking an action on a target client component or control.
ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard.</docstr>
      </procedure>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
FMX.StdActns.TViewAction.Update inherits from System.Classes.TBasicAction.Update. All content below this line refers to System.Classes.TBasicAction.Update.
Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.StdActns" name="TBaseValueRange">
    <docstr></docstr>
    <members>
      <property name="Min">
        <docstr>Minimum permissible value of the floating-point Value range.</docstr>
      </property>
      <property name="Max">
        <docstr>Maximum permissible value of the floating-point Value range.</docstr>
      </property>
      <property name="Value">
        <docstr>A changeable floating-point parameter. 
The TBaseValueRange class associates a floating-point number Value to its Min and Max ranges.</docstr>
      </property>
      <property name="Frequency">
        <docstr>The step of possible Value variations. 
Value can be multiple of Frequency, Min, or Max. For example, if

Min = 0.1
Max = 2.1
ViewportSize = 0
Frequency = 1

then Value can be:

0.1
1
2
2.1

but it cannot be:

Value = 1.1</docstr>
      </property>
      <property name="ViewportSize">
        <docstr>Used by controls such as TScrollBar to define the thumb size. 
Note that the effective maximum value of Value decreases according to Max - ViewportSize.</docstr>
      </property>
      <procedure name="Assign">
        <docstr>Copies the contents of another similar object.
FMX.StdActns.TBaseValueRange.Assign inherits from System.Classes.TPersistent.Assign. All content below this line refers to System.Classes.TPersistent.Assign.
Copies the contents of another similar object.
Assign copies properties and other attributes of the specified Source object to the current object. The standard form of a call to Assign is:

Destination.Assign(Source); {Delphi}

Destination-&gt;Assign(Source); // C++

which tells the current object to copy the contents of the Source object to itself.
Most objects override Assign to handle the assignment of properties from similar objects. When overriding Assign, call the inherited method if the destination object cannot handle the assignment of properties from the class of the Source parameter.
If no overridden Assign method can handle the assignment of properties from Source, the method implemented in TPersistent calls the source object&apos;s AssignTo method. This allows the source object to handle the assignment. If the Source object is nil (Delphi) or NULL (C++), Assign raises an EConvertError exception.
In general, the statement

Destination := Source; {Delphi}

Destination = Source; // C++

is not the same as the statement

Destination.Assign(Source); {Delphi}

Destination-&gt;Assign(Source); // C++

The assignment operator makes Destination reference the same object as Source, whereas the Assign method copies the contents of the object referenced by Source into the object referenced by Destination.

Note: The types of some properties are also objects. If these properties have written methods that use Assign to set the value of the property, then in these cases the assignment operator does the same thing as the Assign method.</docstr>
      </procedure>
      <function name="Equals">
        <docstr>Checks whether the current instance and the Obj parameter are equal.
FMX.StdActns.TBaseValueRange.Equals inherits from System.TObject.Equals. All content below this line refers to System.TObject.Equals.
Checks whether the current instance and the Obj parameter are equal.
The function has one Obj parameter of the TObject type.
By default, the Equals method shows whether the addresses corresponding to the current object and the Obj object are identical. The method returns a boolean value that represents the equality between the two addresses. 


Note: Equals is supposed to be overridden in user-derived classes, to provide consumer objects with an equality determining function. 
For example, in the FMX.Types.TBounds class, Equals also returns True if the Rect properties of the current object and of the Obj object are equal. In the FMX.StdActns.TBaseValueRange class, Equals also returns True if all the properties of the current object and of the Obj object are equal.</docstr>
      </function>
      <function name="Same">
        <docstr>Checks whether the values of all properties of the current object are close to the values of the corresponding properties of the specified Obj object. 
This function is similar to Equals, but it uses the SameValue function to compare values. That is, if between the values there is a difference that is less than the possible rounding error, then the SameValue function estimates the values as equal and Same returns True.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.StdActns" name="TCustomValueRange">
    <docstr></docstr>
    <members>
      <procedure name="DoBeforeChange">
        <docstr>This virtual method fires the BeforeChange event. 
In descendant classes, you can override this method to provide specific actions instead of calling an assigned BeforeChange event handler.</docstr>
      </procedure>
      <procedure name="DoChanged">
        <docstr>This virtual method fires the OnChanged event. 
In descendant classes, you can override this method to provide specific actions instead of calling an assigned OnChanged event handler.</docstr>
      </procedure>
      <procedure name="DoAfterChange">
        <docstr>This virtual method fires the AfterChange event. 
In descendant classes, you can override this method to provide specific actions instead of calling an assigned AfterChange event handler.</docstr>
      </procedure>
      <procedure name="DoTrackingChange">
        <docstr>This virtual method fires the OnTrackingChange event. 
In descendant classes, you can override this method to provide specific actions instead of calling an assigned OnTrackingChange event handler.</docstr>
      </procedure>
      <property name="Initialized">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <function name="GetOwner">
        <docstr>Returns the owner of an object.
FMX.StdActns.TCustomValueRange.GetOwner inherits from System.Classes.TPersistent.GetOwner. All content below this line refers to System.Classes.TPersistent.GetOwner.
Returns the owner of an object.
GetOwner is used by the GetNamePath method to find the owner of a persistent object. GetNamePath and GetOwner are introduced in TPersistent so descendants such as collections can appear in the Object Inspector. As implemented in TPersistent, GetOwner returns nil (Delphi) or NULL (C++). 
For TOwnedCollection, GetOwner returns the owner of the collection. For TCollectionItem collection items, GetOwner returns the collection object into which the collection item has been inserted. For TComponent, GetOwner returns the value of the Owner property.</docstr>
      </function>
      <function name="MaxStored">
        <docstr>Returns True if the corresponding property value differs from the default. 
The MaxStored  virtual function returns True if the Max  property value differs from the default. That is, if Max  &lt;&gt; DefaultMaxValue. The StdActns unit declares this constant as: 

DefaultMaxValue = 100.0</docstr>
      </function>
      <function name="MinStored">
        <docstr>Returns True if the corresponding property value differs from the default. 
The MinStored  virtual function returns True if the Min  property value differs from the default. That is, if Min  &lt;&gt; 0.</docstr>
      </function>
      <function name="ValueStored">
        <docstr>Returns True if the corresponding property value differs from the default. 
The ValueStored  virtual function returns True if the Value  property value differs from the default. That is, if Value  &lt;&gt; 0.</docstr>
      </function>
      <function name="FrequencyStored">
        <docstr>Returns True if the corresponding property value differs from the default. 
The FrequencyStored  virtual function returns True if the Frequency  property value differs from the default. That is, if Frequency  &lt;&gt; 0.</docstr>
      </function>
      <function name="ViewportSizeStored">
        <docstr>Returns True if the corresponding property value differs from the default. 
The ViewportSizeStored  virtual function returns True if the ViewportSize  property value differs from the default. That is, if ViewportSize  &lt;&gt; 0.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Constructs an object and initializes its data before the object is first used.
FMX.StdActns.TCustomValueRange.Create inherits from System.TObject.Create. All content below this line refers to System.TObject.Create.
Constructs an object and initializes its data before the object is first used.
Create constructs an object. The purpose, size, and behavior of objects differ greatly. The Create constructor defined by TObject allocates memory but does not initialize data. 
Descendant objects usually define a constructor that creates the particular kind of object and initializes its data.

Note: If an exception escapes from a constructor, the object&apos;s destructor is called to clean up the failed instance.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the TPersistent instance and frees its memory.
FMX.StdActns.TCustomValueRange.Destroy inherits from System.Classes.TPersistent.Destroy. All content below this line refers to System.Classes.TPersistent.Destroy.
Destroys the TPersistent instance and frees its memory.
Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy.</docstr>
      </destructor>
      <procedure name="Assign">
        <docstr>Copies the contents of another similar object.
FMX.StdActns.TCustomValueRange.Assign inherits from System.Classes.TPersistent.Assign. All content below this line refers to System.Classes.TPersistent.Assign.
Copies the contents of another similar object.
Assign copies properties and other attributes of the specified Source object to the current object. The standard form of a call to Assign is:

Destination.Assign(Source); {Delphi}

Destination-&gt;Assign(Source); // C++

which tells the current object to copy the contents of the Source object to itself.
Most objects override Assign to handle the assignment of properties from similar objects. When overriding Assign, call the inherited method if the destination object cannot handle the assignment of properties from the class of the Source parameter.
If no overridden Assign method can handle the assignment of properties from Source, the method implemented in TPersistent calls the source object&apos;s AssignTo method. This allows the source object to handle the assignment. If the Source object is nil (Delphi) or NULL (C++), Assign raises an EConvertError exception.
In general, the statement

Destination := Source; {Delphi}

Destination = Source; // C++

is not the same as the statement

Destination.Assign(Source); {Delphi}

Destination-&gt;Assign(Source); // C++

The assignment operator makes Destination reference the same object as Source, whereas the Assign method copies the contents of the object referenced by Source into the object referenced by Destination.

Note: The types of some properties are also objects. If these properties have written methods that use Assign to set the value of the property, then in these cases the assignment operator does the same thing as the Assign method.</docstr>
      </procedure>
      <function name="GetNamePath">
        <docstr>Returns the name of the object as it appears in the Object Inspector.
FMX.StdActns.TCustomValueRange.GetNamePath inherits from System.Classes.TPersistent.GetNamePath. All content below this line refers to System.Classes.TPersistent.GetNamePath.
Returns the name of the object as it appears in the Object Inspector.
GetNamePath is for internal use only. It determines the text that the Object Inspector displays for the name of the object being edited. GetNamePath is introduced in TPersistent so descendants such as collections can appear in the Object Inspector. Do not call GetNamePath directly.
For components, GetNamePath returns the component name. For TCollectionItem objects it returns the name of the hosting component, the name of the property, and the index into the collection surrounded by brackets.</docstr>
      </function>
      <function name="IsEmpty">
        <docstr>Checks whether any of the current object properties has an assigned value. 
Returns True if any of the Value, Min, Max, ViewportSize, and Frequency properties of the current object has an assigned value.</docstr>
      </function>
      <procedure name="Clear">
        <docstr>Assigns the default values to all properties (Value, Min, Max, and so on). 
In TCustomValueRange, Clear assigns the following default values:

Value = 0,
Min = 0,
Max = 100.0,
ViewportSize = 0,
Frequency = 0.</docstr>
      </procedure>
      <property name="Tracking">
        <docstr>Controls whether the BeforeChange and AfterChange events are fired on each property change. 
If Tracking = True, then the BeforeChange and AfterChange events are fired on each property change. If Tracking = False, then the BeforeChange and AfterChange events are not fired.

Note: The OnChanged and OnTrackingChange events are fired independently from the Tracking value.</docstr>
      </property>
      <procedure name="Changed">
        <docstr>Recalculates values of properties, fires proper events, and sets IsChanged to False. 
Changed is called immediately after the value of any property (Value, Min, Max, ViewportSize, and Frequency) of the current object has been changed. It recalculates values, raises the proper events (if needed), and sets IsChanged to False. If the Owner component of the action is loading (csLoading) or UpdateCount &gt; 0, then no operations are performed and IsChanged is set to True. After loading the Owner component is finished, the component should check the IsChanged property&apos;s value and call the Changed method (if needed).
If IgnoreLoading = True, then Changed does not check the loading state (csLoading).</docstr>
      </procedure>
      <property name="IsChanged">
        <docstr>Handles whether some properties have been changed, but values are still not recalculated.</docstr>
      </property>
      <property name="New">
        <docstr>Keeps the new values of ValueRange properties. 
New is the TBaseValueRange type property that keeps the new values of the Value, Min, Max, ViewportSize, and Frequency properties of the current object, declared in the TBaseValueRange class. It can be used in the BeforeChange event handler.</docstr>
      </property>
      <property name="Min">
        <docstr>Minimum permissible value of the floating-point Value range.
FMX.StdActns.TCustomValueRange.Min inherits from FMX.StdActns.TBaseValueRange.Min. All content below this line refers to FMX.StdActns.TBaseValueRange.Min.
Minimum permissible value of the floating-point Value range.</docstr>
      </property>
      <property name="Max">
        <docstr>Maximum permissible value of the floating-point Value range.
FMX.StdActns.TCustomValueRange.Max inherits from FMX.StdActns.TBaseValueRange.Max. All content below this line refers to FMX.StdActns.TBaseValueRange.Max.
Maximum permissible value of the floating-point Value range.</docstr>
      </property>
      <property name="Value">
        <docstr>A changeable floating-point parameter.
FMX.StdActns.TCustomValueRange.Value inherits from FMX.StdActns.TBaseValueRange.Value. All content below this line refers to FMX.StdActns.TBaseValueRange.Value.
A changeable floating-point parameter. 
The TBaseValueRange class associates a floating-point number Value to its Min and Max ranges.</docstr>
      </property>
      <property name="Frequency">
        <docstr>The step of possible Value variations.
FMX.StdActns.TCustomValueRange.Frequency inherits from FMX.StdActns.TBaseValueRange.Frequency. All content below this line refers to FMX.StdActns.TBaseValueRange.Frequency.
The step of possible Value variations. 
Value can be multiple of Frequency, Min, or Max. For example, if

Min = 0.1
Max = 2.1
ViewportSize = 0
Frequency = 1

then Value can be:

0.1
1
2
2.1

but it cannot be:

Value = 1.1</docstr>
      </property>
      <property name="ViewportSize">
        <docstr>Used by controls such as TScrollBar to define the thumb size.
FMX.StdActns.TCustomValueRange.ViewportSize inherits from FMX.StdActns.TBaseValueRange.ViewportSize. All content below this line refers to FMX.StdActns.TBaseValueRange.ViewportSize.
Used by controls such as TScrollBar to define the thumb size. 
Note that the effective maximum value of Value decreases according to Max - ViewportSize.</docstr>
      </property>
      <property name="RelativeValue">
        <docstr>The Value-based position of the thumb in the scrollable control. 
The RelativeValue property is calculated relatively to Value, according to the following expression:

RelativeValue = (Value-Min)/(Max-Min-ViewportSize)

It can be in the range from 0 through 1. It can be used for positioning a thumb in a scrollable control, whose parameters are defined by the ValueRange properties (Value, Min, Max, ViewportSize, and Frequency).</docstr>
      </property>
      <property name="LastValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Increment">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <function name="Inc">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="Dec">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="Owner">
        <docstr>The owner component of this class instance.</docstr>
      </property>
      <procedure name="BeginUpdate">
        <docstr>Called when the ValueRange properties start to update. 
The BeginUpdate method is called when the object starts to change values of the ValueRange properties (Value, Min, Max, ViewportSize, and Frequency).
BeginUpdate increments the UpdateCount property&apos;s value by 1.</docstr>
      </procedure>
      <procedure name="EndUpdate">
        <docstr>Called when the ValueRange properties have finished updating. 
The EndUpdate method is called when the object accomplishes to change values of the ValueRange properties (Value, Min, Max, ViewportSize, and Frequency).
EndUpdate decrements the UpdateCount property value by 1.</docstr>
      </procedure>
      <property name="UpdateCount">
        <docstr>Counter of how many times update changes of the ValueRange properties have been started and not accomplished. 
If UpdateCount &gt; 0, then no update changes will be actually implemented, and
all (Value, Min, Max, ViewportSize, and Frequency) properties will have old values. Update changes will be actually implemented only after calls to the EndUpdate method decrement UpdateCount to 0.
To set new values to these properties, use the New property.</docstr>
      </property>
      <property name="Changing">
        <docstr>This property identifies that the TCustomValueRange type object is recalculating property values.</docstr>
      </property>
      <event name="BeforeChange">
        <docstr>This event is fired before new values of the ValueRange properties become effective.  
The BeforeChange event is fired before new values of the ValueRange properties (Value, Min, Max, ViewportSize, and Frequency) become effective. For example, Min still contains an old value, while the new value is kept only in the New.Min parameter. The BeforeChange event is fired if Tracking = True.</docstr>
      </event>
      <event name="OnChanged">
        <docstr>This event is fired after a value of any ValueRange property has changed. 
The OnChanged event is fired independently from the Tracking value, after a value of any of the ValueRange properties (Value, Min, Max, ViewportSize, and Frequency) has changed.</docstr>
      </event>
      <event name="AfterChange">
        <docstr>This event is fired after a value of any ValueRange property has changed, but only if Tracking = True. 
The AfterChange event is fired after a value of any of the ValueRange properties (Value, Min, Max, ViewportSize, and Frequency) has changed, but only if Tracking = True.</docstr>
      </event>
      <event name="OnTrackingChange">
        <docstr>This event is fired after a value of the Tracking property has changed, independently from UpdateCount.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.StdActns" name="TCustomValueRangeAction">
    <docstr></docstr>
    <members>
      <function name="CreateValueRange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.StdActns.TCustomValueRangeAction.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Instantiates and initializes a FireMonkey TCustomAction object.
FMX.StdActns.TCustomValueRangeAction.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
Instantiates and initializes a FireMonkey TCustomAction object.
Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True .</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the instance of the contained action.
FMX.StdActns.TCustomValueRangeAction.Destroy inherits from System.Actions.TContainedAction.Destroy. All content below this line refers to System.Actions.TContainedAction.Destroy.
Destroys the instance of the contained action.
If the action is contained in an action list or action manager, Destroy removes the action from that list. Then it calls the inherited Destroy method.</docstr>
      </destructor>
      <property name="ValueRange">
        <docstr>Provides access to a floating-point value and its permitted ranges.
ValueRange provides access to the Value, Min, Max, Frequency, ViewportSize, and
RelativeValue properties and to the methods handling consistency of these properties.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdActns" name="TValueRangeAction">
    <docstr></docstr>
    <members>
      <function name="CreateValueRange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TPresentedTextControl">
    <docstr></docstr>
    <members>
      <procedure name="DoRootChanging">
        <docstr>DoRootChanging is executed when the root container (typically a form) is defined or changes.
For example, DoRootChanging is executed when this control is added to a form or moved from one form to another. 
When this control works as an accelerator key receiver, DoRootChanging overrides TControl.DoRootChanging to:

Register this control to a specific form when the text control is added to the form.
Unregister and register this control from one form to another when this control is moved between forms.</docstr>
      </procedure>
      <function name="DoFilterPresentedText">
        <docstr>Filters the string contained in the Text property.
For example, you can use DoFilterPresentedText to filter the ampersand symbol of the accelerator key character.
If the control is registered as an accelerator key receiver, you can override this method to do your own filtering to the accelerator keys.</docstr>
      </function>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.StdCtrls.TPresentedTextControl.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TPresentedTextControl.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.StdCtrls.TPresentedTextControl.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <procedure name="DoStyleChanged">
        <docstr>Indicates that the control needs to update the style and calls Repaint.
FMX.StdCtrls.TPresentedTextControl.DoStyleChanged inherits from FMX.Controls.TStyledControl.DoStyleChanged. All content below this line refers to FMX.Controls.TStyledControl.DoStyleChanged.
Indicates that the control needs to update the style and calls Repaint.
FMX calls DoStyleChanged after the style was changed.</docstr>
      </procedure>
      <procedure name="SetText">
        <docstr>This property is used to change the displayed text.</docstr>
      </procedure>
      <procedure name="SetTextInternal">
        <docstr>Sets a new value to the Text property in TPresentedTextControl.
Use SetTextInternal to set a value to the text property without calling DoTextChanged.</docstr>
      </procedure>
      <procedure name="SetName">
        <docstr>Sets the value of the Name property.
FMX.StdCtrls.TPresentedTextControl.SetName inherits from System.Classes.TComponent.SetName. All content below this line refers to System.Classes.TComponent.SetName.
Sets the value of the Name property.
SetName is the virtual property setter for the Name property. It calls the ChangeName method, which performs the actual name change.
ChangeName is not virtual; override SetName instead when modifying the behavior of the Name property.

Warning: Using SetName to change the name of a component at run time causes any references to the old name to become undefined. Any subsequent code that uses the old name will cause an exception.</docstr>
      </procedure>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.StdCtrls.TPresentedTextControl.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
FMX.StdCtrls.TPresentedTextControl.SetData inherits from FMX.Types.TFmxObject.SetData. All content below this line refers to FMX.Types.TFmxObject.SetData.
Protected setter implementation for the Data property.</docstr>
      </procedure>
      <procedure name="ActionChange">
        <docstr>Sends a message to the presentation layer of the presentation proxy when the Action property changes.
FMX.StdCtrls.TPresentedTextControl.ActionChange inherits from FMX.Controls.Presentation.TPresentedControl.ActionChange. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.ActionChange.
Sends a message to the presentation layer of the presentation proxy when the Action property changes.
The presentation layer receives a message with PM_ACTION_CHANGE as MsgID and an instance of TActionInfo as Value with the following data:



Property

Data



Value.Sender



ASender




Value.CheckDefaults



ACheckDefaults


 See Also
FMX.Controls.TControl.ActionChange
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Presentation.Messages.TMessageSender.Receiver
System.TObject.Dispatch
FMX.Presentation.Messages.TDispatchMessageWithValue
FMX.Presentation.Messages.TDispatchMessageWithValue.MsgID
FMX.Presentation.Messages.TDispatchMessageWithValue.Value
FMX.Controls.Presentation.TActionInfo
FMX.Controls.Presentation.TActionInfo.Sender
FMX.Controls.Presentation.TActionInfo.CheckDefaults</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the control after the form file has been read into memory and loads its presentation.
FMX.StdCtrls.TPresentedTextControl.Loaded inherits from FMX.Controls.Presentation.TPresentedControl.Loaded. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Loaded.
Initializes the control after the form file has been read into memory and loads its presentation.
For details, see TControl.Loaded.

 See Also
FMX.Controls.Presentation.TPresentedControl.LoadPresentation
FMX.Controls.TControl.Loaded</docstr>
      </procedure>
      <function name="FindTextObject">
        <docstr>Returns the resource object that is linked to the current text object.</docstr>
      </function>
      <procedure name="UpdateTextObject">
        <docstr>Updates the text of the TextObject.
UpdateTextObject accepts the following parameters:

TextControl: TextObject.
Str: Text.
DoChanged calls UpdateTextObject.</docstr>
      </procedure>
      <property name="TextObject">
        <docstr>The control that displays the data of the control.</docstr>
      </property>
      <procedure name="DoTextChanged">
        <docstr>Executed when text is changed.
SetText calls DoTextChanged.</docstr>
      </procedure>
      <procedure name="DoEndUpdate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="CalcTextObjectSize">
        <docstr>Sets the bounds of the TextObject according to the current alignment values of that TextObject.
The parameters serve as variables where CalcTextObjectSize puts the calculated bounds:

MaxWidth: The maximum width of the text object.
Size: The actual width and height of the text object.</docstr>
      </function>
      <procedure name="SetTextSettings">
        <docstr>Setter method for the TextSettings property.</docstr>
      </procedure>
      <procedure name="SetStyledSettings">
        <docstr>Setter method for the StyledSettings property.</docstr>
      </procedure>
      <procedure name="DoChanged">
        <docstr>Updates the representation of the text that is displayed on the control.
Call this method to apply your changes to the text representation.</docstr>
      </procedure>
      <function name="StyledSettingsStored">
        <docstr>Indicates whether the set of styled text representation properties stored in StyledSettings differs from the default set for this control.
StyledSettingsStored returns True when the set of styled text representation properties stored in 
StyledSettings differs from the default set of styled text representation properties for this control.
When StyledSettingsStored returns True, then values of text representation properties of this control are stored in the corresponding FMX file.</docstr>
      </function>
      <function name="GetTextSettingsClass">
        <docstr>Returns the class type that instance represents the used text settings.
GetTextSettingsClass returns the TTextSettingsInfo.TCustomTextSettingsClass (or its descendant)  class reference. An instance of such class provides the DefaultTextSettings,   TextSettings, StyledSettings, ResultingTextSettings, and other properties handling the text representation settings of a control. 
You can override the method in descendant classes to modify the default behavior.
Typical implementations of GetTextSettingsClass returns the class declaring properties like the Font, FontColor, HorzAlign, and WordWrap. Some of these properties can be declared as published to be editable in the Object Inspector.</docstr>
      </function>
      <procedure name="TriggerAcceleratorKey">
        <docstr>Allows the object to perform an action when the accelerator key is pressed.
FMX.StdCtrls.TPresentedTextControl.TriggerAcceleratorKey inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey.
Allows the object to perform an action when the accelerator key is pressed.
Use TriggerAcceleratorKey to trigger an action as a response to the accelerator key. For example, use TriggerAcceleratorKey to set focus to the acceleration key receiver control.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.CanTriggerAcceleratorKey</docstr>
      </procedure>
      <function name="CanTriggerAcceleratorKey">
        <docstr>Determines whether the object reacts to the accelerator key or not.
FMX.StdCtrls.TPresentedTextControl.CanTriggerAcceleratorKey inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.CanTriggerAcceleratorKey. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.CanTriggerAcceleratorKey.
Determines whether the object reacts to the accelerator key or not.
Use CanTriggerAcceleratorKey for objects that are not intended to react to the accelerator key, for example: a hidden tab page or a hidden submenu. The object triggers the action if CanTriggerAcceleratorKey is True. Otherwise, the object cannot trigger the action.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey</docstr>
      </function>
      <function name="GetAcceleratorChar">
        <docstr>Returns the index of the accelerator character within the text string of the receiver object.
FMX.StdCtrls.TPresentedTextControl.GetAcceleratorChar inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.GetAcceleratorCharIndex. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.GetAcceleratorCharIndex.
Returns the index of the accelerator character within the text string of the receiver object.
Use GetAcceleratorCharIndex to highlight the accelerator character when the text string contains several times the same character.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.GetAcceleratorChar</docstr>
      </function>
      <function name="GetAcceleratorCharIndex">
        <docstr>Returns the character key that serves as the  keyboard accelerator for the receiver object.
FMX.StdCtrls.TPresentedTextControl.GetAcceleratorCharIndex inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.GetAcceleratorChar. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.GetAcceleratorChar.
Returns the character key that serves as the  keyboard accelerator for the receiver object.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.GetAcceleratorCharIndex</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TPresentedTextControl.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TPresentedControl.
FMX.StdCtrls.TPresentedTextControl.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
Destroys this instance of TPresentedControl.

 See Also
FMX.Controls.Presentation.TPresentedControl.Create</docstr>
      </destructor>
      <procedure name="AfterConstruction">
        <docstr>Responds after the last constructor has executed and loads the control presentation.
FMX.StdCtrls.TPresentedTextControl.AfterConstruction inherits from FMX.Controls.Presentation.TPresentedControl.AfterConstruction. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.AfterConstruction.
Responds after the last constructor has executed and loads the control presentation.
AfterConstruction is called automatically after the object&apos;s last constructor has executed. Do not call it explicitly in your applications.</docstr>
      </procedure>
      <function name="ToString">
        <docstr>Returns a string containing the class name.
FMX.StdCtrls.TPresentedTextControl.ToString inherits from System.TObject.ToString. All content below this line refers to System.TObject.ToString.
Returns a string containing the class name.
By default, the ToString returns a string containing the class name of the instance that is being called. 
For example, calling ToString on a TButton instance returns a string containing &quot;TButton&quot;. 

Note: ToString is intended to be overridden in user-derived classes, to provide consumer objects with a string representation.</docstr>
      </function>
      <property name="Text">
        <docstr>Specifies the text that will be displayed over the surface of this control.
In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an &lt;accelerator_letter&gt; with an ampersand &amp; character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &amp;Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+&lt;accelerator_letter&gt; key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand &amp; character in a Text property specify doubled ampersand &amp;&amp; characters.</docstr>
      </property>
      <property name="DefaultTextSettings">
        <docstr>Stores a TTextSettings type object that keeps the default values of the text representation properties.
DefaultTextSettings is set during the loading of the style in the ApplyStyle method.</docstr>
      </property>
      <property name="TextSettings">
        <docstr>Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
TTextSettings type objects provide all styled text representation properties and methods to manage them.
The styled text representation properties are 
FontColor, TextAlign,
VertTextAlign,
Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
VertTextAlign properties of the control.</docstr>
      </property>
      <property name="StyledSettings">
        <docstr>Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
Text representation properties are used as parameters for drawing texts in controls.
The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
StyledSettings can contain the Family, Size, Style, FontColor, and 
Other values defined in TStyledSetting. The &quot;Relation between TStyledSetting constants and TTextSettings properties&quot; table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):

With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
VertTextAlign properties of the control.</docstr>
      </property>
      <property name="ResultingTextSettings">
        <docstr>Keeps final values of text representation properties. These values are really used to draw texts in a control. 
ResultingTextSettings keeps a TTextSettings object that manages the final values of the text representation properties. These values are really used to draw texts in a control. 
To obtain values stored in ResultingTextSettings, a control uses the StyledSettings property. For example, if StyledSettings contains the TStyledSetting.Family value, then the TFont.Family value is taken from the DefaultTextSettings. (That is the font family name defined in the loaded style is used. The font family name defined by the programmer in the Object Editor is ignored.) Oppositely, if StyledSettings does not contain TStyledSetting.Family, then the font family name defined by the programmer in the Object Editor is used and the font family name defined in the loaded style is ignored.
The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
RecalculateTextSettings updates the ResultingTextSettings.</docstr>
      </property>
      <procedure name="Change">
        <docstr>Calls DoChanged when any of the styled text representation properties of the control changes.</docstr>
      </procedure>
      <property name="Font">
        <docstr>Specifies the font to use when displaying the text.</docstr>
      </property>
      <property name="FontColor">
        <docstr>Specifies the font color to use when displaying the text.
This property sets or returns a value of the TAlphaColor type.</docstr>
      </property>
      <property name="VertTextAlign">
        <docstr>Specifies the vertical alignment of the text in this control.
This property can take values of the TTextAlign enumeration.</docstr>
      </property>
      <property name="TextAlign">
        <docstr>Specifies the horizontal alignment of the text in this control.
This property can take values of the TTextAlign enumeration.</docstr>
      </property>
      <property name="WordWrap">
        <docstr>Specifies whether to wrap the text inside the control when the text length exceeds the text area width.</docstr>
      </property>
      <property name="Trimming">
        <docstr>Specifies how the text is trimmed when it exceeds the edges of the text area in this control.
This property sets or returns a value of the TTextTrimming type.</docstr>
      </property>
      <property name="PrefixStyle">
        <docstr>Determines whether the ampersand character (&amp;) is considered as a special prefix character.
The default value is TPrefixStyle.HidePrefix, which means that the (first) ampersand is hidden at run-time.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TPanel">
    <docstr>Represents a generic general-purpose panel used to hold multiple controls for organizing purposes.
Use TPanel components when you need to provide the user with a way of placing multiple graphical components on a surface for organizing purposes.
Panels have methods to help manage the placement of child controls embedded in the panel. You can also use panels to group controls together, similarly to the way you can use a group box. Panels are typically used for groups of controls within a single form. Panels with no borders are useful as docking sites when writing applications that use drag-and-dock.</docstr>
    <members>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TPanel.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.StdCtrls.TPanel.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TPanel.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TCalloutPanel">
    <docstr>A container for extra information relevant to another item, with a visual indicator pointing to that item.
A call-out often takes the form of a pull-quote, in which a particular snippet of text in a document is duplicated to attract attention: in a larger size, with a different typeface, in a colored box, with stylized quote marks, etc. With illustrations, boxed text will refer to different elements of interest, and each box will be drawn with extra lines that point to its element.
Use TCalloutPanel to create a call-out for elements in the user interface. The call-out may be transient, like a heavy-duty tool tip.
The default style is a TCalloutRectangle, a rectangle with a triangular &quot;peak&quot; on one of four sides. A custom style that is not a TCalloutRectangle at the root should contain one with the ResourceName &quot;background&quot;, so that the size and position properties for the triangle can be applied. The bounds of the control includes that peak: the longer the peak, the shorter the rectangle, and vice versa.</docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TCalloutPanel.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.StdCtrls.TCalloutPanel.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <procedure name="UpdateCallout">
        <docstr>Updates the properties of the CalloutRectangle.
UpdateCallout updates the following properties of the CalloutRectangle:

CalloutLength
CalloutWidth
CalloutPosition
CalloutOffset</docstr>
      </procedure>
      <procedure name="UpdatePadding">
        <docstr>Updates the padding based on the values of CalloutLength and CalloutPosition.</docstr>
      </procedure>
      <procedure name="SavePadding">
        <docstr>Saves the current padding.</docstr>
      </procedure>
      <procedure name="RestorePadding">
        <docstr>Restores a previously-saved padding.</docstr>
      </procedure>
      <procedure name="PaddingChanged">
        <docstr>Executed right after the value of the Padding property changes.
FMX.StdCtrls.TCalloutPanel.PaddingChanged inherits from FMX.Controls.TControl.PaddingChanged. All content below this line refers to FMX.Controls.TControl.PaddingChanged.
Executed right after the value of the Padding property changes.
The control does not execute PaddingChanged if you assign Padding the same value that it already has.

 See Also
FMX.Controls.TControl.ClipChildrenChanged
FMX.Controls.TControl.EffectEnabledChanged
FMX.Controls.TControl.EnabledChanged
FMX.Controls.TControl.HandleSizeChanged
FMX.Controls.TControl.HitTestChanged
FMX.Controls.TControl.ParentChanged
FMX.Controls.TControl.VisibleChanged
FMX.Controls.TControl.AncestorVisibleChanged
FMX.Controls.TControl.AncestorParentChanged
FMX.Controls.TControl.ChildrenAlignChanged</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TCalloutPanel.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <property name="CalloutRectangle">
        <docstr>A reference to a TCalloutRectangle style object.</docstr>
      </property>
      <property name="CalloutWidth">
        <docstr>The width of the visual element that points at the area of interest.
By default, TCalloutPanel uses TCalloutRectangle, which renders its callout pointer as an isosceles triangle on one of its sides. 
CalloutWidth is the length of the base of the triangle.</docstr>
      </property>
      <property name="CalloutLength">
        <docstr>The length of the visual element that points at the area of interest.
By default, TCalloutPanel uses TCalloutRectangle, which renders its callout pointer as an isosceles triangle on one of its sides. CalloutLength is the height of this triangle. 
The triangle is included in the bounding rectangle ShapeRect of the TCalloutPanel object; therefore, the longer CalloutLength is, the smaller the height (or width) of the callout panel itself is, and vice versa. Keeping the bounding rectangle the same size while changing the length of the triangle CalloutLength requires changing the height or width of the callout panel TCalloutPanel itself, depending on which side the triangle appears.</docstr>
      </property>
      <property name="CalloutPosition">
        <docstr>Defines the side where the callout pointer appears.
Set CalloutPosition to one of the Top, Left, Bottom, or Right constants predefined in TCalloutPosition to define the side on which the callout pointer should appear.
By default, the callout pointer appears on the top side CalloutPosition = Top.  
By default, TCalloutPanel uses TCalloutRectangle, which renders its callout pointer--the visual element that points at the area of interest--as an isosceles triangle on one of its four sides.</docstr>
      </property>
      <property name="CalloutOffset">
        <docstr>The position of the callout pointer, relative to the center or edges of the side on which it appears.
By default, TCalloutPanel uses TCalloutRectangle, which renders its callout pointer--visual element that points at the area of interest--as an isosceles triangle on one of its sides. The CalloutPosition defines the side on which the triangle appears.
CalloutOffset is the offset of the callout pointer implemented according to the following conditions:

If CalloutOffset is zero, then the callout pointer is centered on the specified side.
If CalloutOffset is positive, then the closest point to a corner of the callout pointer has the CalloutOffset offset on the following sides:
Top--offset to the right from the upper-left corner.
Left--offset to the bottom from the upper-left corner.
Right--offset to the bottom from the upper-right corner.
Bottom--offset to the right from the lower-left corner.
If CalloutOffset is negative, then the closest point to a corner of the callout pointer has the CalloutOffset offset on the following sides:
Top--offset to the left from the upper-right corner.
Left--offset to the top from the lower-left corner.
Right--offset to the top from the lower-right corner.
Bottom--offset to the left from the lower-right corner.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TLabel">
    <docstr>Represents a graphical control used to display text in FireMonkey forms.
A TLabel control shows a text. The user cannot edit this text. A TLabel control can be used to label another control and can set focus to this control when the user presses an accelerator key assigned to the TLabel control.
TLabel controls cannot receive focus.
The Text property can be used to set an accelerator key to a TLabel control. The FocusControl property keeps the control that receives the focus when the accelerator key is pressed. 
To add an object to a form that displays text that a user can scroll or edit, use a TEdit.</docstr>
    <members>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.StdCtrls.TLabel.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.StdCtrls.TLabel.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>OnMouseMove event dispatcher. 
FMX.StdCtrls.TLabel.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
OnMouseMove event dispatcher. 
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.StdCtrls.TLabel.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.StdCtrls.TLabel.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TLabel.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.StdCtrls.TLabel.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <procedure name="DoChanged">
        <docstr>Updates the representation of the text that is displayed on the control.
FMX.StdCtrls.TLabel.DoChanged inherits from FMX.StdCtrls.TPresentedTextControl.DoChanged. All content below this line refers to FMX.StdCtrls.TPresentedTextControl.DoChanged.
Updates the representation of the text that is displayed on the control.
Call this method to apply your changes to the text representation.</docstr>
      </procedure>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TLabel.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <function name="GetTextSettingsClass">
        <docstr>Returns the class type that instance represents the used text settings.
FMX.StdCtrls.TLabel.GetTextSettingsClass inherits from FMX.StdCtrls.TPresentedTextControl.GetTextSettingsClass. All content below this line refers to FMX.StdCtrls.TPresentedTextControl.GetTextSettingsClass.
Returns the class type that instance represents the used text settings.
GetTextSettingsClass returns the TTextSettingsInfo.TCustomTextSettingsClass (or its descendant)  class reference. An instance of such class provides the DefaultTextSettings,   TextSettings, StyledSettings, ResultingTextSettings, and other properties handling the text representation settings of a control. 
You can override the method in descendant classes to modify the default behavior.
Typical implementations of GetTextSettingsClass returns the class declaring properties like the Font, FontColor, HorzAlign, and WordWrap. Some of these properties can be declared as published to be editable in the Object Inspector.

 See Also
FMX.Controls.TTextSettingsInfo
FMX.Controls.TTextSettingsInfo.TCustomTextSettingsClass
FMX.Controls.TTextSettingsInfo.DefaultTextSettings
FMX.Controls.TTextSettingsInfo.TextSettings
FMX.Controls.TTextSettingsInfo.StyledSettings
FMX.Controls.TTextSettingsInfo.ResultingTextSettings</docstr>
      </function>
      <procedure name="TriggerAcceleratorKey">
        <docstr>Allows the object to perform an action when the accelerator key is pressed.
FMX.StdCtrls.TLabel.TriggerAcceleratorKey inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey.
Allows the object to perform an action when the accelerator key is pressed.
Use TriggerAcceleratorKey to trigger an action as a response to the accelerator key. For example, use TriggerAcceleratorKey to set focus to the acceleration key receiver control.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.CanTriggerAcceleratorKey</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TLabel.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <procedure name="SetNewScene">
        <docstr>Sets a new Scene for the current control.
Sets a new Scene for the current control.
FMX.StdCtrls.TLabel.SetNewScene inherits from FMX.Controls.TControl.SetNewScene. All content below this line refers to FMX.Controls.TControl.SetNewScene.
Sets a new Scene for the current control.
AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
SetNewScene sets the same scene for the control&apos;s children.</docstr>
      </procedure>
      <property name="IsPressed">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="AutoSize">
        <docstr>Specifies whether TLabel control is auto-sized based on the length of the text.
Set the AutoSize property to True to automatically resize the TLabel control according to the length of the Text.
Set the AutoSize property to False to lock autoresize of the TLabel control.

Tip:  The size of the TLabel control readjusts when the Font property changes.
When both AutoSize and WordWrap are set to True, the label&apos;s width does not change, and the height increases to show the full Text. So, the text might occupy several lines.
When AutoSize  is set to True and WordWrap is set to False, the label&apos;s width changes to display the text in one line, while the height does not change.</docstr>
      </property>
      <property name="FocusControl">
        <docstr>Keeps the control that receives the focus when the accelerator key of the current label control is used. 
Links the label control with another control. 
If the Text property includes an accelerator key, the control specified by FocusControl receives focus when the accelerator is pressed.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TCustomButton">
    <docstr>Represents the base class for all buttons.
TCustomButton is the base class for all button components such as TButton. If you need to create a custom button for your application, then you should consider deriving your component from TCustomButton, as it already implements basic button drawing and operating functionality.</docstr>
    <members>
      <procedure name="ActionChange">
        <docstr>Sends a message to the presentation layer of the presentation proxy when the Action property changes.
FMX.StdCtrls.TCustomButton.ActionChange inherits from FMX.Controls.Presentation.TPresentedControl.ActionChange. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.ActionChange.
Sends a message to the presentation layer of the presentation proxy when the Action property changes.
The presentation layer receives a message with PM_ACTION_CHANGE as MsgID and an instance of TActionInfo as Value with the following data:



Property

Data



Value.Sender



ASender




Value.CheckDefaults



ACheckDefaults


 See Also
FMX.Controls.TControl.ActionChange
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Presentation.Messages.TMessageSender.Receiver
System.TObject.Dispatch
FMX.Presentation.Messages.TDispatchMessageWithValue
FMX.Presentation.Messages.TDispatchMessageWithValue.MsgID
FMX.Presentation.Messages.TDispatchMessageWithValue.Value
FMX.Controls.Presentation.TActionInfo
FMX.Controls.Presentation.TActionInfo.Sender
FMX.Controls.Presentation.TActionInfo.CheckDefaults</docstr>
      </procedure>
      <function name="IsPressedStored">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="RestoreButtonState">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ApplyTriggers">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetIsPressed">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetStaysPressed">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Click">
        <docstr>Responds to user clicks.
Click is an event handler for the OnClick event. It is automatically called when the left mouse button is pressed and released with the pointer over the control.
Call Click in applications to simulate a mouse OnClick event.  
If ModalResult is defined, the ModalResult property of its parent form is set to the same value as the button&apos;s ModalResult property.</docstr>
      </procedure>
      <procedure name="DblClick">
        <docstr>Responds to user double-clicks.
DblClick is an event handler for the OnDblClick event. It is automatically called when the left mouse button is pressed and released twice consecutively with the pointer over the control. 
Call DblClick in applications to simulate a mouse OnDblClick event.  
If ModalResult is defined, the ModalResult property of its parent form is set to the same value as the button&apos;s ModalResult property.</docstr>
      </procedure>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TCustomButton.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.StdCtrls.TCustomButton.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <procedure name="ToggleStaysPressed">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoRealign">
        <docstr>Sends a PM_REALIGN message to the presentation layer through its presentation proxy.
FMX.StdCtrls.TCustomButton.DoRealign inherits from FMX.Controls.Presentation.TPresentedControl.DoRealign. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DoRealign.
Sends a PM_REALIGN message to the presentation layer through its presentation proxy.
For details about the circumstances that trigger this procedure, see TControl.DoRealign.

 See Also
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Controls.TControl.DoRealign</docstr>
      </procedure>
      <procedure name="DoRepeatTimer">
        <docstr>Internally executes every 100 milliseconds to perform the OnClick event, if the RepeatClick property is True.
If the RepeatClick property is True, each time 100 milliseconds pass, DoRepeatDelayTimer is executed and the DoRepeatTimer method is internally called to perform this button&apos;s OnClick event.</docstr>
      </procedure>
      <procedure name="DoRepeatDelayTimer">
        <docstr>Internally executes every 100 milliseconds if the RepeatClick property is True.
If the RepeatClick property is True, each time 100 milliseconds pass, DoRepeatDelayTimer is executed and the DoRepeatTimer method is internally called to perform the button&apos;s OnClick event.</docstr>
      </procedure>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.StdCtrls.TCustomButton.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
FMX.StdCtrls.TCustomButton.SetData inherits from FMX.Types.TFmxObject.SetData. All content below this line refers to FMX.Types.TFmxObject.SetData.
Protected setter implementation for the Data property.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.StdCtrls.TCustomButton.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>OnMouseMove event dispatcher. 
FMX.StdCtrls.TCustomButton.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
OnMouseMove event dispatcher. 
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.StdCtrls.TCustomButton.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Sends a PM_KEYDOWN message to the presentation layer through its presentation proxy when a key is pressed down while your presented control has the focus.
FMX.StdCtrls.TCustomButton.KeyDown inherits from FMX.Controls.Presentation.TPresentedControl.KeyDown. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.KeyDown.
Sends a PM_KEYDOWN message to the presentation layer through its presentation proxy when a key is pressed down while your presented control has the focus.
The message includes a TKeyInfo record that contains the data of the parameters (AKey, AKeyChar, AShift).

 See Also
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Controls.Presentation.TKeyInfo
FMX.Controls.TControl.KeyDown
FMX.Forms.TCommonCustomForm.KeyDown
FMX.Controls.Presentation.TPresentedControl.KeyUp</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TCustomButton.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <function name="GetDefaultTouchTargetExpansion">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetTextSettingsClass">
        <docstr>Returns the class type that instance represents the used text settings.
FMX.StdCtrls.TCustomButton.GetTextSettingsClass inherits from FMX.StdCtrls.TPresentedTextControl.GetTextSettingsClass. All content below this line refers to FMX.StdCtrls.TPresentedTextControl.GetTextSettingsClass.
Returns the class type that instance represents the used text settings.
GetTextSettingsClass returns the TTextSettingsInfo.TCustomTextSettingsClass (or its descendant)  class reference. An instance of such class provides the DefaultTextSettings,   TextSettings, StyledSettings, ResultingTextSettings, and other properties handling the text representation settings of a control. 
You can override the method in descendant classes to modify the default behavior.
Typical implementations of GetTextSettingsClass returns the class declaring properties like the Font, FontColor, HorzAlign, and WordWrap. Some of these properties can be declared as published to be editable in the Object Inspector.

 See Also
FMX.Controls.TTextSettingsInfo
FMX.Controls.TTextSettingsInfo.TCustomTextSettingsClass
FMX.Controls.TTextSettingsInfo.DefaultTextSettings
FMX.Controls.TTextSettingsInfo.TextSettings
FMX.Controls.TTextSettingsInfo.StyledSettings
FMX.Controls.TTextSettingsInfo.ResultingTextSettings</docstr>
      </function>
      <property name="TintColor">
        <docstr>Allows you to apply a tint to a button component. 
This property is a value of the TAlphaColor type.

Note: Some buttons might not have the tint support. In the Object Inspector, the RAD Studio IDE automatically displays/hides the TintColor property when you change the button&apos;s StyleLookup property. Currently, the TintColor property is only available for mobile platforms (iOS and Android). For more information, see Using Styled and Colored Buttons on Target Platforms.</docstr>
      </property>
      <property name="TintObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="IconTintColor">
        <docstr>Allows you to apply a tint to a button icon. 
This property is a value of the TAlphaColor type.

Note: Some buttons might not have the tint support. In the Object Inspector, the IDE automatically displays/hides the IconTintColor property as appropriate when you change the button&apos;s StyleLookup property. Currently, the IconTintColor property is only available for mobile platforms (iOS and Android). For more information, see Using Styled and Colored Buttons on Target Platforms.</docstr>
      </property>
      <property name="IconTintObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <procedure name="ImagesChanged">
        <docstr>Should be called when the component needs to redraw the image.
ImagesChanged should be called
when you change the Images reference to the TCustomImageList object or 
the object itself or when you change the ImageIndex property.</docstr>
      </procedure>
      <function name="ImageIndexStored">
        <docstr>Returns True when the ImageIndex property needs to be stored in the fmx-file.</docstr>
      </function>
      <procedure name="TriggerAcceleratorKey">
        <docstr>Allows the object to perform an action when the accelerator key is pressed.
FMX.StdCtrls.TCustomButton.TriggerAcceleratorKey inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey.
Allows the object to perform an action when the accelerator key is pressed.
Use TriggerAcceleratorKey to trigger an action as a response to the accelerator key. For example, use TriggerAcceleratorKey to set focus to the acceleration key receiver control.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.CanTriggerAcceleratorKey</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TCustomButton.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TPresentedControl.
FMX.StdCtrls.TCustomButton.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
Destroys this instance of TPresentedControl.

 See Also
FMX.Controls.Presentation.TPresentedControl.Create</docstr>
      </destructor>
      <procedure name="SetNewScene">
        <docstr>Sets a new Scene for the current control.
Sets a new Scene for the current control.
FMX.StdCtrls.TCustomButton.SetNewScene inherits from FMX.Controls.TControl.SetNewScene. All content below this line refers to FMX.Controls.TControl.SetNewScene.
Sets a new Scene for the current control.
AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
SetNewScene sets the same scene for the control&apos;s children.</docstr>
      </procedure>
      <property name="StaysPressed">
        <docstr>Specifies whether this button remains in a pressed state once you click it.
Set the StaysPressed property to True to force this button to remain in a pressed state once you click it. The button comes back to its initial depressed state once you click it again.
If StaysPressed is set to False, then this button behaves like a standard push button that comes back to its initial state once you release the mouse button over its surface.</docstr>
      </property>
      <property name="IsPressed">
        <docstr>Specifies whether the default state of this button is pressed or not.
Set the IsPressed property to True in order to force this button&apos;s default state to be pressed. The button comes back to its initial unpressed state once you click it.

Tip: Setting the IsPressed property only has an effect if the StaysPressed property is set to True.</docstr>
      </property>
      <property name="ModalResult">
        <docstr>Determines whether and how the button closes its (modal) parent form.
Setting the ModalResult property of a button is an easy way to make clicking the button to close the parent modal form. When a button is clicked, the ModalResult property of its parent form is set to the same value as the ModalResult property of a button.
For example, if a dialog box has OK and Cancel buttons, their ModalResult properties could be set at design time to mrOk and mrCancel, respectively. At run time, clicking the OK button changes the ModalResult property of the dialog box to mrOk, and clicking the Cancel button changes the ModalResult property of the dialog box to mrCancel. Unless further processing is required, no OnClick event handlers are required for the buttons.
The following table lists the constants defined in the System.UITypes unit to be used for the ModalResult property of the TModalResult type.



Constant

Value

Meaning



mrNone



0



None. Used as a default value before the user exits.




mrOk



idOK = 1



The user exited with the OK button.




mrCancel



idCancel = 2



The user exited with the CANCEL button.




mrAbort



idAbort = 3



The user exited with the ABORT button.




mrRetry



idRetry = 4



The user exited with the RETRY button.




mrIgnore



idIgnore = 5



The user exited with the IGNORE button.




mrYes



idYes = 6



The user exited with the YES button.




mrNo



idNo = 7



The user exited with the NO button.




mrClose



idClose = 8



The user exited with the CLOSE button.




mrHelp



idHelp = 9



The user exited with the HELP button.




mrTryAgain



idTryAgain = 10



The user exited with the TRY AGAIN button.




mrContinue



idContinue = 11



The user exited with the CONTINUE button.




mrAll



mrContinue + 1 (12 or $C)



The user exited with the ALL button.




mrNoToAll



mrAll +1 (13 or $D)



The user exited with the NO TO ALL button.




mrYesToAll



mrNoToAll +1 (14 or $E)



The user exited with the YES TO ALL button.


You can check a ModalResult value using the global IsAbortResult, IsAnAllResult, IsNegativeResult, or IsPositiveResult functions, and use the StripAllFromResult function to convert ModalResult values that refer to &quot;ALL&quot; buttons to identifying values corresponding to simple buttons (Ok, No, or Yes).</docstr>
      </property>
      <property name="RepeatClick">
        <docstr>Specifies whether to automatically repeat the button click after a preset time.
Set the RepeatClick property to True to make the button automatically repeat the clicking event, thus executing its OnClick event cyclically, after a preset time has passed since the last OnClick execution.
The timer interval starts with 500 milliseconds for the first wait and then moves to 100 milliseconds per wait cycle. This interval cannot be modified by the user.
Each time 100 milliseconds pass, DoRepeatDelayTimer is executed. DoRepeatDelayTimer internally calls the DoRepeatTimer method to perform the button&apos;s OnClick event.</docstr>
      </property>
      <property name="Images">
        <docstr>Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
If the TCustomImageList list is empty, then Images is nil/null.
Call ImagesChanged when Images is changed.</docstr>
      </property>
      <property name="ImageIndex">
        <docstr>Defines the zero-based index enumerating images in the Images list of images.
If you use a non-existing ImageIndex value to access an image in the Images list, then no image is retrieved and no exception is raised. The usual default value is -1. Call ImagesChanged when ImageIndex is changed.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TButton">
    <docstr>Represents a push button that contains a text caption.
A TButton is a general-purpose push button for use in applications. Buttons can be enabled, disabled, pressed, and can respond to control keys such as ESCAPE and ENTER. These buttons can receive TAB focus.
Buttons can have a modal result attached, which is useful if these buttons are the main validating controls for a dialog box, for instance OK -- save and close; Cancel -- quit, no save; and so on.
The Text property can be used to define an accelerator key to a control.</docstr>
    <members>
      <procedure name="AfterDialogKey">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="Font">
        <docstr>Specifies the font to use when displaying the text.</docstr>
      </property>
      <property name="TextAlign">
        <docstr>Specifies the horizontal alignment of the text in this control.
This property can take values of the TTextAlign enumeration.</docstr>
      </property>
      <property name="Trimming">
        <docstr>Specifies how the text is trimmed when it exceeds the edges of the text area in this control.
This property sets or returns a value of the TTextTrimming type.</docstr>
      </property>
      <property name="WordWrap">
        <docstr>Specifies whether to wrap the text inside the control when the text length exceeds the text area width.</docstr>
      </property>
      <property name="Cancel">
        <docstr>Determines whether the button&apos;s OnClick event handler executes when the ESCAPE key is pressed.
If Cancel is True, the button&apos;s OnClick event handler executes when you press the ESCAPE key. Although an application can have more than one Cancel button, the form calls the OnClick event handler only for the first visible button in the tab order.</docstr>
      </property>
      <property name="Default">
        <docstr>Determines whether the button&apos;s OnClick event handler executes when the ENTER key is pressed.
If Default is True, the button&apos;s OnClick event handler executes when the you press the ENTER key. Although an application can have more than one Default button, the form calls the OnClick event handler only for the first visible button in the tab order. Moreover, any button that has focus becomes the Default button temporarily; hence, if you select another button before pressing ENTER, the selected button&apos;s OnClick event handler executes instead.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TSpeedButton">
    <docstr>Represents a push button that contains a text caption, for usage in various toolbars that you might employ into your applications.
A TSpeedButton is a general-purpose push button for use in an application&apos;s toolbar. These buttons can be enabled, disabled, pressed, and can respond to control keys such as ESCAPE and ENTER.
These speed buttons can also have a modal result attached to them.
Their distinctive appearance differentiates them from other buttons. Also, speed buttons cannot receive TAB focus.</docstr>
    <members>
      <function name="IsPressedStored">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ToggleStaysPressed">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetIsPressed">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ActionChange">
        <docstr>Sends a message to the presentation layer of the presentation proxy when the Action property changes.
FMX.StdCtrls.TSpeedButton.ActionChange inherits from FMX.Controls.Presentation.TPresentedControl.ActionChange. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.ActionChange.
Sends a message to the presentation layer of the presentation proxy when the Action property changes.
The presentation layer receives a message with PM_ACTION_CHANGE as MsgID and an instance of TActionInfo as Value with the following data:



Property

Data



Value.Sender



ASender




Value.CheckDefaults



ACheckDefaults


 See Also
FMX.Controls.TControl.ActionChange
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Presentation.Messages.TMessageSender.Receiver
System.TObject.Dispatch
FMX.Presentation.Messages.TDispatchMessageWithValue
FMX.Presentation.Messages.TDispatchMessageWithValue.MsgID
FMX.Presentation.Messages.TDispatchMessageWithValue.Value
FMX.Controls.Presentation.TActionInfo
FMX.Controls.Presentation.TActionInfo.Sender
FMX.Controls.Presentation.TActionInfo.CheckDefaults</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TSpeedButton.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TPresentedControl.
FMX.StdCtrls.TSpeedButton.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
Destroys this instance of TPresentedControl.

 See Also
FMX.Controls.Presentation.TPresentedControl.Create</docstr>
      </destructor>
      <property name="GroupName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TCustomCornerButton">
    <docstr>Represents a TCustomButton control and, additionally, provides the tools to customize shapes of TCustomCornerButton control&apos;s corners.
Use Corners to specify the corners to be customized. Use CornerType, XRadius, and YRadius to customize corners. See also TRectangle.</docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TCustomCornerButton.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TCustomCornerButton.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TPresentedControl.
FMX.StdCtrls.TCustomCornerButton.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
Destroys this instance of TPresentedControl.

 See Also
FMX.Controls.Presentation.TPresentedControl.Create</docstr>
      </destructor>
      <property name="XRadius">
        <docstr>Specifies the distance from a corner to the start point of the corner shape customization, on the horizontal sides of the button.
How corners are customized is defined by the Corners,
CornerType, XRadius, and YRadius properties.</docstr>
      </property>
      <property name="YRadius">
        <docstr>Specifies the distance from a corner to the start point of the corner shape customization, on the vertical sides of the button.
How corners are customized is defined by the Corners,
CornerType, XRadius, and YRadius properties.</docstr>
      </property>
      <property name="Corners">
        <docstr>Specifies which corners are customized by the CornerType, XRadius, and YRadius properties.
By default, all four corners are customized. 
Corners contains a set of values defined in the TCorner type: TopLeft, TopRight, BottomLeft, and BottomRight. Use the AllCorners constant to select all corners. 
If Corners is an empty set, then no corner shape customization is used.</docstr>
      </property>
      <property name="CornerType">
        <docstr>Specifies the type of the corner customization in the TCustomCornerButton control.
Values of CornerType are defined in the TCornerType: Round, Bevel, InnerRound, and InnerLine. These values define the following types of corner shape customizations: 


CornerType applies to corners specified in the Corners set.
XRadius and YRadius specify the distance from a corner to the start point of the corner customization, on the horizontal and vertical sides. 

Note: If Corners is an empty set, or any of the XRadius and YRadius properties is zero, modifying the CornerType property has no visual effect.</docstr>
      </property>
      <property name="Sides">
        <docstr>Specifies which sides of the control to display.
A side is a button boundary between two adjacent corners or end points of corner customizations. End points of corner customizations are defined by XRadius and YRadius. A corner customization applies to corners included into the Corners set.
By default, all sides of the control are displayed.
Sides can contain a set of values defined in TSide: Top, Left, Bottom, and Right. 
Use the AllSides constant to select all sides.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TCornerButton">
    <docstr>Represents a button with customizable corners.
Use the Corners property to choose the corners to be customized and the CornerType, XRadius, and YRadius  properties to customize the corners.</docstr>
  </class>
  <class unit="FMX.StdCtrls" name="TCheckBox">
    <docstr>Represents a FireMonkey styled check box that can be either on (selected) or off (cleared).
TCheckBox represents a FireMonkey styled check box that can be either on (selected) or off (cleared). A TCheckBox component presents you an option. Select the box to turn on the option, or clear it to turn off the option.
A FireMonkey TCheckBox control supports linking to a Boolean database field. The Boolean field can be null, so there are actually three states: True, False, Null. The TCheckBox control treats the Null state as False.
The Text property can be used to define an accelerator key to a control. The accelerator key behavior for TCheckBox is to check and uncheck the box control.</docstr>
    <members>
      <procedure name="DoExit">
        <docstr>Sends a PM_RESET_FOCUS message to the presentation layer through its presentation proxy, followed by a PM_DO_EXIT message.
FMX.StdCtrls.TCheckBox.DoExit inherits from FMX.Controls.Presentation.TPresentedControl.DoExit. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DoExit.
Sends a PM_RESET_FOCUS message to the presentation layer through its presentation proxy, followed by a PM_DO_EXIT message.
For details about the circumstances that trigger this procedure, see TControl.DoExit.

 See Also
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Controls.TControl.DoExit</docstr>
      </procedure>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TCheckBox.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.StdCtrls.TCheckBox.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <function name="CanObserve">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.</docstr>
      </function>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
GetData overrides FMX.Types.TFmxObject.GetData and returns the value of IsChecked.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
SetData overrides FMX.Types.TFmxObject.SetData and sets the value of IsChecked.
Value may be any of the following:

A Boolean value. IsChecked is assigned that value.
A String Boolean. IsChecked is assigned that value.
An event handler to be assigned to OnChange. IsChecked remains unchanged.</docstr>
      </procedure>
      <procedure name="ActionChange">
        <docstr>Specifies the behavior of a TCheckBox menu item when Action changes. 
ActionChange calls the inherited TTextControl.ActionChange method and then, depending on the CheckDefaults value,  ActionChange uses the Checked property of the Sender action to set the new value of the  
IsChecked property. 
Do not call ActionChange explicitly in an application. It is for internal use.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TCheckBox.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <function name="GetTextSettingsClass">
        <docstr>Returns the class type that instance represents the used text settings.
FMX.StdCtrls.TCheckBox.GetTextSettingsClass inherits from FMX.StdCtrls.TPresentedTextControl.GetTextSettingsClass. All content below this line refers to FMX.StdCtrls.TPresentedTextControl.GetTextSettingsClass.
Returns the class type that instance represents the used text settings.
GetTextSettingsClass returns the TTextSettingsInfo.TCustomTextSettingsClass (or its descendant)  class reference. An instance of such class provides the DefaultTextSettings,   TextSettings, StyledSettings, ResultingTextSettings, and other properties handling the text representation settings of a control. 
You can override the method in descendant classes to modify the default behavior.
Typical implementations of GetTextSettingsClass returns the class declaring properties like the Font, FontColor, HorzAlign, and WordWrap. Some of these properties can be declared as published to be editable in the Object Inspector.

 See Also
FMX.Controls.TTextSettingsInfo
FMX.Controls.TTextSettingsInfo.TCustomTextSettingsClass
FMX.Controls.TTextSettingsInfo.DefaultTextSettings
FMX.Controls.TTextSettingsInfo.TextSettings
FMX.Controls.TTextSettingsInfo.StyledSettings
FMX.Controls.TTextSettingsInfo.ResultingTextSettings</docstr>
      </function>
      <function name="TryValueIsChecked">
        <docstr>Checks whether the provided Value is a Boolean or a Boolean String.
TryValueIsChecked returns True if Value is a Boolean or a Boolean String, False otherwise.
The out parameter IsChecked is assigned the the value of Value or False if Value is not a Boolean or a Boolean String.</docstr>
      </function>
      <procedure name="TriggerAcceleratorKey">
        <docstr>Allows the object to perform an action when the accelerator key is pressed.
FMX.StdCtrls.TCheckBox.TriggerAcceleratorKey inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey.
Allows the object to perform an action when the accelerator key is pressed.
Use TriggerAcceleratorKey to trigger an action as a response to the accelerator key. For example, use TriggerAcceleratorKey to set focus to the acceleration key receiver control.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.CanTriggerAcceleratorKey</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TCheckBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <procedure name="SetNewScene">
        <docstr>Sets a new Scene for the current control.
Sets a new Scene for the current control.
FMX.StdCtrls.TCheckBox.SetNewScene inherits from FMX.Controls.TControl.SetNewScene. All content below this line refers to FMX.Controls.TControl.SetNewScene.
Sets a new Scene for the current control.
AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
SetNewScene sets the same scene for the control&apos;s children.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.StdCtrls.TCheckBox.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>OnMouseMove event dispatcher. 
FMX.StdCtrls.TCheckBox.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
OnMouseMove event dispatcher. 
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.StdCtrls.TCheckBox.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Sends a PM_KEYDOWN message to the presentation layer through its presentation proxy when a key is pressed down while your presented control has the focus.
FMX.StdCtrls.TCheckBox.KeyDown inherits from FMX.Controls.Presentation.TPresentedControl.KeyDown. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.KeyDown.
Sends a PM_KEYDOWN message to the presentation layer through its presentation proxy when a key is pressed down while your presented control has the focus.
The message includes a TKeyInfo record that contains the data of the parameters (AKey, AKeyChar, AShift).

 See Also
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Controls.Presentation.TKeyInfo
FMX.Controls.TControl.KeyDown
FMX.Forms.TCommonCustomForm.KeyDown
FMX.Controls.Presentation.TPresentedControl.KeyUp</docstr>
      </procedure>
      <property name="IsPressed">
        <docstr>Reads the pressed state of this check box.
The IsPressed read-only property is True when this check box is pressed, False otherwise.</docstr>
      </property>
      <property name="IsChecked">
        <docstr>Specifies whether the default state of this check box is selected or cleared.
Set the IsChecked property to True in order to force this check box&apos;s default state to be selected. The check box becomes cleared once you click it again.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs when the state of TCheckBox is changed.
Usually, the OnChange event happens when the check box&apos;s state is changed. This can happen:

When the state is altered programmatically by setting the IsChecked property.
By user interaction, after the box is clicked by mouse.
When the control has keyboard focus, by pressing SPACE or ENTER.
Write an OnChange event handler to customize what happens when the box is selected. 

Tip: The OnClick event happens before the OnChange event.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TRadioButton">
    <docstr>Represents a radio (option) button.
TRadioButton, also called option button, presents a set of mutually exclusive choices. You can create individual radio buttons using TRadioButton or use a group to automatically arrange radio buttons into groups. You can group radio buttons to let the user select one from a limited set of choices.
A selected radio button is displayed as a circle filled in the middle. When not selected, the radio button shows an empty circle. Assign the value True or False to the IsChecked property to change the visual state of the radio button.
The Text property can be used to define an accelerator key to the control. The accelerator key behavior for TRadioButton is to select the radio button.</docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TRadioButton.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.StdCtrls.TRadioButton.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
GetData overrides FMX.Types.TFmxObject.GetData and returns the value of IsChecked.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
SetData overrides FMX.Types.TFmxObject.SetData and sets the value of IsChecked.
Value is the new Boolean value of IsChecked, or an event handler to be assigned to OnChange.</docstr>
      </procedure>
      <procedure name="ActionChange">
        <docstr>Specifies the behavior of a TRadioButton menu item when Action changes. 
ActionChange calls the inherited TTextControl.ActionChange method and then, depending on the CheckDefaults value,  ActionChange uses properties of the Sender action to set new values to the  
IsChecked and GroupName properties of TRadioButton. 
Do not call ActionChange explicitly in an application. It is for internal use.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TRadioButton.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <function name="GetTextSettingsClass">
        <docstr>Returns the class type that instance represents the used text settings.
FMX.StdCtrls.TRadioButton.GetTextSettingsClass inherits from FMX.StdCtrls.TPresentedTextControl.GetTextSettingsClass. All content below this line refers to FMX.StdCtrls.TPresentedTextControl.GetTextSettingsClass.
Returns the class type that instance represents the used text settings.
GetTextSettingsClass returns the TTextSettingsInfo.TCustomTextSettingsClass (or its descendant)  class reference. An instance of such class provides the DefaultTextSettings,   TextSettings, StyledSettings, ResultingTextSettings, and other properties handling the text representation settings of a control. 
You can override the method in descendant classes to modify the default behavior.
Typical implementations of GetTextSettingsClass returns the class declaring properties like the Font, FontColor, HorzAlign, and WordWrap. Some of these properties can be declared as published to be editable in the Object Inspector.

 See Also
FMX.Controls.TTextSettingsInfo
FMX.Controls.TTextSettingsInfo.TCustomTextSettingsClass
FMX.Controls.TTextSettingsInfo.DefaultTextSettings
FMX.Controls.TTextSettingsInfo.TextSettings
FMX.Controls.TTextSettingsInfo.StyledSettings
FMX.Controls.TTextSettingsInfo.ResultingTextSettings</docstr>
      </function>
      <procedure name="TriggerAcceleratorKey">
        <docstr>Allows the object to perform an action when the accelerator key is pressed.
FMX.StdCtrls.TRadioButton.TriggerAcceleratorKey inherits from FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey. All content below this line refers to FMX.AcceleratorKey.IAcceleratorKeyReceiver.TriggerAcceleratorKey.
Allows the object to perform an action when the accelerator key is pressed.
Use TriggerAcceleratorKey to trigger an action as a response to the accelerator key. For example, use TriggerAcceleratorKey to set focus to the acceleration key receiver control.

 See Also
FMX.AcceleratorKey.IAcceleratorKeyReceiver.CanTriggerAcceleratorKey</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TRadioButton.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TPresentedControl.
FMX.StdCtrls.TRadioButton.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
Destroys this instance of TPresentedControl.

 See Also
FMX.Controls.Presentation.TPresentedControl.Create</docstr>
      </destructor>
      <procedure name="SetNewScene">
        <docstr>Sets a new Scene for the current control.
Sets a new Scene for the current control.
FMX.StdCtrls.TRadioButton.SetNewScene inherits from FMX.Controls.TControl.SetNewScene. All content below this line refers to FMX.Controls.TControl.SetNewScene.
Sets a new Scene for the current control.
AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
SetNewScene sets the same scene for the control&apos;s children.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.StdCtrls.TRadioButton.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>OnMouseMove event dispatcher. 
FMX.StdCtrls.TRadioButton.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
OnMouseMove event dispatcher. 
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.StdCtrls.TRadioButton.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Sends a PM_KEYDOWN message to the presentation layer through its presentation proxy when a key is pressed down while your presented control has the focus.
FMX.StdCtrls.TRadioButton.KeyDown inherits from FMX.Controls.Presentation.TPresentedControl.KeyDown. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.KeyDown.
Sends a PM_KEYDOWN message to the presentation layer through its presentation proxy when a key is pressed down while your presented control has the focus.
The message includes a TKeyInfo record that contains the data of the parameters (AKey, AKeyChar, AShift).

 See Also
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Controls.Presentation.TKeyInfo
FMX.Controls.TControl.KeyDown
FMX.Forms.TCommonCustomForm.KeyDown
FMX.Controls.Presentation.TPresentedControl.KeyUp</docstr>
      </procedure>
      <property name="IsPressed">
        <docstr>Reads the pressed state of this radio button.
The IsPressed read-only property is True when this radio button is pressed, False otherwise.</docstr>
      </property>
      <property name="GroupName">
        <docstr>Specifies the name of the group this radio button is part of.
Set the GroupName property to the name of the group this radio button belongs to. If multiple radio buttons are part of the same group, that is, all of them have the same GroupName, when you click one of them, it becomes selected, while the others in this group become cleared.</docstr>
      </property>
      <property name="IsChecked">
        <docstr>Specifies whether the default state of this radio button is selected or cleared.
Set the IsChecked property to True to force this radio button&apos;s default state to be selected. The button comes back to its initial cleared state once you click it.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs when the state of TRadioButton is changed.
Usually, an OnChange event happens when the radio button state is changed. 
This can happen:

When the state is altered programmatically by setting the IsChecked property.
By user interaction, after the radio button is clicked.
When the control has keyboard focus, by pressing SPACE or ENTER.
Selecting the state of a radio button will clear all the other radio buttons within the defined GroupName, causing their respective OnChange events. OnChange will not occur on those TRadioButtons whose state would not have changed.
TRadioButtons that have their GroupName undefined form a default group of radio buttons.

Tip: The OnClick event happens before the OnChange event.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TGroupBox">
    <docstr>Represents a graphical control used to arrange multiple related graphical controls on the surface of a form.
Use TGroupBox whenever you need to arrange multiple related controls on a form (for instance, multiple radio buttons or check boxes). The most commonly grouped controls are radio buttons. After placing a group box on a FireMonkey form, select components from the Tool Palette and place them in the group box. The Text property contains text that labels the group box at run time.

Similar components are:

TPanel (without the frame and text caption)
TExpander (additionally provides collapse/expand functionality)</docstr>
    <members>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.StdCtrls.TGroupBox.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TGroupBox.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <function name="StyledSettingsStored">
        <docstr>Indicates whether the set of styled text representation properties stored in StyledSettings differs from the default set for this control.
FMX.StdCtrls.TGroupBox.StyledSettingsStored inherits from FMX.StdCtrls.TPresentedTextControl.StyledSettingsStored. All content below this line refers to FMX.StdCtrls.TPresentedTextControl.StyledSettingsStored.
Indicates whether the set of styled text representation properties stored in StyledSettings differs from the default set for this control.
StyledSettingsStored returns True when the set of styled text representation properties stored in 
StyledSettings differs from the default set of styled text representation properties for this control.
When StyledSettingsStored returns True, then values of text representation properties of this control are stored in the corresponding FMX file.</docstr>
      </function>
      <function name="GetTextSettingsClass">
        <docstr>Returns the class type that instance represents the used text settings.
FMX.StdCtrls.TGroupBox.GetTextSettingsClass inherits from FMX.StdCtrls.TPresentedTextControl.GetTextSettingsClass. All content below this line refers to FMX.StdCtrls.TPresentedTextControl.GetTextSettingsClass.
Returns the class type that instance represents the used text settings.
GetTextSettingsClass returns the TTextSettingsInfo.TCustomTextSettingsClass (or its descendant)  class reference. An instance of such class provides the DefaultTextSettings,   TextSettings, StyledSettings, ResultingTextSettings, and other properties handling the text representation settings of a control. 
You can override the method in descendant classes to modify the default behavior.
Typical implementations of GetTextSettingsClass returns the class declaring properties like the Font, FontColor, HorzAlign, and WordWrap. Some of these properties can be declared as published to be editable in the Object Inspector.

 See Also
FMX.Controls.TTextSettingsInfo
FMX.Controls.TTextSettingsInfo.TCustomTextSettingsClass
FMX.Controls.TTextSettingsInfo.DefaultTextSettings
FMX.Controls.TTextSettingsInfo.TextSettings
FMX.Controls.TTextSettingsInfo.StyledSettings
FMX.Controls.TTextSettingsInfo.ResultingTextSettings</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TGroupBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TStatusBar">
    <docstr>Represents a status bar component for use in FireMonkey forms.
The status bar is usually aligned at the bottom of a form, and displays information about an application as it runs. A status bar can display a size grip, so if your form is sizable, there is no need to add a TSizeGrip component as long as you have a status bar already.
The status bar can also intercept hints. See Using Hints to Show Contextual Help in a FireMonkey Application for more information on how to use hints.</docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Applies the style to this status bar component.
Do not call ApplyStyle explicitly in an application. It is called when a style specified by StyleLookup is applied or when the control is visually changed. To check whether a style exists, use the FindStyleResource method.  
For an example of the ApplyStyle implementation, see Style Contracts.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.StdCtrls.TStatusBar.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TStatusBar.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <procedure name="DoRootChanging">
        <docstr>A reimplementation of TFmxObject.DoRootChanging.
Allows the control to be unregistered from the old root and registered to the new root. This is useful for a control to be registered on unregistered as a hint receiver.</docstr>
      </procedure>
      <procedure name="TriggerOnHint">
        <docstr>Triggers the hint event.
TriggerOnHint calls DoHint</docstr>
      </procedure>
      <function name="DoHint">
        <docstr>Triggers the OnHint event.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates an instance of the TStatusBar class and places a status bar component on the form.</docstr>
      </constructor>
      <property name="ShowSizeGrip">
        <docstr>Specifies whether the status bar displays its size grip or not.</docstr>
      </property>
      <property name="AutoHint">
        <docstr>Indicates whether the OnHint event is enabled.
Set this property to False to disable the OnHint event.</docstr>
      </property>
      <event name="OnHint">
        <docstr>Occurs when a hint is triggered.
See Using Hints to Show Contextual Help in a FireMonkey Application for more information on how to use hints.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TToolBar">
    <docstr>Represents a toolbar component for use in FireMonkey forms.
The toolbar is usually aligned at the top of a form, and has a bunch of buttons that represent shortcuts or ways to access the functionality embedded into your application. A toolbar holds essentially speed buttons, but any other FireMonkey control can sit inside a toolbar. All tool buttons on a toolbar should maintain a uniform width and height for consistency.
Typically, the tool buttons correspond to items in an application&apos;s menu and give the user more direct access to the application&apos;s commands, but they can access other functionality implemented into your application.</docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TToolBar.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.StdCtrls.TToolBar.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.StdCtrls.TToolBar.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TToolBar.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TToolBar.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <property name="TintObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="TintColor">
        <docstr>Allows you to apply a tint to a toolbar. 
This property is a value of the TAlphaColor type.

Note: Currently, the TintColor property is only available for mobile platforms (iOS and Android). For more information, see Using Styled and Colored Buttons on Target Platforms.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TSizeGrip">
    <docstr>Represents a graphical control used to dynamically resize FireMonkey forms.
Use a TSizeGrip component in a FireMonkey form  to add a custom-placed size grip used to dynamically resize the form.

It is better that you position this size grip control in the bottom-rightmost position of the form, for consistency. If your FireMonkey form already contains a TStatusBar component, there is no need to add a TSizeGrip, because the status bar can display the size grip for your resizable form.</docstr>
    <members>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.StdCtrls.TSizeGrip.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.StdCtrls.TSizeGrip.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TSplitter">
    <docstr>TSplitter divides the client area of a FireMonkey form into resizable panes.
Add a splitter to a form between two aligned controls to allow users to resize the controls at run time. The splitter sits between a control aligned to one edge of the form and the controls that fill up the rest of the client area. Give the splitter the same alignment as the control that is anchored to the edge of the form. When the user moves the splitter, it resizes the anchored control. This, in turn, changes the client area of the form, and the controls that fill up the rest of the client area resize accordingly.
Use each control on the form as a separate pane. After each pane is placed, place a splitter with the same alignment to allow that pane to be resized. The last pane to be placed on the form should be client-aligned, so that it resizes automatically to fill up the remaining space after all other panes are resized.</docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TSplitter.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.StdCtrls.TSplitter.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.StdCtrls.TSplitter.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <procedure name="SetAlign">
        <docstr>Setter function for the Align property.
FMX.StdCtrls.TSplitter.SetAlign inherits from FMX.Controls.TControl.SetAlign. All content below this line refers to FMX.Controls.TControl.SetAlign.
Setter function for the Align property. Value specifies the new value of the Align property.</docstr>
      </procedure>
      <function name="FindObject">
        <docstr>Internally used to locate the controls that are about to be resized.</docstr>
      </function>
      <procedure name="CalcSplitSize">
        <docstr>Internally used for calculating the new dimensions of the controls that are being split.</docstr>
      </procedure>
      <procedure name="UpdateSize">
        <docstr>Internally called whenever you change the position of this splitter.
UpdateSize internally calls CalcSplitSize to update the dimensions of the controls that are being split by this splitter.</docstr>
      </procedure>
      <function name="DoCanResize">
        <docstr>Internally used to know whether the controls that are about to be resized can actually be resized.</docstr>
      </function>
      <procedure name="UpdateControlSize">
        <docstr>Internally used for updating the size of the controls that are being split.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TSplitter.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.StdCtrls.TSplitter.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.StdCtrls.TSplitter.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>OnMouseMove event dispatcher. 
FMX.StdCtrls.TSplitter.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
OnMouseMove event dispatcher. 
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.StdCtrls.TSplitter.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <property name="MinSize">
        <docstr>Specifies the minimum size, in pixels, of the controls that are being split in case of sliding the splitter to the maximum of one of the left, right, top, or bottom margins.
Use MinSize to set the minimum width or height of the controls that are being split using this splitter.</docstr>
      </property>
      <property name="ShowGrip">
        <docstr>Specifies whether to show the grip control of the  TSplitter.
Set the  ShowGrip property to False to hide the grip control from the  TSplitter component. The default value is True so the  TSplitter shows the grip by default.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TProgressBar">
    <docstr>Represents an animated progress bar indicator for general progress indication.
Use a TProgressBar in applications where you need to inform the user about the progress of one or multiple tasks effectuated by your application. A TProgressBar control can display its progress (Value) in the range specified by Min and Max.

Metropolis UI ProgressBar:

When a task with an indefinite amount of time or operations is in progress, we recommend that you use a TAniIndicator to illustrate the progress.</docstr>
    <members>
      <function name="ChooseAdjustType">
        <docstr>Returns an adjust type based on the provided FixedSize.
FMX.StdCtrls.TProgressBar.ChooseAdjustType inherits from FMX.Controls.TStyledControl.ChooseAdjustType. All content below this line refers to FMX.Controls.TStyledControl.ChooseAdjustType.
Returns an adjust type based on the provided FixedSize.
FixedSize is the value of the FixedSize property of the control that is passed to AdjustFixedSize.

 See Also
System.Types.TSize
FMX.Controls.TControl.FixedSize
FMX.Types.TAdjustType
FMX.Controls.TStyledControl.AdjustFixedSize</docstr>
      </function>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TProgressBar.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.StdCtrls.TProgressBar.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.StdCtrls.TProgressBar.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
FMX.StdCtrls.TProgressBar.SetData inherits from FMX.Types.TFmxObject.SetData. All content below this line refers to FMX.Types.TFmxObject.SetData.
Protected setter implementation for the Data property.</docstr>
      </procedure>
      <procedure name="DoRealign">
        <docstr>Sends a PM_REALIGN message to the presentation layer through its presentation proxy.
FMX.StdCtrls.TProgressBar.DoRealign inherits from FMX.Controls.Presentation.TPresentedControl.DoRealign. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DoRealign.
Sends a PM_REALIGN message to the presentation layer through its presentation proxy.
For details about the circumstances that trigger this procedure, see TControl.DoRealign.

 See Also
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Controls.TControl.DoRealign</docstr>
      </procedure>
      <function name="GetActionLinkClass">
        <docstr>Returns the associated action link class.
FMX.StdCtrls.TProgressBar.GetActionLinkClass inherits from FMX.Types.TFmxObject.GetActionLinkClass. All content below this line refers to FMX.Types.TFmxObject.GetActionLinkClass.
Returns the associated action link class.
Returns the class reference for the TActionLink class or for one of its descendants. 
In TFmxObject, GetActionLinkClass always returns nil.
In descendant classes, GetActionLinkClass should return the appropriate class type for the action link used with the class object. When a control object of the descendant from the TFmxObject class tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass. If GetActionLinkClass returns a non-nil value, then the action object is assigned to Action. If the control object does not support actions, then GetActionLinkClass should return nil. In this case, attempting to set a value to the Action property raises the following exception:  

StrEActionNoSuported = &apos;Class %s does not support the action&apos;</docstr>
      </function>
      <procedure name="ActionChange">
        <docstr>Specifies the behavior of a TProgressBar control when Action changes. 
Depending on the CheckDefaults value,  ActionChange uses the TValueRangeAction.ValueRange property of the Sender action to set the new value to the  
value range property of TProgressBar. Then ActionChange calls the inherited TControl.ActionChange method.  
Do not call ActionChange explicitly in an application. It is for internal use.</docstr>
      </procedure>
      <procedure name="AfterChangeProc">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="DefaultValueRange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <procedure name="Loaded">
        <docstr>Initializes the control after the form file has been read into memory and loads its presentation.
FMX.StdCtrls.TProgressBar.Loaded inherits from FMX.Controls.Presentation.TPresentedControl.Loaded. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Loaded.
Initializes the control after the form file has been read into memory and loads its presentation.
For details, see TControl.Loaded.

 See Also
FMX.Controls.Presentation.TPresentedControl.LoadPresentation
FMX.Controls.TControl.Loaded</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TProgressBar.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TProgressBar.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <procedure name="AfterConstruction">
        <docstr>Responds after the last constructor has executed and loads the control presentation.
FMX.StdCtrls.TProgressBar.AfterConstruction inherits from FMX.Controls.Presentation.TPresentedControl.AfterConstruction. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.AfterConstruction.
Responds after the last constructor has executed and loads the control presentation.
AfterConstruction is called automatically after the object&apos;s last constructor has executed. Do not call it explicitly in your applications.</docstr>
      </procedure>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TPresentedControl.
FMX.StdCtrls.TProgressBar.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
Destroys this instance of TPresentedControl.

 See Also
FMX.Controls.Presentation.TPresentedControl.Create</docstr>
      </destructor>
      <property name="Max">
        <docstr>Specifies the maximum value for this progress bar. As you place a TProgressBar component on a form, the default value for the Max property is set to 100.</docstr>
      </property>
      <property name="Min">
        <docstr>Specifies the minimum value for this progress bar. The default value for the Min property is 0.</docstr>
      </property>
      <property name="Orientation">
        <docstr>Specifies the orientation (Horizontal or Vertical) for the progress bar.</docstr>
      </property>
      <property name="Value">
        <docstr>Specifies the current position of the progress bar.
You can read Value to determine the progress from Min to Max. 
Set a needed value for the Value property, and the progress bar will display a position between Min and Max. For example, when the process completes, set Value to Max so that it appears completely filled.
By default, the Min and Max values of the progress bar are represented in percentage terms, where Min is 0 (0% complete) and Max is 100 (100% complete).</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TThumb">
    <docstr>Represents a thumb control for use with track bars.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.StdCtrls.TThumb.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.StdCtrls.TThumb.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>OnMouseMove event dispatcher. 
FMX.StdCtrls.TThumb.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
OnMouseMove event dispatcher. 
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.StdCtrls.TThumb.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <function name="GetDefaultTouchTargetExpansion">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="IsPressed">
        <docstr>Specifies the state of this thumb component (pressed or unpressed).
Use the IsPressed property to specify the status of this thumb (pressed - True; unpressed - False).</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TCustomTrack">
    <docstr>Base class for all track bar components.
TCustomTrack is the base class for all track bar components such as TTrackBar.
If you need to create your own custom track bar, then you should derive your component from TCustomTrack, as it already implements functionality for drawing and manipulating the track bar.</docstr>
    <members>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.StdCtrls.TCustomTrack.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
FMX.StdCtrls.TCustomTrack.SetData inherits from FMX.Types.TFmxObject.SetData. All content below this line refers to FMX.Types.TFmxObject.SetData.
Protected setter implementation for the Data property.</docstr>
      </procedure>
      <function name="CanObserve">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.</docstr>
      </function>
      <procedure name="SetOrientation">
        <docstr>Protected setter implementation for the Orientation property.</docstr>
      </procedure>
      <function name="GetThumbRect">
        <docstr>Returns a TRectF with the coordinates of the area that the thumb has access to.</docstr>
      </function>
      <function name="GetThumbRect">
        <docstr>Returns a TRectF with the coordinates of the area that the thumb has access to.</docstr>
      </function>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.StdCtrls.TCustomTrack.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.StdCtrls.TCustomTrack.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="DoMouseUp">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Sends a PM_KEYDOWN message to the presentation layer through its presentation proxy when a key is pressed down while your presented control has the focus.
FMX.StdCtrls.TCustomTrack.KeyDown inherits from FMX.Controls.Presentation.TPresentedControl.KeyDown. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.KeyDown.
Sends a PM_KEYDOWN message to the presentation layer through its presentation proxy when a key is pressed down while your presented control has the focus.
The message includes a TKeyInfo record that contains the data of the parameters (AKey, AKeyChar, AShift).

 See Also
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Controls.Presentation.TKeyInfo
FMX.Controls.TControl.KeyDown
FMX.Forms.TCommonCustomForm.KeyDown
FMX.Controls.Presentation.TPresentedControl.KeyUp</docstr>
      </procedure>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TCustomTrack.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.StdCtrls.TCustomTrack.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <function name="ChooseAdjustType">
        <docstr>Returns an adjust type based on the provided FixedSize.
FMX.StdCtrls.TCustomTrack.ChooseAdjustType inherits from FMX.Controls.TStyledControl.ChooseAdjustType. All content below this line refers to FMX.Controls.TStyledControl.ChooseAdjustType.
Returns an adjust type based on the provided FixedSize.
FixedSize is the value of the FixedSize property of the control that is passed to AdjustFixedSize.

 See Also
System.Types.TSize
FMX.Controls.TControl.FixedSize
FMX.Types.TAdjustType
FMX.Controls.TStyledControl.AdjustFixedSize</docstr>
      </function>
      <function name="GetDefaultTouchTargetExpansion">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="DoThumbClick">
        <docstr>Executes internally each time the OnClick event of the attached TThumb component fires.</docstr>
      </procedure>
      <procedure name="DoThumbDblClick">
        <docstr>Executes internally each time the OnDblClick event of the attached TThumb component fires.</docstr>
      </procedure>
      <function name="GetThumbSize">
        <docstr>Returns the size of the thumb. The thumb size represents the percentage of the viewport relative to the content size.</docstr>
      </function>
      <procedure name="DoRealign">
        <docstr>Sends a PM_REALIGN message to the presentation layer through its presentation proxy.
FMX.StdCtrls.TCustomTrack.DoRealign inherits from FMX.Controls.Presentation.TPresentedControl.DoRealign. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DoRealign.
Sends a PM_REALIGN message to the presentation layer through its presentation proxy.
For details about the circumstances that trigger this procedure, see TControl.DoRealign.

 See Also
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Controls.TControl.DoRealign</docstr>
      </procedure>
      <property name="IsTracking">
        <docstr>Indicates whether the Thumb that is associated with this TCustomTrack is pressed.
This is a read-only property.
The following table shows the value of IsTracking in some common scenarios:



Tracking

Scenario

Behaviour

Events fired

IsTracking



True or False



Press an arrow key on the keyboard.



The Thumb moves for one &quot;step&quot;.



OnTracking
OnChange


False




True



Click on the Thumb of the track bar and move the Thumb.



The Thumb moves as much as you move it.



For each &quot;step&quot; of the movement:

OnTracking
OnChange


True




False



Click on the Thumb of the track bar and move the Thumb.



The Thumb moves as much as you move it.



For each step of the movement:

OnTracking
After you release the Thumb

OnChange


True




True



Click anywhere on the track bar (excluding the Thumb).



The Thumb moves for one &quot;step&quot;.



OnTracking
OnChange


False




False



Click anywhere on the track bar (excluding the Thumb).



The Thumb moves to the position where you click.



OnTracking
OnChange


False




True or False



Hold the Shift button and click anywhere on the track bar (excluding the Thumb).



The Thumb moves to the position where you click.



OnTracking
OnChange


False</docstr>
      </property>
      <function name="GetActionLinkClass">
        <docstr>Returns the associated action link class.
FMX.StdCtrls.TCustomTrack.GetActionLinkClass inherits from FMX.Types.TFmxObject.GetActionLinkClass. All content below this line refers to FMX.Types.TFmxObject.GetActionLinkClass.
Returns the associated action link class.
Returns the class reference for the TActionLink class or for one of its descendants. 
In TFmxObject, GetActionLinkClass always returns nil.
In descendant classes, GetActionLinkClass should return the appropriate class type for the action link used with the class object. When a control object of the descendant from the TFmxObject class tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass. If GetActionLinkClass returns a non-nil value, then the action object is assigned to Action. If the control object does not support actions, then GetActionLinkClass should return nil. In this case, attempting to set a value to the Action property raises the following exception:  

StrEActionNoSuported = &apos;Class %s does not support the action&apos;</docstr>
      </function>
      <procedure name="ActionChange">
        <docstr>Specifies the behavior of a TCustomTrack control when Action changes. 
Depending on the CheckDefaults value,  ActionChange uses the TValueRangeAction.ValueRange property of the Sender action to set the new value to the  
ValueRange property of TCustomTrack. Then ActionChange calls the inherited TControl.ActionChange method.  
Do not call ActionChange explicitly in an application. It is for internal use.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the control after the form file has been read into memory and loads its presentation.
FMX.StdCtrls.TCustomTrack.Loaded inherits from FMX.Controls.Presentation.TPresentedControl.Loaded. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Loaded.
Initializes the control after the form file has been read into memory and loads its presentation.
For details, see TControl.Loaded.

 See Also
FMX.Controls.Presentation.TPresentedControl.LoadPresentation
FMX.Controls.TControl.Loaded</docstr>
      </procedure>
      <procedure name="DoChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoTracking">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TCustomTrack.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <function name="CreateValueRangeTrack">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="MouseDownAction">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="DefaultValueRange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <procedure name="Resize">
        <docstr>OnResize event dispatcher. 
FMX.StdCtrls.TCustomTrack.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
OnResize event dispatcher. 
A control calls Resize when the dimensions of the control change.
Derived classes can override the protected Resize method to implement specific responses to control resizing.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
FMX.StdCtrls.TCustomTrack.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TCustomTrack.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TPresentedControl.
FMX.StdCtrls.TCustomTrack.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
Destroys this instance of TPresentedControl.

 See Also
FMX.Controls.Presentation.TPresentedControl.Create</docstr>
      </destructor>
      <procedure name="AfterConstruction">
        <docstr>Responds after the last constructor has executed and loads the control presentation.
FMX.StdCtrls.TCustomTrack.AfterConstruction inherits from FMX.Controls.Presentation.TPresentedControl.AfterConstruction. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.AfterConstruction.
Responds after the last constructor has executed and loads the control presentation.
AfterConstruction is called automatically after the object&apos;s last constructor has executed. Do not call it explicitly in your applications.</docstr>
      </procedure>
      <property name="ValueRange">
        <docstr>Provides access to the Value value, to its Min and Max boundaries, and to the Frequency and ViewportSize properties.</docstr>
      </property>
      <property name="Min">
        <docstr>Specifies the minimum value of this track bar, for the minimum position of the slider.
Use the Min property to set a minimum value down to which the slider of this track bar can go. For instance, if Min is set to 0 (a default value), then attempting to move the slider to the minimum will result in a Value of 0.</docstr>
      </property>
      <property name="Max">
        <docstr>Specifies the maximum value of this track bar for the maximum position of the slider.
Use the Max property to set a maximum value up to which the slider of this track bar can go. For instance, if Max is set to 100 (a default value), then attempting to move the slider to the maximum will result in a Value of 100.</docstr>
      </property>
      <property name="Frequency">
        <docstr>Specifies the number of positions the slider advances with each move.
Use the Frequency property to specify how many steps at once the slider advances with each move. For instance, if you set Frequency to 10, Min to 0, and Max to 100, then there are only 10 steps for this slider to move within the 0 to 100 range; Value is incremented or decremented with 10 divisions.
Frequency is a floating-point Single value; setting Frequency to 0 enables this track bar to increment or decrement by 0.01 divisions by step. Setting Frequency to any integer value (for instance 1, or 5, and so on) will enable this track bar to increment or decrement by the specified value.
However, please take into consideration that if you set Frequency to any value greater than 0 and you try to programmatically assign a value to Value, then your value will be converted to the nearest multiple of Frequency.
For instance, setting Frequency to 5 and then attempting to programmatically set Value to 12 will actually set Value to 10.

  MyTrackBar.Frequency := 5;
  MyTrackBar.Value := 12; { actually sets Value to 10 }

  MyTrackBar-&gt;Frequency = 5;
  MyTrackBar-&gt;Value = 12; /* actually sets Value to 10 */</docstr>
      </property>
      <property name="SmallChange">
        <docstr>Controls the number of positions that the Thumb of the TCustomTrack moves each time the user presses on a free area.</docstr>
      </property>
      <property name="Value">
        <docstr>Specifies the current value of this track bar.
Set or get Value to specify or obtain the current value of this track bar. You can set Value programmatically or visually at run time, with any value within the interval delimited by Min and Max.</docstr>
      </property>
      <property name="ViewportSize">
        <docstr>Specifies the size, in pixels, of the area that the slider cannot span to the left or right of this track bar.
Use the ViewportSize property to specify the size of the view port of this track bar, that is, the area, in pixels, that the slider of this track bar cannot span. As an example, the picture below shows two track bars, one with ViewportSize set to 0 and the other with ViewportSize set to 50.


Tip: Changing the ViewportSize property does not affect the limits (Min or Max) or the Value of this track bar.</docstr>
      </property>
      <property name="Orientation">
        <docstr>Specifies the orientation of this track bar (from left to right or from bottom to top).
Use the Orientation property to specify how this track bar will be displayed in terms of left-to-right orientation or bottom-to-top orientation. Orientation can have one of the following values:



Value

Meaning



Vertical



The track bar is rendered with the bottom-to-top orientation.




Horizontal



The track bar is rendered with the left-to-right orientation.</docstr>
      </property>
      <property name="Tracking">
        <docstr>Indicates whether thumb tracking is active or not. The default value of Tracking is True.
The following table shows how the value of Tracking impacts the behavior of a track bar and the related events:



Tracking

Scenario

Behaviour

Events fired

IsTracking



True or False



Press an arrow key on the keyboard.



The Thumb moves for one &quot;step&quot;.



OnTracking
OnChange


False




True



Click on the Thumb of the track bar and move the Thumb.



The Thumb moves as much as you move it.



For each &quot;step&quot; of the movement:

OnTracking
OnChange


True




False



Click on the Thumb of the track bar and move the Thumb.



The Thumb moves as much as you move it.



For each step of the movement:

OnTracking
After you release the Thumb

OnChange


True




True



Click anywhere on the track bar (excluding the Thumb).



The Thumb moves for one &quot;step&quot;.



OnTracking
OnChange


False




False



Click anywhere on the track bar (excluding the Thumb).



The Thumb moves to the position where you click.



OnTracking
OnChange


False




True or False



Hold the Shift button and click anywhere on the track bar (excluding the Thumb).



The Thumb moves to the position where you click.



OnTracking
OnChange


False</docstr>
      </property>
      <property name="Thumb">
        <docstr>The part of a track bar that you move to change the value of the track bar.
The default appearance of the Thumb depends on the platform:

Windows: The Thumb is a rectangle.
OS X: The Thumb is a circle.
iOS: The Thumb is a circle.
Android: The Thumb is a circle.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs immediately after the position of the slider of this track bar changes.
Write an OnChange event handler to provide additional functionality when changing the position of the slider of this track bar component.
The OnTracking is very similar to OnChange. The following table shows the difference in the behavior of these events in certain scenarios:



Tracking

Scenario

Behaviour

Events fired

IsTracking



True or False



Press an arrow key on the keyboard.



The Thumb moves for one &quot;step&quot;.



OnTracking
OnChange


False




True



Click on the Thumb of the track bar and move the Thumb.



The Thumb moves as much as you move it.



For each &quot;step&quot; of the movement:

OnTracking
OnChange


True




False



Click on the Thumb of the track bar and move the Thumb.



The Thumb moves as much as you move it.



For each step of the movement:

OnTracking
After you release the Thumb

OnChange


True




True



Click anywhere on the track bar (excluding the Thumb).



The Thumb moves for one &quot;step&quot;.



OnTracking
OnChange


False




False



Click anywhere on the track bar (excluding the Thumb).



The Thumb moves to the position where you click.



OnTracking
OnChange


False




True or False



Hold the Shift button and click anywhere on the track bar (excluding the Thumb).



The Thumb moves to the position where you click.



OnTracking
OnChange


False</docstr>
      </event>
      <event name="OnTracking">
        <docstr>Occurs immediately after the position of the slider of this track bar changes.
Write an OnTracking event handler to provide additional functionality when changing the position of the slider of this track bar component.
The OnTracking is very similar to OnChange. The following table shows the difference in the behavior of these events in certain scenarios:



Tracking

Scenario

Behaviour

Events fired

IsTracking



True or False



Press an arrow key on the keyboard.



The Thumb moves for one &quot;step&quot;.



OnTracking
OnChange


False




True



Click on the Thumb of the track bar and move the Thumb.



The Thumb moves as much as you move it.



For each &quot;step&quot; of the movement:

OnTracking
OnChange


True




False



Click on the Thumb of the track bar and move the Thumb.



The Thumb moves as much as you move it.



For each step of the movement:

OnTracking
After you release the Thumb

OnChange


True




True



Click anywhere on the track bar (excluding the Thumb).



The Thumb moves for one &quot;step&quot;.



OnTracking
OnChange


False




False



Click anywhere on the track bar (excluding the Thumb).



The Thumb moves to the position where you click.



OnTracking
OnChange


False




True or False



Hold the Shift button and click anywhere on the track bar (excluding the Thumb).



The Thumb moves to the position where you click.



OnTracking
OnChange


False</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TTrack">
    <docstr>Is a TCustomTrack with a set of published properties.
TTrack publishes a set of properties from the TCustomTrack base component, but is not registered to the Tool Palette, so it cannot be added directly to a FireMonkey form.
You can derive your own custom track bar component from TTrack.</docstr>
  </class>
  <class unit="FMX.StdCtrls" name="TTrackBar">
    <docstr>Represents a general-purpose track bar for use in applications where tracking is required.
TTrackBar represents a FireMonkey styled track bar that can be used for various types of tracking operations; for instance, it is useful for adjusting properties such as color, volume, and brightness. Move the slide indicator by dragging it to a particular location or click in the bar to change its Value. Adjust this track bar&apos;s view port by affecting the value of the ViewportSize property.

Use the Max and Min properties to set the upper and lower range of the track bar. The Orientation property determines whether this track bar is vertical or horizontal.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TTrackBar.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TBitmapTrackBar">
    <docstr>Represents a track bar similar to that implemented by TTrackBar.
TBitmapTrackBar is not registered to the IDE, thus it cannot be dragged and dropped from the tool palette. You can manually instantiate such component, override the constructor, and create a track bar that can display bitmaps.
TBitmapTrackBar is intended for component designers as a base component for other custom track bars.
Use TTrackBar in applications, instead.</docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TBitmapTrackBar.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.StdCtrls.TBitmapTrackBar.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <procedure name="DoRealign">
        <docstr>Sends a PM_REALIGN message to the presentation layer through its presentation proxy.
FMX.StdCtrls.TBitmapTrackBar.DoRealign inherits from FMX.Controls.Presentation.TPresentedControl.DoRealign. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DoRealign.
Sends a PM_REALIGN message to the presentation layer through its presentation proxy.
For details about the circumstances that trigger this procedure, see TControl.DoRealign.

 See Also
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Controls.TControl.DoRealign</docstr>
      </procedure>
      <function name="GetDefaultStyleLookupName">
        <docstr>Protected getter implementation for the DefaultStyleLookupName property.
FMX.StdCtrls.TBitmapTrackBar.GetDefaultStyleLookupName inherits from FMX.Controls.TStyledControl.GetDefaultStyleLookupName. All content below this line refers to FMX.Controls.TStyledControl.GetDefaultStyleLookupName.
Protected getter implementation for the DefaultStyleLookupName property.
When you Create a styled FireMonkey component by extending an existing component, override this method, if you want your component to inherit styles from the parent component. See Step 2 - Implement a Property to Specify the Format: Inheriting Styles of the Parent Component for more information and example code.</docstr>
      </function>
      <procedure name="UpdateBitmap">
        <docstr>Internally executed whenever there is a need to update this component&apos;s bitmap image. The bitmap image is updated when it is changed, when the orientation of this bitmap track bar control changes, or when it needs a repaint.</docstr>
      </procedure>
      <procedure name="FillBitmap">
        <docstr>Draws the bitmap behind this track bar.
The FillBitmap virtual method is provided in order to be overridden in derived classes to allow for custom drawing of the bitmap image behind this track bar.</docstr>
      </procedure>
      <procedure name="SetOrientation">
        <docstr>Protected setter implementation for the Orientation property.
FMX.StdCtrls.TBitmapTrackBar.SetOrientation inherits from FMX.StdCtrls.TCustomTrack.SetOrientation. All content below this line refers to FMX.StdCtrls.TCustomTrack.SetOrientation.
Protected setter implementation for the Orientation property.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TBitmapTrackBar.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TPresentedControl.
FMX.StdCtrls.TBitmapTrackBar.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
Destroys this instance of TPresentedControl.

 See Also
FMX.Controls.Presentation.TPresentedControl.Create</docstr>
      </destructor>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TSwitchModel">
    <docstr></docstr>
    <members>
      <procedure name="DoChanged">
        <docstr>Invokes OnSwitch event handler</docstr>
      </procedure>
      <procedure name="Change">
        <docstr>Invokes OnSwitch event handler</docstr>
      </procedure>
      <property name="Value">
        <docstr>Property representing the boolean value of the switch. When the switch is On, the boolean value is
           True. When the switch is Off, the boolean value is False.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TCustomSwitch">
    <docstr></docstr>
    <members>
      <procedure name="ActionChange">
        <docstr>Sends a message to the presentation layer of the presentation proxy when the Action property changes.
FMX.StdCtrls.TCustomSwitch.ActionChange inherits from FMX.Controls.Presentation.TPresentedControl.ActionChange. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.ActionChange.
Sends a message to the presentation layer of the presentation proxy when the Action property changes.
The presentation layer receives a message with PM_ACTION_CHANGE as MsgID and an instance of TActionInfo as Value with the following data:



Property

Data



Value.Sender



ASender




Value.CheckDefaults



ACheckDefaults


 See Also
FMX.Controls.TControl.ActionChange
FMX.Controls.Presentation.TPresentedControl.PresentationProxy
FMX.Presentation.Messages.TMessageSender.SendMessage
FMX.Presentation.Messages.TMessageSender.Receiver
System.TObject.Dispatch
FMX.Presentation.Messages.TDispatchMessageWithValue
FMX.Presentation.Messages.TDispatchMessageWithValue.MsgID
FMX.Presentation.Messages.TDispatchMessageWithValue.Value
FMX.Controls.Presentation.TActionInfo
FMX.Controls.Presentation.TActionInfo.Sender
FMX.Controls.Presentation.TActionInfo.CheckDefaults</docstr>
      </procedure>
      <function name="GetActionLinkClass">
        <docstr>Returns the associated action link class.
FMX.StdCtrls.TCustomSwitch.GetActionLinkClass inherits from FMX.Types.TFmxObject.GetActionLinkClass. All content below this line refers to FMX.Types.TFmxObject.GetActionLinkClass.
Returns the associated action link class.
Returns the class reference for the TActionLink class or for one of its descendants. 
In TFmxObject, GetActionLinkClass always returns nil.
In descendant classes, GetActionLinkClass should return the appropriate class type for the action link used with the class object. When a control object of the descendant from the TFmxObject class tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass. If GetActionLinkClass returns a non-nil value, then the action object is assigned to Action. If the control object does not support actions, then GetActionLinkClass should return nil. In this case, attempting to set a value to the Action property raises the following exception:  

StrEActionNoSuported = &apos;Class %s does not support the action&apos;</docstr>
      </function>
      <function name="CanObserve">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
FMX.StdCtrls.TCustomSwitch.SetData inherits from FMX.Types.TFmxObject.SetData. All content below this line refers to FMX.Types.TFmxObject.SetData.
Protected setter implementation for the Data property.</docstr>
      </procedure>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.StdCtrls.TCustomSwitch.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.StdCtrls.TCustomSwitch.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="Click">
        <docstr>Responds to user clicks, key pressing, and input on touch devices (gestures).
FMX.StdCtrls.TCustomSwitch.Click inherits from FMX.Controls.TControl.Click. All content below this line refers to FMX.Controls.TControl.Click.
Responds to user clicks, key pressing, and input on touch devices (gestures).
Click is an event handler for the OnClick event. It is automatically called when the left mouse button is pressed and released with the pointer over the control. Click also can be called in DialogKey and other methods handling an input from keyboards and touch devices.
Call Click in applications to simulate an OnClick mouse event.  
If EnableExecuteAction is True and the OnClick event handler is not assigned (or is equal to Action.OnExecute), then Click executes the assigned Action, otherwise executes the OnClick event handler.</docstr>
      </procedure>
      <function name="GetDefaultTouchTargetExpansion">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="DefineModelClass">
        <docstr>Returns a class reference to a data model of this presented control.
FMX.StdCtrls.TCustomSwitch.DefineModelClass inherits from FMX.Controls.Presentation.TPresentedControl.DefineModelClass. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.DefineModelClass.
Returns a class reference to a data model of this presented control.
Returns a class reference to a data model class that the constructor of this presented control uses to create a data model for the control.
By default DefineModelClass returns TDataModel. Descendant classes reimplement DefineModelClass to determine the data model class that a descendant presented control uses for its data model.

 See Also
FMX.Controls.Model.TDataModelClass
FMX.Controls.Model.TDataModel
FMX.Controls.Presentation.TPresentedControl.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Presentation.Style.TStyledPresentation.DefineModelClass
Class References</docstr>
      </function>
      <procedure name="DoSwitch">
        <docstr>Updates the action of the switch and calls the handler of the OnSwitch event.
Called by the DoChanged procedure of the data model of the control when the value of the switch control changes.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TCustomSwitch.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TCustomSwitch.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <property name="Model">
        <docstr>A data model for this control.</docstr>
      </property>
      <property name="IsChecked">
        <docstr>Indicates if the Switch is turned on or off.
IsChecked is True if the Switch is turned on, False otherwise.</docstr>
      </property>
      <event name="OnSwitch">
        <docstr>Event handler that is invoked when Switch changes the value of IsChecked.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TSwitch">
    <docstr>Represents a two-way on-off switch for use in applications.
Use a TSwitch whenever you need to provide the user with a two-way on-off switch.</docstr>
  </class>
  <class unit="FMX.StdCtrls" name="TScrollBar">
    <docstr>Represents a standard scroll bar that is used to scroll the contents of a window, form, or a control.
TScrollBar adds a free-standing scroll bar to a form. Many controls have properties that add scroll bars that are an integral part of the control. However, TScrollBar allows controls that do not have integrated scroll bars or groupings of controls to be scrolled when the user manipulates the TScrollBar object.</docstr>
    <members>
      <procedure name="DoMinButtonClick">
        <docstr>Executes internally each time the min button is pressed.</docstr>
      </procedure>
      <procedure name="DoMaxButtonClick">
        <docstr>Executes internally each time the max button is pressed.</docstr>
      </procedure>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TScrollBar.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.StdCtrls.TScrollBar.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <function name="CanObserve">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.</docstr>
      </function>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.StdCtrls.TScrollBar.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
FMX.StdCtrls.TScrollBar.SetData inherits from FMX.Types.TFmxObject.SetData. All content below this line refers to FMX.Types.TFmxObject.SetData.
Protected setter implementation for the Data property.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Provides a response when a key is pressed down while the control has the keyboard focus. 
FMX.StdCtrls.TScrollBar.KeyDown inherits from FMX.Controls.TControl.KeyDown. All content below this line refers to FMX.Controls.TControl.KeyDown.
Provides a response when a key is pressed down while the control has the keyboard focus. 
If the pressed key is the Applications key (Key = vkApps), then KeyDown shows the context menu of the control. Otherwise, KeyDown calls the OnKeyDown event handler if one is assigned. 
TCommonCustomForm and descendant of TControl classes--like TCustomGrid--call KeyDown from their methods handling key pressing. They decode the message parameters into the key code, character code, and shift state. They pass them into the called KeyDown method in the Key, KeyChar, and Shift parameters, respectively:  



Parameters

Descriptions



Key



Is the scan code of the pressed keyboard key or $0.
If a pressed key combination can be a shortcut, then Key &lt;&gt; 0 is a virtual key and KeyChar = #0. 
Physical scan codes of the same key can differ under different platforms (Windows or iOS).
Platform-specific units (for example FMX.Platform.Mac.pas) should translate native scan codes to corresponding Windows codes defined in the UITypes unit.  For example, 

vkReturn = $0D;  {  13 } corresponds to the RETURN keyboard key.
vkF2     = $71;  { 113 } corresponds to the F2 keyboard key.



KeyChar



Is the pressed character (digit) or #0.
If a pressed key combination can be treated as a printable character or digit, then Key = 0 and KeyChar contains a pressed symbol according to the current keyboard&apos;s input language, keyboard mode (CAPS LOCK and NUM LOCK keys), keyboard Shift state, and IME state. Editors can use this symbol to add into a text being edited. 




Shift



Indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the specified key was pressed with the control in focus.


If the control has successfully processed the pressed key combination and no additional processing is required, then KeyDown assigns Key = 0 and KeyChar = #0.  
Override the protected KeyDown method to provide other responses when a key is down while the control has keyboard input focus.
See TCommonCustomForm.KeyDown for more information about parameters.</docstr>
      </procedure>
      <function name="GetActionLinkClass">
        <docstr>Returns the associated action link class.
FMX.StdCtrls.TScrollBar.GetActionLinkClass inherits from FMX.Types.TFmxObject.GetActionLinkClass. All content below this line refers to FMX.Types.TFmxObject.GetActionLinkClass.
Returns the associated action link class.
Returns the class reference for the TActionLink class or for one of its descendants. 
In TFmxObject, GetActionLinkClass always returns nil.
In descendant classes, GetActionLinkClass should return the appropriate class type for the action link used with the class object. When a control object of the descendant from the TFmxObject class tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass. If GetActionLinkClass returns a non-nil value, then the action object is assigned to Action. If the control object does not support actions, then GetActionLinkClass should return nil. In this case, attempting to set a value to the Action property raises the following exception:  

StrEActionNoSuported = &apos;Class %s does not support the action&apos;</docstr>
      </function>
      <procedure name="DoActionClientChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ActionChange">
        <docstr>Specifies the behavior of a TScrollBar control when Action changes. 
ActionChange uses the Action property of the Sender object to set Action for the Track control of TScrollBar. 
Do not call ActionChange explicitly in an application. It is for internal use.</docstr>
      </procedure>
      <property name="Track">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="MinButton">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="MaxButton">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <procedure name="DoChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.StdCtrls.TScrollBar.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TScrollBar.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
FMX.StdCtrls.TScrollBar.Loaded inherits from FMX.Controls.TControl.Loaded. All content below this line refers to FMX.Controls.TControl.Loaded.
Initializes the component after the form file has been read into memory. 
Loaded inherits TComponent.Loaded, realigns the children, if any, and updates the tab list.
For details, see TComponent.Loaded.</docstr>
      </procedure>
      <property name="DefaultValueRange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.StdCtrls.TScrollBar.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.StdCtrls.TScrollBar.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="AfterConstruction">
        <docstr>Responds after the last constructor has executed.
FMX.StdCtrls.TScrollBar.AfterConstruction inherits from System.TObject.AfterConstruction. All content below this line refers to System.TObject.AfterConstruction.
Responds after the last constructor has executed.
AfterConstruction is called automatically after the object&apos;s last constructor has executed. Do not call it explicitly in your applications. 
The AfterConstruction method implemented in TObject does nothing. Override this method when creating a class that performs an action after the object is created. For example, TCustomForm overrides AfterConstruction to generate an OnCreate event.</docstr>
      </procedure>
      <property name="ValueRange">
        <docstr>Provides access to the Value value, to its Min and Max boundaries, and to the ViewportSize property.</docstr>
      </property>
      <property name="Max">
        <docstr>Specifies the maximum value of this scroll bar for the maximum position of the slider.
Use the Max property to set a maximum value up to which the slider of this scroll bar can go. For instance, if Max is set to 100 (a default value), then attempting to move the slider to the maximum will result in a Value of 100.</docstr>
      </property>
      <property name="Min">
        <docstr>Specifies the minimum value of this scroll bar for the minimum position of the slider.
Use the Min property to set a minimum value down to which the slider of this scroll bar can go. For instance, if Min is set to 0 (a default value), then attempting to move the slider to the minimum will result in a Value of 0.</docstr>
      </property>
      <property name="Value">
        <docstr>Specifies the current value of this scroll bar.
Set or get Value to specify or obtain the current value of this scroll bar. You can set Value programmatically or visually, at run time, with any value within the interval delimited by Min and Max.</docstr>
      </property>
      <property name="ViewportSize">
        <docstr>Specifies the size, in pixels, of the slider of this scroll bar.
Use the ViewportSize property to specify the size of the viewport of this scroll bar, that is, the area, in pixels, of the slider of this scroll. As an example, the picture below shows two scroll bars, one with ViewportSize set to 0 and the other with ViewportSize set to 50.


Tip: Changing the ViewportSize property does not affect the limits (Min or Max) of the Value of this scroll bar.</docstr>
      </property>
      <property name="SmallChange">
        <docstr>Controls the number of positions this scroll bar&apos;s slider moves on each pressing of the min or max button.
Use the SmallChange property to control the number of positions the slider of this scroll bar forwards or backwards in respect to pressing the max or min buttons.
For instance, setting SmallChange to 10 causes each push of the max or min button make the slider move with exactly 10 positions forwards or backwards.

Tip: If the current position of the slider (reflected by Value) is a number lower than SmallChange, then pressing the min button will bring Value to 0.</docstr>
      </property>
      <property name="Orientation">
        <docstr>Specifies the orientation of this scroll bar (left to right or bottom to top).
Use the Orientation property to specify how this scroll bar will be displayed (left to right or bottom to top). Orientation can have one of the following values:



Value

Meaning



Vertical



The scroll bar is rendered with the bottom-to-top orientation.




Horizontal



The scroll bar is rendered with the left-to-right orientation.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs immediately after the position of the slider on this scroll bar changes.
Write an OnChange event handler to provide additional functionality when changing the position of the slider on this scroll bar component.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TSmallScrollBar">
    <docstr>Represents a variation of a standard scroll bar.
A TSmallScrollBar component is a trimmed-down standard TScrollBar without the min and max buttons. Otherwise the behavior is the same.</docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TSmallScrollBar.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TSmallScrollBar.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.StdCtrls.TSmallScrollBar.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TAniIndicator">
    <docstr>Represents an animated spinning indicator used for illustrating an indefinite waiting time for application processes.
Use a TAniIndicator in applications where you need to inform the user that a task that takes an indefinite amount of time is in progress. Enable or disable the spinning effect by controlling the state of the Enabled property (True or False). 
An animated spinning indicator can be rendered as lines or as circles:

You can also style TAniIndicator to be a Metropolis UI  indeterminate ring progress bar (Windows 8 style):

For more information about the Metropolis UI indeterminate ring progress indicator, see Creating an Animated Indeterminate Progress Ring and Developing Metropolis UI Applications.

Note:
When a task with a definite amount of time or operations is in progress, we recommend that you use a TProgressBar to illustrate the progress.</docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TAniIndicator.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.StdCtrls.TAniIndicator.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <procedure name="SetEnabled">
        <docstr>Setter of Enabled.
FMX.StdCtrls.TAniIndicator.SetEnabled inherits from FMX.Controls.TControl.SetEnabled. All content below this line refers to FMX.Controls.TControl.SetEnabled.
Setter of Enabled.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.StdCtrls.TAniIndicator.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the control&apos;s surface. 
FMX.StdCtrls.TAniIndicator.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
Renders the control&apos;s surface. 
The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes.</docstr>
      </procedure>
      <function name="EnabledStored">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.StdCtrls.TAniIndicator.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.StdCtrls.TAniIndicator.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="Style">
        <docstr>Specifies the way this animated indicator looks (either linear or circular).
Use the Style property to specify how this animated indicator looks. You can set its look as a linear indicator (Linear) or a circular indicator (Circular). The following picture illustrates the two rendering modes.

Enable or disable the rotating effect by setting the Enabled property to either True or False.</docstr>
      </property>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TArcDial">
    <docstr>Represents a general-purpose knob-style rotating button.
Use a TArcDial button in applications wherever you need to provide the user with a rotating button that resembles a knob. This arc dial control variates its Value in degrees, so if you want to use it as a linear control for varying the progress of a progress bar, for instance, you need to programmatically make a conversion from degrees to linear movement.

Control whether this arc dial component displays the value or not using the FMX.StdCtrls.TArcDial.ShowValue property.</docstr>
    <members>
      <function name="Tick">
        <docstr>Used internally to determine the rotation angle.</docstr>
      </function>
      <function name="Text">
        <docstr>Used internally to render the text that displays the value of this arc dial component.</docstr>
      </function>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TArcDial.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <function name="CanObserve">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.StdCtrls.TArcDial.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
FMX.StdCtrls.TArcDial.SetData inherits from FMX.Types.TFmxObject.SetData. All content below this line refers to FMX.Types.TFmxObject.SetData.
Protected setter implementation for the Data property.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the control after the form file has been read into memory and loads its presentation.
FMX.StdCtrls.TArcDial.Loaded inherits from FMX.Controls.Presentation.TPresentedControl.Loaded. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Loaded.
Initializes the control after the form file has been read into memory and loads its presentation.
For details, see TControl.Loaded.

 See Also
FMX.Controls.Presentation.TPresentedControl.LoadPresentation
FMX.Controls.TControl.Loaded</docstr>
      </procedure>
      <function name="GetActionLinkClass">
        <docstr>Returns the associated action link class.
FMX.StdCtrls.TArcDial.GetActionLinkClass inherits from FMX.Types.TFmxObject.GetActionLinkClass. All content below this line refers to FMX.Types.TFmxObject.GetActionLinkClass.
Returns the associated action link class.
Returns the class reference for the TActionLink class or for one of its descendants. 
In TFmxObject, GetActionLinkClass always returns nil.
In descendant classes, GetActionLinkClass should return the appropriate class type for the action link used with the class object. When a control object of the descendant from the TFmxObject class tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass. If GetActionLinkClass returns a non-nil value, then the action object is assigned to Action. If the control object does not support actions, then GetActionLinkClass should return nil. In this case, attempting to set a value to the Action property raises the following exception:  

StrEActionNoSuported = &apos;Class %s does not support the action&apos;</docstr>
      </function>
      <procedure name="ActionChange">
        <docstr>Specifies the behavior of a TArcDial control when Action changes. 
Depending on the CheckDefaults value,  ActionChange uses the TValueRangeAction.ValueRange property of the Sender action to set the new value to the  
ValueRange property of TArcDial. Then ActionChange calls the inherited TControl.ActionChange method.  
Do not call ActionChange explicitly in an application. It is for internal use.</docstr>
      </procedure>
      <procedure name="BeforeChangeProc">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ValueRangeChangeProc">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AfterChangedProc">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TArcDial.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <property name="DefaultValueRange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TArcDial.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TPresentedControl.
FMX.StdCtrls.TArcDial.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
Destroys this instance of TPresentedControl.

 See Also
FMX.Controls.Presentation.TPresentedControl.Create</docstr>
      </destructor>
      <procedure name="AfterConstruction">
        <docstr>Responds after the last constructor has executed and loads the control presentation.
FMX.StdCtrls.TArcDial.AfterConstruction inherits from FMX.Controls.Presentation.TPresentedControl.AfterConstruction. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.AfterConstruction.
Responds after the last constructor has executed and loads the control presentation.
AfterConstruction is called automatically after the object&apos;s last constructor has executed. Do not call it explicitly in your applications.</docstr>
      </procedure>
      <property name="ValueRange">
        <docstr>Provides access to the Value and  Frequency properties.</docstr>
      </property>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher. 
FMX.StdCtrls.TArcDial.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
OnMouseDown event dispatcher. 
A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:

Button determines which mouse button is pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>OnMouseMove event dispatcher. 
FMX.StdCtrls.TArcDial.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
OnMouseMove event dispatcher. 
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation:

Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>OnMouseUp event dispatcher. 
FMX.StdCtrls.TArcDial.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
OnMouseUp event dispatcher. 
A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 

Button determines which mouse button was previously pressed: left, right, or middle.
Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control.</docstr>
      </procedure>
      <property name="ShowValue">
        <docstr>Specifies whether this arc dial component displays a text with the current value.
Use the ShowValue property to enable or disable the display of a text in the middle of this arc dial component that contains the current value (in degrees) of this arc dial component.</docstr>
      </property>
      <property name="Tracking">
        <docstr>Specifies whether thumb tracking is active or not.</docstr>
      </property>
      <property name="Value">
        <docstr>Specifies the value (in degrees) of this arc dial component.
Read or write the Value property to get or set the value (in degrees) of this arc dial component. Use the ShowValue property to enable or disable the display of this value inside the surface of this arc dial component.</docstr>
      </property>
      <property name="Frequency">
        <docstr>Specifies the number of positions this arc dial advances with each move.
Use the Frequency property to specify how many steps at once this arc dial advances (rotates) with each move. For instance, if you set Frequency to 10, then rotating the arc dial to either the left or the right produces an advancement of only 10 divisions at a time (0 degrees, 10 degrees, 20 degrees, and so on).</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs immediately after the position of this arc dial control changes.
Write an OnChange event handler to provide additional functionality when changing the position of this arc dial component.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TExpanderButton">
    <docstr>Represents a collapse/expand button used exclusively by the TExpander component.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates a new instance of TPresentedControl.
FMX.StdCtrls.TExpanderButton.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
Creates a new instance of TPresentedControl.
AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
Create also sets the value of the CanUseDefaultPresentation property to True.

 See Also
System.Classes.TComponent.Create
FMX.Controls.Presentation.TPresentedControl.Model
FMX.Controls.Presentation.TPresentedControl.DefineModelClass
FMX.Controls.Presentation.TPresentedControl.Destroy
FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation</docstr>
      </constructor>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TExpander">
    <docstr>Represents a graphical control used to hold multiple graphical controls with the possibility to expand or contract its display area.
Use TExpander components when you need to provide the user with a way of placing graphical components on a surface that can be expanded or collapsed in order to show or hide its contents.

Collapse or expand this expander control by clicking its collapse/expand button.</docstr>
    <members>
      <const name="cDefaultHeaderHeight">
        <docstr>Default header height</docstr>
      </const>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TExpander.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.StdCtrls.TExpander.FreeStyle inherits from FMX.Controls.TTextControl.FreeStyle. All content below this line refers to FMX.Controls.TTextControl.FreeStyle.
Frees the style of TStyledControl.
FreeStyle frees some TTextControl-specific style resources like TextObject and TextSettings, then calls the inherited TStyledControl.FreeStyle.</docstr>
      </procedure>
      <procedure name="DoRealign">
        <docstr>Performs the alignment of a FireMonkey control.
FMX.StdCtrls.TExpander.DoRealign inherits from FMX.Controls.TControl.DoRealign. All content below this line refers to FMX.Controls.TControl.DoRealign.
Performs the alignment of a FireMonkey control.

 See Also
FMX.Types.AlignObjects</docstr>
      </procedure>
      <procedure name="DoStyleChanged">
        <docstr>Calls the inherited TStyledControl.DoStyleChanged, then tries to translate the Text.
FMX.StdCtrls.TExpander.DoStyleChanged inherits from FMX.Controls.TTextControl.DoStyleChanged. All content below this line refers to FMX.Controls.TTextControl.DoStyleChanged.
Calls the inherited TStyledControl.DoStyleChanged, then tries to translate the Text.
DoStyleChanged calls the inherited TStyledControl.DoStyleChanged to set that the control needs to update the style, then calls Repaint to redraw the control, and then tries to translate the control&apos;s Text calling Translate.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.StdCtrls.TExpander.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="ReadContentSize">
        <docstr>Protected method that sets the vertical size (height) of the content display area of this expander, based on what is read from the given Reader.</docstr>
      </procedure>
      <procedure name="WriteContentSize">
        <docstr>Protected method that writes the vertical size (height) of the content display area of this expander to the given Writer.</docstr>
      </procedure>
      <procedure name="DoAddObject">
        <docstr>Adds the AObject object to the Children list of children attached to this parent object (self).
FMX.StdCtrls.TExpander.DoAddObject inherits from FMX.Types.TFmxObject.DoAddObject. All content below this line refers to FMX.Types.TFmxObject.DoAddObject.
Adds the AObject object to the Children list of children attached to this parent object (self).
DoAddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). DoAddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then DoAddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object. 
DoAddObject is internally called from AddObject.</docstr>
      </procedure>
      <procedure name="UpdateContentSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoResized">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="DoSetSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TExpander.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <procedure name="DoExpandedChanging">
        <docstr>DoExpandedChanging is called when the expanded state is changing.</docstr>
      </procedure>
      <procedure name="DoExpandedChanged">
        <docstr>DoExpandedChanged is called when the expanded state just has changed.</docstr>
      </procedure>
      <procedure name="DoCheckedChanged">
        <docstr>DoCheckedChanged is called when the checked state just has changed.</docstr>
      </procedure>
      <function name="GetTextSettingsClass">
        <docstr>Returns the class type that instance represents the used text settings.
FMX.StdCtrls.TExpander.GetTextSettingsClass inherits from FMX.Controls.TTextControl.GetTextSettingsClass. All content below this line refers to FMX.Controls.TTextControl.GetTextSettingsClass.
Returns the class type that instance represents the used text settings.
GetTextSettingsClass returns the TTextSettingsInfo.TCustomTextSettingsClass (or its descendant)  class reference. An instance of such class provides the DefaultTextSettings,   TextSettings, StyledSettings, ResultingTextSettings, and other properties handling the text representation settings of a control. 
You can override the method in descendant classes to modify the default behavior.
Typical implementations of GetTextSettingsClass returns the class declaring properties like the Font, FontColor, HorzAlign, and WordWrap. Some of these properties can be declared as published to be editable in the Object Inspector.

 See Also
FMX.Controls.TTextSettingsInfo
FMX.Controls.TTextSettingsInfo.TCustomTextSettingsClass
FMX.Controls.TTextSettingsInfo.DefaultTextSettings
FMX.Controls.TTextSettingsInfo.TextSettings
FMX.Controls.TTextSettingsInfo.StyledSettings
FMX.Controls.TTextSettingsInfo.ResultingTextSettings</docstr>
      </function>
      <procedure name="SetHeaderHeight">
        <docstr>It allows to set the header height.</docstr>
      </procedure>
      <function name="GetHeaderHeight">
        <docstr>Returns the calculated header height.
Default value is -1. 
When the value is -1, if the style defines a header element style, the element height will be taken for default. If style element is not defined, it takes the FMX.StdCtrls.TExpander.cDefaultHeaderHeight value.</docstr>
      </function>
      <function name="EffectiveHeaderHeight">
        <docstr>Evaluates the header height that will be used based on style availability and property value.</docstr>
      </function>
      <function name="DefaultHeaderHeight">
        <docstr>Evaluates the default header height based on style availability.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.StdCtrls.TExpander.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <function name="GetTabList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="HeaderHeight">
        <docstr>Allows to customize header height. Default value is -1.
When the value is -1, if the style defines a header element style, the element height will be taken for default. If style element is not defined, it takes the FMX.StdCtrls.TExpander.cDefaultHeaderHeight value.</docstr>
      </property>
      <property name="IsChecked">
        <docstr>Specifies whether the expander&apos;s check box is selected or not.
Set the IsChecked property to True to select the expander&apos;s check box. Set IsChecked to False in order to clear the expander&apos;s check box.
The default value for the IsChecked property is True.</docstr>
      </property>
      <property name="IsExpanded">
        <docstr>Specifies whether the expander control is expanded or not.
Set the IsExpanded property to True to expand the contents of the expander in order to show all the items it contains. Set IsExpanded to False in order to collapse the expander.
The default value for the IsExpanded property is True.
You can programatically expand and collapse the expander as shown in the following code snippet:

var
  Expander1: TExpander1;

begin
  { expand the expander control }
  Expander1.IsExpanded := True;

  { collapse the expander control }
  Expander1.IsExpanded := False;
end;</docstr>
      </property>
      <property name="ShowCheck">
        <docstr>Specifies whether the expander control shows a check box in the upper-right corner.
Set the ShowCheck property to True to show a check box in the upper-right corner of the expander object. Set ShowCheck to False to hide the check box.</docstr>
      </property>
      <event name="OnCheckChange">
        <docstr>Occurs every time this expander&apos;s check box changes its state.
Write an OnCheckChange event to specify what happens every time the check box attached to this expander changes its state from True to False and vice versa.</docstr>
      </event>
      <event name="OnExpandedChanging">
        <docstr>OnExpandedChanging is called when the checkbox state is about to change.
You can cancel OnExpandedChanging with EAbort.</docstr>
      </event>
      <event name="OnExpandedChanged">
        <docstr>Occurs when IsExpanded value has changed.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TImageControl">
    <docstr>Represents a graphical control used to display images on a FireMonkey form.
Use a TImageControl whenever you need to put an image on a FireMonkey form. You can use the Bitmap property to specify the image that will be displayed.</docstr>
    <members>
      <function name="GetData">
        <docstr>Protected getter implementation for the Data property.
FMX.StdCtrls.TImageControl.GetData inherits from FMX.Types.TFmxObject.GetData. All content below this line refers to FMX.Types.TFmxObject.GetData.
Protected getter implementation for the Data property.</docstr>
      </function>
      <procedure name="SetData">
        <docstr>Protected setter implementation for the Data property.
FMX.StdCtrls.TImageControl.SetData inherits from FMX.Types.TFmxObject.SetData. All content below this line refers to FMX.Types.TFmxObject.SetData.
Protected setter implementation for the Data property.</docstr>
      </procedure>
      <function name="CanObserve">
        <docstr>For internal use only.
Do not use this member. It is for internal use only.</docstr>
      </function>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TImageControl.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.StdCtrls.TImageControl.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <procedure name="Click">
        <docstr>Responds to user clicks, key pressing, and input on touch devices (gestures).
FMX.StdCtrls.TImageControl.Click inherits from FMX.Controls.TControl.Click. All content below this line refers to FMX.Controls.TControl.Click.
Responds to user clicks, key pressing, and input on touch devices (gestures).
Click is an event handler for the OnClick event. It is automatically called when the left mouse button is pressed and released with the pointer over the control. Click also can be called in DialogKey and other methods handling an input from keyboards and touch devices.
Call Click in applications to simulate an OnClick mouse event.  
If EnableExecuteAction is True and the OnClick event handler is not assigned (or is equal to Action.OnExecute), then Click executes the assigned Action, otherwise executes the OnClick event handler.</docstr>
      </procedure>
      <procedure name="DragOver">
        <docstr>OnDragOver event dispatcher. 
FMX.StdCtrls.TImageControl.DragOver inherits from FMX.Controls.TControl.DragOver. All content below this line refers to FMX.Controls.TControl.DragOver.
OnDragOver event dispatcher. 
Data specifies the dragged object.
Point specifies the current point of the  mouse cursor within the client area of the control.
Operation is the operation parameter (None, Move, Copy, Link) that specifies the action to perform when an item is dragged over the object.  

None is the default. No action takes place, it does not display any name.
Move - the word Move is displayed once an item is dragged over the object.
Copy - the word Copy is displayed once an item is dragged over the object.
Link - the word Link is displayed once an item is dragged over the object.
A control calls DragOver when a dragged object is over the control area.
Override the protected DragOver method to provide other responses when a dragged object is over the control area.</docstr>
      </procedure>
      <procedure name="DragDrop">
        <docstr>OnDragDrop event dispatcher. 
FMX.StdCtrls.TImageControl.DragDrop inherits from FMX.Controls.TControl.DragDrop. All content below this line refers to FMX.Controls.TControl.DragDrop.
OnDragDrop event dispatcher. 
Data specifies the dragged object.
Point specifies the current point of the mouse cursor, within the client area of the control.
A control calls DragDrop when a dragged object is dropped on the control area.
Override the protected DragDrop method to provide other responses when a dragged object is dropped on the control area.</docstr>
      </procedure>
      <procedure name="DoBitmapChanged">
        <docstr>Executes internally each time the OnChange event fires.</docstr>
      </procedure>
      <procedure name="DoLoadFromFile">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetDefaultSize">
        <docstr>Getter of DefaultSize.
FMX.StdCtrls.TImageControl.GetDefaultSize inherits from FMX.Controls.TControl.GetDefaultSize. All content below this line refers to FMX.Controls.TControl.GetDefaultSize.
Getter of DefaultSize.</docstr>
      </function>
      <property name="Image">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.StdCtrls.TImageControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.StdCtrls.TImageControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="LoadFromFile">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="ShowOpenDialog">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="Bitmap">
        <docstr>Specifies a TBitmap picture to be displayed onto the surface of this image control component.
Use Bitmap to specify the image for the TImageControl component. Bitmap is a reference to a FMX.Graphics.TBitmap object.
Setting Bitmap at design time brings up the Bitmap Editor, which can be used to specify the file that contains the image you want to display.</docstr>
      </property>
      <property name="EnableOpenDialog">
        <docstr>For future use only.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs immediately after the bitmap picture of this image control changes.
Write an OnChange event handler to provide additional functionality when changing the bitmap picture of this image control component.</docstr>
      </event>
      <event name="OnLoaded">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
    </members>
  </class>
  <class unit="FMX.StdCtrls" name="TPathLabel">
    <docstr>Represents a graphical control used to display information contained in TPathData within FireMonkey forms.
Use TPathLabel components in FireMonkey forms to add TPathData display capabilities.
For instance, the following image displays three rectangles by using a TPathData object.

var
  PathData: TPathData;

begin
  PathData:= TPathData.Create;
  PathData.AddRectangle(RectF(20, 20, 80, 80), 0, 0, AllCorners);
  PathData.AddRectangle(RectF(10, 10, 90, 90), 0, 0, AllCorners);
  PathData.AddRectangle(RectF(0, 0, 100, 100), 0, 0, AllCorners);
  PathLabel1.Data := PathData;

  { ... other instructions ... }


To add an object to a form that displays text, use a TLabel.</docstr>
    <members>
      <procedure name="ApplyStyle">
        <docstr>Customizes styles in complex objects.
FMX.StdCtrls.TPathLabel.ApplyStyle inherits from FMX.Controls.TStyledControl.ApplyStyle. All content below this line refers to FMX.Controls.TStyledControl.ApplyStyle.
Customizes styles in complex objects.
TStyledControl descendants override it to apply styles in concordance with their primitive components.      
Do not call ApplyStyle explicitly in an application. It is called by the ApplyStyleLookup method when object styles are updated.
For an example of an ApplyStyle implementation, see &quot;TCalloutPanel:Style Contracts&quot; in FireMonkey Component Design.</docstr>
      </procedure>
      <procedure name="FreeStyle">
        <docstr>Frees the style of TStyledControl.
FMX.StdCtrls.TPathLabel.FreeStyle inherits from FMX.Controls.TStyledControl.FreeStyle. All content below this line refers to FMX.Controls.TStyledControl.FreeStyle.
Frees the style of TStyledControl.
Override it to free additional component-specific style resources.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
FMX.StdCtrls.TPathLabel.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Allocates memory and constructs a safely initialized instance of a component.
FMX.StdCtrls.TPathLabel.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Disposes of the component and its owned components.
FMX.StdCtrls.TPathLabel.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="Data">
        <docstr>Stores a Tvalue, which is a data structure that can store different kinds of data types.
FMX.StdCtrls.TPathLabel.Data inherits from FMX.Types.TFmxObject.Data. All content below this line refers to FMX.Types.TFmxObject.Data.
Stores a Tvalue, which is a data structure that can store different kinds of data types.
Data has no predefined meaning. Although Data is used for LiveBinding, any succesor override this behavior. Then, the behaviour of Data is based on the type of its value.

Note: Do not use this member. It is for internal use only.</docstr>
      </property>
      <property name="WrapMode">
        <docstr>Specifies the way the contents of this path label will be drawn.
WrapMode can take one of the following values:



Value

Meaning



Fit



The graphical path contents fit the entire area of this path label.




Original



The graphical path contents show at their original size in this path label.




Stretch



The graphical path contents stretch to fit the entire area of this path label.




Tile



The graphical path contents tile one or multiple times to fill the entire area of this path label.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Types" name="TBitConverter">
    <docstr>TBitConverter class implements converter of an array of bytes
        into Delphi native data types and backward.</docstr>
    <members>
      <procedure name="RangeCheckError">
        <docstr>RangeCheckError is a helper used to raise a range check exception
            if a conversion (From or Into) accesses memory outside the bounds of the
            Byte array.
            NOTE: Only used by C++; Delphi calls System.Error(reRangeError) directly.</docstr>
      </procedure>
      <procedure name="UnsafeFrom">
        <docstr>UnsafeFrom method converts Value of T type into array of bytes B.
            The value will be written into B at Offset offset. The method does not check
            that value will fit into B at Offset.</docstr>
      </procedure>
      <procedure name="From">
        <docstr>From method converts Value of T type into array of bytes B.
            The value will be written into B at Offset offset. The method checks that
            value will fit into B at Offset. If not, then range check exception is raised.</docstr>
      </procedure>
      <function name="UnsafeInTo">
        <docstr>UnsafeInTo method converts array of bytes B into value of T type.
            The value will be read from B at Offset offset. The method does not check
            that value fits into B at Offset.</docstr>
      </function>
      <function name="InTo">
        <docstr>InTo method converts array of bytes B into value of T type.
            The value will be read from B at Offset offset. The method checks that
            value fits into B at Offset. If not, then range check exception is raised.</docstr>
      </function>
    </members>
  </class>
  <class unit="System.Types" name="TMultiWaitEvent">
    <docstr>Abstract base class fully implemented in System.Classes and returned by IAsyncResult.GetAsyncWaitEvent.
          This class allows for blocking with any number of these events using WaitForAll() and WaitForAny()
          While this class can be implemented by creating a descendant, it is expected that the implementation
          will be provided by System.Classes. Any attempt at creating an alternate implementation must adhere to
          the &quot;contracts&quot; laid out in the abstract virtual methods.</docstr>
    <members>
      <field name="FMultiEventType">
        <docstr>This class variable will be set by a single descendent. The expectation is that one and only one descedent
              of this class exists. That one descendent provides the actual implementation. This class variable is
              used by the static class function Create to construct an instance of that one class that implements the
              needed functionality.</docstr>
      </field>
      <function name="CreateInstance">
        <docstr>Abstract virtual class overridden in descendant classes to create the proper type for the instance.</docstr>
      </function>
      <procedure name="ArgumentException">
        <docstr>Since This unit doesn&apos;t cannot use System.SysUtls, this virtual allows descendants which do have access to
              System.SysUtils to provide a means for this base ancestor class to raise exceptions when validating arguments.</docstr>
      </procedure>
      <function name="GetTickCount64">
        <docstr>Since This unit doesn&apos;t cannot use System.Classes, this virtual allows descendants which do have access to
              System.Classes to provide a means for this base ancestor to call System.Classes.TThread.GetTickCount64.</docstr>
      </function>
      <procedure name="Lock">
        <docstr>Overridden in descendents. This explicitly locks this specific instance.</docstr>
      </procedure>
      <procedure name="Unlock">
        <docstr>Overridden in descendents. This explicitly unlocks this specific instance.</docstr>
      </procedure>
      <procedure name="NotifyWaiters">
        <docstr>Overridden in descendents. Notifies all current waiters this event is signaled.</docstr>
      </procedure>
      <procedure name="ClearWaiters">
        <docstr>Overridden in descendents. Clears the storage used for the waiters.</docstr>
      </procedure>
      <procedure name="PushWaiter">
        <docstr>Overridden in descendents. Add a new waiter to the list of waiters.</docstr>
      </procedure>
      <procedure name="RemoveWaiter">
        <docstr>Overridden in descendents. Removed a waiter from the list of waiters.</docstr>
      </procedure>
      <function name="GetWaiterCount">
        <docstr>Overridden in descendents. Returns the current number of waiters in the list of waiters.</docstr>
      </function>
      <function name="GetWaiter">
        <docstr>Overridden in descendents. Returns the index&apos;th waiter from the waiter list.</docstr>
      </function>
      <property name="WaiterCount">
        <docstr>Current number of threads waiting on this event.</docstr>
      </property>
      <property name="Waiters[Index]">
        <docstr>Array of PWaitInfo references which contain information about each waiting thread.</docstr>
      </property>
      <function name="WaitFor">
        <docstr>Wait for this event instance to be signaled or Timeout is reached.</docstr>
      </function>
      <procedure name="SetEvent">
        <docstr>Explicitly set the event as signaled. This procedure is typically called by the implementation of
              a specific IAsyncResult.</docstr>
      </procedure>
      <procedure name="ResetEvent">
        <docstr>Explicitly reset the event as unsignaled. This procedure is rarely if ever called. If it is called, it
              is called by the implementation of a specific IAsyncResult.</docstr>
      </procedure>
      <function name="WaitForAll">
        <docstr>Wait until all of the indicated TMultiWaitEvents are signaled or Timeout is reached</docstr>
      </function>
      <function name="WaitForAny">
        <docstr>Wait until at least one of the indicated TMultiWaitEvents are signaled or Timeout is reached</docstr>
      </function>
      <function name="WaitForAny">
        <docstr>Wait until at least one of the indicated TMultiWaitEvents are signaled or Timeout is reached.
             Index out parameter is set to the index of the TMultiWaitEvent in the provided array which was signaled.
             More than one event may be signaled; Index only indicates which one caused the function to return. Index is undefined if
             Timeout was reached.</docstr>
      </function>
      <function name="WaitForAny">
        <docstr>Wait until at least one of the indicated TMultiWaitEvents are signaled or Timeout is reached.
              Returns the TMultiWaitEvent instance which was signaled and caused the function to return. Event is
              undefined if Timeout is reached.</docstr>
      </function>
    </members>
  </class>
</docs>
