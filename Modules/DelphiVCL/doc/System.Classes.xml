<?xml version="1.0" ?>
<namespace name="System.Classes" platform="Win32">
  <const name="MaxListSize" type="Integer" file="System.Classes.pas" line="81" symflags="deprecated">
    <value>
      $7FFFFFF
    </value>
  </const>
  <const name="soFromBeginning" type="Integer" file="System.Classes.pas" line="85">
    <value>
      $0
    </value>
  </const>
  <const name="soFromCurrent" type="Integer" file="System.Classes.pas" line="86">
    <value>
      $1
    </value>
  </const>
  <const name="soFromEnd" type="Integer" file="System.Classes.pas" line="87">
    <value>
      $2
    </value>
  </const>
  <const name="soBeginning" type="TSeekOrigin" file="System.Classes.pas" line="91">
    <value>
      soBeginning
    </value>
  </const>
  <const name="soCurrent" type="TSeekOrigin" file="System.Classes.pas" line="91">
    <value>
      soCurrent
    </value>
  </const>
  <const name="soEnd" type="TSeekOrigin" file="System.Classes.pas" line="91">
    <value>
      soEnd
    </value>
  </const>
  <enum name="TSeekOrigin" file="System.Classes.pas" line="91">
    <element value="0" name="soBeginning" file="System.Classes.pas" line="91"/>
    <element value="1" name="soCurrent" file="System.Classes.pas" line="91"/>
    <element value="2" name="soEnd" file="System.Classes.pas" line="91"/>
  </enum>
  <type name="TPlatformIds" type="cardinal" loBound="0" hiBound="-1" file="System.pas" line="12"/>
  <const name="fmCreate" type="Integer" file="System.Classes.pas" line="98">
    <value>
      $FF00
    </value>
  </const>
  <const name="toEOF" type="Char" file="System.Classes.pas" line="102">
    <value>
      $0
    </value>
  </const>
  <const name="toSymbol" type="Char" file="System.Classes.pas" line="103">
    <value>
      $1
    </value>
  </const>
  <const name="toString" type="Char" file="System.Classes.pas" line="104">
    <value>
      $2
    </value>
  </const>
  <const name="toInteger" type="Char" file="System.Classes.pas" line="105">
    <value>
      $3
    </value>
  </const>
  <const name="toFloat" type="Char" file="System.Classes.pas" line="106">
    <value>
      $4
    </value>
  </const>
  <const name="toWString" type="Char" file="System.Classes.pas" line="107">
    <value>
      $5
    </value>
  </const>
  <const name="scCommand" type="Integer" file="System.Classes.pas" line="111">
    <value>
      $1000
    </value>
  </const>
  <const name="scShift" type="Integer" file="System.Classes.pas" line="112">
    <value>
      $2000
    </value>
  </const>
  <const name="scCtrl" type="Integer" file="System.Classes.pas" line="113">
    <value>
      $4000
    </value>
  </const>
  <const name="scAlt" type="Integer" file="System.Classes.pas" line="114">
    <value>
      $8000
    </value>
  </const>
  <const name="scNone" type="Integer" file="System.Classes.pas" line="115">
    <value>
      $0
    </value>
  </const>
  <const name="pidWin32" type="Integer" file="System.Classes.pas" line="118">
    <value>
      $1
    </value>
  </const>
  <const name="pidWin64" type="Integer" file="System.Classes.pas" line="119">
    <value>
      $2
    </value>
  </const>
  <const name="pidOSX32" type="Integer" file="System.Classes.pas" line="120">
    <value>
      $4
    </value>
  </const>
  <const name="pidiOSSimulator32" type="Integer" file="System.Classes.pas" line="121">
    <value>
      $8
    </value>
  </const>
  <const name="pidiOSSimulator" type="Integer" file="System.Classes.pas" line="122" symflags="deprecated">
    <value>
      $8
    </value>
  </const>
  <const name="pidAndroidArm32" type="Integer" file="System.Classes.pas" line="123">
    <value>
      $10
    </value>
  </const>
  <const name="pidAndroid32Arm" type="Integer" file="System.Classes.pas" line="124" symflags="deprecated">
    <value>
      $10
    </value>
  </const>
  <const name="pidAndroid" type="Integer" file="System.Classes.pas" line="125" symflags="deprecated">
    <value>
      $10
    </value>
  </const>
  <const name="pidLinux32" type="Integer" file="System.Classes.pas" line="126">
    <value>
      $20
    </value>
  </const>
  <const name="pidiOSDevice32" type="Integer" file="System.Classes.pas" line="127">
    <value>
      $40
    </value>
  </const>
  <const name="pidiOSDevice" type="Integer" file="System.Classes.pas" line="128" symflags="deprecated">
    <value>
      $40
    </value>
  </const>
  <const name="pidLinux64" type="Integer" file="System.Classes.pas" line="129">
    <value>
      $80
    </value>
  </const>
  <const name="pidWinNX32" type="Integer" file="System.Classes.pas" line="131">
    <value>
      $100
    </value>
  </const>
  <const name="pidWinIoT32" type="Integer" file="System.Classes.pas" line="132">
    <value>
      $200
    </value>
  </const>
  <const name="pidiOSDevice64" type="Integer" file="System.Classes.pas" line="133">
    <value>
      $400
    </value>
  </const>
  <const name="pidWinARM32" type="Integer" file="System.Classes.pas" line="134">
    <value>
      $800
    </value>
  </const>
  <const name="pidWin32ARM" type="Integer" file="System.Classes.pas" line="135" symflags="deprecated">
    <value>
      $800
    </value>
  </const>
  <const name="pidOSX64" type="Integer" file="System.Classes.pas" line="136">
    <value>
      $1000
    </value>
  </const>
  <const name="pidLinuxArm32" type="Integer" file="System.Classes.pas" line="137">
    <value>
      $2000
    </value>
  </const>
  <const name="pidLinuxArm64" type="Integer" file="System.Classes.pas" line="138">
    <value>
      $4000
    </value>
  </const>
  <const name="pidAndroidArm64" type="Integer" file="System.Classes.pas" line="139">
    <value>
      $8000
    </value>
  </const>
  <const name="pidAndroid64Arm" type="Integer" file="System.Classes.pas" line="140" symflags="deprecated">
    <value>
      $8000
    </value>
  </const>
  <const name="pidiOSSimulator64" type="Integer" file="System.Classes.pas" line="142">
    <value>
      $10000
    </value>
  </const>
  <const name="pidOSXArm64" type="Integer" file="System.Classes.pas" line="144">
    <value>
      $20000
    </value>
  </const>
  <const name="pidWinArm64" type="Integer" file="System.Classes.pas" line="145">
    <value>
      $40000
    </value>
  </const>
  <const name="pidiOSSimulatorArm64" type="Integer" file="System.Classes.pas" line="146">
    <value>
      $80000
    </value>
  </const>
  <const name="pidAllPlatforms" type="Integer" file="System.Classes.pas" line="148">
    <value>
      $394DF
    </value>
  </const>
  <const name="pfidWindows" type="Integer" file="System.Classes.pas" line="156">
    <value>
      $3
    </value>
  </const>
  <const name="pfidOSX" type="Integer" file="System.Classes.pas" line="157">
    <value>
      $21004
    </value>
  </const>
  <const name="pfidiOS" type="Integer" file="System.Classes.pas" line="158">
    <value>
      $10448
    </value>
  </const>
  <const name="pfidAndroid" type="Integer" file="System.Classes.pas" line="160">
    <value>
      $8010
    </value>
  </const>
  <const name="pfidLinux" type="Integer" file="System.Classes.pas" line="161">
    <value>
      $80
    </value>
  </const>
  <const name="dupIgnore" type="TDuplicates" file="System.Classes.pas" line="163">
    <value>
      dupIgnore
    </value>
  </const>
  <const name="dupAccept" type="TDuplicates" file="System.Classes.pas" line="164">
    <value>
      dupAccept
    </value>
  </const>
  <const name="dupError" type="TDuplicates" file="System.Classes.pas" line="165">
    <value>
      dupError
    </value>
  </const>
  <const name="taLeftJustify" type="TAlignment" file="System.Classes.pas" line="172">
    <value>
      taLeftJustify
    </value>
  </const>
  <const name="taRightJustify" type="TAlignment" file="System.Classes.pas" line="172">
    <value>
      taRightJustify
    </value>
  </const>
  <const name="taCenter" type="TAlignment" file="System.Classes.pas" line="172">
    <value>
      taCenter
    </value>
  </const>
  <const name="bdLeftToRight" type="TBiDiMode" file="System.Classes.pas" line="174">
    <value>
      bdLeftToRight
    </value>
  </const>
  <const name="bdRightToLeft" type="TBiDiMode" file="System.Classes.pas" line="174">
    <value>
      bdRightToLeft
    </value>
  </const>
  <const name="bdRightToLeftNoAlign" type="TBiDiMode" file="System.Classes.pas" line="174">
    <value>
      bdRightToLeftNoAlign
    </value>
  </const>
  <const name="bdRightToLeftReadingOnly" type="TBiDiMode" file="System.Classes.pas" line="175">
    <value>
      bdRightToLeftReadingOnly
    </value>
  </const>
  <const name="taAlignTop" type="TVerticalAlignment" file="System.Classes.pas" line="176">
    <value>
      taAlignTop
    </value>
  </const>
  <const name="taAlignBottom" type="TVerticalAlignment" file="System.Classes.pas" line="176">
    <value>
      taAlignBottom
    </value>
  </const>
  <const name="taVerticalCenter" type="TVerticalAlignment" file="System.Classes.pas" line="176">
    <value>
      taVerticalCenter
    </value>
  </const>
  <const name="ssShift" type=":1" file="System.Classes.pas" line="183">
    <value>
      ssShift
    </value>
  </const>
  <const name="ssAlt" type=":1" file="System.Classes.pas" line="183">
    <value>
      ssAlt
    </value>
  </const>
  <const name="ssCtrl" type=":1" file="System.Classes.pas" line="183">
    <value>
      ssCtrl
    </value>
  </const>
  <const name="ssLeft" type=":1" file="System.Classes.pas" line="184">
    <value>
      ssLeft
    </value>
  </const>
  <const name="ssRight" type=":1" file="System.Classes.pas" line="184">
    <value>
      ssRight
    </value>
  </const>
  <const name="ssMiddle" type=":1" file="System.Classes.pas" line="184">
    <value>
      ssMiddle
    </value>
  </const>
  <const name="ssDouble" type=":1" file="System.Classes.pas" line="184">
    <value>
      ssDouble
    </value>
  </const>
  <const name="ssTouch" type=":1" file="System.Classes.pas" line="184">
    <value>
      ssTouch
    </value>
  </const>
  <const name="ssPen" type=":1" file="System.Classes.pas" line="184">
    <value>
      ssPen
    </value>
  </const>
  <const name="ssCommand" type=":1" file="System.Classes.pas" line="184">
    <value>
      ssCommand
    </value>
  </const>
  <const name="ssHorizontal" type=":1" file="System.Classes.pas" line="184">
    <value>
      ssHorizontal
    </value>
  </const>
  <const name="htKeyword" type="THelpType" file="System.Classes.pas" line="187">
    <value>
      htKeyword
    </value>
  </const>
  <const name="htContext" type="THelpType" file="System.Classes.pas" line="187">
    <value>
      htContext
    </value>
  </const>
  <enum name="TAlignment" file="System.Classes.pas" line="172">
    <element value="0" name="taLeftJustify" file="System.Classes.pas" line="172"/>
    <element value="1" name="taRightJustify" file="System.Classes.pas" line="172"/>
    <element value="2" name="taCenter" file="System.Classes.pas" line="172"/>
  </enum>
  <enum name="TLeftRight" alias="System.Classes.TAlignment" file="System.Classes.pas" line="173">
    <element value="0" name="taLeftJustify" file="System.Classes.pas" line="172"/>
    <element value="1" name="taRightJustify" file="System.Classes.pas" line="172"/>
  </enum>
  <enum name="TBiDiMode" file="System.Classes.pas" line="174">
    <element value="0" name="bdLeftToRight" file="System.Classes.pas" line="174"/>
    <element value="1" name="bdRightToLeft" file="System.Classes.pas" line="174"/>
    <element value="2" name="bdRightToLeftNoAlign" file="System.Classes.pas" line="174"/>
    <element value="3" name="bdRightToLeftReadingOnly" file="System.Classes.pas" line="175"/>
  </enum>
  <enum name="TVerticalAlignment" file="System.Classes.pas" line="176">
    <element value="0" name="taAlignTop" file="System.Classes.pas" line="176"/>
    <element value="1" name="taAlignBottom" file="System.Classes.pas" line="176"/>
    <element value="2" name="taVerticalCenter" file="System.Classes.pas" line="176"/>
  </enum>
  <enum name="TTopBottom" alias="System.Classes.TVerticalAlignment" file="System.Classes.pas" line="177">
    <element value="0" name="taAlignTop" file="System.Classes.pas" line="176"/>
    <element value="1" name="taAlignBottom" file="System.Classes.pas" line="176"/>
  </enum>
  <set name="TShiftState" file="System.Classes.pas" line="183">
    <element name="ssShift"/>
    <element name="ssAlt"/>
    <element name="ssCtrl"/>
    <element name="ssLeft"/>
    <element name="ssRight"/>
    <element name="ssMiddle"/>
    <element name="ssDouble"/>
    <element name="ssTouch"/>
    <element name="ssPen"/>
    <element name="ssCommand"/>
    <element name="ssHorizontal"/>
  </set>
  <type name="THelpContext" type="integer" loBound="-2147483647" hiBound="2147483647" file="System.Classes.pas" line="186"/>
  <enum name="THelpType" file="System.Classes.pas" line="187">
    <element value="0" name="htKeyword" file="System.Classes.pas" line="187"/>
    <element value="1" name="htContext" file="System.Classes.pas" line="187"/>
  </enum>
  <type name="TShortCut" type="word" loBound="0" hiBound="65535" file="System.Classes.pas" line="191"/>
  <const name="lnAdded" type="TListNotification" file="System.Classes.pas" line="239">
    <value>
      lnAdded
    </value>
  </const>
  <const name="lnExtracted" type="TListNotification" file="System.Classes.pas" line="239">
    <value>
      lnExtracted
    </value>
  </const>
  <const name="lnDeleted" type="TListNotification" file="System.Classes.pas" line="239">
    <value>
      lnDeleted
    </value>
  </const>
  <const name="laCopy" type="TListAssignOp" file="System.Classes.pas" line="250">
    <value>
      laCopy
    </value>
  </const>
  <const name="laAnd" type="TListAssignOp" file="System.Classes.pas" line="250">
    <value>
      laAnd
    </value>
  </const>
  <const name="laOr" type="TListAssignOp" file="System.Classes.pas" line="250">
    <value>
      laOr
    </value>
  </const>
  <const name="laXor" type="TListAssignOp" file="System.Classes.pas" line="250">
    <value>
      laXor
    </value>
  </const>
  <const name="laSrcUnique" type="TListAssignOp" file="System.Classes.pas" line="250">
    <value>
      laSrcUnique
    </value>
  </const>
  <const name="laDestUnique" type="TListAssignOp" file="System.Classes.pas" line="250">
    <value>
      laDestUnique
    </value>
  </const>
  <const name="sdDelimiter" type=":23" file="System.Classes.pas" line="615">
    <value>
      sdDelimiter
    </value>
  </const>
  <const name="sdQuoteChar" type=":23" file="System.Classes.pas" line="615">
    <value>
      sdQuoteChar
    </value>
  </const>
  <const name="sdNameValueSeparator" type=":23" file="System.Classes.pas" line="615">
    <value>
      sdNameValueSeparator
    </value>
  </const>
  <const name="sdLineBreak" type=":23" file="System.Classes.pas" line="616">
    <value>
      sdLineBreak
    </value>
  </const>
  <const name="sdStrictDelimiter" type=":23" file="System.Classes.pas" line="616">
    <value>
      sdStrictDelimiter
    </value>
  </const>
  <const name="soStrictDelimiter" type="TStringsOption" file="System.Classes.pas" line="618">
    <value>
      soStrictDelimiter
    </value>
  </const>
  <const name="soWriteBOM" type="TStringsOption" file="System.Classes.pas" line="618">
    <value>
      soWriteBOM
    </value>
  </const>
  <const name="soTrailingLineBreak" type="TStringsOption" file="System.Classes.pas" line="618">
    <value>
      soTrailingLineBreak
    </value>
  </const>
  <const name="soUseLocale" type="TStringsOption" file="System.Classes.pas" line="619">
    <value>
      soUseLocale
    </value>
  </const>
  <const name="soReference" type="TStreamOwnership" file="System.Classes.pas" line="1261">
    <value>
      soReference
    </value>
  </const>
  <const name="soOwned" type="TStreamOwnership" file="System.Classes.pas" line="1261">
    <value>
      soOwned
    </value>
  </const>
  <const name="vaNull" type="TValueType" file="System.Classes.pas" line="1306">
    <value>
      vaNull
    </value>
  </const>
  <const name="vaList" type="TValueType" file="System.Classes.pas" line="1306">
    <value>
      vaList
    </value>
  </const>
  <const name="vaInt8" type="TValueType" file="System.Classes.pas" line="1306">
    <value>
      vaInt8
    </value>
  </const>
  <const name="vaInt16" type="TValueType" file="System.Classes.pas" line="1306">
    <value>
      vaInt16
    </value>
  </const>
  <const name="vaInt32" type="TValueType" file="System.Classes.pas" line="1306">
    <value>
      vaInt32
    </value>
  </const>
  <const name="vaExtended" type="TValueType" file="System.Classes.pas" line="1306">
    <value>
      vaExtended
    </value>
  </const>
  <const name="vaString" type="TValueType" file="System.Classes.pas" line="1307">
    <value>
      vaString
    </value>
  </const>
  <const name="vaIdent" type="TValueType" file="System.Classes.pas" line="1307">
    <value>
      vaIdent
    </value>
  </const>
  <const name="vaFalse" type="TValueType" file="System.Classes.pas" line="1307">
    <value>
      vaFalse
    </value>
  </const>
  <const name="vaTrue" type="TValueType" file="System.Classes.pas" line="1307">
    <value>
      vaTrue
    </value>
  </const>
  <const name="vaBinary" type="TValueType" file="System.Classes.pas" line="1307">
    <value>
      vaBinary
    </value>
  </const>
  <const name="vaSet" type="TValueType" file="System.Classes.pas" line="1307">
    <value>
      vaSet
    </value>
  </const>
  <const name="vaLString" type="TValueType" file="System.Classes.pas" line="1307">
    <value>
      vaLString
    </value>
  </const>
  <const name="vaNil" type="TValueType" file="System.Classes.pas" line="1308">
    <value>
      vaNil
    </value>
  </const>
  <const name="vaCollection" type="TValueType" file="System.Classes.pas" line="1308">
    <value>
      vaCollection
    </value>
  </const>
  <const name="vaSingle" type="TValueType" file="System.Classes.pas" line="1308">
    <value>
      vaSingle
    </value>
  </const>
  <const name="vaCurrency" type="TValueType" file="System.Classes.pas" line="1308">
    <value>
      vaCurrency
    </value>
  </const>
  <const name="vaDate" type="TValueType" file="System.Classes.pas" line="1308">
    <value>
      vaDate
    </value>
  </const>
  <const name="vaWString" type="TValueType" file="System.Classes.pas" line="1308">
    <value>
      vaWString
    </value>
  </const>
  <const name="vaInt64" type="TValueType" file="System.Classes.pas" line="1309">
    <value>
      vaInt64
    </value>
  </const>
  <const name="vaUTF8String" type="TValueType" file="System.Classes.pas" line="1309">
    <value>
      vaUTF8String
    </value>
  </const>
  <const name="vaDouble" type="TValueType" file="System.Classes.pas" line="1309">
    <value>
      vaDouble
    </value>
  </const>
  <const name="ffInherited" type="TFilerFlag" file="System.Classes.pas" line="1311">
    <value>
      ffInherited
    </value>
  </const>
  <const name="ffChildPos" type="TFilerFlag" file="System.Classes.pas" line="1311">
    <value>
      ffChildPos
    </value>
  </const>
  <const name="ffInline" type="TFilerFlag" file="System.Classes.pas" line="1311">
    <value>
      ffInline
    </value>
  </const>
  <const name="tpIdle" type="TThreadPriority" file="System.Classes.pas" line="1690">
    <value>
      tpIdle
    </value>
  </const>
  <const name="tpLowest" type="TThreadPriority" file="System.Classes.pas" line="1690">
    <value>
      tpLowest
    </value>
  </const>
  <const name="tpLower" type="TThreadPriority" file="System.Classes.pas" line="1690">
    <value>
      tpLower
    </value>
  </const>
  <const name="tpNormal" type="TThreadPriority" file="System.Classes.pas" line="1690">
    <value>
      tpNormal
    </value>
  </const>
  <const name="tpHigher" type="TThreadPriority" file="System.Classes.pas" line="1690">
    <value>
      tpHigher
    </value>
  </const>
  <const name="tpHighest" type="TThreadPriority" file="System.Classes.pas" line="1690">
    <value>
      tpHighest
    </value>
  </const>
  <const name="tpTimeCritical" type="TThreadPriority" file="System.Classes.pas" line="1691">
    <value>
      tpTimeCritical
    </value>
  </const>
  <const name="opInsert" type="TOperation" file="System.Classes.pas" line="1914">
    <value>
      opInsert
    </value>
  </const>
  <const name="opRemove" type="TOperation" file="System.Classes.pas" line="1914">
    <value>
      opRemove
    </value>
  </const>
  <const name="csLoading" type=":65" file="System.Classes.pas" line="1915">
    <value>
      csLoading
    </value>
  </const>
  <const name="csReading" type=":65" file="System.Classes.pas" line="1915">
    <value>
      csReading
    </value>
  </const>
  <const name="csWriting" type=":65" file="System.Classes.pas" line="1915">
    <value>
      csWriting
    </value>
  </const>
  <const name="csDestroying" type=":65" file="System.Classes.pas" line="1915">
    <value>
      csDestroying
    </value>
  </const>
  <const name="csDesigning" type=":65" file="System.Classes.pas" line="1916">
    <value>
      csDesigning
    </value>
  </const>
  <const name="csAncestor" type=":65" file="System.Classes.pas" line="1916">
    <value>
      csAncestor
    </value>
  </const>
  <const name="csUpdating" type=":65" file="System.Classes.pas" line="1916">
    <value>
      csUpdating
    </value>
  </const>
  <const name="csFixups" type=":65" file="System.Classes.pas" line="1916">
    <value>
      csFixups
    </value>
  </const>
  <const name="csFreeNotification" type=":65" file="System.Classes.pas" line="1916">
    <value>
      csFreeNotification
    </value>
  </const>
  <const name="csInline" type=":65" file="System.Classes.pas" line="1917">
    <value>
      csInline
    </value>
  </const>
  <const name="csDesignInstance" type=":65" file="System.Classes.pas" line="1917">
    <value>
      csDesignInstance
    </value>
  </const>
  <const name="csInheritable" type=":75" file="System.Classes.pas" line="1918">
    <value>
      csInheritable
    </value>
  </const>
  <const name="csCheckPropAvail" type=":75" file="System.Classes.pas" line="1918">
    <value>
      csCheckPropAvail
    </value>
  </const>
  <const name="csSubComponent" type=":75" file="System.Classes.pas" line="1918">
    <value>
      csSubComponent
    </value>
  </const>
  <const name="csTransient" type=":75" file="System.Classes.pas" line="1919">
    <value>
      csTransient
    </value>
  </const>
  <type name="TNotifyEvent" file="System.Classes.pas" line="195" procflags="closure">
  </type>
  <type name="TGetStrProc" file="System.Classes.pas" line="196" procflags="closure">
  </type>
  <class name="EStreamError" file="System.Classes.pas" line="200">
    <ancestor name="Exception" namespace="System.SysUtils">
      <methodref name="Create@" visibility="class private" procflags="class constructor noself">
      </methodref>
      <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
      </methodref>
      <methodref name="SetInnerException" visibility="protected">
      </methodref>
      <methodref name="SetStackInfo" visibility="protected">
      </methodref>
      <methodref name="GetStackTrace" visibility="protected">
      </methodref>
      <methodref name="RaisingException" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmt" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="GetBaseException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="override">
      </methodref>
      <propertyref name="BaseException" visibility="public">
      </propertyref>
      <propertyref name="HelpContext" visibility="public">
      </propertyref>
      <propertyref name="InnerException" visibility="public">
      </propertyref>
      <propertyref name="Message" visibility="public">
      </propertyref>
      <propertyref name="StackTrace" visibility="public">
      </propertyref>
      <propertyref name="StackInfo" visibility="public">
      </propertyref>
      <methodref name="RaiseOuterException" visibility="public" procflags="static">
      </methodref>
      <methodref name="ThrowOuterException" visibility="public" procflags="static">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
  </class>
  <class name="EFileStreamError" file="System.Classes.pas" line="201">
    <ancestor name="EStreamError" namespace="System.Classes">
      <ancestor name="Exception" namespace="System.SysUtils">
        <methodref name="Create@" visibility="class private" procflags="class constructor noself">
        </methodref>
        <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
        </methodref>
        <methodref name="SetInnerException" visibility="protected">
        </methodref>
        <methodref name="SetStackInfo" visibility="protected">
        </methodref>
        <methodref name="GetStackTrace" visibility="protected">
        </methodref>
        <methodref name="RaisingException" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="CreateFmt" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="CreateRes" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateRes" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateHelp" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor override">
        </methodref>
        <methodref name="GetBaseException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="override">
        </methodref>
        <propertyref name="BaseException" visibility="public">
        </propertyref>
        <propertyref name="HelpContext" visibility="public">
        </propertyref>
        <propertyref name="InnerException" visibility="public">
        </propertyref>
        <propertyref name="Message" visibility="public">
        </propertyref>
        <propertyref name="StackTrace" visibility="public">
        </propertyref>
        <propertyref name="StackInfo" visibility="public">
        </propertyref>
        <methodref name="RaiseOuterException" visibility="public" procflags="static">
        </methodref>
        <methodref name="ThrowOuterException" visibility="public" procflags="static">
        </methodref>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="202">
        <parameters>
          <parameter name="ResStringRec" type="PResStringRec"/>
          <parameter name="FileName" type="string" paramflags="const"/>
        </parameters>
      </constructor>
    </members>
  </class>
  <class name="EFCreateError" file="System.Classes.pas" line="204">
    <ancestor name="EFileStreamError" namespace="System.Classes">
      <methodref name="Create" visibility="public" procflags="constructor"/>
      <ancestor name="EStreamError" namespace="System.Classes">
        <ancestor name="Exception" namespace="System.SysUtils">
          <methodref name="Create@" visibility="class private" procflags="class constructor noself">
          </methodref>
          <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
          </methodref>
          <methodref name="SetInnerException" visibility="protected">
          </methodref>
          <methodref name="SetStackInfo" visibility="protected">
          </methodref>
          <methodref name="GetStackTrace" visibility="protected">
          </methodref>
          <methodref name="RaisingException" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmt" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override">
          </methodref>
          <methodref name="GetBaseException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="override">
          </methodref>
          <propertyref name="BaseException" visibility="public">
          </propertyref>
          <propertyref name="HelpContext" visibility="public">
          </propertyref>
          <propertyref name="InnerException" visibility="public">
          </propertyref>
          <propertyref name="Message" visibility="public">
          </propertyref>
          <propertyref name="StackTrace" visibility="public">
          </propertyref>
          <propertyref name="StackInfo" visibility="public">
          </propertyref>
          <methodref name="RaiseOuterException" visibility="public" procflags="static">
          </methodref>
          <methodref name="ThrowOuterException" visibility="public" procflags="static">
          </methodref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
  </class>
  <class name="EFOpenError" file="System.Classes.pas" line="205">
    <ancestor name="EFileStreamError" namespace="System.Classes">
      <methodref name="Create" visibility="public" procflags="constructor"/>
      <ancestor name="EStreamError" namespace="System.Classes">
        <ancestor name="Exception" namespace="System.SysUtils">
          <methodref name="Create@" visibility="class private" procflags="class constructor noself">
          </methodref>
          <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
          </methodref>
          <methodref name="SetInnerException" visibility="protected">
          </methodref>
          <methodref name="SetStackInfo" visibility="protected">
          </methodref>
          <methodref name="GetStackTrace" visibility="protected">
          </methodref>
          <methodref name="RaisingException" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmt" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override">
          </methodref>
          <methodref name="GetBaseException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="override">
          </methodref>
          <propertyref name="BaseException" visibility="public">
          </propertyref>
          <propertyref name="HelpContext" visibility="public">
          </propertyref>
          <propertyref name="InnerException" visibility="public">
          </propertyref>
          <propertyref name="Message" visibility="public">
          </propertyref>
          <propertyref name="StackTrace" visibility="public">
          </propertyref>
          <propertyref name="StackInfo" visibility="public">
          </propertyref>
          <methodref name="RaiseOuterException" visibility="public" procflags="static">
          </methodref>
          <methodref name="ThrowOuterException" visibility="public" procflags="static">
          </methodref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
  </class>
  <class name="EFilerError" file="System.Classes.pas" line="206">
    <ancestor name="EStreamError" namespace="System.Classes">
      <ancestor name="Exception" namespace="System.SysUtils">
        <methodref name="Create@" visibility="class private" procflags="class constructor noself">
        </methodref>
        <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
        </methodref>
        <methodref name="SetInnerException" visibility="protected">
        </methodref>
        <methodref name="SetStackInfo" visibility="protected">
        </methodref>
        <methodref name="GetStackTrace" visibility="protected">
        </methodref>
        <methodref name="RaisingException" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="CreateFmt" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="CreateRes" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateRes" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateHelp" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor override">
        </methodref>
        <methodref name="GetBaseException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="override">
        </methodref>
        <propertyref name="BaseException" visibility="public">
        </propertyref>
        <propertyref name="HelpContext" visibility="public">
        </propertyref>
        <propertyref name="InnerException" visibility="public">
        </propertyref>
        <propertyref name="Message" visibility="public">
        </propertyref>
        <propertyref name="StackTrace" visibility="public">
        </propertyref>
        <propertyref name="StackInfo" visibility="public">
        </propertyref>
        <methodref name="RaiseOuterException" visibility="public" procflags="static">
        </methodref>
        <methodref name="ThrowOuterException" visibility="public" procflags="static">
        </methodref>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
  </class>
  <class name="EReadError" file="System.Classes.pas" line="207">
    <ancestor name="EFilerError" namespace="System.Classes">
      <ancestor name="EStreamError" namespace="System.Classes">
        <ancestor name="Exception" namespace="System.SysUtils">
          <methodref name="Create@" visibility="class private" procflags="class constructor noself">
          </methodref>
          <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
          </methodref>
          <methodref name="SetInnerException" visibility="protected">
          </methodref>
          <methodref name="SetStackInfo" visibility="protected">
          </methodref>
          <methodref name="GetStackTrace" visibility="protected">
          </methodref>
          <methodref name="RaisingException" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmt" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override">
          </methodref>
          <methodref name="GetBaseException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="override">
          </methodref>
          <propertyref name="BaseException" visibility="public">
          </propertyref>
          <propertyref name="HelpContext" visibility="public">
          </propertyref>
          <propertyref name="InnerException" visibility="public">
          </propertyref>
          <propertyref name="Message" visibility="public">
          </propertyref>
          <propertyref name="StackTrace" visibility="public">
          </propertyref>
          <propertyref name="StackInfo" visibility="public">
          </propertyref>
          <methodref name="RaiseOuterException" visibility="public" procflags="static">
          </methodref>
          <methodref name="ThrowOuterException" visibility="public" procflags="static">
          </methodref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
  </class>
  <class name="EWriteError" file="System.Classes.pas" line="208">
    <ancestor name="EFilerError" namespace="System.Classes">
      <ancestor name="EStreamError" namespace="System.Classes">
        <ancestor name="Exception" namespace="System.SysUtils">
          <methodref name="Create@" visibility="class private" procflags="class constructor noself">
          </methodref>
          <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
          </methodref>
          <methodref name="SetInnerException" visibility="protected">
          </methodref>
          <methodref name="SetStackInfo" visibility="protected">
          </methodref>
          <methodref name="GetStackTrace" visibility="protected">
          </methodref>
          <methodref name="RaisingException" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmt" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override">
          </methodref>
          <methodref name="GetBaseException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="override">
          </methodref>
          <propertyref name="BaseException" visibility="public">
          </propertyref>
          <propertyref name="HelpContext" visibility="public">
          </propertyref>
          <propertyref name="InnerException" visibility="public">
          </propertyref>
          <propertyref name="Message" visibility="public">
          </propertyref>
          <propertyref name="StackTrace" visibility="public">
          </propertyref>
          <propertyref name="StackInfo" visibility="public">
          </propertyref>
          <methodref name="RaiseOuterException" visibility="public" procflags="static">
          </methodref>
          <methodref name="ThrowOuterException" visibility="public" procflags="static">
          </methodref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
  </class>
  <class name="EClassNotFound" file="System.Classes.pas" line="209">
    <ancestor name="EFilerError" namespace="System.Classes">
      <ancestor name="EStreamError" namespace="System.Classes">
        <ancestor name="Exception" namespace="System.SysUtils">
          <methodref name="Create@" visibility="class private" procflags="class constructor noself">
          </methodref>
          <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
          </methodref>
          <methodref name="SetInnerException" visibility="protected">
          </methodref>
          <methodref name="SetStackInfo" visibility="protected">
          </methodref>
          <methodref name="GetStackTrace" visibility="protected">
          </methodref>
          <methodref name="RaisingException" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmt" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override">
          </methodref>
          <methodref name="GetBaseException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="override">
          </methodref>
          <propertyref name="BaseException" visibility="public">
          </propertyref>
          <propertyref name="HelpContext" visibility="public">
          </propertyref>
          <propertyref name="InnerException" visibility="public">
          </propertyref>
          <propertyref name="Message" visibility="public">
          </propertyref>
          <propertyref name="StackTrace" visibility="public">
          </propertyref>
          <propertyref name="StackInfo" visibility="public">
          </propertyref>
          <methodref name="RaiseOuterException" visibility="public" procflags="static">
          </methodref>
          <methodref name="ThrowOuterException" visibility="public" procflags="static">
          </methodref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
  </class>
  <class name="EMethodNotFound" file="System.Classes.pas" line="210">
    <ancestor name="EFilerError" namespace="System.Classes">
      <ancestor name="EStreamError" namespace="System.Classes">
        <ancestor name="Exception" namespace="System.SysUtils">
          <methodref name="Create@" visibility="class private" procflags="class constructor noself">
          </methodref>
          <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
          </methodref>
          <methodref name="SetInnerException" visibility="protected">
          </methodref>
          <methodref name="SetStackInfo" visibility="protected">
          </methodref>
          <methodref name="GetStackTrace" visibility="protected">
          </methodref>
          <methodref name="RaisingException" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmt" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override">
          </methodref>
          <methodref name="GetBaseException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="override">
          </methodref>
          <propertyref name="BaseException" visibility="public">
          </propertyref>
          <propertyref name="HelpContext" visibility="public">
          </propertyref>
          <propertyref name="InnerException" visibility="public">
          </propertyref>
          <propertyref name="Message" visibility="public">
          </propertyref>
          <propertyref name="StackTrace" visibility="public">
          </propertyref>
          <propertyref name="StackInfo" visibility="public">
          </propertyref>
          <methodref name="RaiseOuterException" visibility="public" procflags="static">
          </methodref>
          <methodref name="ThrowOuterException" visibility="public" procflags="static">
          </methodref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
  </class>
  <class name="EInvalidImage" file="System.Classes.pas" line="211">
    <ancestor name="EFilerError" namespace="System.Classes">
      <ancestor name="EStreamError" namespace="System.Classes">
        <ancestor name="Exception" namespace="System.SysUtils">
          <methodref name="Create@" visibility="class private" procflags="class constructor noself">
          </methodref>
          <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
          </methodref>
          <methodref name="SetInnerException" visibility="protected">
          </methodref>
          <methodref name="SetStackInfo" visibility="protected">
          </methodref>
          <methodref name="GetStackTrace" visibility="protected">
          </methodref>
          <methodref name="RaisingException" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmt" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override">
          </methodref>
          <methodref name="GetBaseException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="override">
          </methodref>
          <propertyref name="BaseException" visibility="public">
          </propertyref>
          <propertyref name="HelpContext" visibility="public">
          </propertyref>
          <propertyref name="InnerException" visibility="public">
          </propertyref>
          <propertyref name="Message" visibility="public">
          </propertyref>
          <propertyref name="StackTrace" visibility="public">
          </propertyref>
          <propertyref name="StackInfo" visibility="public">
          </propertyref>
          <methodref name="RaiseOuterException" visibility="public" procflags="static">
          </methodref>
          <methodref name="ThrowOuterException" visibility="public" procflags="static">
          </methodref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
  </class>
  <class name="EResNotFound" file="System.Classes.pas" line="212">
    <ancestor name="Exception" namespace="System.SysUtils">
      <methodref name="Create@" visibility="class private" procflags="class constructor noself">
      </methodref>
      <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
      </methodref>
      <methodref name="SetInnerException" visibility="protected">
      </methodref>
      <methodref name="SetStackInfo" visibility="protected">
      </methodref>
      <methodref name="GetStackTrace" visibility="protected">
      </methodref>
      <methodref name="RaisingException" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmt" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="GetBaseException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="override">
      </methodref>
      <propertyref name="BaseException" visibility="public">
      </propertyref>
      <propertyref name="HelpContext" visibility="public">
      </propertyref>
      <propertyref name="InnerException" visibility="public">
      </propertyref>
      <propertyref name="Message" visibility="public">
      </propertyref>
      <propertyref name="StackTrace" visibility="public">
      </propertyref>
      <propertyref name="StackInfo" visibility="public">
      </propertyref>
      <methodref name="RaiseOuterException" visibility="public" procflags="static">
      </methodref>
      <methodref name="ThrowOuterException" visibility="public" procflags="static">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
  </class>
  <class name="EListError" alias="System.SysUtils.EListError" file="System.Classes.pas" line="213">
    <ancestor name="Exception" namespace="System.SysUtils">
      <methodref name="Create@" visibility="class private" procflags="class constructor noself">
      </methodref>
      <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
      </methodref>
      <methodref name="SetInnerException" visibility="protected">
      </methodref>
      <methodref name="SetStackInfo" visibility="protected">
      </methodref>
      <methodref name="GetStackTrace" visibility="protected">
      </methodref>
      <methodref name="RaisingException" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmt" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="GetBaseException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="override">
      </methodref>
      <propertyref name="BaseException" visibility="public">
      </propertyref>
      <propertyref name="HelpContext" visibility="public">
      </propertyref>
      <propertyref name="InnerException" visibility="public">
      </propertyref>
      <propertyref name="Message" visibility="public">
      </propertyref>
      <propertyref name="StackTrace" visibility="public">
      </propertyref>
      <propertyref name="StackInfo" visibility="public">
      </propertyref>
      <methodref name="RaiseOuterException" visibility="public" procflags="static">
      </methodref>
      <methodref name="ThrowOuterException" visibility="public" procflags="static">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
  </class>
  <class name="EBitsError" file="System.Classes.pas" line="214">
    <ancestor name="Exception" namespace="System.SysUtils">
      <methodref name="Create@" visibility="class private" procflags="class constructor noself">
      </methodref>
      <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
      </methodref>
      <methodref name="SetInnerException" visibility="protected">
      </methodref>
      <methodref name="SetStackInfo" visibility="protected">
      </methodref>
      <methodref name="GetStackTrace" visibility="protected">
      </methodref>
      <methodref name="RaisingException" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmt" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="GetBaseException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="override">
      </methodref>
      <propertyref name="BaseException" visibility="public">
      </propertyref>
      <propertyref name="HelpContext" visibility="public">
      </propertyref>
      <propertyref name="InnerException" visibility="public">
      </propertyref>
      <propertyref name="Message" visibility="public">
      </propertyref>
      <propertyref name="StackTrace" visibility="public">
      </propertyref>
      <propertyref name="StackInfo" visibility="public">
      </propertyref>
      <methodref name="RaiseOuterException" visibility="public" procflags="static">
      </methodref>
      <methodref name="ThrowOuterException" visibility="public" procflags="static">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
  </class>
  <class name="EStringListError" file="System.Classes.pas" line="215">
    <ancestor name="Exception" namespace="System.SysUtils">
      <methodref name="Create@" visibility="class private" procflags="class constructor noself">
      </methodref>
      <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
      </methodref>
      <methodref name="SetInnerException" visibility="protected">
      </methodref>
      <methodref name="SetStackInfo" visibility="protected">
      </methodref>
      <methodref name="GetStackTrace" visibility="protected">
      </methodref>
      <methodref name="RaisingException" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmt" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="GetBaseException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="override">
      </methodref>
      <propertyref name="BaseException" visibility="public">
      </propertyref>
      <propertyref name="HelpContext" visibility="public">
      </propertyref>
      <propertyref name="InnerException" visibility="public">
      </propertyref>
      <propertyref name="Message" visibility="public">
      </propertyref>
      <propertyref name="StackTrace" visibility="public">
      </propertyref>
      <propertyref name="StackInfo" visibility="public">
      </propertyref>
      <methodref name="RaiseOuterException" visibility="public" procflags="static">
      </methodref>
      <methodref name="ThrowOuterException" visibility="public" procflags="static">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
  </class>
  <class name="EComponentError" file="System.Classes.pas" line="216">
    <ancestor name="Exception" namespace="System.SysUtils">
      <methodref name="Create@" visibility="class private" procflags="class constructor noself">
      </methodref>
      <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
      </methodref>
      <methodref name="SetInnerException" visibility="protected">
      </methodref>
      <methodref name="SetStackInfo" visibility="protected">
      </methodref>
      <methodref name="GetStackTrace" visibility="protected">
      </methodref>
      <methodref name="RaisingException" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmt" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="GetBaseException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="override">
      </methodref>
      <propertyref name="BaseException" visibility="public">
      </propertyref>
      <propertyref name="HelpContext" visibility="public">
      </propertyref>
      <propertyref name="InnerException" visibility="public">
      </propertyref>
      <propertyref name="Message" visibility="public">
      </propertyref>
      <propertyref name="StackTrace" visibility="public">
      </propertyref>
      <propertyref name="StackInfo" visibility="public">
      </propertyref>
      <methodref name="RaiseOuterException" visibility="public" procflags="static">
      </methodref>
      <methodref name="ThrowOuterException" visibility="public" procflags="static">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
  </class>
  <class name="EParserError" file="System.Classes.pas" line="217">
    <ancestor name="Exception" namespace="System.SysUtils">
      <methodref name="Create@" visibility="class private" procflags="class constructor noself">
      </methodref>
      <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
      </methodref>
      <methodref name="SetInnerException" visibility="protected">
      </methodref>
      <methodref name="SetStackInfo" visibility="protected">
      </methodref>
      <methodref name="GetStackTrace" visibility="protected">
      </methodref>
      <methodref name="RaisingException" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmt" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="GetBaseException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="override">
      </methodref>
      <propertyref name="BaseException" visibility="public">
      </propertyref>
      <propertyref name="HelpContext" visibility="public">
      </propertyref>
      <propertyref name="InnerException" visibility="public">
      </propertyref>
      <propertyref name="Message" visibility="public">
      </propertyref>
      <propertyref name="StackTrace" visibility="public">
      </propertyref>
      <propertyref name="StackInfo" visibility="public">
      </propertyref>
      <methodref name="RaiseOuterException" visibility="public" procflags="static">
      </methodref>
      <methodref name="ThrowOuterException" visibility="public" procflags="static">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
  </class>
  <class name="EOutOfResources" file="System.Classes.pas" line="218">
    <ancestor name="EOutOfMemory" namespace="System.SysUtils">
      <ancestor name="EHeapException" namespace="System.SysUtils">
        <methodref name="RaisingException" visibility="protected" procflags="override">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="override">
        </methodref>
        <ancestor name="Exception" namespace="System.SysUtils">
          <methodref name="Create@" visibility="class private" procflags="class constructor noself">
          </methodref>
          <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
          </methodref>
          <methodref name="SetInnerException" visibility="protected">
          </methodref>
          <methodref name="SetStackInfo" visibility="protected">
          </methodref>
          <methodref name="GetStackTrace" visibility="protected">
          </methodref>
          <methodref name="RaisingException" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmt" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateRes" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override">
          </methodref>
          <methodref name="GetBaseException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="override">
          </methodref>
          <propertyref name="BaseException" visibility="public">
          </propertyref>
          <propertyref name="HelpContext" visibility="public">
          </propertyref>
          <propertyref name="InnerException" visibility="public">
          </propertyref>
          <propertyref name="Message" visibility="public">
          </propertyref>
          <propertyref name="StackTrace" visibility="public">
          </propertyref>
          <propertyref name="StackInfo" visibility="public">
          </propertyref>
          <methodref name="RaiseOuterException" visibility="public" procflags="static">
          </methodref>
          <methodref name="ThrowOuterException" visibility="public" procflags="static">
          </methodref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
  </class>
  <class name="EInvalidOperation" file="System.Classes.pas" line="219">
    <ancestor name="Exception" namespace="System.SysUtils">
      <methodref name="Create@" visibility="class private" procflags="class constructor noself">
      </methodref>
      <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
      </methodref>
      <methodref name="SetInnerException" visibility="protected">
      </methodref>
      <methodref name="SetStackInfo" visibility="protected">
      </methodref>
      <methodref name="GetStackTrace" visibility="protected">
      </methodref>
      <methodref name="RaisingException" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmt" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="GetBaseException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="override">
      </methodref>
      <propertyref name="BaseException" visibility="public">
      </propertyref>
      <propertyref name="HelpContext" visibility="public">
      </propertyref>
      <propertyref name="InnerException" visibility="public">
      </propertyref>
      <propertyref name="Message" visibility="public">
      </propertyref>
      <propertyref name="StackTrace" visibility="public">
      </propertyref>
      <propertyref name="StackInfo" visibility="public">
      </propertyref>
      <methodref name="RaiseOuterException" visibility="public" procflags="static">
      </methodref>
      <methodref name="ThrowOuterException" visibility="public" procflags="static">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
  </class>
  <enum name="TDuplicates" alias="System.Types.TDuplicates" file="System.Classes.pas" line="223">
    <element value="0" name="dupIgnore" file="System.Types.pas" line="89"/>
    <element value="1" name="dupAccept" file="System.Types.pas" line="89"/>
    <element value="2" name="dupError" file="System.Types.pas" line="89"/>
  </enum>
  <pointer name="PPointerList" type="TPointerList" indircnt="1" file="System.Classes.pas" line="235"/>
  <array name="TPointerList" file="System.Classes.pas" line="236">
    <element type="Pointer"/>
  </array>
  <type name="TListSortCompare" file="System.Classes.pas" line="237" procflags="">
  </type>
  <anonMethod name="TListSortCompareFunc" file="System.Classes.pas" line="238">
    <function name="Invoke" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="238">
      <parameters>
        <parameter name="Item1" type="Pointer"/>
        <parameter name="Item2" type="Pointer"/>
        <retval type="Integer"/>
      </parameters>
    </function>
  </anonMethod>
  <enum name="TListNotification" file="System.Classes.pas" line="239">
    <element value="0" name="lnAdded" file="System.Classes.pas" line="239"/>
    <element value="1" name="lnExtracted" file="System.Classes.pas" line="239"/>
    <element value="2" name="lnDeleted" file="System.Classes.pas" line="239"/>
  </enum>
  <enum name="TListAssignOp" file="System.Classes.pas" line="250">
    <element value="0" name="laCopy" file="System.Classes.pas" line="250"/>
    <element value="1" name="laAnd" file="System.Classes.pas" line="250"/>
    <element value="2" name="laOr" file="System.Classes.pas" line="250"/>
    <element value="3" name="laXor" file="System.Classes.pas" line="250"/>
    <element value="4" name="laSrcUnique" file="System.Classes.pas" line="250"/>
    <element value="5" name="laDestUnique" file="System.Classes.pas" line="250"/>
  </enum>
  <class name="TListEnumerator" file="System.Classes.pas" line="254">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FIndex" type="Integer" visibility="private" size="4" offset="4" file="System.Classes.pas" line="256"/>
      <field name="FList" type="TList" visibility="private" size="4" offset="8" file="System.Classes.pas" line="257"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="259">
        <parameters>
          <parameter name="AList" type="TList"/>
        </parameters>
      </constructor>
      <function name="GetCurrent" visibility="public" procflags="inline" file="System.Classes.pas" line="260">
        <parameters>
          <retval type="Pointer"/>
        </parameters>
      </function>
      <function name="MoveNext" visibility="public" procflags="inline" file="System.Classes.pas" line="261">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <property name="Current" visibility="public" read="GetCurrent" type="Pointer" file="System.Classes.pas" line="262"/>
    </members>
  </class>
  <enum name="TDirection" visibility="private" alias="System.Types.TDirection" file="System.Classes.pas" line="279">
    <element value="0" name="FromBeginning" file="System.Types.pas" line="90"/>
    <element value="1" name="FromEnd" file="System.Types.pas" line="90"/>
  </enum>
  <class name="TList" file="System.Classes.pas" line="265">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FList" type="TPointerList" visibility="private" size="4" offset="4" file="System.Classes.pas" line="267"/>
      <field name="FCount" type="Integer" visibility="private" size="4" offset="8" file="System.Classes.pas" line="268"/>
      <field name="FCapacity" type="Integer" visibility="private" size="4" offset="12" file="System.Classes.pas" line="269"/>
      <function name="Get" visibility="protected" file="System.Classes.pas" line="271">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="Pointer"/>
        </parameters>
      </function>
      <procedure name="Grow" visibility="protected" procflags="virtual" file="System.Classes.pas" line="272">
      </procedure>
      <procedure name="Put" visibility="protected" file="System.Classes.pas" line="273">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="Item" type="Pointer"/>
        </parameters>
      </procedure>
      <procedure name="Notify" visibility="protected" procflags="virtual" file="System.Classes.pas" line="274">
        <parameters>
          <parameter name="Ptr" type="Pointer"/>
          <parameter name="Action" type="TListNotification"/>
        </parameters>
      </procedure>
      <procedure name="SetCapacity" visibility="protected" file="System.Classes.pas" line="275">
        <parameters>
          <parameter name="NewCapacity" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="SetCount" visibility="protected" file="System.Classes.pas" line="276">
        <parameters>
          <parameter name="NewCount" type="Integer"/>
        </parameters>
      </procedure>
      <enum name="TDirection" visibility="public" alias="System.Types.TDirection" file="System.Classes.pas" line="279">
        <element value="0" name="FromBeginning" file="System.Types.pas" line="90"/>
        <element value="1" name="FromEnd" file="System.Types.pas" line="90"/>
      </enum>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="281">
        <parameters>
        </parameters>
      </destructor>
      <function name="Add" visibility="public" file="System.Classes.pas" line="282">
        <parameters>
          <parameter name="Item" type="Pointer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="Clear" visibility="public" procflags="virtual" file="System.Classes.pas" line="283">
      </procedure>
      <procedure name="Delete" visibility="public" file="System.Classes.pas" line="284">
        <parameters>
          <parameter name="Index" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Error" visibility="public" procflags="class overload virtual" file="System.Classes.pas" line="285">
        <parameters>
          <parameter name="Msg" type="string" paramflags="const"/>
          <parameter name="Data" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="Error" visibility="public" procflags="class overload" file="System.Classes.pas" line="286">
        <parameters>
          <parameter name="Msg" type="PResStringRec"/>
          <parameter name="Data" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="Exchange" visibility="public" file="System.Classes.pas" line="287">
        <parameters>
          <parameter name="Index1" type="Integer"/>
          <parameter name="Index2" type="Integer"/>
        </parameters>
      </procedure>
      <function name="Expand" visibility="public" file="System.Classes.pas" line="288">
        <parameters>
          <retval type="TList"/>
        </parameters>
      </function>
      <function name="Extract" visibility="public" procflags="inline" file="System.Classes.pas" line="289">
        <parameters>
          <parameter name="Item" type="Pointer"/>
          <retval type="Pointer"/>
        </parameters>
      </function>
      <function name="ExtractItem" visibility="public" file="System.Classes.pas" line="290">
        <parameters>
          <parameter name="Item" type="Pointer"/>
          <parameter name="Direction" type="TDirection"/>
          <retval type="Pointer"/>
        </parameters>
      </function>
      <function name="First" visibility="public" procflags="inline" file="System.Classes.pas" line="291">
        <parameters>
          <retval type="Pointer"/>
        </parameters>
      </function>
      <function name="GetEnumerator" visibility="public" procflags="inline" file="System.Classes.pas" line="292">
        <parameters>
          <retval type="TListEnumerator"/>
        </parameters>
      </function>
      <function name="IndexOf" visibility="public" file="System.Classes.pas" line="293">
        <parameters>
          <parameter name="Item" type="Pointer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="IndexOfItem" visibility="public" file="System.Classes.pas" line="294">
        <parameters>
          <parameter name="Item" type="Pointer"/>
          <parameter name="Direction" type="TDirection"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="Insert" visibility="public" file="System.Classes.pas" line="295">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="Item" type="Pointer"/>
        </parameters>
      </procedure>
      <function name="Last" visibility="public" file="System.Classes.pas" line="296">
        <parameters>
          <retval type="Pointer"/>
        </parameters>
      </function>
      <procedure name="Move" visibility="public" file="System.Classes.pas" line="297">
        <parameters>
          <parameter name="CurIndex" type="Integer"/>
          <parameter name="NewIndex" type="Integer"/>
        </parameters>
      </procedure>
      <function name="Remove" visibility="public" procflags="inline" file="System.Classes.pas" line="298">
        <parameters>
          <parameter name="Item" type="Pointer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="RemoveItem" visibility="public" file="System.Classes.pas" line="299">
        <parameters>
          <parameter name="Item" type="Pointer"/>
          <parameter name="Direction" type="TDirection"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="Pack" visibility="public" file="System.Classes.pas" line="300">
      </procedure>
      <procedure name="Sort" visibility="public" file="System.Classes.pas" line="301">
        <parameters>
          <parameter name="Compare" type="TListSortCompare"/>
        </parameters>
      </procedure>
      <procedure name="SortList" visibility="public" file="System.Classes.pas" line="302">
        <parameters>
          <parameter name="Compare" type="TListSortCompareFunc" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Assign" visibility="public" file="System.Classes.pas" line="303">
        <parameters>
          <parameter name="ListA" type="TList"/>
          <parameter name="AOperator" type="TListAssignOp">
            <value>
              laCopy
            </value>
          </parameter>
          <parameter name="ListB" type="TList">
            <value>
              nil
            </value>
          </parameter>
        </parameters>
      </procedure>
      <property name="Capacity" visibility="public" read="FCapacity" write="SetCapacity" type="Integer" file="System.Classes.pas" line="304"/>
      <property name="Count" visibility="public" read="FCount" write="SetCount" type="Integer" file="System.Classes.pas" line="305"/>
      <property name="Items[Index]" visibility="public" read="Get" write="Put" type="Pointer" file="System.Classes.pas" line="306"/>
      <property name="List" visibility="public" read="FList" type="TPointerList" file="System.Classes.pas" line="307"/>
    </members>
  </class>
  <class name="TThreadList" file="System.Classes.pas" line="312">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FList" type="TList" visibility="private" size="4" offset="4" file="System.Classes.pas" line="314"/>
      <field name="FLock" type="TObject" visibility="private" size="4" offset="8" file="System.Classes.pas" line="315"/>
      <field name="FDuplicates" type="TDuplicates" visibility="private" size="1" offset="12" file="System.Classes.pas" line="316"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="318">
        <parameters>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="319">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Add" visibility="public" file="System.Classes.pas" line="320">
        <parameters>
          <parameter name="Item" type="Pointer"/>
        </parameters>
      </procedure>
      <procedure name="Clear" visibility="public" file="System.Classes.pas" line="321">
      </procedure>
      <function name="LockList" visibility="public" file="System.Classes.pas" line="322">
        <parameters>
          <retval type="TList"/>
        </parameters>
      </function>
      <procedure name="Remove" visibility="public" procflags="inline" file="System.Classes.pas" line="323">
        <parameters>
          <parameter name="Item" type="Pointer"/>
        </parameters>
      </procedure>
      <procedure name="RemoveItem" visibility="public" file="System.Classes.pas" line="324">
        <parameters>
          <parameter name="Item" type="Pointer"/>
          <parameter name="Direction" type="TDirection"/>
        </parameters>
      </procedure>
      <procedure name="UnlockList" visibility="public" procflags="inline" file="System.Classes.pas" line="325">
      </procedure>
      <property name="Duplicates" visibility="public" read="FDuplicates" write="FDuplicates" type="TDuplicates" file="System.Classes.pas" line="326"/>
    </members>
  </class>
  <interface name="IInterfaceList" GUID="{285DEA8A-B865-11D1-AAA7-00C04FB17A72}" ancestor="IInterface" file="System.Classes.pas" line="331">
    <function name="Get" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="333">
      <parameters>
        <parameter name="Index" type="Integer"/>
        <retval type="IInterface"/>
      </parameters>
    </function>
    <function name="GetCapacity" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="334">
      <parameters>
        <retval type="Integer"/>
      </parameters>
    </function>
    <function name="GetCount" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="335">
      <parameters>
        <retval type="Integer"/>
      </parameters>
    </function>
    <procedure name="Put" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="336">
      <parameters>
        <parameter name="Index" type="Integer"/>
        <parameter name="Item" type="IInterface" paramflags="const"/>
      </parameters>
    </procedure>
    <procedure name="SetCapacity" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="337">
      <parameters>
        <parameter name="NewCapacity" type="Integer"/>
      </parameters>
    </procedure>
    <procedure name="SetCount" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="338">
      <parameters>
        <parameter name="NewCount" type="Integer"/>
      </parameters>
    </procedure>
    <procedure name="Clear" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="340">
    </procedure>
    <procedure name="Delete" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="341">
      <parameters>
        <parameter name="Index" type="Integer"/>
      </parameters>
    </procedure>
    <procedure name="Exchange" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="342">
      <parameters>
        <parameter name="Index1" type="Integer"/>
        <parameter name="Index2" type="Integer"/>
      </parameters>
    </procedure>
    <function name="First" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="343">
      <parameters>
        <retval type="IInterface"/>
      </parameters>
    </function>
    <function name="IndexOf" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="344">
      <parameters>
        <parameter name="Item" type="IInterface" paramflags="const"/>
        <retval type="Integer"/>
      </parameters>
    </function>
    <function name="Add" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="345">
      <parameters>
        <parameter name="Item" type="IInterface" paramflags="const"/>
        <retval type="Integer"/>
      </parameters>
    </function>
    <procedure name="Insert" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="346">
      <parameters>
        <parameter name="Index" type="Integer"/>
        <parameter name="Item" type="IInterface" paramflags="const"/>
      </parameters>
    </procedure>
    <function name="Last" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="347">
      <parameters>
        <retval type="IInterface"/>
      </parameters>
    </function>
    <function name="Remove" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="348">
      <parameters>
        <parameter name="Item" type="IInterface" paramflags="const"/>
        <retval type="Integer"/>
      </parameters>
    </function>
    <procedure name="Lock" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="349">
    </procedure>
    <procedure name="Unlock" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="350">
    </procedure>
    <property name="Capacity" visibility="public" read="GetCapacity" write="SetCapacity" type="Integer" file="System.Classes.pas" line="351"/>
    <property name="Count" visibility="public" read="GetCount" write="SetCount" type="Integer" file="System.Classes.pas" line="352"/>
    <property name="Items[Index]" visibility="public" read="Get" write="Put" type="IInterface" file="System.Classes.pas" line="353"/>
  </interface>
  <interface name="IInterfaceListEx" GUID="{FDB39D70-65B9-4995-9436-6084ACA05DB3}" ancestor="IInterfaceList" file="System.Classes.pas" line="362">
    <function name="GetEnumerator" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="364">
      <parameters>
        <retval type="TInterfaceListEnumerator"/>
      </parameters>
    </function>
  </interface>
  <class name="TInterfaceListEnumerator" file="System.Classes.pas" line="373">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FIndex" type="Integer" visibility="private" size="4" offset="4" file="System.Classes.pas" line="375"/>
      <field name="FInterfaceList" type="TInterfaceList" visibility="private" size="4" offset="8" file="System.Classes.pas" line="376"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="378">
        <parameters>
          <parameter name="AInterfaceList" type="TInterfaceList"/>
        </parameters>
      </constructor>
      <function name="GetCurrent" visibility="public" procflags="inline" file="System.Classes.pas" line="379">
        <parameters>
          <retval type="IInterface"/>
        </parameters>
      </function>
      <function name="MoveNext" visibility="public" procflags="inline" file="System.Classes.pas" line="380">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <property name="Current" visibility="public" read="GetCurrent" type="IInterface" file="System.Classes.pas" line="381"/>
    </members>
  </class>
  <class name="TInterfaceList" file="System.Classes.pas" line="384">
    <ancestor name="TInterfacedObject" namespace="System">
      <interfaces>
        <implements name="IInterface"/>
      </interfaces>
      <methodref name="GetRefCount" visibility="private" procflags="inline">
      </methodref>
      <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
      </methodref>
      <methodref name="QueryInterface" visibility="protected">
      </methodref>
      <methodref name="_AddRef" visibility="protected">
      </methodref>
      <methodref name="_Release" visibility="protected">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="override">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="override">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class override">
      </methodref>
      <propertyref name="RefCount" visibility="public">
      </propertyref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <interfaces>
      <implements name="IInterfaceListEx"/>
      <implements name="IInterfaceList"/>
    </interfaces>
    <members>
      <field name="FList" type="TThreadList&lt;System.IInterface&gt;" visibility="private" size="4" offset="12" file="System.Classes.pas" line="386"/>
      <function name="Get" visibility="protected" file="System.Classes.pas" line="389">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="IInterface"/>
        </parameters>
      </function>
      <function name="GetCapacity" visibility="protected" file="System.Classes.pas" line="390">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetCount" visibility="protected" file="System.Classes.pas" line="391">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="Put" visibility="protected" file="System.Classes.pas" line="392">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="Item" type="IInterface" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetCapacity" visibility="protected" file="System.Classes.pas" line="393">
        <parameters>
          <parameter name="NewCapacity" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="SetCount" visibility="protected" file="System.Classes.pas" line="394">
        <parameters>
          <parameter name="NewCount" type="Integer"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="396">
        <parameters>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="397">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Clear" visibility="public" file="System.Classes.pas" line="398">
      </procedure>
      <procedure name="Delete" visibility="public" file="System.Classes.pas" line="399">
        <parameters>
          <parameter name="Index" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Exchange" visibility="public" file="System.Classes.pas" line="400">
        <parameters>
          <parameter name="Index1" type="Integer"/>
          <parameter name="Index2" type="Integer"/>
        </parameters>
      </procedure>
      <function name="Expand" visibility="public" file="System.Classes.pas" line="401">
        <parameters>
          <retval type="TInterfaceList"/>
        </parameters>
      </function>
      <function name="First" visibility="public" file="System.Classes.pas" line="402">
        <parameters>
          <retval type="IInterface"/>
        </parameters>
      </function>
      <function name="IndexOf" visibility="public" file="System.Classes.pas" line="403">
        <parameters>
          <parameter name="Item" type="IInterface" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="IndexOfItem" visibility="public" file="System.Classes.pas" line="404">
        <parameters>
          <parameter name="Item" type="IInterface" paramflags="const"/>
          <parameter name="Direction" type="TDirection"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="Add" visibility="public" file="System.Classes.pas" line="405">
        <parameters>
          <parameter name="Item" type="IInterface" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="Insert" visibility="public" file="System.Classes.pas" line="406">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="Item" type="IInterface" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="Last" visibility="public" file="System.Classes.pas" line="407">
        <parameters>
          <retval type="IInterface"/>
        </parameters>
      </function>
      <function name="Remove" visibility="public" file="System.Classes.pas" line="408">
        <parameters>
          <parameter name="Item" type="IInterface" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="RemoveItem" visibility="public" file="System.Classes.pas" line="409">
        <parameters>
          <parameter name="Item" type="IInterface" paramflags="const"/>
          <parameter name="Direction" type="TDirection"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="Lock" visibility="public" file="System.Classes.pas" line="410">
      </procedure>
      <procedure name="Unlock" visibility="public" file="System.Classes.pas" line="411">
      </procedure>
      <function name="GetEnumerator" visibility="public" file="System.Classes.pas" line="413">
        <parameters>
          <retval type="TInterfaceListEnumerator"/>
        </parameters>
      </function>
      <property name="Capacity" visibility="public" read="GetCapacity" write="SetCapacity" type="Integer" file="System.Classes.pas" line="415"/>
      <property name="Count" visibility="public" read="GetCount" write="SetCount" type="Integer" file="System.Classes.pas" line="416"/>
      <property name="Items[Index]" visibility="public" read="Get" write="Put" type="IInterface" file="System.Classes.pas" line="417"/>
    </members>
  </class>
  <class name="TBits" file="System.Classes.pas" line="424">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FSize" type="Integer" visibility="private" size="4" offset="4" file="System.Classes.pas" line="426"/>
      <field name="FBits" type="Pointer" visibility="private" size="4" offset="8" file="System.Classes.pas" line="427"/>
      <procedure name="Error" visibility="private" file="System.Classes.pas" line="428">
      </procedure>
      <procedure name="SetSize" visibility="private" file="System.Classes.pas" line="429">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="SetBit" visibility="private" file="System.Classes.pas" line="430">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <function name="GetBit" visibility="private" file="System.Classes.pas" line="431">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="433">
        <parameters>
        </parameters>
      </destructor>
      <function name="OpenBit" visibility="public" file="System.Classes.pas" line="434">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <property name="Bits[Index]" visibility="public" read="GetBit" write="SetBit" type="Boolean" file="System.Classes.pas" line="435"/>
      <property name="Size" visibility="public" read="FSize" write="SetSize" type="Integer" file="System.Classes.pas" line="436"/>
    </members>
  </class>
  <class name="TPersistent" file="System.Classes.pas" line="443">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <procedure name="AssignError" visibility="private" file="System.Classes.pas" line="445">
        <parameters>
          <parameter name="Source" type="TPersistent"/>
        </parameters>
      </procedure>
      <procedure name="AssignTo" visibility="protected" procflags="virtual" file="System.Classes.pas" line="447">
        <parameters>
          <parameter name="Dest" type="TPersistent"/>
        </parameters>
      <devnotes><summary>
Copies the properties of an object to a destination object.
Override the AssignTo method to extend the functionality of the Assign method of destination objects so that they handle newly created object classes. When defining a new object class, override the Assign method for every existing object class that should be able to copy its properties to the new class. Override the AssignTo method for every existing class to which the new class can copy.
The Assign method of TPersistent calls AssignTo if the descendant object does not succeed in copying the properties of a source object. The AssignTo method defined by TPersistent raises an EConvertError exception. 
For example, given the following code in which A and B are instance variables:

A.Assign(B); {Delphi}

A-&gt;Assign(B); // C++

if A knows how to handle B, then it does so and returns. If A doesn't know how to handle B's type, execution will trickle to the TPersistent version of Assign, which calls:

B.AssignTo(A); {Delphi}

B-&gt;AssignTo(A); // C++

If B knows how to copy to A, the assignment succeeds. Otherwise, TPersistent raises an exception.
</summary></devnotes></procedure>
      <procedure name="DefineProperties" visibility="protected" procflags="virtual" file="System.Classes.pas" line="448">
        <parameters>
          <parameter name="Filer" type="TFiler"/>
        </parameters>
      <devnotes><summary>
Provides an interface for a method that reads and writes otherwise unpublished data.
Descendants of TPersistent override DefineProperties to designate a method for storing the object's unpublished data to a stream such as a form file. By default, writing an object to a stream writes the values of all its published properties, and reading the object in reads those values and assigns them to the properties. Objects can also specify methods that read and write data other than published properties by overriding the DefineProperties method.
When overriding DefineProperties, consider including some or all of the following:

A call to the inherited method
Calls to the filer object's DefineProperty method
Calls to the filer object's DefineBinaryProperty method
DefineProperties is virtual, so descendant classes can override it as necessary but are not required to do so.
</summary></devnotes></procedure>
      <function name="GetOwner" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="449">
        <parameters>
          <retval type="TPersistent"/>
        </parameters>
      <devnotes><summary>
Returns the owner of an object.
GetOwner is used by the GetNamePath method to find the owner of a persistent object. GetNamePath and GetOwner are introduced in TPersistent so descendants such as collections can appear in the Object Inspector. As implemented in TPersistent, GetOwner returns nil (Delphi) or NULL (C++). 
For TOwnedCollection, GetOwner returns the owner of the collection. For TCollectionItem collection items, GetOwner returns the collection object into which the collection item has been inserted. For TComponent, GetOwner returns the value of the Owner property.
</summary></devnotes></function>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="451">
        <parameters>
        </parameters>
      <devnotes><summary>
Destroys the TPersistent instance and frees its memory.
Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy.
</summary></devnotes></destructor>
      <procedure name="Assign" visibility="public" procflags="virtual" file="System.Classes.pas" line="452">
        <parameters>
          <parameter name="Source" type="TPersistent"/>
        </parameters>
      <devnotes><summary>
Copies the contents of another similar object.
Assign copies properties and other attributes of the specified Source object to the current object. The standard form of a call to Assign is:

Destination.Assign(Source); {Delphi}

Destination-&gt;Assign(Source); // C++

which tells the current object to copy the contents of the Source object to itself.
Most objects override Assign to handle the assignment of properties from similar objects. When overriding Assign, call the inherited method if the destination object cannot handle the assignment of properties from the class of the Source parameter.
If no overridden Assign method can handle the assignment of properties from Source, the method implemented in TPersistent calls the source object's AssignTo method. This allows the source object to handle the assignment. If the Source object is nil (Delphi) or NULL (C++), Assign raises an EConvertError exception.
In general, the statement

Destination := Source; {Delphi}

Destination = Source; // C++

is not the same as the statement

Destination.Assign(Source); {Delphi}

Destination-&gt;Assign(Source); // C++

The assignment operator makes Destination reference the same object as Source, whereas the Assign method copies the contents of the object referenced by Source into the object referenced by Destination.

Note: The types of some properties are also objects. If these properties have written methods that use Assign to set the value of the property, then in these cases the assignment operator does the same thing as the Assign method.</summary></devnotes></procedure>
      <function name="GetNamePath" visibility="public" procflags="dynamic" file="System.Classes.pas" line="453">
        <parameters>
          <retval type="string"/>
        </parameters>
      <devnotes><summary>
Returns the name of the object as it appears in the Object Inspector.
GetNamePath is for internal use only. It determines the text that the Object Inspector displays for the name of the object being edited. GetNamePath is introduced in TPersistent so descendants such as collections can appear in the Object Inspector. Do not call GetNamePath directly.
For components, GetNamePath returns the component name. For TCollectionItem objects it returns the name of the hosting component, the name of the property, and the index into the collection surrounded by brackets.
</summary></devnotes></function>
    </members>
  <devnotes><summary>
TPersistent is the ancestor for all objects that have assignment and streaming capabilities.
TPersistent encapsulates the behavior common to all objects that can be assigned to other objects, and that can read and write their properties to and from a form file (.xfm or .dfm file). For this purpose, TPersistent introduces methods that can be overridden to:

Define the procedure for loading and storing unpublished data to a stream.
Provide the means to assign values to properties.
Provide the means to assign the contents of one object to another.
Do not create instances of TPersistent. Use TPersistent as a base class when declaring objects that are not components, but that need to be saved to a stream or have their properties assigned to other objects.
</summary></devnotes></class>
  <classref name="TPersistentClass" ref="TPersistent" file="System.Classes.pas" line="460"/>
  <class name="TInterfacedPersistent" file="System.Classes.pas" line="464">
    <ancestor name="TPersistent" namespace="System.Classes">
      <methodref name="AssignError" visibility="private"/>
      <methodref name="AssignTo" visibility="protected" procflags="virtual"/>
      <methodref name="DefineProperties" visibility="protected" procflags="virtual"/>
      <methodref name="GetOwner" visibility="protected" procflags="dynamic"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="Assign" visibility="public" procflags="virtual"/>
      <methodref name="GetNamePath" visibility="public" procflags="dynamic"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <interfaces>
      <implements name="IInterface"/>
    </interfaces>
    <members>
      <field name="FOwnerInterface" type="IInterface" visibility="private" size="4" offset="4" file="System.Classes.pas" line="466"/>
      <function name="_AddRef" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="469">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="_Release" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="470">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="QueryInterface" visibility="public" procflags="virtual" callconv="stdcall" file="System.Classes.pas" line="472">
        <parameters>
          <parameter name="IID" type="TGUID" paramflags="const"/>
          <parameter name="Obj" paramflags="out"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <procedure name="AfterConstruction" visibility="public" procflags="override" file="System.Classes.pas" line="473">
      </procedure>
    </members>
  </class>
  <class name="TRecall" file="System.Classes.pas" line="478">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FStorage" type="TPersistent" visibility="private" size="4" offset="4" file="System.Classes.pas" line="480"/>
      <field name="FReference" type="TPersistent" visibility="private" size="4" offset="8" file="System.Classes.pas" line="480"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="482">
        <parameters>
          <parameter name="AStorage" type="TPersistent"/>
          <parameter name="AReference" type="TPersistent"/>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="483">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Store" visibility="public" file="System.Classes.pas" line="484">
      </procedure>
      <procedure name="Forget" visibility="public" file="System.Classes.pas" line="485">
      </procedure>
      <property name="Reference" visibility="public" read="FReference" type="TPersistent" file="System.Classes.pas" line="486"/>
    </members>
  </class>
  <class name="TCollectionItem" file="System.Classes.pas" line="493">
    <ancestor name="TPersistent" namespace="System.Classes">
      <methodref name="AssignError" visibility="private"/>
      <methodref name="AssignTo" visibility="protected" procflags="virtual"/>
      <methodref name="DefineProperties" visibility="protected" procflags="virtual"/>
      <methodref name="GetOwner" visibility="protected" procflags="dynamic"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="Assign" visibility="public" procflags="virtual"/>
      <methodref name="GetNamePath" visibility="public" procflags="dynamic"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FCollection" type="TCollection" visibility="private" size="4" offset="4" file="System.Classes.pas" line="495">
        <attributes>
          <attribute name="TObject"/>
        </attributes>
      </field>
      <field name="FID" type="Integer" visibility="private" size="4" offset="8" file="System.Classes.pas" line="496"/>
      <function name="GetIndex" visibility="private" file="System.Classes.pas" line="497">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="Changed" visibility="protected" file="System.Classes.pas" line="499">
        <parameters>
          <parameter name="AllItems" type="Boolean"/>
        </parameters>
      </procedure>
      <function name="GetOwner" visibility="protected" procflags="override" file="System.Classes.pas" line="500">
        <parameters>
          <retval type="TPersistent"/>
        </parameters>
      </function>
      <function name="GetDisplayName" visibility="protected" procflags="virtual" file="System.Classes.pas" line="501">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <procedure name="SetCollection" visibility="protected" procflags="virtual" file="System.Classes.pas" line="502">
        <parameters>
          <parameter name="Value" type="TCollection"/>
        </parameters>
      </procedure>
      <procedure name="SetIndex" visibility="protected" procflags="virtual" file="System.Classes.pas" line="503">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="SetDisplayName" visibility="protected" procflags="virtual" file="System.Classes.pas" line="504">
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="506">
        <parameters>
          <parameter name="Collection" type="TCollection"/>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="507">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Release" visibility="public" procflags="virtual" file="System.Classes.pas" line="508">
      </procedure>
      <function name="GetNamePath" visibility="public" procflags="override" file="System.Classes.pas" line="509">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <property name="Collection" visibility="public" read="FCollection" write="SetCollection" type="TCollection" file="System.Classes.pas" line="510"/>
      <property name="ID" visibility="public" read="FID" type="Integer" file="System.Classes.pas" line="511"/>
      <property name="Index" visibility="public" read="GetIndex" write="SetIndex" type="Integer" file="System.Classes.pas" line="512"/>
      <property name="DisplayName" visibility="public" read="GetDisplayName" write="SetDisplayName" type="string" default="0" file="System.Classes.pas" line="513"/>
    </members>
  </class>
  <classref name="TCollectionItemClass" ref="TCollectionItem" file="System.Classes.pas" line="516"/>
  <enum name="TCollectionNotification" alias="System.Generics.Collections.TCollectionNotification" file="System.Classes.pas" line="517">
    <element value="0" name="cnAdding" file="System.Generics.Collections.pas" line="49"/>
    <element value="1" name="cnAdded" file="System.Generics.Collections.pas" line="49"/>
    <element value="2" name="cnExtracting" file="System.Generics.Collections.pas" line="49"/>
    <element value="3" name="cnExtracted" file="System.Generics.Collections.pas" line="49"/>
    <element value="4" name="cnDeleting" file="System.Generics.Collections.pas" line="49"/>
    <element value="5" name="cnRemoved" file="System.Generics.Collections.pas" line="49"/>
  </enum>
  <class name="TCollectionEnumerator" file="System.Classes.pas" line="520">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FIndex" type="Integer" visibility="private" size="4" offset="4" file="System.Classes.pas" line="522"/>
      <field name="FCollection" type="TCollection" visibility="private" size="4" offset="8" file="System.Classes.pas" line="523"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="525">
        <parameters>
          <parameter name="ACollection" type="TCollection"/>
        </parameters>
      </constructor>
      <function name="GetCurrent" visibility="public" procflags="inline" file="System.Classes.pas" line="526">
        <parameters>
          <retval type="TCollectionItem"/>
        </parameters>
      </function>
      <function name="MoveNext" visibility="public" procflags="inline" file="System.Classes.pas" line="527">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <property name="Current" visibility="public" read="GetCurrent" type="TCollectionItem" file="System.Classes.pas" line="528"/>
    </members>
  </class>
  <class name="TCollection" file="System.Classes.pas" line="531">
    <ancestor name="TPersistent" namespace="System.Classes">
      <methodref name="AssignError" visibility="private"/>
      <methodref name="AssignTo" visibility="protected" procflags="virtual"/>
      <methodref name="DefineProperties" visibility="protected" procflags="virtual"/>
      <methodref name="GetOwner" visibility="protected" procflags="dynamic"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="Assign" visibility="public" procflags="virtual"/>
      <methodref name="GetNamePath" visibility="public" procflags="dynamic"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FItemClass" type="TCollectionItemClass" visibility="private" size="4" offset="4" file="System.Classes.pas" line="533"/>
      <field name="FItems" type="TList&lt;System.Classes.TCollectionItem&gt;" visibility="private" size="4" offset="8" file="System.Classes.pas" line="534"/>
      <field name="FUpdateCount" type="Integer" visibility="private" size="4" offset="12" file="System.Classes.pas" line="535"/>
      <field name="FNextID" type="Integer" visibility="private" size="4" offset="16" file="System.Classes.pas" line="536"/>
      <field name="FPropName" type="string" visibility="private" size="4" offset="20" file="System.Classes.pas" line="537"/>
      <function name="GetCapacity" visibility="private" file="System.Classes.pas" line="538">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetCount" visibility="private" procflags="inline" file="System.Classes.pas" line="539">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetPropName" visibility="private" file="System.Classes.pas" line="540">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <procedure name="InsertItem" visibility="private" file="System.Classes.pas" line="541">
        <parameters>
          <parameter name="Item" type="TCollectionItem"/>
        </parameters>
      </procedure>
      <procedure name="RemoveItem" visibility="private" file="System.Classes.pas" line="542">
        <parameters>
          <parameter name="Item" type="TCollectionItem"/>
        </parameters>
      </procedure>
      <procedure name="SetCapacity" visibility="private" file="System.Classes.pas" line="543">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Added" visibility="protected" procflags="virtual" file="System.Classes.pas" line="545" symflags="deprecated">
        <parameters>
          <parameter name="Item" type="TCollectionItem" paramflags="var"/>
        </parameters>
      <devnotes><summary>

Warning: Added is deprecated.  


Responds when items are added to the collection.
Applications cannot call the protected Added method. It is called automatically immediately after items are added to the collection.
Item is the item that was just added to the collection.
Added is a deprecated method. Descendent classes should override the Notify method instead when responding to changes in the list of items.
</summary></devnotes></procedure>
      <procedure name="Deleting" visibility="protected" procflags="virtual" file="System.Classes.pas" line="546" symflags="deprecated">
        <parameters>
          <parameter name="Item" type="TCollectionItem"/>
        </parameters>
      <devnotes><summary>

Warning: Deleting is deprecated.  


Responds when items are deleted from the collection.
Applications cannot call the protected Deleting method. The Delete method calls Deleting immediately before it removes an item from the collection.
Item is the item that is about to be removed.
Deleting is a deprecated method. Descendent classes should override the Notify method instead when responding to changes in the list of items.
</summary></devnotes></procedure>
      <property name="NextID" visibility="protected" read="FNextID" type="Integer" file="System.Classes.pas" line="547"><devnotes><summary>
Specifies a unique ID that can be assigned to the next added collection item.
TCollection uses NextID internally to assign unique identifiers to collection items. When a new item is added to the collection, its ID property is given the value of NextID and NextID is incremented.
</summary></devnotes></property>
      <procedure name="Notify" visibility="protected" procflags="virtual" file="System.Classes.pas" line="548">
        <parameters>
          <parameter name="Item" type="TCollectionItem"/>
          <parameter name="Action" type="TCollectionNotification"/>
        </parameters>
      <devnotes><summary>
Responds when items are added to or removed from the collection.
Notify is called automatically when the items in the collection change.
Item is the item that was just added to or that is about to be removed from the collection.
Action indicates whether the item was added, is about to be extracted or is about to be deleted.
As implemented in TCollection, Notify calls Added when Action is cnAdded and calls Deleting when Action is cnDeleting. TCollection ignores the cnExtracting action. Descendant classes can override Notify to modify this behavior.
</summary></devnotes></procedure>
      <function name="GetAttrCount" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="550">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Returns the number of custom attributes associated with items in the collection.
TCollection descendants can associate user-defined attributes with the items in the collection. Each attribute has a name and, for each item in the collection, a value that is a string. GetAttrCount returns the number of distinct attributes assigned to each item in the collection.
As implemented in TCollection, GetAttrCount always returns 0, because TCollection defines no custom attributes.
</summary></devnotes></function>
      <function name="GetAttr" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="551">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="string"/>
        </parameters>
      <devnotes><summary>
Returns the name of a custom attribute that can be retrieved using the GetItemAttr method.
TCollection descendants can associate user-defined attributes with the items in the collection. Each attribute has a name and, for each item in the collection, a value that is a string. The GetAttr method returns the name of an attribute.
Index identifies the attribute whose name is requested. This is a value between 0 and n-1, where n is the value returned by GetAttrCount.
As implemented by TCollection, GetAttr always returns an empty string, because TCollection defines no custom attributes.
</summary></devnotes></function>
      <function name="GetItemAttr" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="552">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="ItemIndex" type="Integer"/>
          <retval type="string"/>
        </parameters>
      <devnotes><summary>
Returns the value of a custom attribute assigned to one of the collection's items.
TCollection descendants can associate user-defined attributes with the items in the collection. Each attribute has a name and -- for each item in the collection -- a value, which is a string. GetItemAttr returns the value of one of these attributes for a specified item in the collection.
Index identifies which of the attribute's values is desired. This is a value between 0 and n-1, where n is the value returned by GetAttrCount.
ItemIndex identifies the item whose attribute value is desired. This is an index into the Items property array.
As implemented in TCollection, GetItemAttr always returns an empty string, because TCollection defines no custom attributes.
</summary></devnotes></function>
      <procedure name="Changed" visibility="protected" file="System.Classes.pas" line="553">
      <devnotes><summary>
Responds when the collection or any of its items changes.
Changed is called automatically when items in the collection change or when the EndUpdate method signals that an update is complete. It checks the value of UpdateCount, and if it is 0, calls the Update method, which performs any necessary updates.
When writing a TCollection descendant, there is no need to call Changed. Instead, bracket any changes by calls to BeginUpdate and EndUpdate.
</summary></devnotes></procedure>
      <function name="GetItem" visibility="protected" file="System.Classes.pas" line="554">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="TCollectionItem"/>
        </parameters>
      <devnotes><summary>
Returns a specified item in the collection.
GetItem is the protected read implementation of the Items property.
</summary></devnotes></function>
      <procedure name="SetItem" visibility="protected" file="System.Classes.pas" line="555">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="Value" type="TCollectionItem"/>
        </parameters>
      <devnotes><summary>
Copies the properties of another item to a specified item in the collection.
SetItem is the protected write implementation of the Items property. It calls the Assign method of the item specified by Index, so that the properties of the item specified by Value are copied to that item.
</summary></devnotes></procedure>
      <procedure name="SetItemName" visibility="protected" procflags="virtual" file="System.Classes.pas" line="556">
        <parameters>
          <parameter name="Item" type="TCollectionItem"/>
        </parameters>
      <devnotes><summary>
Initializes the name of a newly inserted collection item.
The Insert method calls SetItemName to initialize the Name property of items when it inserts them into the collection.
As implemented in TCollection, SetItemName does nothing. Some TCollection descendants override this method to provide collection items with default names.
</summary></devnotes></procedure>
      <procedure name="Update" visibility="protected" procflags="virtual" file="System.Classes.pas" line="557">
        <parameters>
          <parameter name="Item" type="TCollectionItem"/>
        </parameters>
      <devnotes><summary>
Updates the collection to reflect changes to its items.
Override Update in a descendent class to make any necessary changes when the items in the collection change. This method is called automatically when an update is complete.
Item identifies the item that changed. If the Item parameter is nil (Delphi) or NULL (C++), then the change affects more than one item in the collection.
As implemented in TCollection, Update does nothing. Descendent classes override this method to make any necessary adjustments.
</summary></devnotes></procedure>
      <property name="PropName" visibility="protected" read="GetPropName" write="FPropName" type="string" default="0" file="System.Classes.pas" line="558"><devnotes><summary>
Specifies the name of the property that the collection implements.
The GetNamePath method uses this protected property to assemble the name of the collection as it appears in the Object Inspector. It identifies the name of the property in the object returned by the protected GetOwner method that is implemented using this collection object.
</summary></devnotes></property>
      <property name="UpdateCount" visibility="protected" read="FUpdateCount" type="Integer" file="System.Classes.pas" line="559"><devnotes><summary>
Counts the number of times BeginUpdate was called without a corresponding call to EndUpdate.
UpdateCount keeps track of calls to BeginUpdate and EndUpdate so that they can be nested. Every call to BeginUpdate increments UpdateCount. Every call to EndUpdate decrements it. When UpdateCount returns to 0, the collection updates itself to reflect all changes that occurred since the first call to BeginUpdate.
</summary></devnotes></property>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="561">
        <parameters>
          <parameter name="ItemClass" type="TCollectionItemClass"/>
        </parameters>
      <devnotes><summary>
Creates and initializes a collection.
Call Create to instantiate a TCollection object at run time. Typically, TCollection descendants are created by a component that uses the collection to implement a property.
ItemClass identifies the TCollectionItem descendants that must be used to represent the items in the collection. The Add method uses this class to create items of the appropriate type.
</summary></devnotes></constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="562">
        <parameters>
        </parameters>
      <devnotes><summary>
Destroys the collection and each item in it.
Destroy uses the Clear method to free each item referenced in the Items array, then destroys the collection itself.
</summary></devnotes></destructor>
      <function name="Owner" visibility="public" file="System.Classes.pas" line="563">
        <parameters>
          <retval type="TPersistent"/>
        </parameters>
      <devnotes><summary>
Returns the Owner of the collection.
Call Owner to obtain a reference to the object that owns this collection. Typically, the owner uses the collection to implement one of its properties.
</summary></devnotes></function>
      <function name="Add" visibility="public" file="System.Classes.pas" line="564">
        <parameters>
          <retval type="TCollectionItem"/>
        </parameters>
      <devnotes><summary>
Creates a new TCollectionItem instance and adds it to the Items array.
Call Add to create an item in the collection. The new item is placed at the end of the Items array.
Add returns the new collection item.
</summary></devnotes></function>
      <procedure name="Assign" visibility="public" procflags="override" file="System.Classes.pas" line="565">
        <parameters>
          <parameter name="Source" type="TPersistent"/>
        </parameters>
      <devnotes><summary>
Copies the contents of the Source collection to the current object.
Use Assign to copy the contents of one TCollection instance to another. The Assign method deletes all items from the destination collection (the object where it is executed), then adds a copy of each item in the source collection's Items array.
Source is another object (typically another collection) that contains the items that replace this collection's items.
</summary></devnotes></procedure>
      <procedure name="BeginUpdate" visibility="public" procflags="virtual" file="System.Classes.pas" line="566">
      <devnotes><summary>
Signals the start of an update operation.
Call BeginUpdate before starting an operation that performs changes to TCollection. After completing all the changes, call EndUpdate to signal the end of the operation. Every call to BeginUpdate must be matched by a corresponding call to the EndUpdate method. 
For example, the method is used to suspend screen repainting until changes to a component that involves TCollection are completed.
</summary></devnotes></procedure>
      <procedure name="Clear" visibility="public" file="System.Classes.pas" line="567">
      <devnotes><summary>
Deletes all items from the collection.
Clear empties the Items array and destroys each TCollectionItem.
</summary></devnotes></procedure>
      <procedure name="ClearAndResetID" visibility="public" file="System.Classes.pas" line="568">
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></procedure>
      <procedure name="Delete" visibility="public" file="System.Classes.pas" line="569">
        <parameters>
          <parameter name="Index" type="Integer"/>
        </parameters>
      <devnotes><summary>
Deletes a single item from the collection.
Delete removes the specified collection item, moving up any items that come after that item in the Items property array.
Index identifies the item to delete. This is the index of the item in the Items property array. 0 specifies the first item, 1 specifies the second item, and so on.
</summary></devnotes></procedure>
      <procedure name="EndUpdate" visibility="public" procflags="virtual" file="System.Classes.pas" line="570">
      <devnotes><summary>
Signals the end of an update operation.
Call EndUpdate after completing an operation that was preceded by a call to the BeginUpdate method. Every call to BeginUpdate must be matched by a corresponding call to the EndUpdate method.
For example, use EndUpdate to re-enable screen repainting that was turned off with the BeginUpdate method for the components that involve TCollection.  
</summary></devnotes></procedure>
      <procedure name="Sort" visibility="public" file="System.Classes.pas" line="572">
        <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes>
        <parameters>
          <parameter name="AComparer" type="IComparer&lt;System.Classes.TCollectionItem&gt;" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="FindItemID" visibility="public" file="System.Classes.pas" line="573">
        <parameters>
          <parameter name="ID" type="Integer"/>
          <retval type="TCollectionItem"/>
        </parameters>
      <devnotes><summary>
Returns the item with the specified ID.
The FindItemID method returns the item in the collection whose ID property is passed to it as a parameter. If no item has the specified ID, FindItemID returns nil (Delphi) or NULL (C++).
</summary></devnotes></function>
      <function name="GetEnumerator" visibility="public" procflags="inline" file="System.Classes.pas" line="574">
        <parameters>
          <retval type="TCollectionEnumerator"/>
        </parameters>
      <devnotes><summary>
Returns a TCollection enumerator.
GetEnumerator returns a TCollectionEnumerator reference, which enumerates all items in the collection. 
To do so, call the TCollectionEnumerator GetCurrent method within a While MoveNext do loop. 
</summary></devnotes></function>
      <function name="GetNamePath" visibility="public" procflags="override" file="System.Classes.pas" line="575">
        <parameters>
          <retval type="string"/>
        </parameters>
      <devnotes><summary>
Returns a string used by the Object Inspector.
If the collection has no owner, GetNamePath returns the name of the collection's actual (runtime) type. If the collection is owned, GetNamePath returns the owner's name followed, if applicable, by a dot and the name of the owner's property that holds the collection. For example, GetNamePath might return &quot;TreeView1.Items&quot;.

Note:  For a collection to have an owner, it must override the GetOwner method.</summary></devnotes></function>
      <function name="Insert" visibility="public" file="System.Classes.pas" line="576">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="TCollectionItem"/>
        </parameters>
      <devnotes><summary>
Creates a new TCollectionItem instance and adds it to the Items array.
Call Insert to add a new item at a specified position in the collection. Existing items (starting from the specified position) are moved up in the Items array.
Insert returns the new collection item.
</summary></devnotes></function>
      <property name="Capacity" visibility="public" read="GetCapacity" write="SetCapacity" type="Integer" file="System.Classes.pas" line="577"><devnotes><summary>
Provides access to the internal TList.Capacity property.
The Capacity property specifies the allocated size of the array of pointers maintained by the TList object. This value is set to the number of pointers the list will need to contain.


</summary></devnotes></property>
      <property name="Count" visibility="public" read="GetCount" type="Integer" file="System.Classes.pas" line="578"><devnotes><summary>
Returns the number of items in the collection.
Count contains the number of items in the Items array. Since Items is indexed starting with 0, the value of Count is always one greater than the index of the last member of Items.
</summary></devnotes></property>
      <property name="ItemClass" visibility="public" read="FItemClass" type="TCollectionItemClass" file="System.Classes.pas" line="579"><devnotes><summary>
Indicates the class to which the collection's items belong.
ItemClass is the class (descended from TCollectionItem) to which the items in the collection belong. For example, in an instance of the TCollection descendant THeaderSections, the value of the ItemClass property is THeaderSection.
</summary></devnotes></property>
      <property name="Items[Index]" visibility="public" read="GetItem" write="SetItem" type="TCollectionItem" file="System.Classes.pas" line="580"/>
    </members>
  <devnotes><summary>
TCollection is a container for TCollectionItem objects.
Each TCollection holds a group of TCollectionItem descendants. TCollection maintains an index of the collection items in its Items array. The Count property contains the number of items in the collection. Use the Add and Delete methods to add items to the collection and delete items from the collection.
Objects descended from TCollection can contain objects descended from TCollectionItem. Thus, for each TCollection descendant, there is a corresponding TCollectionItem descendant. 
The following table lists some typical descendants of TCollection with the corresponding TCollectionItem descendant and the component that uses each pair:



TCollection descendant

TCollectionItem descendant

Component



TBitmapLinks



TBitmapLink



TCustomStyleObject




TAggregates



TAggregate



TClientDataSet




TCookieCollection



TCookie



TWebResponse




TCoolBands



TCoolBand



TCoolBar




TDBGridColumns



TColumn



TDBGrid




TDependencies



TDependency



TService




THeaderSections



THeaderSection



THeaderControl




TListColumns



TListColumn



TListView




TParams



TParam



many datasets




TStatusPanels



TStatusPanel



TStatusBar


The controls that use TCollection and TCollectionItem descendants have a published property that holds a collection. (For example, the Panels property of TStatusBar holds a TStatusPanels.) A standard property editor, referred to generically as the Collection editor, can be invoked from the Object Inspector to edit the items in the collection. 

Note: When writing a TCollection descendant that is used by another control, be sure to override the protected GetOwner method of the collection so that the descendant class instances can appear in the Object Inspector.
Note: TCollection has the TOwnedCollection descendant that maintains information about its owner. TOwnedCollection implements the GetOwner method. Therefore, classes derived from TOwnedCollection do not need to add anything in order to appear in the Object Inspector.</summary></devnotes></class>
  <class name="TOwnedCollection" file="System.Classes.pas" line="586">
    <ancestor name="TCollection" namespace="System.Classes">
      <methodref name="GetCapacity" visibility="private"/>
      <methodref name="GetCount" visibility="private" procflags="inline"/>
      <methodref name="GetPropName" visibility="private"/>
      <methodref name="InsertItem" visibility="private"/>
      <methodref name="RemoveItem" visibility="private"/>
      <methodref name="SetCapacity" visibility="private"/>
      <methodref name="Added" visibility="protected" procflags="virtual" symflags="deprecated">
      </methodref>
      <methodref name="Deleting" visibility="protected" procflags="virtual" symflags="deprecated">
      </methodref>
      <propertyref name="NextID" visibility="protected"/>
      <methodref name="Notify" visibility="protected" procflags="virtual"/>
      <methodref name="GetAttrCount" visibility="protected" procflags="dynamic"/>
      <methodref name="GetAttr" visibility="protected" procflags="dynamic"/>
      <methodref name="GetItemAttr" visibility="protected" procflags="dynamic"/>
      <methodref name="Changed" visibility="protected"/>
      <methodref name="GetItem" visibility="protected"/>
      <methodref name="SetItem" visibility="protected"/>
      <methodref name="SetItemName" visibility="protected" procflags="virtual"/>
      <methodref name="Update" visibility="protected" procflags="virtual"/>
      <propertyref name="PropName" visibility="protected"/>
      <propertyref name="UpdateCount" visibility="protected"/>
      <methodref name="Create" visibility="public" procflags="constructor"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="Owner" visibility="public"/>
      <methodref name="Add" visibility="public"/>
      <methodref name="Assign" visibility="public" procflags="override"/>
      <methodref name="BeginUpdate" visibility="public" procflags="virtual"/>
      <methodref name="Clear" visibility="public"/>
      <methodref name="ClearAndResetID" visibility="public"/>
      <methodref name="Delete" visibility="public"/>
      <methodref name="EndUpdate" visibility="public" procflags="virtual"/>
      <methodref name="Sort" visibility="public">
      </methodref>
      <methodref name="FindItemID" visibility="public"/>
      <methodref name="GetEnumerator" visibility="public" procflags="inline"/>
      <methodref name="GetNamePath" visibility="public" procflags="override"/>
      <methodref name="Insert" visibility="public"/>
      <propertyref name="Capacity" visibility="public"/>
      <propertyref name="Count" visibility="public"/>
      <propertyref name="ItemClass" visibility="public"/>
      <propertyref name="Items" visibility="public"/>
      <ancestor name="TPersistent" namespace="System.Classes">
        <methodref name="AssignError" visibility="private"/>
        <methodref name="AssignTo" visibility="protected" procflags="virtual"/>
        <methodref name="DefineProperties" visibility="protected" procflags="virtual"/>
        <methodref name="GetOwner" visibility="protected" procflags="dynamic"/>
        <methodref name="Destroy" visibility="public" procflags="destructor override"/>
        <methodref name="Assign" visibility="public" procflags="virtual"/>
        <methodref name="GetNamePath" visibility="public" procflags="dynamic"/>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FOwner" type="TPersistent" visibility="private" size="4" offset="24" file="System.Classes.pas" line="588">
        <attributes>
          <attribute name="TObject"/>
        </attributes>
      </field>
      <function name="GetOwner" visibility="protected" procflags="override" file="System.Classes.pas" line="590">
        <parameters>
          <retval type="TPersistent"/>
        </parameters>
      </function>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="592">
        <parameters>
          <parameter name="AOwner" type="TPersistent"/>
          <parameter name="ItemClass" type="TCollectionItemClass"/>
        </parameters>
      </constructor>
    </members>
  </class>
  <type name="TGetModuleProc" file="System.Classes.pas" line="601" procflags="closure">
  </type>
  <interface name="IStringsAdapter" GUID="{739C2F34-52EC-11D0-9EA6-0020AF3D82DA}" ancestor="IInterface" file="System.Classes.pas" line="607">
    <procedure name="ReferenceStrings" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="609">
      <parameters>
        <parameter name="S" type="TStrings"/>
      </parameters>
    </procedure>
    <procedure name="ReleaseStrings" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="610">
    </procedure>
  </interface>
  <set name="TStringsDefined" file="System.Classes.pas" line="615">
    <element name="sdDelimiter"/>
    <element name="sdQuoteChar"/>
    <element name="sdNameValueSeparator"/>
    <element name="sdLineBreak"/>
    <element name="sdStrictDelimiter"/>
  </set>
  <enum name="TStringsOption" file="System.Classes.pas" line="618">
    <element value="0" name="soStrictDelimiter" file="System.Classes.pas" line="618"/>
    <element value="1" name="soWriteBOM" file="System.Classes.pas" line="618"/>
    <element value="2" name="soTrailingLineBreak" file="System.Classes.pas" line="618"/>
    <element value="3" name="soUseLocale" file="System.Classes.pas" line="619"/>
  </enum>
  <set name="TStringsOptions" type="TStringsOption" file="System.Classes.pas" line="620">
    <element name="soStrictDelimiter"/>
    <element name="soWriteBOM"/>
    <element name="soTrailingLineBreak"/>
    <element name="soUseLocale"/>
  </set>
  <class name="TStringsEnumerator" file="System.Classes.pas" line="622">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FIndex" type="Integer" visibility="private" size="4" offset="4" file="System.Classes.pas" line="624"/>
      <field name="FStrings" type="TStrings" visibility="private" size="4" offset="8" file="System.Classes.pas" line="625"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="627">
        <parameters>
          <parameter name="AStrings" type="TStrings"/>
        </parameters>
      </constructor>
      <function name="GetCurrent" visibility="public" file="System.Classes.pas" line="628">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="MoveNext" visibility="public" procflags="inline" file="System.Classes.pas" line="629">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <property name="Current" visibility="public" read="GetCurrent" type="string" default="0" file="System.Classes.pas" line="630"/>
    </members>
  </class>
  <class name="TStrings" file="System.Classes.pas" line="633">
    <ancestor name="TPersistent" namespace="System.Classes">
      <methodref name="AssignError" visibility="private"/>
      <methodref name="AssignTo" visibility="protected" procflags="virtual"/>
      <methodref name="DefineProperties" visibility="protected" procflags="virtual"/>
      <methodref name="GetOwner" visibility="protected" procflags="dynamic"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="Assign" visibility="public" procflags="virtual"/>
      <methodref name="GetNamePath" visibility="public" procflags="dynamic"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FEncoding" type="TEncoding" visibility="private" size="4" offset="4" file="System.Classes.pas" line="635"/>
      <field name="FDefaultEncoding" type="TEncoding" visibility="private" size="4" offset="8" file="System.Classes.pas" line="636"/>
      <field name="FLineBreak" type="string" visibility="private" size="4" offset="12" file="System.Classes.pas" line="637"/>
      <field name="FAdapter" type="IStringsAdapter" visibility="private" size="4" offset="16" file="System.Classes.pas" line="638"/>
      <field name="FUpdateCount" type="Integer" visibility="private" size="4" offset="20" file="System.Classes.pas" line="639"/>
      <field name="FDelimiter" type="Char" visibility="private" size="2" offset="24" file="System.Classes.pas" line="640"/>
      <field name="FQuoteChar" type="Char" visibility="private" size="2" offset="26" file="System.Classes.pas" line="641"/>
      <field name="FNameValueSeparator" type="Char" visibility="private" size="2" offset="28" file="System.Classes.pas" line="642"/>
      <field name="FOptions" type="TStringsOptions" visibility="private" size="1" offset="30" file="System.Classes.pas" line="643"/>
      <function name="GetCommaText" visibility="private" file="System.Classes.pas" line="644">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="GetDelimitedText" visibility="private" file="System.Classes.pas" line="645">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="GetName" visibility="private" file="System.Classes.pas" line="646">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="GetValue" visibility="private" file="System.Classes.pas" line="647">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <retval type="string"/>
        </parameters>
      </function>
      <procedure name="ReadData" visibility="private" file="System.Classes.pas" line="648">
        <parameters>
          <parameter name="Reader" type="TReader"/>
        </parameters>
      </procedure>
      <procedure name="SetCommaText" visibility="private" file="System.Classes.pas" line="649">
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetDelimitedText" visibility="private" file="System.Classes.pas" line="650">
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetStringsAdapter" visibility="private" file="System.Classes.pas" line="651">
        <parameters>
          <parameter name="Value" type="IStringsAdapter" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetValue" visibility="private" file="System.Classes.pas" line="652">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteData" visibility="private" file="System.Classes.pas" line="653">
        <parameters>
          <parameter name="Writer" type="TWriter"/>
        </parameters>
      </procedure>
      <function name="GetStrictDelimiter" visibility="private" procflags="inline" file="System.Classes.pas" line="654">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="SetStrictDelimiter" visibility="private" file="System.Classes.pas" line="655">
        <parameters>
          <parameter name="Value" type="Boolean" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="GetValueFromIndex" visibility="private" file="System.Classes.pas" line="656">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="string"/>
        </parameters>
      </function>
      <procedure name="SetValueFromIndex" visibility="private" file="System.Classes.pas" line="657">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetDefaultEncoding" visibility="private" file="System.Classes.pas" line="658">
        <parameters>
          <parameter name="Value" type="TEncoding" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="GetTrailingLineBreak" visibility="private" procflags="inline" file="System.Classes.pas" line="659">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="SetTrailingLineBreak" visibility="private" file="System.Classes.pas" line="660">
        <parameters>
          <parameter name="Value" type="Boolean" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="GetUseLocale" visibility="private" procflags="inline" file="System.Classes.pas" line="661">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="SetUseLocale" visibility="private" file="System.Classes.pas" line="662">
        <parameters>
          <parameter name="Value" type="Boolean" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="GetWriteBOM" visibility="private" procflags="inline" file="System.Classes.pas" line="663">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="SetWriteBOM" visibility="private" file="System.Classes.pas" line="664">
        <parameters>
          <parameter name="Value" type="Boolean" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="GetUpdating" visibility="private" procflags="inline" file="System.Classes.pas" line="665">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="GetKeyName" visibility="private" file="System.Classes.pas" line="666">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="string"/>
        </parameters>
      </function>
      <procedure name="DefineProperties" visibility="protected" procflags="override" file="System.Classes.pas" line="668">
        <parameters>
          <parameter name="Filer" type="TFiler"/>
        </parameters>
      <devnotes><summary>
Reads and writes the Strings property as if it were published.
TStrings overrides DefineProperties so that the strings in the list can be loaded and saved with a form file as if the Strings property were published.
</summary></devnotes></procedure>
      <procedure name="Error" visibility="protected" procflags="overload" file="System.Classes.pas" line="669">
        <parameters>
          <parameter name="Msg" type="string" paramflags="const"/>
          <parameter name="Data" type="Integer"/>
        </parameters>
      <devnotes><summary>
Raises an EStringListError exception.
TStrings calls Error internally to raise an EStringListError exception when it encounters a problem.
Msg specifies the string with a single format specifier for an integer, that appears in the exception message box. It can be either a string, or a pointer to a record structure that indicates the module and resource identifier for a string.
Data is an integer value that is inserted into Msg.
</summary></devnotes></procedure>
      <procedure name="Error" visibility="protected" procflags="overload" file="System.Classes.pas" line="670">
        <parameters>
          <parameter name="Msg" type="PResStringRec"/>
          <parameter name="Data" type="Integer"/>
        </parameters>
      <devnotes><summary>
Raises an EStringListError exception.
TStrings calls Error internally to raise an EStringListError exception when it encounters a problem.
Msg specifies the string with a single format specifier for an integer, that appears in the exception message box. It can be either a string, or a pointer to a record structure that indicates the module and resource identifier for a string.
Data is an integer value that is inserted into Msg.
</summary></devnotes></procedure>
      <function name="ExtractName" visibility="protected" procflags="overload inline" file="System.Classes.pas" line="671">
        <parameters>
          <parameter name="S" type="string" paramflags="const"/>
          <retval type="string"/>
        </parameters>
      <devnotes><summary>
Returns the name portion of a string that is a name value pair.
TStrings calls ExtractName internally to parse strings that are name-value pairs and return the name portion.
S is the string to parse. If the string S:

Is a name-value pair, ExtractName returns the name portion.
Is not a name-value pair, ExtractName returns:
The entire string S when AllNames is True.
An empty string when AllNames is False.
Note: If AllNames is not specified is False by default.</summary></devnotes></function>
      <function name="ExtractName" visibility="protected" procflags="overload" file="System.Classes.pas" line="672">
        <parameters>
          <parameter name="S" type="string" paramflags="const"/>
          <parameter name="AllNames" type="Boolean"/>
          <retval type="string"/>
        </parameters>
      <devnotes><summary>
Returns the name portion of a string that is a name value pair.
TStrings calls ExtractName internally to parse strings that are name-value pairs and return the name portion.
S is the string to parse. If the string S:

Is a name-value pair, ExtractName returns the name portion.
Is not a name-value pair, ExtractName returns:
The entire string S when AllNames is True.
An empty string when AllNames is False.
Note: If AllNames is not specified is False by default.</summary></devnotes></function>
      <function name="Get" visibility="protected" procflags="abstract virtual" file="System.Classes.pas" line="673">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="string"/>
        </parameters>
      <devnotes><summary>
Returns a string given its index.
Get is the protected read implementation of the Strings property.
In TStrings Get is abstract or, in C++ terminology, pure virtual, meaning it has no implementation. Descendant classes must override this method to return the string with the specified index.
</summary></devnotes></function>
      <function name="GetCapacity" visibility="protected" procflags="virtual" file="System.Classes.pas" line="674">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Returns the currently allocated size of the list of strings.
GetCapacity is the protected read implementation of the Capacity property. In TStrings, GetCapacity returns the value of the Count property. Descendants of TStrings can override this property to let a string list allocate memory for entries that have not been added to the list.
</summary></devnotes></function>
      <function name="GetCount" visibility="protected" procflags="abstract virtual" file="System.Classes.pas" line="675">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Returns the number of strings in the list
GetCount is the protected read implementation of the Count property.
In TStrings GetCount is abstract or, in C++ terminology, pure virtual, meaning it has no implementation. Descendant classes must override this method to return the number of strings that have been added to the list.
</summary></devnotes></function>
      <function name="GetObject" visibility="protected" procflags="virtual" file="System.Classes.pas" line="676">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="TObject"/>
        </parameters>
      <devnotes><summary>
Returns the object associated with the string at a specified index.
GetObject is the protected read implementation of the Objects property.
Index is the index of the string with which the object is associated.
In TStrings, GetObject always returns nil (Delphi) or NULL (C++). This provides a default implementation for descendants that do not support associating objects with the strings in the list. Descendants that support this feature override GetObject to return the specified object.
</summary></devnotes></function>
      <function name="GetTextStr" visibility="protected" procflags="virtual" file="System.Classes.pas" line="677">
        <parameters>
          <retval type="string"/>
        </parameters>
      <devnotes><summary>
Returns the value of the Text property.
GetTextStr is the protected read implementation of the Text property. It returns a string that lists all the strings in the list, with individual strings separated by the string terminator characters LineBreak. By default, LineBreak is a carriage return and a line feed (#13#10) characters on Windows operating systems and a carriage return (#13) character on the macOS operating system.
</summary></devnotes></function>
      <procedure name="Put" visibility="protected" procflags="virtual" file="System.Classes.pas" line="678">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="S" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Changes the value of the string with a specified index.
Put is the protected write implementation of the Strings property.
Put changes the value of the string with the index specified by Index to S. Put does not change the object at the specified position. That is, any object associated with the previous string becomes associated with the new string.
</summary></devnotes></procedure>
      <procedure name="PutObject" visibility="protected" procflags="virtual" file="System.Classes.pas" line="679">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="AObject" type="TObject"/>
        </parameters>
      <devnotes><summary>
Changes the object associated with the string at a specified index.
PutObject is the protected write implementation of the Objects property.
As implemented in TStrings, PutObject does nothing. This provides a default implementation for descendants that do not support associating objects with the strings in the list. Descendants that support this feature override PutObject to change the specified object.
</summary></devnotes></procedure>
      <procedure name="SetCapacity" visibility="protected" procflags="virtual" file="System.Classes.pas" line="680">
        <parameters>
          <parameter name="NewCapacity" type="Integer"/>
        </parameters>
      <devnotes><summary>
Changes the amount of memory allocated to hold strings in the list.
SetCapacity is the protected write implementation of the Capacity property.
NewCapacity is the number of strings the list can hold after the capacity has changed.
In TStrings, the SetCapacity method does nothing. Descendent classes must override this method to change the number of strings that the list can hold. 

Note: For descendent classes that implement SetCapacity, assigning a value smaller than Count removes strings from the end of the list. Assigning a value greater than Count allocates space for more strings to be added.</summary></devnotes></procedure>
      <procedure name="SetEncoding" visibility="protected" procflags="virtual" file="System.Classes.pas" line="681">
        <parameters>
          <parameter name="Value" type="TEncoding" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Protected setter of the Encoding property.
If Value is one of standard encoding values, SetEncoding sets the Encoding property to Value. Otherwise, SetEncoding sets the Encoding property to default.
Internally, Assign and LoadFromStream call SetEncoding.
</summary></devnotes></procedure>
      <procedure name="SetTextStr" visibility="protected" procflags="virtual" file="System.Classes.pas" line="682">
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Sets the Text property.
GetTextStr is the protected write implementation of the Text property. It replaces the list with the strings specified by the Value parameter. SetTextStr adds strings one at a time to the list, using the carriage returns or linefeed characters in Value as delimiters indicating when to add a new string.
</summary></devnotes></procedure>
      <procedure name="SetUpdateState" visibility="protected" procflags="virtual" file="System.Classes.pas" line="683">
        <parameters>
          <parameter name="Updating" type="Boolean"/>
        </parameters>
      <devnotes><summary>
Performs internal adjustments before or after a series of updates.
SetUpdateState is called at the beginning or end of a series of updates. When the BeginUpdate method is first called and the TStrings object is not already in the middle of an update, TStrings calls SetUpdateState internally, with Updating set to true. When the EndUpdate method is called and it cancels out the last unmatched call to BeginUpdate, TStrings calls SetUpdateState internally, with Updating set to false.
As implemented in TStrings, SetUpdateState does nothing. Descendant classes can override this method to optimize the response to updates.
</summary></devnotes></procedure>
      <function name="CompareStrings" visibility="protected" procflags="virtual" file="System.Classes.pas" line="684">
        <parameters>
          <parameter name="S1" type="string" paramflags="const"/>
          <parameter name="S2" type="string" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Compares two strings.
TStrings uses CompareStrings internally to compare the values of strings that appear in the list. For example, the IndexOf and IndexOfName methods use CompareStrings to compare a specified string with the strings in the list.
S1 and S2 are the strings to compare.
CompareStrings returns a value less than 0 if S1 &lt; S2, 0 if S1 == S2, and a value greater than 0 if S1 &gt; S2.
As implemented in TStrings, CompareStrings uses the global AnsiCompareText function, which compares strings case insensitively. Some descendant classes override this method to change the way strings are compared (for example, to introduce case sensitivity).
</summary></devnotes></function>
      <property name="UpdateCount" visibility="protected" read="FUpdateCount" type="Integer" file="System.Classes.pas" line="685"><devnotes><summary>
Indicates the number of calls to BeginUpdate that have not been matched by a call to EndUpdate.
TStrings uses UpdateCount to keep track of calls to the BeginUpdate and EndUpdate methods. Every time a call is made to BeginUpdate, TStrings increments the value of UpdateCount. Every call to EndUpdate causes TStrings to decrement UpdateCount.
When UpdateCount changes from 0 to 1, TStrings calls the SetUpdateState method with a parameter of true. When UpdateCount changes from 1 to 0, TStrings calls the SetUpdateState method with a parameter of false. This allows descendant classes to perform optimizations when handling multiple updates.
</summary></devnotes></property>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="687">
        <parameters>
        </parameters>
      <devnotes><summary>
Creates an instance of a TStrings object.
Do not call the Create method for TStrings directly. TStrings is an abstract class and its constructor should only be called as an inherited method from the constructor of a derived class.

</summary></devnotes></constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="688">
        <parameters>
        </parameters>
      <devnotes><summary>
Destroys the TStrings instance and frees its memory.
Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy.
</summary></devnotes></destructor>
      <function name="Add" visibility="public" procflags="virtual" file="System.Classes.pas" line="689">
        <parameters>
          <parameter name="S" type="string" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Adds a string at the end of the list.
Call Add to add a string to the end of the list. Add returns the index of the new string.
</summary></devnotes></function>
      <function name="AddPair" visibility="public" procflags="overload" file="System.Classes.pas" line="695">
        <devnotes><summary>
Adds name-value pairs to the list of strings using fluent-style coding.
AddPair adds name-value pairs using the current NameValueSeparator. You can also use AddPair to add name-value pairs and the corresponding AObject.
TStrings returns a reference to the string list, allowing to populate the list using the fluent-style coding.
</summary></devnotes>
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <parameter name="Value" type="string" paramflags="const"/>
          <retval type="TStrings"/>
        </parameters>
      </function>
      <function name="AddPair" visibility="public" procflags="overload" file="System.Classes.pas" line="701">
        <devnotes><summary>
Adds name-value pairs to the list of strings using fluent-style coding.
AddPair adds name-value pairs using the current NameValueSeparator. You can also use AddPair to add name-value pairs and the corresponding AObject.
TStrings returns a reference to the string list, allowing to populate the list using the fluent-style coding.
</summary></devnotes>
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <parameter name="Value" type="string" paramflags="const"/>
          <parameter name="AObject" type="TObject"/>
          <retval type="TStrings"/>
        </parameters>
      </function>
      <function name="AddObject" visibility="public" procflags="virtual" file="System.Classes.pas" line="702">
        <parameters>
          <parameter name="S" type="string" paramflags="const"/>
          <parameter name="AObject" type="TObject"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Adds a string to the list, and associates an object with the string.
Call AddObject to add a string and its associated object to the list. AddObject returns the index of the new string and object.

Note:  The TStrings object does not own the objects you add this way. Objects added to the TStrings object still exist even if the TStrings instance is destroyed. They must be explicitly destroyed by the application.</summary></devnotes></function>
      <procedure name="Append" visibility="public" file="System.Classes.pas" line="703">
        <parameters>
          <parameter name="S" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Adds a string to the list.
Append is the same as the Add method, except that it does not return a value. Use Append when there is no need to know the index of the string after it has been added, or with descendants of TStrings for which the index returned is not meaningful. 
For example, the TStrings descendant used by memo objects uses an index to determine where to insert a string, but the inserted string does not necessarily end up as a single string in the list. Part of the inserted text may become part of the previous string, and part may be broken off into a subsequent string. The index returned by Add is not meaningful in this case. 
Use Append rather than Add as a parameter for a function requiring a TGetStrProc.
</summary></devnotes></procedure>
      <procedure name="AddStrings" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="704">
        <parameters>
          <parameter name="Strings" type="TStrings"/>
        </parameters>
      <devnotes><summary>
Adds the specified strings (and objects) to the current TStrings object.
AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised.
</summary></devnotes></procedure>
      <procedure name="AddStrings" visibility="public" procflags="overload" file="System.Classes.pas" line="712">
        <attributes>
          <attribute name="HPPGENAttribute"/>
        </attributes>
        <parameters>
          <parameter name="Strings" paramflags="const">
            <array name="Strings" file="System.Classes.pas" line="6726">
              <element type="string"/>
            </array>
          </parameter>
        </parameters>
      <devnotes><summary>
Adds the specified strings (and objects) to the current TStrings object.
AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised.
</summary></devnotes></procedure>
      <procedure name="AddStrings" visibility="public" procflags="overload" file="System.Classes.pas" line="721">
        <attributes>
          <attribute name="HPPGENAttribute"/>
        </attributes>
        <parameters>
          <parameter name="Strings" paramflags="const">
            <array name="Strings" file="System.Classes.pas" line="6739">
              <element type="string"/>
            </array>
          </parameter>
          <parameter name="Objects" paramflags="const">
            <array name="Objects" file="System.Classes.pas" line="6739">
              <element type="TObject"/>
            </array>
          </parameter>
        </parameters>
      <devnotes><summary>
Adds the specified strings (and objects) to the current TStrings object.
AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised.
</summary></devnotes></procedure>
      <procedure name="Assign" visibility="public" procflags="override" file="System.Classes.pas" line="722">
        <parameters>
          <parameter name="Source" type="TPersistent"/>
        </parameters>
      <devnotes><summary>
Sets the strings in the Strings array, possibly associated Objects, and some other properties of the current TStrings object, from the Source object.
Use Assign to set the properties of the TStrings object from the Source object. If Source is of the TStrings type, Assign copies the following properties:

Strings
Objects
DefaultEncoding
Encoding
LineBreak
Delimiter
QuoteChar
NameValueSeparator
Options
If Source is not of the TStrings type, the inherited Assign will set the value of the string array from any object that supports TStrings in its AssignTo method.
</summary></devnotes></procedure>
      <procedure name="SetStrings" visibility="public" file="System.Classes.pas" line="729">
        <devnotes><summary>
Sets the strings from another TStrings object to the list of strings.
Use SetStrings to assign the value of the TStrings object from another TStrings object (Source).

Note: SetStrings is similar to Assign, but Assign also copies multiple additional properties.</summary></devnotes>
        <parameters>
          <parameter name="Source" type="TStrings"/>
        </parameters>
      </procedure>
      <procedure name="BeginUpdate" visibility="public" file="System.Classes.pas" line="730">
      <devnotes><summary>
Enables the TStrings object to track when the list of strings is changing.
BeginUpdate is called automatically by any property or method that changes the list of strings. Once the changes are complete, the property or method calls EndUpdate. Call BeginUpdate before directly modifying the strings in the list, and EndUpdate after. When implementing properties or methods that change the list in descendants of TStrings, call BeginUpdate before the changes are made, and EndUpdate when the changes are complete.
TStrings simply keeps track of when the list of strings is being changed. Some descendants of TStrings use this information to perform certain actions, such as telling a control to repaint, when updates are complete.
</summary></devnotes></procedure>
      <procedure name="Clear" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="731">
      <devnotes><summary>
Introduces an abstract (Delphi) or pure virtual (C++) method to empty the list and any associated objects.
Descendants of TStrings implement a Clear method to delete all the strings in the list, and to remove any references to associated objects.
</summary></devnotes></procedure>
      <procedure name="Delete" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="732">
        <parameters>
          <parameter name="Index" type="Integer"/>
        </parameters>
      <devnotes><summary>
Introduces an abstract (Delphi) or pure virtual (C++) method to delete a specified string from the list.
Descendants of TStrings implement a Delete method to remove a specified string from the list. If an object is associated with the string, the reference to the object is removed as well. Index gives the position of the string, where 0 is the first string, 1 is the second string, and so on.
</summary></devnotes></procedure>
      <procedure name="EndUpdate" visibility="public" file="System.Classes.pas" line="733">
      <devnotes><summary>
Enables the TStrings object to keep track of when the list of strings has finished changing.
EndUpdate is called automatically by any property or method that changes the list of strings. Call BeginUpdate before directly modifying the strings in the list, and EndUpdate after. When implementing properties or methods that change the list in descendants of TStrings, call BeginUpdate before the changes are made, and EndUpdate when the changes are complete.
TStrings simply keeps track of when the list of strings is being changed. Some descendants of TStrings use this information to perform certain actions, such as telling a control to repaint, when updates are complete.
</summary></devnotes></procedure>
      <function name="Equals" visibility="public" file="System.Classes.pas" line="734">
        <parameters>
          <parameter name="Strings" type="TStrings"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Compares the list of strings to the list from another TStrings object and returns true if the two lists match.
Call Equals to compare the lists in two TStrings objects. Equals compares only the strings, not any references to associated objects. Equals returns true if the lists for both TStrings objects have the same number of strings and the strings in each list match. Equals returns false if the lists are different in length, if they contain different strings, or if the order of the strings in the two lists differ.

Note:  The Equals method uses an overridden Get method to perform the compare, thus it does not provide a context-insensitive option.</summary></devnotes></function>
      <procedure name="Exchange" visibility="public" procflags="virtual" file="System.Classes.pas" line="735">
        <parameters>
          <parameter name="Index1" type="Integer"/>
          <parameter name="Index2" type="Integer"/>
        </parameters>
      <devnotes><summary>
Swaps the position of two strings in the list.
Call Exchange to rearrange the strings in the list. The strings are specified by their index values in the Index1 and Index2 parameters. Indexes are zero-based, so the first string in the list has an index value of 0, the second has an index value of 1, and so on.
If either string has an associated object, Exchange changes the position of the object as well.
</summary></devnotes></procedure>
      <function name="GetEnumerator" visibility="public" procflags="inline" file="System.Classes.pas" line="736">
        <parameters>
          <retval type="TStringsEnumerator"/>
        </parameters>
      <devnotes><summary>
Returns a TStrings enumerator.
GetEnumerator returns a TStringsEnumerator reference, which enumerates the strings in a TStrings object. 
To process all these strings, call the TStringsEnumerator GetCurrent method within a While MoveNext do loop. 
</summary></devnotes></function>
      <function name="GetText" visibility="public" procflags="virtual" file="System.Classes.pas" line="737">
        <parameters>
          <retval type="PWideChar"/>
        </parameters>
      <devnotes><summary>
Allocates a text buffer and fills it with the value of the Text property.
Call GetText to obtain a dynamically allocated character buffer containing all of the strings in the list. Individual strings are separated by a carriage return (#13) on the OS X operating system, or by a carriage return and a line feed (#13#10) on Windows operating systems. The caller is responsible for freeing the returned value using the StrDispose procedure.
</summary></devnotes></function>
      <function name="IndexOf" visibility="public" procflags="virtual" file="System.Classes.pas" line="738">
        <parameters>
          <parameter name="S" type="string" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Returns the position of a string in the list.
Call IndexOf to obtain the position of the first occurrence of the S string. IndexOf is not case-sensitive; this means that the given string may differ in case from the string in the list. For example:

String1 := MyStrings.Items.IndexOf('My First String');

is equivalent to

String1 := MyStrings.Items.IndexOf('My FIRST String');

IndexOf returns the 0-based index of the string. Thus, if S matches the first string in the list, IndexOf returns 0, if S is the second string, IndexOf returns 1, and so on. If the string is not in the string list, IndexOf returns -1. 

Note: If the string appears in the list more than once, IndexOf returns the position of the first occurrence.</summary></devnotes></function>
      <function name="IndexOfName" visibility="public" procflags="virtual" file="System.Classes.pas" line="739">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Returns the position of the first name-value pair with the specified name.
Call IndexOfName to locate the first occurrence of a name-value pair where the name part is equal to the Name parameter or differs only in case. IndexOfName returns the 0-based index of the string. If no string in the list has the indicated name, IndexOfName returns -1.

Note:  If there is more than one name-value pair with a name portion matching the Name parameter, IndexOfName returns the position of the first such string.</summary></devnotes></function>
      <function name="IndexOfObject" visibility="public" procflags="virtual" file="System.Classes.pas" line="740">
        <parameters>
          <parameter name="AObject" type="TObject"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Returns the index of the first string in the list associated with a given object.
Call IndexOfObject to locate the first string in the list associated with the object AObject. Specify the object you want to locate as the value of the AObject parameter. IndexOfObject returns the 0-based index of the string and object. If the object is not associated with any of the strings, IndexOfObject returns -1.
</summary></devnotes></function>
      <procedure name="Insert" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="741">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="S" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Introduces abstract (Delphi) or pure virtual (C++) method to insert a string at a specified position.
Descendants of TStrings implement an Insert method to add the string S to the list at the position specified by Index. If Index is 0, the string is inserted at the beginning of the list. If Index is 1, the string is put in the second position of the list, and so on.
All methods that add strings to the list use the Insert method to add the string.
If the string has an associated object, use the InsertObject method instead.
</summary></devnotes></procedure>
      <procedure name="InsertObject" visibility="public" procflags="virtual" file="System.Classes.pas" line="742">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="S" type="string" paramflags="const"/>
          <parameter name="AObject" type="TObject"/>
        </parameters>
      <devnotes><summary>
Inserts a string into the list at the specified position, and associates it with an object.
Call InsertObject to insert the string S into the list at the position identified by Index, and associate it with the object AObject. If Index is 0, the string is inserted at the beginning of the list. If Index is 1, the string is put in the second position of the list, and so on.
</summary></devnotes></procedure>
      <procedure name="LoadFromFile" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="744">
        <parameters>
          <parameter name="FileName" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Fills the string list with the lines of text in a specified file.
LoadFromFile fills the string list of the TStrings object from the file specified by FileName. LoadFromFile first clears any strings already in the list. Lines in the file are separated by a carriage return and a line feed (#13#10) on Windows operating systems and a carriage return (#13) on the OS X operating system. Each line in the file is then appended in the list as a string.
If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromFile then saves the value of the encoding in the Encoding property, to be used if the file is saved.

Note: LoadFromFile uses the Add method to add the strings that are read from the file.
If the specified file is not found, an EFOpenError is raised.
</summary></devnotes></procedure>
      <procedure name="LoadFromFile" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="745">
        <parameters>
          <parameter name="FileName" type="string" paramflags="const"/>
          <parameter name="Encoding" type="TEncoding"/>
        </parameters>
      <devnotes><summary>
Fills the string list with the lines of text in a specified file.
LoadFromFile fills the string list of the TStrings object from the file specified by FileName. LoadFromFile first clears any strings already in the list. Lines in the file are separated by a carriage return and a line feed (#13#10) on Windows operating systems and a carriage return (#13) on the OS X operating system. Each line in the file is then appended in the list as a string.
If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromFile then saves the value of the encoding in the Encoding property, to be used if the file is saved.

Note: LoadFromFile uses the Add method to add the strings that are read from the file.
If the specified file is not found, an EFOpenError is raised.
</summary></devnotes></procedure>
      <procedure name="LoadFromStream" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="746">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Fills the list with lines of text read from a stream.
LoadFromStream fills the string list of the TStrings object from the stream specified by Stream. The text read from the stream is parsed into strings separated by a carriage return and a line feed (#13#10) characters on Windows operating systems and a carriage return (#13) character on the macOS operating system. Thus, LoadFromStream reads the value of the Text property.
If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromStream then saves the value of the encoding in the Encoding property, to be used if the stream is saved.
If the stream is a file stream, LoadFromStream does the same thing as LoadFromFile, except that LoadFromFile creates and destroys the file stream.
</summary></devnotes></procedure>
      <procedure name="LoadFromStream" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="747">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="Encoding" type="TEncoding"/>
        </parameters>
      <devnotes><summary>
Fills the list with lines of text read from a stream.
LoadFromStream fills the string list of the TStrings object from the stream specified by Stream. The text read from the stream is parsed into strings separated by a carriage return and a line feed (#13#10) characters on Windows operating systems and a carriage return (#13) character on the macOS operating system. Thus, LoadFromStream reads the value of the Text property.
If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromStream then saves the value of the encoding in the Encoding property, to be used if the stream is saved.
If the stream is a file stream, LoadFromStream does the same thing as LoadFromFile, except that LoadFromFile creates and destroys the file stream.
</summary></devnotes></procedure>
      <procedure name="Move" visibility="public" procflags="virtual" file="System.Classes.pas" line="748">
        <parameters>
          <parameter name="CurIndex" type="Integer"/>
          <parameter name="NewIndex" type="Integer"/>
        </parameters>
      <devnotes><summary>
Changes the position of a string in the list.
Use Move to move the string at position CurIndex so that it occupies the position NewIndex. The positions are specified as 0-based indexes. For example, the following lines of code move the string in the first position to the last position:
For Delphi:

MyStringsObject.Move(0, MyStringsObject.Count - 1);

For C++: 

MyStringsObject-&gt;Move(0, MyStringsObject-&gt;Count - 1);

If the string has an associated object, the object remains associated with the string in its new position.
</summary></devnotes></procedure>
      <procedure name="SaveToFile" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="749">
        <parameters>
          <parameter name="FileName" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Saves the strings in the current object to the specified FileName file.
SaveToFile does the same thing as SaveToStream when it writes to a file stream, except that SaveToFile creates and destroys the file stream.
Each string from the list is written to a separate line in the file.
If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property. 
</summary></devnotes></procedure>
      <procedure name="SaveToFile" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="750">
        <parameters>
          <parameter name="FileName" type="string" paramflags="const"/>
          <parameter name="Encoding" type="TEncoding"/>
        </parameters>
      <devnotes><summary>
Saves the strings in the current object to the specified FileName file.
SaveToFile does the same thing as SaveToStream when it writes to a file stream, except that SaveToFile creates and destroys the file stream.
Each string from the list is written to a separate line in the file.
If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property. 
</summary></devnotes></procedure>
      <procedure name="SaveToStream" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="751">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Writes the  value of the Text property to the Stream stream.
SaveToStream gets all strings from the current TStrings object and combines them into the single string containing these strings delimited by LineBreak sequence. Then SaveToStream encodes this string using the specified Encoding. Then SaveToStream writes the encoded string into the specified Stream stream.
If WriteBOM is True then SaveToStream first gets the preamble of the specified Encoding or of the DefaultEncoding (if Encoding = nil)  and writes the preamble bytes into the stream before the main string.
If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property. 

Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on macOS, it is just a line feed (#10).
Note:  If TrailingLineBreak is True, then SaveToStream writes a finishing line break LineBreak after the last string.
If the stream is a file stream, SaveToStream does the same thing as SaveToFile, except that SaveToFile creates and destroys the file stream.
</summary></devnotes></procedure>
      <procedure name="SaveToStream" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="752">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="Encoding" type="TEncoding"/>
        </parameters>
      <devnotes><summary>
Writes the  value of the Text property to the Stream stream.
SaveToStream gets all strings from the current TStrings object and combines them into the single string containing these strings delimited by LineBreak sequence. Then SaveToStream encodes this string using the specified Encoding. Then SaveToStream writes the encoded string into the specified Stream stream.
If WriteBOM is True then SaveToStream first gets the preamble of the specified Encoding or of the DefaultEncoding (if Encoding = nil)  and writes the preamble bytes into the stream before the main string.
If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property. 

Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on macOS, it is just a line feed (#10).
Note:  If TrailingLineBreak is True, then SaveToStream writes a finishing line break LineBreak after the last string.
If the stream is a file stream, SaveToStream does the same thing as SaveToFile, except that SaveToFile creates and destroys the file stream.
</summary></devnotes></procedure>
      <procedure name="SetText" visibility="public" procflags="virtual" file="System.Classes.pas" line="753">
        <parameters>
          <parameter name="Text" type="PWideChar"/>
        </parameters>
      <devnotes><summary>
Sets the Text property.
Call SetText to replace the list with the strings specified by the Text parameter. SetText adds strings one at a time to the list, using the carriage returns or linefeed characters in Text as delimiters indicating when to add a new string.
</summary></devnotes></procedure>
      <function name="ToStringArray" visibility="public" file="System.Classes.pas" line="754">
        <parameters>
          <retval type="TArray&lt;System.string&gt;"/>
        </parameters>
      <devnotes><summary>
Converts a TStrings descendant to a string array.
 
Use ToStringArray to obtain an array of strings for each string in the list.
</summary></devnotes></function>
      <function name="ToObjectArray" visibility="public" file="System.Classes.pas" line="755">
        <parameters>
          <retval type="TArray&lt;System.TObject&gt;"/>
        </parameters>
      <devnotes><summary>
Returns the TObject array associated with Strings.
 
Use ToObjectArray to obtain the array of TObject associated with Strings.

Note: TStrings is an abstract class and this method has no effect. Descendent classes can associate objects with strings.
Note:  The TStrings object does not own the objects in the Objects array. Objects added to the Objects array still exist even if the TStrings object is destroyed. They must be explicitly destroyed by the application.</summary></devnotes></function>
      <property name="Updating" visibility="public" read="GetUpdating" type="Boolean" file="System.Classes.pas" line="760">
        <devnotes><summary>
Indicates whether or not the list of strings is in the middle of an update.
</summary></devnotes>
      </property>
      <property name="Capacity" visibility="public" read="GetCapacity" write="SetCapacity" type="Integer" file="System.Classes.pas" line="761"><devnotes><summary>
Indicates the number of strings the TStrings object can hold.
Read Capacity to determine the currently allocated size of the string list. For the TStrings object, reading Capacity returns the Count property, and setting Capacity does nothing. Descendants of TStrings can override this property to allow a string list to allocate memory for entries that have not been added to the list.
</summary></devnotes></property>
      <property name="CommaText" visibility="public" read="GetCommaText" write="SetCommaText" type="string" default="0" file="System.Classes.pas" line="762"><devnotes><summary>
Lists the strings in the TStrings object in a single comma-delimited string.
Use CommaText to get or set all the strings in the TStrings object in a single comma-delimited string. The single comma-delimited string format is also known as the system data format (SDF).
When retrieving CommaText, any string in the list that include spaces, commas or double quotes will be contained in double quotes, and any double quotes in a string will be repeated. For example, if the list contains the following strings:

Stri,ng1
Stri&quot;ng2
String 3
String4

CommaText will return: 

&quot;Stri,ng1&quot;,&quot;Stri&quot;&quot;ng2&quot;,&quot;String 3&quot;,String4

When assigning CommaText, the value is parsed as SDF formatted text. For SDF format, strings are separated by commas or spaces, and optionally enclosed in double quotes. Double quote marks that are part of the string are repeated to distinguish them from the quotes that surround the string. Spaces and commas that are not contained within double quote marks are delimiters. Two commas next to each other will indicate an empty string, but spaces that appear next to another delimiter are ignored. For example, suppose CommaText is set to:

&quot;Stri,ng 1&quot;,&quot;Stri&quot;&quot;ng 2&quot;,String 3,String4

The list will then contain:

Stri,ng 1
Stri&quot;ng 2
String
3
String4

Note: CommaText is the same as the DelimitedText property with a delimiter of ',' and a quote character of '&quot;'.
Including a trailing comma in the source string causes a blank item to be included in the string list. For example, if CommaText is set to

&quot;String1,String2,String3, &quot;

the string list will contain

String1
String2
String3
&lt;Blank&gt;
</summary></devnotes></property>
      <property name="Count" visibility="public" read="GetCount" type="Integer" file="System.Classes.pas" line="763"><devnotes><summary>
Introduces an abstract property to represent the number of strings in the list.
Descendants of TStrings implement a Count property to indicate the number of strings in the list.
Use the Count property when iterating over all the strings in the list, or when trying to locate the position of a string relative to the last string in the list.
</summary></devnotes></property>
      <property name="DefaultEncoding" visibility="public" read="FDefaultEncoding" write="SetDefaultEncoding" type="TEncoding" file="System.Classes.pas" line="764"><devnotes><summary>
The default encoding for the current object.
DefaultEncoding is used when the nil encoding is specified in a call to LoadFromStream or SaveToStream. 
By default, DefaultEncoding is set to Default. The user can change DefaultEncoding if another default encoding is desired for LoadFromStream or SaveToStream. 
</summary></devnotes></property>
      <property name="Delimiter" visibility="public" read="FDelimiter" write="FDelimiter" type="Char" file="System.Classes.pas" line="765"><devnotes><summary>
Specifies the delimiter used by the DelimitedText property.
Use Delimiter to get or set the delimiter used by the DelimitedText property. DelimitedText represents all of the strings in the TStrings object as a single string, with individual strings separated by the character that is the value of Delimiter.
The default delimiter is represented by comma (,).
</summary></devnotes></property>
      <property name="DelimitedText" visibility="public" read="GetDelimitedText" write="SetDelimitedText" type="string" default="0" file="System.Classes.pas" line="766"><devnotes><summary>
Represents all the strings in the TStrings object as a single delimited string.
Use DelimitedText to get or set all the strings in the TStrings object in a single string, separated by the character specified by the Delimiter property. 
When retrieving DelimitedText, any string in the list that includes spaces or the delimiter and quotation marks characters specified in the Delimiter and QuoteChar properties will be surrounded (before and after) by the quotation mark character (QuoteChar). In addition, any QuoteChar character contained in an individual string will be repeated. 
When retrieving DelimitedText, the resulting value delimits individual strings in two ways: each string is surrounded (before and after) by the quotation marks character specified by the QuoteChar property. In addition, individual strings are separated by the character specified by the Delimiter property. 
When assigning DelimitedText, individual strings must be separated using Delimiter marks, and optionally enclosed in QuoteChar characters. 
When assigning DelimitedText, the value is parsed as SDF formatted text. For SDF format, strings are separated by Delimiter characters or spaces, and optionally enclosed in QuoteChar characters. QuoteChar marks that are part of the string are repeated to distinguish them from the QuoteChar characters that surround the string. Spaces and Delimiter characters that are not contained within QuoteChar marks are delimiters. Two Delimiter characters next to each other will indicate an empty string, but spaces that appear next to another Delimiter character are ignored. 
If StrictDelimiter is set to False, the space character is also interpreted as a delimiter, regardless of the value of Delimiter. This is not true when the space character occurs between quotation marks. 

Note: CommaText is the same as the DelimitedText property when Delimiter is ',' and QuoteChar is '&quot;'. Including a trailing Delimiter in the source string causes a blank item to be included in the string list. </summary></devnotes></property>
      <property name="Encoding" visibility="public" read="FEncoding" type="TEncoding" file="System.Classes.pas" line="767"><devnotes><summary>
Character encoding determined during reading from a stream or file.
Encoding is a read-only property that contains the value of the character encoding detected when the LoadFromStream or LoadFromFile methods are called. If a file or stream does not contain a BOM (the encoding value cannot be detected) then Encoding is set to the value specified in the DefaultEncoding property.
Encoding is used in the SaveToStream and SaveToFile methods.
</summary></devnotes></property>
      <property name="LineBreak" visibility="public" read="FLineBreak" write="FLineBreak" type="string" default="0" file="System.Classes.pas" line="768"><devnotes><summary>
Defines line-break characters.
The LineBreak property is used internally in TStrings to set the string terminator characters. Set or read the LineBreak property to determine the string terminator characters in multistring output operations. 
For example, the GetText method returns a long string containing all TStrings strings, each of which is terminated by the LineBreak value.

Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on Android, Linux, macOS and iOS it is just a line feed (#10).</summary></devnotes></property>
      <property name="Names[Index]" visibility="public" read="GetName" type="string" file="System.Classes.pas" line="769"/>
      <property name="KeyNames[Index]" visibility="public" read="GetKeyName" type="string" file="System.Classes.pas" line="776">
        <devnotes>
           <summary>
              When the list of strings includes strings that are name-value pairs or just names,
              read Keys to access the name part of a string. If the string is not a name-value
              pair, Keys returns full string. Assigning Keys will write new name for name-value
              pair. This is in contrast to Names property.
           </summary>
        </devnotes>
      </property>
      <property name="Objects[Index]" visibility="public" read="GetObject" write="PutObject" type="TObject" file="System.Classes.pas" line="777"/>
      <property name="QuoteChar" visibility="public" read="FQuoteChar" write="FQuoteChar" type="Char" file="System.Classes.pas" line="778"><devnotes><summary>
Specifies the quote character used by the DelimitedText property.
Use QuoteChar to get or set the quote character that is used to enclose individual strings in the DelimitedText property.
When QuoteChar is set to the null character, then DelimitedText does the following: 

At reading, does not return quoted list items.
At assigning, does not check an assigning value for quote char.
That is, you can set QuoteChar to the null character to disable quoting in DelimitedText. To set the QuoteChar to the null character, do the following:


Delphi:

MyStringList.QuoteChar := #0;



C++:

MyStringList-&gt;QuoteChar = '\0';

</summary></devnotes></property>
      <property name="Values[const Name]" visibility="public" read="GetValue" write="SetValue" type="string" file="System.Classes.pas" line="779"/>
      <property name="ValueFromIndex[Index]" visibility="public" read="GetValueFromIndex" write="SetValueFromIndex" type="string" file="System.Classes.pas" line="780"/>
      <property name="NameValueSeparator" visibility="public" read="FNameValueSeparator" write="FNameValueSeparator" type="Char" file="System.Classes.pas" line="781"><devnotes><summary>
Indicates the character used to separate names from values.
Strings that contain the NameValueSeparator character are considered name-value pairs. NameValueSeparator defaults to the equal sign (=). TStrings defines various methods for accessing names and values and for searching for specific names.
Strings that are name-value pairs consist of a name part, the separator character, and a value part. Any spaces around the separator character are part of the name or value. This convention corresponds to the format used in many initialization files. For example:

DisplayGrid=1
SnapToGrid=1
GridSizeX=8
GridSizeY=8
</summary></devnotes></property>
      <property name="StrictDelimiter" visibility="public" read="GetStrictDelimiter" write="SetStrictDelimiter" type="Boolean" file="System.Classes.pas" line="782"><devnotes><summary>
Determines how the Delimiter property is used.
If StrictDelimiter is True, individual strings in DelimitedText are only separated by Delimiter or quoted between  QuoteChar. If StrictDelimiter is False, spaces and non-printable character are also used as delimiters.

Tip: You can set QuoteChar to the null character (#0 in Delphi, '\0' in C++) if you do not want quoted strings to be extracted as if they where surrounded by Delimiter.

</summary></devnotes></property>
      <property name="Strings[Index]" visibility="public" read="Get" write="Put" type="string" file="System.Classes.pas" line="783"/>
      <property name="Text" visibility="public" read="GetTextStr" write="SetTextStr" type="string" default="0" file="System.Classes.pas" line="784"><devnotes><summary>
Lists the strings in the TStrings object as a single string with the individual strings delimited by carriage returns and line feeds.
Use Text to get or set all the strings in the TStrings object in a single string delimited by carriage return, line feed pairs.
When setting Text, the value will be parsed and separated into substrings whenever the LineBreak value is encountered. For backward compatibility, on POSIX, if the LineBreak separator is LF, then LF, CR, or CRLF are treated as separators. On Windows if the LineBreak separator is CRLF, then LF, CR, or CRLF are treated as separators. 
If the strings in the list contain carriage return or linefeed characters, a less ambiguous format for the strings is available through the CommaText or DelimitedText property.
</summary></devnotes></property>
      <property name="StringsAdapter" visibility="public" read="FAdapter" write="SetStringsAdapter" type="IStringsAdapter" file="System.Classes.pas" line="785"><devnotes><summary>
Implements an IStringsAdapter interface for the TStrings object.

StringsAdapter specifies the attached TStringsAdapter when it is used in OLE applications.

Note: To create a StringsAdapter you can use GetOleStrings and SetOleStrings instead of creating an instance of TStringsAdapter. StringsAdapter is used internally with OLE applications.</summary></devnotes></property>
      <property name="WriteBOM" visibility="public" read="GetWriteBOM" write="SetWriteBOM" type="Boolean" file="System.Classes.pas" line="786"><devnotes><summary>
Will cause SaveToStream and SaveToFile to write a BOM.
Set WriteBOM to True to cause SaveToStream to write a BOM (byte-order mark) to the stream and to cause SaveToFile to write a BOM to the file.
</summary></devnotes></property>
      <property name="TrailingLineBreak" visibility="public" read="GetTrailingLineBreak" write="SetTrailingLineBreak" type="Boolean" file="System.Classes.pas" line="793">
        <devnotes><summary>
Determines whether to add a line Break after the last line of the Text property or not.
Use TrailingLineBreak to add a finishing line break to Text. Set TrailingLineBreak to True to add a  line Break after the last line of Text. Set TrailingLineBreak to False to finish Text without a  line Break. Default is True.
</summary></devnotes>
      </property>
      <property name="UseLocale" visibility="public" read="GetUseLocale" write="SetUseLocale" type="Boolean" file="System.Classes.pas" line="800">
        <devnotes><summary>
Determines the implementation that the list of strings must use for string comparison.
Set UseLocale to True to use AnsiCompareStr and AnsiCompareText to compare strings.
Set UseLocale to False to use CompareStr and CompareText. Default is True.
</summary></devnotes>
      </property>
      <property name="Options" visibility="public" read="FOptions" write="FOptions" type="TStringsOptions" file="System.Classes.pas" line="806">
        <devnotes><summary>
Controls a set of boolean properties of TStrings.
Use Options to specify the value of the following boolean properties of the list of strings:



Option

Property


soStrictDelimiter

StrictDelimiter


soWriteBOM

WriteBOM


soTrailingLineBreak

TrailingLineBreak


soUseLocale

UseLocale
</summary></devnotes>
      </property>
    </members>
  <devnotes><summary>
TStrings is the base class for objects that represent a list of strings.
Derive a class from TStrings to store and manipulate a list of strings. TStrings contains abstract or, in C++ terminology, pure virtual methods and should not be directly instantiated.
Descendants of TStrings can represent several individual strings, such as the individual lines that appear in a list box. Some objects use descendants of TStrings to represent one long body of text so that it can be manipulated in smaller chunks.
TStrings introduces many properties and methods to:

Add or delete strings at specified positions in the list.
Rearrange the strings in the list.
Access the string at a particular location.
Read the strings from or write the strings to a file or stream.
Associate an object with each string in the list.
Store and retrieve strings as name-value pairs.
For an explanation of name-value pairs, refer to the NameValueSeparator property.
</summary></devnotes>
</class>
  <pointer name="PStringItem" type="TStringItem" indircnt="1" file="System.Classes.pas" line="813"/>
  <struct name="TStringItem" size="8" file="System.Classes.pas" line="814">
    <field name="FString" type="string" visibility="public" size="4" offset="0" file="System.Classes.pas" line="815"/>
    <field name="FObject" type="TObject" visibility="public" size="4" offset="4" file="System.Classes.pas" line="816"/>
  </struct>
  <pointer name="PStringItemList" type="TStringItemList" indircnt="1" file="System.Classes.pas" line="819"/>
  <array name="TStringItemList" file="System.Classes.pas" line="820">
    <element type="TStringItem"/>
  </array>
  <type name="TStringListSortCompare" file="System.Classes.pas" line="821" procflags="">
  </type>
  <class name="TStringList" file="System.Classes.pas" line="823">
    <ancestor name="TStrings" namespace="System.Classes">
      <methodref name="GetCommaText" visibility="private"/>
      <methodref name="GetDelimitedText" visibility="private"/>
      <methodref name="GetName" visibility="private"/>
      <methodref name="GetValue" visibility="private"/>
      <methodref name="ReadData" visibility="private"/>
      <methodref name="SetCommaText" visibility="private"/>
      <methodref name="SetDelimitedText" visibility="private"/>
      <methodref name="SetStringsAdapter" visibility="private"/>
      <methodref name="SetValue" visibility="private"/>
      <methodref name="WriteData" visibility="private"/>
      <methodref name="GetStrictDelimiter" visibility="private" procflags="inline"/>
      <methodref name="SetStrictDelimiter" visibility="private"/>
      <methodref name="GetValueFromIndex" visibility="private"/>
      <methodref name="SetValueFromIndex" visibility="private"/>
      <methodref name="SetDefaultEncoding" visibility="private"/>
      <methodref name="GetTrailingLineBreak" visibility="private" procflags="inline"/>
      <methodref name="SetTrailingLineBreak" visibility="private"/>
      <methodref name="GetUseLocale" visibility="private" procflags="inline"/>
      <methodref name="SetUseLocale" visibility="private"/>
      <methodref name="GetWriteBOM" visibility="private" procflags="inline"/>
      <methodref name="SetWriteBOM" visibility="private"/>
      <methodref name="GetUpdating" visibility="private" procflags="inline"/>
      <methodref name="GetKeyName" visibility="private"/>
      <methodref name="DefineProperties" visibility="protected" procflags="override"/>
      <methodref name="Error" visibility="protected" procflags="overload"/>
      <methodref name="Error" visibility="protected" procflags="overload"/>
      <methodref name="ExtractName" visibility="protected" procflags="overload inline"/>
      <methodref name="ExtractName" visibility="protected" procflags="overload"/>
      <methodref name="Get" visibility="protected" procflags="abstract virtual"/>
      <methodref name="GetCapacity" visibility="protected" procflags="virtual"/>
      <methodref name="GetCount" visibility="protected" procflags="abstract virtual"/>
      <methodref name="GetObject" visibility="protected" procflags="virtual"/>
      <methodref name="GetTextStr" visibility="protected" procflags="virtual"/>
      <methodref name="Put" visibility="protected" procflags="virtual"/>
      <methodref name="PutObject" visibility="protected" procflags="virtual"/>
      <methodref name="SetCapacity" visibility="protected" procflags="virtual"/>
      <methodref name="SetEncoding" visibility="protected" procflags="virtual"/>
      <methodref name="SetTextStr" visibility="protected" procflags="virtual"/>
      <methodref name="SetUpdateState" visibility="protected" procflags="virtual"/>
      <methodref name="CompareStrings" visibility="protected" procflags="virtual"/>
      <propertyref name="UpdateCount" visibility="protected"/>
      <methodref name="Create" visibility="public" procflags="constructor"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="Add" visibility="public" procflags="virtual"/>
      <methodref name="AddPair" visibility="public" procflags="overload">
      </methodref>
      <methodref name="AddPair" visibility="public" procflags="overload">
      </methodref>
      <methodref name="AddObject" visibility="public" procflags="virtual"/>
      <methodref name="Append" visibility="public"/>
      <methodref name="AddStrings" visibility="public" procflags="overload virtual"/>
      <methodref name="AddStrings" visibility="public" procflags="overload">
        <attributes>
          <attribute name="HPPGENAttribute"/>
        </attributes>
      </methodref>
      <methodref name="AddStrings" visibility="public" procflags="overload">
        <attributes>
          <attribute name="HPPGENAttribute"/>
        </attributes>
      </methodref>
      <methodref name="Assign" visibility="public" procflags="override"/>
      <methodref name="SetStrings" visibility="public">
      </methodref>
      <methodref name="BeginUpdate" visibility="public"/>
      <methodref name="Clear" visibility="public" procflags="abstract virtual"/>
      <methodref name="Delete" visibility="public" procflags="abstract virtual"/>
      <methodref name="EndUpdate" visibility="public"/>
      <methodref name="Equals" visibility="public"/>
      <methodref name="Exchange" visibility="public" procflags="virtual"/>
      <methodref name="GetEnumerator" visibility="public" procflags="inline"/>
      <methodref name="GetText" visibility="public" procflags="virtual"/>
      <methodref name="IndexOf" visibility="public" procflags="virtual"/>
      <methodref name="IndexOfName" visibility="public" procflags="virtual"/>
      <methodref name="IndexOfObject" visibility="public" procflags="virtual"/>
      <methodref name="Insert" visibility="public" procflags="abstract virtual"/>
      <methodref name="InsertObject" visibility="public" procflags="virtual"/>
      <methodref name="LoadFromFile" visibility="public" procflags="overload virtual"/>
      <methodref name="LoadFromFile" visibility="public" procflags="overload virtual"/>
      <methodref name="LoadFromStream" visibility="public" procflags="overload virtual"/>
      <methodref name="LoadFromStream" visibility="public" procflags="overload virtual"/>
      <methodref name="Move" visibility="public" procflags="virtual"/>
      <methodref name="SaveToFile" visibility="public" procflags="overload virtual"/>
      <methodref name="SaveToFile" visibility="public" procflags="overload virtual"/>
      <methodref name="SaveToStream" visibility="public" procflags="overload virtual"/>
      <methodref name="SaveToStream" visibility="public" procflags="overload virtual"/>
      <methodref name="SetText" visibility="public" procflags="virtual"/>
      <methodref name="ToStringArray" visibility="public"/>
      <methodref name="ToObjectArray" visibility="public"/>
      <propertyref name="Updating" visibility="public">
      </propertyref>
      <propertyref name="Capacity" visibility="public"/>
      <propertyref name="CommaText" visibility="public"/>
      <propertyref name="Count" visibility="public"/>
      <propertyref name="DefaultEncoding" visibility="public"/>
      <propertyref name="Delimiter" visibility="public"/>
      <propertyref name="DelimitedText" visibility="public"/>
      <propertyref name="Encoding" visibility="public"/>
      <propertyref name="LineBreak" visibility="public"/>
      <propertyref name="Names" visibility="public"/>
      <propertyref name="KeyNames" visibility="public">
      </propertyref>
      <propertyref name="Objects" visibility="public"/>
      <propertyref name="QuoteChar" visibility="public"/>
      <propertyref name="Values" visibility="public"/>
      <propertyref name="ValueFromIndex" visibility="public"/>
      <propertyref name="NameValueSeparator" visibility="public"/>
      <propertyref name="StrictDelimiter" visibility="public"/>
      <propertyref name="Strings" visibility="public"/>
      <propertyref name="Text" visibility="public"/>
      <propertyref name="StringsAdapter" visibility="public"/>
      <propertyref name="WriteBOM" visibility="public"/>
      <propertyref name="TrailingLineBreak" visibility="public">
      </propertyref>
      <propertyref name="UseLocale" visibility="public">
      </propertyref>
      <propertyref name="Options" visibility="public">
      </propertyref>
      <ancestor name="TPersistent" namespace="System.Classes">
        <methodref name="AssignError" visibility="private"/>
        <methodref name="AssignTo" visibility="protected" procflags="virtual"/>
        <methodref name="DefineProperties" visibility="protected" procflags="virtual"/>
        <methodref name="GetOwner" visibility="protected" procflags="dynamic"/>
        <methodref name="Destroy" visibility="public" procflags="destructor override"/>
        <methodref name="Assign" visibility="public" procflags="virtual"/>
        <methodref name="GetNamePath" visibility="public" procflags="dynamic"/>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <set name="TOverridden" visibility="private" alias="System.Classes.TOverridden" file="System.Classes.pas" line="825">
        <element name="sloCompareStrings"/>
        <element name="sloGetObject"/>
      </set>
      <field name="FList" type="TStringItemList" visibility="private" size="4" offset="32" file="System.Classes.pas" line="827"/>
      <field name="FCount" type="Integer" visibility="private" size="4" offset="36" file="System.Classes.pas" line="828"/>
      <field name="FCapacity" type="Integer" visibility="private" size="4" offset="40" file="System.Classes.pas" line="829"/>
      <field name="FSorted" type="Boolean" visibility="private" size="1" offset="44" file="System.Classes.pas" line="830"/>
      <field name="FDuplicates" type="TDuplicates" visibility="private" size="1" offset="45" file="System.Classes.pas" line="831"/>
      <field name="FCaseSensitive" type="Boolean" visibility="private" size="1" offset="46" file="System.Classes.pas" line="832"/>
      <field name="FOnChange" type="TNotifyEvent" visibility="private" size="8" offset="48" file="System.Classes.pas" line="833"/>
      <field name="FOnChanging" type="TNotifyEvent" visibility="private" size="8" offset="56" file="System.Classes.pas" line="834"/>
      <field name="FOwnsObject" type="Boolean" visibility="private" size="1" offset="64" file="System.Classes.pas" line="835"/>
      <field name="FOverridden" type="TStringList.TOverridden" visibility="private" size="1" offset="65" file="System.Classes.pas" line="836"/>
      <procedure name="Grow" visibility="private" file="System.Classes.pas" line="837">
      </procedure>
      <procedure name="QuickSort" visibility="private" file="System.Classes.pas" line="838">
        <parameters>
          <parameter name="L" type="Integer"/>
          <parameter name="R" type="Integer"/>
          <parameter name="SCompare" type="TStringListSortCompare"/>
        </parameters>
      </procedure>
      <procedure name="SetSorted" visibility="private" file="System.Classes.pas" line="839">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="SetCaseSensitive" visibility="private" file="System.Classes.pas" line="840">
        <parameters>
          <parameter name="Value" type="Boolean" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="InternalStrComp" visibility="private" procflags="static inline" file="System.Classes.pas" line="841">
        <parameters>
          <parameter name="L" type="PWideChar"/>
          <parameter name="R" type="PWideChar"/>
          <parameter name="Len" type="Integer"/>
          <parameter name="Mode" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="LinearIndexOfName" visibility="private" file="System.Classes.pas" line="842">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="SortedIndexOfName" visibility="private" file="System.Classes.pas" line="843">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="Changed" visibility="protected" procflags="virtual" file="System.Classes.pas" line="845">
      </procedure>
      <procedure name="Changing" visibility="protected" procflags="virtual" file="System.Classes.pas" line="846">
      </procedure>
      <procedure name="ExchangeItems" visibility="protected" file="System.Classes.pas" line="847">
        <parameters>
          <parameter name="Index1" type="Integer"/>
          <parameter name="Index2" type="Integer"/>
        </parameters>
      </procedure>
      <function name="Get" visibility="protected" procflags="override" file="System.Classes.pas" line="848">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="GetCapacity" visibility="protected" procflags="override" file="System.Classes.pas" line="849">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetCount" visibility="protected" procflags="override" file="System.Classes.pas" line="850">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetObject" visibility="protected" procflags="override" file="System.Classes.pas" line="851">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="TObject"/>
        </parameters>
      </function>
      <procedure name="Put" visibility="protected" procflags="override" file="System.Classes.pas" line="852">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="S" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="PutObject" visibility="protected" procflags="override" file="System.Classes.pas" line="853">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="AObject" type="TObject"/>
        </parameters>
      </procedure>
      <procedure name="SetCapacity" visibility="protected" procflags="override" file="System.Classes.pas" line="854">
        <parameters>
          <parameter name="NewCapacity" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="SetUpdateState" visibility="protected" procflags="override" file="System.Classes.pas" line="855">
        <parameters>
          <parameter name="Updating" type="Boolean"/>
        </parameters>
      </procedure>
      <function name="CompareStrings" visibility="protected" procflags="override" file="System.Classes.pas" line="856">
        <parameters>
          <parameter name="S1" type="string" paramflags="const"/>
          <parameter name="S2" type="string" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="InsertItem" visibility="protected" procflags="virtual" file="System.Classes.pas" line="857">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="S" type="string" paramflags="const"/>
          <parameter name="AObject" type="TObject"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="859">
        <parameters>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="860">
        <parameters>
          <parameter name="OwnsObjects" type="Boolean"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="865">
        <devnotes>
           <summary>
              This constructor creates new string list with specified QuoteChar
              and Delimiter property values.
           </summary>
        </devnotes>
        <parameters>
          <parameter name="QuoteChar" type="Char"/>
          <parameter name="Delimiter" type="Char"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="870">
        <devnotes>
           <summary>
              This constructor creates new string list with specified QuoteChar,
              Delimiter and Options property values.
           </summary>
        </devnotes>
        <parameters>
          <parameter name="QuoteChar" type="Char"/>
          <parameter name="Delimiter" type="Char"/>
          <parameter name="Options" type="TStringsOptions"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="875">
        <devnotes>
           <summary>
              This constructor creates new string list with specified Duplicates,
              Sorted and CaseSensitive property values.
           </summary>
        </devnotes>
        <parameters>
          <parameter name="Duplicates" type="TDuplicates"/>
          <parameter name="Sorted" type="Boolean"/>
          <parameter name="CaseSensitive" type="Boolean"/>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="876">
        <parameters>
        </parameters>
      </destructor>
      <function name="Add" visibility="public" procflags="override" file="System.Classes.pas" line="877">
        <parameters>
          <parameter name="S" type="string" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="AddObject" visibility="public" procflags="override" file="System.Classes.pas" line="878">
        <parameters>
          <parameter name="S" type="string" paramflags="const"/>
          <parameter name="AObject" type="TObject"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="AddStrings" visibility="public" procflags="overload override" file="System.Classes.pas" line="889">
        <attributes>
          <attribute name="HPPGENAttribute"/>
        </attributes>
        <parameters>
          <parameter name="Strings" type="TStrings"/>
        </parameters>
      </procedure>
      <procedure name="Assign" visibility="public" procflags="override" file="System.Classes.pas" line="890">
        <parameters>
          <parameter name="Source" type="TPersistent"/>
        </parameters>
      </procedure>
      <procedure name="Clear" visibility="public" procflags="override" file="System.Classes.pas" line="891">
      </procedure>
      <procedure name="Delete" visibility="public" procflags="override" file="System.Classes.pas" line="892">
        <parameters>
          <parameter name="Index" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Exchange" visibility="public" procflags="override" file="System.Classes.pas" line="893">
        <parameters>
          <parameter name="Index1" type="Integer"/>
          <parameter name="Index2" type="Integer"/>
        </parameters>
      </procedure>
      <function name="Find" visibility="public" procflags="virtual" file="System.Classes.pas" line="894">
        <parameters>
          <parameter name="S" type="string" paramflags="const"/>
          <parameter name="Index" type="Integer" paramflags="var"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="IndexOf" visibility="public" procflags="override" file="System.Classes.pas" line="895">
        <parameters>
          <parameter name="S" type="string" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="IndexOfName" visibility="public" procflags="override" file="System.Classes.pas" line="896">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="IndexOfObject" visibility="public" procflags="override" file="System.Classes.pas" line="897">
        <parameters>
          <parameter name="AObject" type="TObject"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="Insert" visibility="public" procflags="override" file="System.Classes.pas" line="898">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="S" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="InsertObject" visibility="public" procflags="override" file="System.Classes.pas" line="899">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="S" type="string" paramflags="const"/>
          <parameter name="AObject" type="TObject"/>
        </parameters>
      </procedure>
      <procedure name="Sort" visibility="public" procflags="virtual" file="System.Classes.pas" line="901">
      </procedure>
      <procedure name="CustomSort" visibility="public" procflags="virtual" file="System.Classes.pas" line="902">
        <parameters>
          <parameter name="Compare" type="TStringListSortCompare"/>
        </parameters>
      </procedure>
      <property name="Duplicates" visibility="public" read="FDuplicates" write="FDuplicates" type="TDuplicates" file="System.Classes.pas" line="903"/>
      <property name="Sorted" visibility="public" read="FSorted" write="SetSorted" type="Boolean" file="System.Classes.pas" line="904"/>
      <property name="CaseSensitive" visibility="public" read="FCaseSensitive" write="SetCaseSensitive" type="Boolean" file="System.Classes.pas" line="905"/>
      <event name="OnChange" visibility="public" read="FOnChange" write="FOnChange" type="TNotifyEvent" file="System.Classes.pas" line="906"/>
      <event name="OnChanging" visibility="public" read="FOnChanging" write="FOnChanging" type="TNotifyEvent" file="System.Classes.pas" line="907"/>
      <property name="OwnsObjects" visibility="public" read="FOwnsObject" write="FOwnsObject" type="Boolean" file="System.Classes.pas" line="908"/>
    </members>
  </class>
  <class name="TStream" file="System.Classes.pas" line="913">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <function name="Read" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="927">
        <parameters>
          <parameter name="Buffer" paramflags="var"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading  up to Count bytes of data  from the stream into Buffer.
Descendant stream classes can define its own Read methods that read data from its particular storage medium (such as memory or a disk file) into a Buffer buffer.
Read is used in cases where the number of bytes to read from the stream is not necessarily fixed. 
Read attempts to read, into Buffer, up to Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. Read returns the number of bytes actually read, which may be less than Count.
Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
All the other data-reading methods of a stream (ReadBuffer, ReadData) call Read to do their actual reading.
</summary></devnotes></function>
      <function name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="928">
        <parameters>
          <parameter name="Buffer" paramflags="const"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
Write attempts to write up to Count bytes from the Buffer to the current position in the stream, and returns the number of bytes written.
After writing to the stream, Write advances the current position by the number of bytes written. 
Offset specifies a zero-based position in Buffer of the first byte to write. 
All other data-writing methods of a stream (WriteBuffer, WriteData) call Write to do their actual writing.
Each descendent stream object defines a Write method that writes data to its particular storage medium (such as memory or a disk file).
</summary></devnotes></function>
      <function name="Read" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="929">
        <parameters>
          <parameter name="Buffer" type="TBytes"/>
          <parameter name="Offset" type="Integer"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading  up to Count bytes of data  from the stream into Buffer.
Descendant stream classes can define its own Read methods that read data from its particular storage medium (such as memory or a disk file) into a Buffer buffer.
Read is used in cases where the number of bytes to read from the stream is not necessarily fixed. 
Read attempts to read, into Buffer, up to Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. Read returns the number of bytes actually read, which may be less than Count.
Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
All the other data-reading methods of a stream (ReadBuffer, ReadData) call Read to do their actual reading.
</summary></devnotes></function>
      <function name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="930">
        <parameters>
          <parameter name="Buffer" type="TBytes" paramflags="const"/>
          <parameter name="Offset" type="Integer"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
Write attempts to write up to Count bytes from the Buffer to the current position in the stream, and returns the number of bytes written.
After writing to the stream, Write advances the current position by the number of bytes written. 
Offset specifies a zero-based position in Buffer of the first byte to write. 
All other data-writing methods of a stream (WriteBuffer, WriteData) call Write to do their actual writing.
Each descendent stream object defines a Write method that writes data to its particular storage medium (such as memory or a disk file).
</summary></devnotes></function>
      <function name="Read" visibility="public" procflags="overload" file="System.Classes.pas" line="932">
        <parameters>
          <parameter name="Buffer" type="TBytes" paramflags="var"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading  up to Count bytes of data  from the stream into Buffer.
Descendant stream classes can define its own Read methods that read data from its particular storage medium (such as memory or a disk file) into a Buffer buffer.
Read is used in cases where the number of bytes to read from the stream is not necessarily fixed. 
Read attempts to read, into Buffer, up to Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. Read returns the number of bytes actually read, which may be less than Count.
Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
All the other data-reading methods of a stream (ReadBuffer, ReadData) call Read to do their actual reading.
</summary></devnotes></function>
      <function name="Write" visibility="public" procflags="overload" file="System.Classes.pas" line="933">
        <parameters>
          <parameter name="Buffer" type="TBytes" paramflags="const"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
Write attempts to write up to Count bytes from the Buffer to the current position in the stream, and returns the number of bytes written.
After writing to the stream, Write advances the current position by the number of bytes written. 
Offset specifies a zero-based position in Buffer of the first byte to write. 
All other data-writing methods of a stream (WriteBuffer, WriteData) call Write to do their actual writing.
Each descendent stream object defines a Write method that writes data to its particular storage medium (such as memory or a disk file).
</summary></devnotes></function>
      <function name="Read64" visibility="public" procflags="virtual" file="System.Classes.pas" line="935">
        <parameters>
          <parameter name="Buffer" type="TBytes"/>
          <parameter name="Offset" type="Int64"/>
          <parameter name="Count" type="Int64"/>
          <retval type="Int64"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></function>
      <function name="Write64" visibility="public" procflags="virtual" file="System.Classes.pas" line="936">
        <parameters>
          <parameter name="Buffer" type="TBytes" paramflags="const"/>
          <parameter name="Offset" type="Int64"/>
          <parameter name="Count" type="Int64"/>
          <retval type="Int64"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="938">
        <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes>
        <parameters>
          <parameter name="Buffer" type="Pointer"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      </function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="939">
        <parameters>
          <parameter name="Buffer" type="TBytes" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="941">
        <parameters>
          <parameter name="Buffer" type="Boolean" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="942">
        <parameters>
          <parameter name="Buffer" type="Boolean" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="947">
        <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes>
        <parameters>
          <parameter name="Buffer" type="AnsiChar" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      </function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="948">
        <parameters>
          <parameter name="Buffer" type="AnsiChar" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="950">
        <parameters>
          <parameter name="Buffer" type="Char" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="951">
        <parameters>
          <parameter name="Buffer" type="Char" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="952">
        <parameters>
          <parameter name="Buffer" type="ShortInt" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="953">
        <parameters>
          <parameter name="Buffer" type="ShortInt" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="954">
        <parameters>
          <parameter name="Buffer" type="Byte" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="955">
        <parameters>
          <parameter name="Buffer" type="Byte" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="956">
        <parameters>
          <parameter name="Buffer" type="SmallInt" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="957">
        <parameters>
          <parameter name="Buffer" type="SmallInt" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="958">
        <parameters>
          <parameter name="Buffer" type="Word" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="959">
        <parameters>
          <parameter name="Buffer" type="Word" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="960">
        <parameters>
          <parameter name="Buffer" type="Integer" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="961">
        <parameters>
          <parameter name="Buffer" type="Integer" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="962">
        <parameters>
          <parameter name="Buffer" type="Cardinal" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="963">
        <parameters>
          <parameter name="Buffer" type="Cardinal" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="964">
        <parameters>
          <parameter name="Buffer" type="Int64" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="965">
        <parameters>
          <parameter name="Buffer" type="Int64" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="966">
        <parameters>
          <parameter name="Buffer" type="UInt64" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="967">
        <parameters>
          <parameter name="Buffer" type="UInt64" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="968">
        <parameters>
          <parameter name="Buffer" type="Single" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="969">
        <parameters>
          <parameter name="Buffer" type="Single" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="970">
        <parameters>
          <parameter name="Buffer" type="Double" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="971">
        <parameters>
          <parameter name="Buffer" type="Double" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="972">
        <parameters>
          <parameter name="Buffer" type="Extended" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="973">
        <parameters>
          <parameter name="Buffer" type="Extended" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="974">
        <parameters>
          <parameter name="Buffer" type="TExtended80Rec" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="975">
        <parameters>
          <parameter name="Buffer" type="TExtended80Rec" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="977">
        <parameters>
          <parameter name="Buffer" type="T" paramflags="var"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="ReadData" visibility="public" procflags="overload" file="System.Classes.pas" line="978">
        <parameters>
          <parameter name="Buffer" type="T" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="980">
        <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes>
        <parameters>
          <parameter name="Buffer" type="TBytes" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      </function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="981">
        <parameters>
          <parameter name="Buffer" type="Pointer" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="983">
        <parameters>
          <parameter name="Buffer" type="Boolean" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="984">
        <parameters>
          <parameter name="Buffer" type="Boolean" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="989">
        <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes>
        <parameters>
          <parameter name="Buffer" type="AnsiChar" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      </function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="990">
        <parameters>
          <parameter name="Buffer" type="AnsiChar" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="992">
        <parameters>
          <parameter name="Buffer" type="Char" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="993">
        <parameters>
          <parameter name="Buffer" type="Char" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="994">
        <parameters>
          <parameter name="Buffer" type="ShortInt" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="995">
        <parameters>
          <parameter name="Buffer" type="ShortInt" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="996">
        <parameters>
          <parameter name="Buffer" type="Byte" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="997">
        <parameters>
          <parameter name="Buffer" type="Byte" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="998">
        <parameters>
          <parameter name="Buffer" type="SmallInt" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="999">
        <parameters>
          <parameter name="Buffer" type="SmallInt" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1000">
        <parameters>
          <parameter name="Buffer" type="Word" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1001">
        <parameters>
          <parameter name="Buffer" type="Word" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1002">
        <parameters>
          <parameter name="Buffer" type="Integer" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1003">
        <parameters>
          <parameter name="Buffer" type="Integer" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1004">
        <parameters>
          <parameter name="Buffer" type="Cardinal" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1005">
        <parameters>
          <parameter name="Buffer" type="Cardinal" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1006">
        <parameters>
          <parameter name="Buffer" type="Int64" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1007">
        <parameters>
          <parameter name="Buffer" type="Int64" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1008">
        <parameters>
          <parameter name="Buffer" type="UInt64" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1009">
        <parameters>
          <parameter name="Buffer" type="UInt64" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1010">
        <parameters>
          <parameter name="Buffer" type="Single" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1011">
        <parameters>
          <parameter name="Buffer" type="Single" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1012">
        <parameters>
          <parameter name="Buffer" type="Double" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1013">
        <parameters>
          <parameter name="Buffer" type="Double" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1014">
        <parameters>
          <parameter name="Buffer" type="Extended" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1015">
        <parameters>
          <parameter name="Buffer" type="Extended" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1016">
        <parameters>
          <parameter name="Buffer" type="TExtended80Rec" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1017">
        <parameters>
          <parameter name="Buffer" type="TExtended80Rec" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1019">
        <parameters>
          <parameter name="Buffer" type="T" paramflags="const"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="WriteData" visibility="public" procflags="overload" file="System.Classes.pas" line="1020">
        <parameters>
          <parameter name="Buffer" type="T" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
          <retval type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.
</summary></devnotes></function>
      <function name="Seek32" visibility="public" procflags="overload inline" file="System.Classes.pas" line="1022">
        <parameters>
          <parameter name="Offset" type="Integer" paramflags="const"/>
          <parameter name="Origin" type="TSeekOrigin"/>
          <retval type="Int64"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></function>
      <function name="Seek" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="1023">
        <parameters>
          <parameter name="Offset" type="Integer"/>
          <parameter name="Origin" type="Word"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Moves to a specified position in the streamed resource.
Call Seek to move the current position of the stream in its particular storage medium (such as memory or a disk file).
The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:



Value

Meaning



soBeginning



Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be &gt;= 0.




soCurrent



Offset is from the current position in the resource. Seek moves to Position + Offset.




soEnd



Offset is from the end of the resource. Offset must be &lt;= 0 to indicate a number of bytes before the end of the file.



Seek returns the new value of the Position property.
Seek is called by the Position and Size properties.

Note: As implemented in TStream, the two versions (the 32-bit or 64-bit syntax) call each other. Descendent stream classes must override at least one of these versions, and the override must not call the inherited default implementation.</summary></devnotes></function>
      <function name="Seek" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="1024">
        <parameters>
          <parameter name="Offset" type="Int64" paramflags="const"/>
          <parameter name="Origin" type="TSeekOrigin"/>
          <retval type="Int64"/>
        </parameters>
      <devnotes><summary>
Moves to a specified position in the streamed resource.
Call Seek to move the current position of the stream in its particular storage medium (such as memory or a disk file).
The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:



Value

Meaning



soBeginning



Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be &gt;= 0.




soCurrent



Offset is from the current position in the resource. Seek moves to Position + Offset.




soEnd



Offset is from the end of the resource. Offset must be &lt;= 0 to indicate a number of bytes before the end of the file.



Seek returns the new value of the Position property.
Seek is called by the Position and Size properties.

Note: As implemented in TStream, the two versions (the 32-bit or 64-bit syntax) call each other. Descendent stream classes must override at least one of these versions, and the override must not call the inherited default implementation.</summary></devnotes></function>
      <function name="Seek" visibility="public" procflags="overload inline" file="System.Classes.pas" line="1026">
        <parameters>
          <parameter name="Offset" type="Int64" paramflags="const"/>
          <parameter name="Origin" type="Word"/>
          <retval type="Int64"/>
        </parameters>
      <devnotes><summary>
Moves to a specified position in the streamed resource.
Call Seek to move the current position of the stream in its particular storage medium (such as memory or a disk file).
The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:



Value

Meaning



soBeginning



Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be &gt;= 0.




soCurrent



Offset is from the current position in the resource. Seek moves to Position + Offset.




soEnd



Offset is from the end of the resource. Offset must be &lt;= 0 to indicate a number of bytes before the end of the file.



Seek returns the new value of the Position property.
Seek is called by the Position and Size properties.

Note: As implemented in TStream, the two versions (the 32-bit or 64-bit syntax) call each other. Descendent stream classes must override at least one of these versions, and the override must not call the inherited default implementation.</summary></devnotes></function>
      <procedure name="ReadBuffer" visibility="public" procflags="overload" file="System.Classes.pas" line="1029">
        <parameters>
          <parameter name="Buffer" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Reads Count bytes from the stream into Buffer.
Use ReadBuffer to read Count bytes from the stream into a Buffer buffer in cases where the number of bytes to read is known and fixed, for example when reading in structures. ReadBuffer is used internally for loading from a stream and copying from a stream.
Read attempts to read exactly Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. 
Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
ReadBuffer calls Read to do the actual reading. If Count bytes cannot be read from the stream, an EReadError exception is raised.
</summary></devnotes></procedure>
      <procedure name="ReadBuffer" visibility="public" procflags="overload" file="System.Classes.pas" line="1030">
        <parameters>
          <parameter name="Buffer" type="TBytes" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Reads Count bytes from the stream into Buffer.
Use ReadBuffer to read Count bytes from the stream into a Buffer buffer in cases where the number of bytes to read is known and fixed, for example when reading in structures. ReadBuffer is used internally for loading from a stream and copying from a stream.
Read attempts to read exactly Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. 
Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
ReadBuffer calls Read to do the actual reading. If Count bytes cannot be read from the stream, an EReadError exception is raised.
</summary></devnotes></procedure>
      <procedure name="ReadBuffer" visibility="public" procflags="overload" file="System.Classes.pas" line="1031">
        <parameters>
          <parameter name="Buffer" type="TBytes" paramflags="var"/>
          <parameter name="Offset" type="NativeInt"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Reads Count bytes from the stream into Buffer.
Use ReadBuffer to read Count bytes from the stream into a Buffer buffer in cases where the number of bytes to read is known and fixed, for example when reading in structures. ReadBuffer is used internally for loading from a stream and copying from a stream.
Read attempts to read exactly Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. 
Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
ReadBuffer calls Read to do the actual reading. If Count bytes cannot be read from the stream, an EReadError exception is raised.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1033">
        <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes>
        <parameters>
          <parameter name="Buffer" type="Boolean" paramflags="var"/>
        </parameters>
      </procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1034">
        <parameters>
          <parameter name="Buffer" type="Boolean" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1039">
        <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes>
        <parameters>
          <parameter name="Buffer" type="AnsiChar" paramflags="var"/>
        </parameters>
      </procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1040">
        <parameters>
          <parameter name="Buffer" type="AnsiChar" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1042">
        <parameters>
          <parameter name="Buffer" type="Char" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1043">
        <parameters>
          <parameter name="Buffer" type="Char" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1044">
        <parameters>
          <parameter name="Buffer" type="ShortInt" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1045">
        <parameters>
          <parameter name="Buffer" type="ShortInt" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1046">
        <parameters>
          <parameter name="Buffer" type="Byte" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1047">
        <parameters>
          <parameter name="Buffer" type="Byte" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1048">
        <parameters>
          <parameter name="Buffer" type="SmallInt" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1049">
        <parameters>
          <parameter name="Buffer" type="SmallInt" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1050">
        <parameters>
          <parameter name="Buffer" type="Word" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1051">
        <parameters>
          <parameter name="Buffer" type="Word" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1052">
        <parameters>
          <parameter name="Buffer" type="Integer" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1053">
        <parameters>
          <parameter name="Buffer" type="Integer" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1054">
        <parameters>
          <parameter name="Buffer" type="Cardinal" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1055">
        <parameters>
          <parameter name="Buffer" type="Cardinal" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1056">
        <parameters>
          <parameter name="Buffer" type="Int64" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1057">
        <parameters>
          <parameter name="Buffer" type="Int64" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1058">
        <parameters>
          <parameter name="Buffer" type="UInt64" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1059">
        <parameters>
          <parameter name="Buffer" type="UInt64" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1060">
        <parameters>
          <parameter name="Buffer" type="Single" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1061">
        <parameters>
          <parameter name="Buffer" type="Single" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1062">
        <parameters>
          <parameter name="Buffer" type="Double" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1063">
        <parameters>
          <parameter name="Buffer" type="Double" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1064">
        <parameters>
          <parameter name="Buffer" type="Extended" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1065">
        <parameters>
          <parameter name="Buffer" type="Extended" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1066">
        <parameters>
          <parameter name="Buffer" type="TExtended80Rec" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="ReadBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1067">
        <parameters>
          <parameter name="Buffer" type="TExtended80Rec" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.
</summary></devnotes></procedure>
      <procedure name="WriteBuffer" visibility="public" procflags="overload" file="System.Classes.pas" line="1069">
        <parameters>
          <parameter name="Buffer" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Writes Count bytes from Buffer onto the stream.
WriteBuffer attempts to write Count  bytes from the Buffer to the current position in the stream, then WriteBuffer advances the current position by Count. If the stream fails to write all the requested bytes, an EWriteError exception is raised.
Offset specifies a zero-based position in Buffer of the first byte to write.
Use WriteBuffer to save data to a stream. WriteBuffer is used in cases, where the number of bytes to write is known and required, for example when writing in structures. Use WriteBuffer for standard file I/O streaming.
WriteBuffer is used internally for writing to a stream. It is used by other objects, such as strings and lists, for writing strings stored in a buffer.
WriteBuffer calls Write to handle the actual writing. 
</summary></devnotes></procedure>
      <procedure name="WriteBuffer" visibility="public" procflags="overload" file="System.Classes.pas" line="1070">
        <parameters>
          <parameter name="Buffer" type="TBytes" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Writes Count bytes from Buffer onto the stream.
WriteBuffer attempts to write Count  bytes from the Buffer to the current position in the stream, then WriteBuffer advances the current position by Count. If the stream fails to write all the requested bytes, an EWriteError exception is raised.
Offset specifies a zero-based position in Buffer of the first byte to write.
Use WriteBuffer to save data to a stream. WriteBuffer is used in cases, where the number of bytes to write is known and required, for example when writing in structures. Use WriteBuffer for standard file I/O streaming.
WriteBuffer is used internally for writing to a stream. It is used by other objects, such as strings and lists, for writing strings stored in a buffer.
WriteBuffer calls Write to handle the actual writing. 
</summary></devnotes></procedure>
      <procedure name="WriteBuffer" visibility="public" procflags="overload" file="System.Classes.pas" line="1071">
        <parameters>
          <parameter name="Buffer" type="TBytes" paramflags="const"/>
          <parameter name="Offset" type="NativeInt"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Writes Count bytes from Buffer onto the stream.
WriteBuffer attempts to write Count  bytes from the Buffer to the current position in the stream, then WriteBuffer advances the current position by Count. If the stream fails to write all the requested bytes, an EWriteError exception is raised.
Offset specifies a zero-based position in Buffer of the first byte to write.
Use WriteBuffer to save data to a stream. WriteBuffer is used in cases, where the number of bytes to write is known and required, for example when writing in structures. Use WriteBuffer for standard file I/O streaming.
WriteBuffer is used internally for writing to a stream. It is used by other objects, such as strings and lists, for writing strings stored in a buffer.
WriteBuffer calls Write to handle the actual writing. 
</summary></devnotes></procedure>
      <procedure name="WriteBufferData" visibility="public" procflags="overload" file="System.Classes.pas" line="1073">
        <parameters>
          <parameter name="Buffer" type="Integer" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Writes up to 4 four or Count bytes from Buffer onto the stream.
WriteBufferData works using the following algorithms: 

If Count  &lt;= 4, then WriteBufferData tries to write up to Count bytes to the stream starting at the current position and advances the current position in the stream by the number of bytes transferred.
If Count  &gt; 4, then WriteBufferData tries to write up to 4 four bytes to the stream, starting at the current position, and then advances the current position in the stream until Count number of bytes from the initial position that was before the starting of WriteBufferData execution.</summary></devnotes></procedure>
      <function name="CopyFrom" visibility="public" file="System.Classes.pas" line="1075">
        <parameters>
          <parameter name="Source" type="TStream" paramflags="const"/>
          <parameter name="Count" type="Int64">
            <value>
              $0
            </value>
          </parameter>
          <parameter name="BufferSize" type="Integer">
            <value>
              $100000
            </value>
          </parameter>
          <retval type="Int64"/>
        </parameters>
      <devnotes><summary>
Copies a specified number of bytes from one stream to another.
Use CopyFrom to copy data from one stream to a different one. Using CopyFrom eliminates the need to create, read into, write from, and free a buffer when copying data. 
CopyFrom copies Count bytes from the stream specified by Source into the stream. It then moves the current position by Count bytes and returns the number of bytes copied. 
If Count is 0, CopyFrom sets Source position to 0 before reading and then copies the entire contents of Source into the stream. If Count is greater than or less than 0, CopyFrom reads from the current position in Source. 
Because the CopyFrom method uses ReadBuffer and WriteBuffer to do the effective copying, if the Count is greater than the SourceStream size, ReadBuffer throws an exception stating that a stream read error has occured. 
</summary></devnotes></function>
      <function name="ReadComponent" visibility="public" file="System.Classes.pas" line="1076">
        <parameters>
          <parameter name="Instance" type="TComponent" paramflags="const"/>
          <retval type="TComponent"/>
        </parameters>
      <devnotes><summary>
Initiates streaming of components and their properties.
ReadComponent is called indirectly by the global routine ReadComponentRes, by the ReadComponentRes method, or it can be called directly to initiate component streaming.
ReadComponent reads data values from the stream and assigns them to Instance's properties. It then constructs a reader object and calls the reader's ReadRootComponent method to read the Instance's property values and construct child objects defined in the stream as children of Instance. ReadComponent returns the component.
If Instance is nil (Delphi) or NULL (C++), ReadComponent constructs a component based on the type information in the stream and returns the newly-constructed component.
</summary></devnotes></function>
      <function name="ReadComponentRes" visibility="public" file="System.Classes.pas" line="1077">
        <parameters>
          <parameter name="Instance" type="TComponent" paramflags="const"/>
          <retval type="TComponent"/>
        </parameters>
      <devnotes><summary>
Reads components and their properties from a stream in a resource file format.
ReadComponentRes is called automatically by the global routine ReadComponentResFile. It can also be called directly if the current position of the stream points to a component written using the WriteComponentRes method.
ReadComponentResFile creates a file stream object, which then calls its ReadComponentRes method.
ReadComponentRes first calls the ReadResHeader method to read a resource header from the stream. If the stream does not contain a resource header at the current position, ReadResHeader will raise an EInvalidImage exception. ReadComponentRes then calls ReadComponent to read the properties that must be set on Instance.
</summary></devnotes></function>
      <procedure name="WriteComponent" visibility="public" file="System.Classes.pas" line="1078">
        <parameters>
          <parameter name="Instance" type="TComponent" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Initiates the writing of components and their properties to a stream.
WriteComponent is used internally in the component streaming system, but can also be called directly when writing components to memory streams or database blobs.
WriteComponent constructs a writer object and calls its WriteRootComponent method to write the component specified by Instance, and its owned objects, to the stream.
</summary></devnotes></procedure>
      <procedure name="WriteComponentRes" visibility="public" file="System.Classes.pas" line="1079">
        <parameters>
          <parameter name="ResName" type="string" paramflags="const"/>
          <parameter name="Instance" type="TComponent" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Writes components and their properties to a stream from a resource file format.
WriteComponentRes is used internally in the streaming system, but can also be called directly when sending data to other applications on disk. WriteComponentRes is used for streaming components that need data, such as a bitmap or icon to be stored in a resource-file format.
WriteComponentRes calls WriteDescendentRes, passing in nil (Delphi) or NULL (C++) as the Ancestor. Therefore, WriteDescendentRes initiates the remainder of the streaming process for a component that, in this case, is not a descendant.
To read a component written with WriteComponentRes, call the ReadComponentRes method.
</summary></devnotes></procedure>
      <procedure name="WriteDescendent" visibility="public" file="System.Classes.pas" line="1080">
        <parameters>
          <parameter name="Instance" type="TComponent" paramflags="const"/>
          <parameter name="Ancestor" type="TComponent" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Streams components and their properties in inherited forms.
Do not call WriteDescendent directly. WriteDescendent is called automatically by WriteComponent.
WriteDescendent constructs a writer object, then calls the writer object's WriteDescendent method to write the component passed in Instance to the stream. Instance is either an inherited form descended from Ancestor or nil (Delphi) or NULL (C++). However, WriteDescendent is never used to write owned components, only to initiate streaming on the root component.
</summary></devnotes></procedure>
      <procedure name="WriteDescendentRes" visibility="public" file="System.Classes.pas" line="1081">
        <parameters>
          <parameter name="ResName" type="string" paramflags="const"/>
          <parameter name="Instance" type="TComponent" paramflags="const"/>
          <parameter name="Ancestor" type="TComponent" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Streams components and their properties in inherited forms.
Do not call WriteDescendentRes directly. WriteDescendentRes is called automatically by WriteComponentRes.
WriteDescendentRes writes a resource-file header to the stream, using the resource name passed in ResName as the name of the resource. It then calls WriteDescendent to write Instance to the stream as a descendant of Ancestor.
</summary></devnotes></procedure>
      <procedure name="WriteResourceHeader" visibility="public" file="System.Classes.pas" line="1082">
        <parameters>
          <parameter name="ResName" type="string" paramflags="const"/>
          <parameter name="FixupInfo" type="Integer" paramflags="out"/>
        </parameters>
      <devnotes><summary>
Writes a resource-file header to the stream.
Do not call WriteResourceHeader; it is used internally. The WriteDescendentRes method calls WriteResourceHeader before writing a component to the stream. This method writes the resource-file header, using the value passed as ResName for the name of the resource. It returns a position in FixupInfo that must be used to adjust the header after the size of the resource is known. WriteDescendentRes calls FixupResourceHeader with the value returned as FixupInfo after streaming out the component.
</summary></devnotes></procedure>
      <procedure name="FixupResourceHeader" visibility="public" file="System.Classes.pas" line="1083">
        <parameters>
          <parameter name="FixupInfo" type="Integer"/>
        </parameters>
      <devnotes><summary>
Patches the resource header for a resource that has been written to the stream.
Do not call FixupResourceHeader it is used internally. The WriteDescendentRes method calls FixupResourceHeader after writing a component to the stream. This method then uses the current position to determine the size of the resource just written and adjust the resource header accordingly.
The FixupInfo parameter is the value returned by WriteResourceHeader when it writes the resource header (before WriteDescendentRes streams out the component.)
</summary></devnotes></procedure>
      <procedure name="ReadResHeader" visibility="public" file="System.Classes.pas" line="1084">
      <devnotes><summary>
Reads a resource-file header from the stream.
Do not call ReadResHeader directly. It is called automatically by ReadComponentRes before reading a component from a resource file.
After reading the resource-file header, ReadResHeader moves the current position of the stream to just beyond the header. If the stream does not contain a valid resource-file header, ReadResHeader raises an EInvalidImage exception.
</summary></devnotes></procedure>
      <property name="Position" visibility="public" read="GetPosition" write="SetPosition" type="Int64" file="System.Classes.pas" line="1085"><devnotes><summary>
Indicates the current offset into the stream for reading and writing.
Use Position to obtain the current position of the stream. This is the number of bytes from the beginning of the streamed data.
</summary></devnotes></property>
      <property name="Size" visibility="public" read="GetSize" write="SetSize64" type="Int64" file="System.Classes.pas" line="1086"><devnotes><summary>
Indicates the size in bytes of the stream.
Use Size to find the size of the stream. Size is used internally in routines that read and write to and from the stream. Setting the Size property of TStream does nothing. However, descendants of TStream can override this property to allow applications to change the size of the resource accessed using the stream. 
The Size property typically indicates the size of the stream in bytes.  But  a descendent of TStream can use -1 to indicate an unknown size.  When the size is unknown, use the return value from TStream.Read to determine end of the stream.

Example of Stream Size using DataSnap and DBX
When you are reading a DataSnap stream in blocks, the actual TStream descendant that is used to read the stream is  TDBXStreamReaderStream.  TDBXStreamReaderStream overrides methods of TStream such as the method System.Classes.TStream.GetSize, which is the reader for the property Size.
DBX connections support reading streams in block. The default block size is 32K. Streams can be passed from the client to the server, or from the server to the client. When the receiver is reading the stream (whether the receiver is the client or the server), the stream is passed from the sender to the receiver in blocks. When the stream is large enough to require multiple block readings, the Size property of the receiver's stream will be -1, which indicates that the size of the stream is unknown. As the receiver reads the stream, DataSnap makes a request to the sender for the next block, as needed. To read the stream, the client calls the Read() method until the return value is less than the value requested.
The following code shows how to read a stream to the end, by checking the return value from Read():

var
  LBuffer: TArray&lt;Byte&gt;;
  LReadCount: Integer;
begin
  SetLength(LBuffer, 1024*10); // 10K buffer for this example.  The buffer size can be larger or smaller.
  repeat
    LReadCount := AStream.Read(LBuffer[0], Length(LBuffer));
    if LReadCount &gt; 0 then
    begin
      // Process buffer
    end;
  until LReadCount &lt; Length(LBuffer);
</summary></devnotes></property>
    </members>
  <devnotes><summary>
TStream is the base class type for stream objects that can read from or write to various kinds of storage media, such as disk files, dynamic memory, and so on.
Use specialized stream objects to read from, write to, or copy information stored in a particular medium. Each descendant of TStream implements methods for transferring information to and from a particular storage medium, such as a disk file, dynamic memory, and so on. In addition to methods for reading, writing, and copying bytes to and from the stream, stream objects permit applications to seek to an arbitrary position in the stream. Properties of TStream provide information about the stream, such as its size and the current position in the stream.
TStream also introduces methods that work in conjunction with components and filers for loading and saving components in simple and inherited forms. These methods are called automatically by global routines that initiate component streaming. They can also be called directly to initiate the streaming process. Note, however, that component streaming always involves two additional objects:

A component object that is passed as a parameter to the stream's methods.
A filer object that is automatically created by the stream, and associated with the stream.
Descendant stream objects, such as memory and file streams used for component streaming, are created automatically by the global functions ReadComponentRes and WriteComponentRes. For streaming other kinds of information, choose a descendent class according to the specific data and storage needs. These include:

TFileStream -- for working with files.
TStringStream -- for manipulating in-memory strings.
TMemoryStream -- for working with a memory buffer.
TWinSocketStream -- for reading and writing over a socket connection.
TOleStream -- for using a COM interface to read and write.</summary></devnotes></class>
  <interface name="IStreamPersist" GUID="{B8CD12A3-267A-11D4-83DA-00C04F60B2DD}" ancestor="IInterface" file="System.Classes.pas" line="1089">
    <procedure name="LoadFromStream" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1091">
      <parameters>
        <parameter name="Stream" type="TStream"/>
      </parameters>
    </procedure>
    <procedure name="SaveToStream" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1092">
      <parameters>
        <parameter name="Stream" type="TStream"/>
      </parameters>
    </procedure>
  </interface>
  <class name="THandleStream" file="System.Classes.pas" line="1097">
    <ancestor name="TStream" namespace="System.Classes">
      <methodref name="GetPosition" visibility="private"/>
      <methodref name="SetPosition" visibility="private"/>
      <methodref name="SetSize64" visibility="private"/>
      <methodref name="Skip" visibility="private"/>
      <methodref name="GetSize" visibility="protected" procflags="virtual"/>
      <methodref name="SetSize" visibility="protected" procflags="overload virtual" symflags="deprecated">
      </methodref>
      <methodref name="SetSize" visibility="protected" procflags="overload virtual"/>
      <methodref name="GetByteCount" visibility="protected"/>
      <methodref name="GetByteCount64" visibility="protected"/>
      <methodref name="Read" visibility="public" procflags="overload virtual"/>
      <methodref name="Write" visibility="public" procflags="overload virtual"/>
      <methodref name="Read" visibility="public" procflags="overload virtual"/>
      <methodref name="Write" visibility="public" procflags="overload virtual"/>
      <methodref name="Read" visibility="public" procflags="overload"/>
      <methodref name="Write" visibility="public" procflags="overload"/>
      <methodref name="Read64" visibility="public" procflags="virtual"/>
      <methodref name="Write64" visibility="public" procflags="virtual"/>
      <methodref name="ReadData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="Seek32" visibility="public" procflags="overload inline"/>
      <methodref name="Seek" visibility="public" procflags="overload virtual"/>
      <methodref name="Seek" visibility="public" procflags="overload virtual"/>
      <methodref name="Seek" visibility="public" procflags="overload inline"/>
      <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
      <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
      <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
      <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
      <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
      <methodref name="WriteBufferData" visibility="public" procflags="overload"/>
      <methodref name="CopyFrom" visibility="public"/>
      <methodref name="ReadComponent" visibility="public"/>
      <methodref name="ReadComponentRes" visibility="public"/>
      <methodref name="WriteComponent" visibility="public"/>
      <methodref name="WriteComponentRes" visibility="public"/>
      <methodref name="WriteDescendent" visibility="public"/>
      <methodref name="WriteDescendentRes" visibility="public"/>
      <methodref name="WriteResourceHeader" visibility="public"/>
      <methodref name="FixupResourceHeader" visibility="public"/>
      <methodref name="ReadResHeader" visibility="public"/>
      <propertyref name="Position" visibility="public"/>
      <propertyref name="Size" visibility="public"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FHandle" type="NativeUInt" visibility="protected" size="4" offset="4" file="System.Classes.pas" line="1099"/>
      <procedure name="SetSize" visibility="protected" procflags="overload override" file="System.Classes.pas" line="1100">
        <parameters>
          <parameter name="NewSize" type="Integer"/>
        </parameters>
      <devnotes><summary>
Sets the end of the file marker to truncate the resource at the indicated position.
Call SetSize to set the size of the resource. SetSize calls Seek to go to the indicated position, and then writes an end of file marker. If the size of the resource cannot be changed, an exception is raised. For example, calling SetSize for a file handle that was opened in fmOpenRead mode will raise an exception.
</summary></devnotes></procedure>
      <procedure name="SetSize" visibility="protected" procflags="overload override" file="System.Classes.pas" line="1101">
        <parameters>
          <parameter name="NewSize" type="Int64" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Sets the end of the file marker to truncate the resource at the indicated position.
Call SetSize to set the size of the resource. SetSize calls Seek to go to the indicated position, and then writes an end of file marker. If the size of the resource cannot be changed, an exception is raised. For example, calling SetSize for a file handle that was opened in fmOpenRead mode will raise an exception.
</summary></devnotes></procedure>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1103">
        <parameters>
          <parameter name="AHandle" type="NativeUInt"/>
        </parameters>
      <devnotes><summary>
Creates an instance of THandleStream.
Call Create to instantiate a THandleStream for a given handle.
The handle must be obtained by opening or creating the resource in the appropriate mode. For example, to create a handle stream for reading from a file, obtain the file handle by opening the file with an fmOpenRead or fmOpenReadWrite mode. To create a handle stream for writing to a file, obtain the file handle by opening the file with an fmOpenWrite or fmOpenReadWrite mode.
</summary></devnotes></constructor>
      <function name="Read" visibility="public" procflags="overload override" file="System.Classes.pas" line="1104">
        <parameters>
          <parameter name="Buffer" paramflags="var"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Reads up to Count bytes of data from the resource associated with the handle stream into Buffer.
Use Read to read data from the resource associated with the handle stream when the number of bytes in the file is not known. Read transfers up to Count bytes from the resource, starting at the current position, and then advances the current position in the resource by the number of bytes actually transferred. Read returns the number of bytes actually transferred, which may be less than Count if the end of file marker is encountered.
All other data-reading methods of a handle stream (ReadBuffer, ReadComponent) call Read to do the actual reading.
</summary></devnotes></function>
      <function name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="1105">
        <parameters>
          <parameter name="Buffer" paramflags="const"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Writes Count bytes from the Buffer to the current position in the resource.
Use Write to write Count bytes to the resource associated with the handle stream, starting at the current position. After writing to the resource, Write advances the current position by the number bytes written, and returns the number of bytes written.
All other data-writing methods of a handle stream (WriteBuffer, WriteComponent) call Write to do the actual writing.
</summary></devnotes></function>
      <function name="Seek" visibility="public" procflags="overload override" file="System.Classes.pas" line="1106">
        <parameters>
          <parameter name="Offset" type="Int64" paramflags="const"/>
          <parameter name="Origin" type="TSeekOrigin"/>
          <retval type="Int64"/>
        </parameters>
      <devnotes><summary>
Resets the current position of the handle stream.
Use Seek to move the current position within the resource associated with the handle stream by the indicated offset. Seek allows an application to read from or write to a particular location within the resource.
The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:



Value

Meaning



soFromBeginning



Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be &gt;= 0.




soFromCurrent



Offset is from the current position in the resource. Seek moves to Position + Offset.




soFromEnd



Offset is from the end of the resource. Offset must be &lt;= 0 to indicate a number of bytes before the end of the file.


Or you can also use TSeekOrigin and its values to indicate where to start a seek operation.
Seek returns the new value of the Position property, the new current position in the resource.
</summary></devnotes></function>
      <property name="Handle" visibility="public" read="FHandle" type="NativeUInt" file="System.Classes.pas" line="1107"><devnotes><summary>
Specifies the handle for the communications resource the stream reads from and writes to.
Read Handle to get the handle for file management functions. To read from or write to the resource, use the methods of the THandleStream object.
Handle is a read-only property. The handle property cannot be changed to allow the handle stream to switch from reading to writing or vice versa. For example, to change from a file handle that is opened in read-only mode to one that is opened in write mode:

Free the stream object.
Call FileClose to close the file.
Reopen the file in write mode and use the handle to create a new instance of a handle stream. Alternately, open a TFileStream object for the file, specifying a write mode for the stream.
Note: Do not call the FileClose function on the Handle until after the THandleStream object has been destroyed.</summary></devnotes></property>
    </members>
  <devnotes><summary>
THandleStream enables applications to read from and write to communications resources identified by a handle.
Use THandleStream to access files, sockets, named pipes, mailslots, or other communications resources that provide a handle when opened. For example, the FileOpen function provides a handle for a file on disk. THandleStream allows applications to use a uniform stream interface when performing I/O using a handle.
To avoid the overhead of managing file handles, use TFileStream to work with disk files.
</summary></devnotes></class>
  <class name="TFileStream" file="System.Classes.pas" line="1112">
    <ancestor name="THandleStream" namespace="System.Classes">
      <methodref name="SetSize" visibility="protected" procflags="overload override"/>
      <methodref name="SetSize" visibility="protected" procflags="overload override"/>
      <methodref name="Create" visibility="public" procflags="constructor"/>
      <methodref name="Read" visibility="public" procflags="overload override"/>
      <methodref name="Write" visibility="public" procflags="overload override"/>
      <methodref name="Seek" visibility="public" procflags="overload override"/>
      <propertyref name="Handle" visibility="public"/>
      <ancestor name="TStream" namespace="System.Classes">
        <methodref name="GetPosition" visibility="private"/>
        <methodref name="SetPosition" visibility="private"/>
        <methodref name="SetSize64" visibility="private"/>
        <methodref name="Skip" visibility="private"/>
        <methodref name="GetSize" visibility="protected" procflags="virtual"/>
        <methodref name="SetSize" visibility="protected" procflags="overload virtual" symflags="deprecated">
        </methodref>
        <methodref name="SetSize" visibility="protected" procflags="overload virtual"/>
        <methodref name="GetByteCount" visibility="protected"/>
        <methodref name="GetByteCount64" visibility="protected"/>
        <methodref name="Read" visibility="public" procflags="overload virtual"/>
        <methodref name="Write" visibility="public" procflags="overload virtual"/>
        <methodref name="Read" visibility="public" procflags="overload virtual"/>
        <methodref name="Write" visibility="public" procflags="overload virtual"/>
        <methodref name="Read" visibility="public" procflags="overload"/>
        <methodref name="Write" visibility="public" procflags="overload"/>
        <methodref name="Read64" visibility="public" procflags="virtual"/>
        <methodref name="Write64" visibility="public" procflags="virtual"/>
        <methodref name="ReadData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="Seek32" visibility="public" procflags="overload inline"/>
        <methodref name="Seek" visibility="public" procflags="overload virtual"/>
        <methodref name="Seek" visibility="public" procflags="overload virtual"/>
        <methodref name="Seek" visibility="public" procflags="overload inline"/>
        <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
        <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
        <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
        <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
        <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
        <methodref name="WriteBufferData" visibility="public" procflags="overload"/>
        <methodref name="CopyFrom" visibility="public"/>
        <methodref name="ReadComponent" visibility="public"/>
        <methodref name="ReadComponentRes" visibility="public"/>
        <methodref name="WriteComponent" visibility="public"/>
        <methodref name="WriteComponentRes" visibility="public"/>
        <methodref name="WriteDescendent" visibility="public"/>
        <methodref name="WriteDescendentRes" visibility="public"/>
        <methodref name="WriteResourceHeader" visibility="public"/>
        <methodref name="FixupResourceHeader" visibility="public"/>
        <methodref name="ReadResHeader" visibility="public"/>
        <propertyref name="Position" visibility="public"/>
        <propertyref name="Size" visibility="public"/>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FFileName" type="string" visibility="class private" size="4" offset="8" file="System.Classes.pas" line="1114"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1116">
        <parameters>
          <parameter name="AFileName" type="string" paramflags="const"/>
          <parameter name="Mode" type="Word"/>
        </parameters>
      <devnotes><summary>
Creates an instance of TFileStream.
Call Create to instantiate a file stream for reading from or writing to the named file. Specify the name of the file and the way the file should be opened as parameters. 
The Mode parameter indicates how the file is to be opened. The Mode parameter consists of an open mode and (possibly) a share mode or'ed together. The open mode must be one of the following values:



Value

Meaning

Declared In



fmCreate



Create a file with the given name. If a file with the given name exists, override the existing file and open it in write mode.



System.Classes




fmOpenRead



Open the file for reading only.



System.SysUtils




fmOpenWrite



Open the file for writing only. Writing to the file completely replaces the current contents.



System.SysUtils




fmOpenReadWrite



Open the file to modify the current contents rather than replace them.



System.SysUtils



The share mode must be one of the following values:



Value

Meaning

Declared In



fmShareCompat



Sharing is compatible with the way FCBs are opened.



System.SysUtils




fmShareExclusive



Other applications cannot open the file for any reason.



System.SysUtils




fmShareDenyWrite



Other applications can open the file for reading but not for writing.



System.SysUtils




fmShareDenyRead



Other applications can open the file for writing but not for reading.



System.SysUtils




fmShareDenyNone



No attempt is made to prevent other applications from reading from or writing to the file.



System.SysUtils


Note: On Windows, the Rights parameter is ignored.
If the file cannot be opened, Create raises an exception. 
</summary></devnotes></constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1117">
        <parameters>
          <parameter name="AFileName" type="string" paramflags="const"/>
          <parameter name="Mode" type="Word"/>
          <parameter name="Rights" type="Cardinal"/>
        </parameters>
      <devnotes><summary>
Creates an instance of TFileStream.
Call Create to instantiate a file stream for reading from or writing to the named file. Specify the name of the file and the way the file should be opened as parameters. 
The Mode parameter indicates how the file is to be opened. The Mode parameter consists of an open mode and (possibly) a share mode or'ed together. The open mode must be one of the following values:



Value

Meaning

Declared In



fmCreate



Create a file with the given name. If a file with the given name exists, override the existing file and open it in write mode.



System.Classes




fmOpenRead



Open the file for reading only.



System.SysUtils




fmOpenWrite



Open the file for writing only. Writing to the file completely replaces the current contents.



System.SysUtils




fmOpenReadWrite



Open the file to modify the current contents rather than replace them.



System.SysUtils



The share mode must be one of the following values:



Value

Meaning

Declared In



fmShareCompat



Sharing is compatible with the way FCBs are opened.



System.SysUtils




fmShareExclusive



Other applications cannot open the file for any reason.



System.SysUtils




fmShareDenyWrite



Other applications can open the file for reading but not for writing.



System.SysUtils




fmShareDenyRead



Other applications can open the file for writing but not for reading.



System.SysUtils




fmShareDenyNone



No attempt is made to prevent other applications from reading from or writing to the file.



System.SysUtils


Note: On Windows, the Rights parameter is ignored.
If the file cannot be opened, Create raises an exception. 
</summary></devnotes></constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="1118">
        <parameters>
        </parameters>
      <devnotes><summary>
Destroys an instance of TFileStream.
Do not call Destroy directly in an application. Instead, call Free, which checks that the TFileStream reference is not nil and only then calls Destroy.
Destroy closes the Handle for the file stream before freeing the object.
</summary></devnotes></destructor>
      <property name="FileName" visibility="public" read="FFileName" type="string" default="0" file="System.Classes.pas" line="1119"><devnotes><summary>
Preserves the file name of the file associated with the file stream.
Use FileName to display the name of the file that TFileStream has accessed from disk. This is a read only property.


</summary></devnotes></property>
    </members>
  <devnotes><summary>
TFileStream enables applications to read from and write to a file on disk.
Use TFileStream to access the information in disk files. TFileStream will open a named file and provide methods to read from or write to it. If an application already has a handle to the file, opened in the appropriate mode, use THandleStream instead.
</summary></devnotes></class>
  <class name="TBufferedFileStream" file="System.Classes.pas" line="1131">
    <devnotes><summary>
TBufferedFileStream adds buffering support to TFileStream.
TBufferedFileStream optimizes multiple consecutive small reads or writes. However, TBufferedFileStream can be used as a drop-in replacement for TFileStream, enabling applications to read from and write to a file on a disk.

Note: TBufferedFileStream will not give performance gain for random position reads or writes, or large reads or writes.</summary></devnotes>
    <ancestor name="TFileStream" namespace="System.Classes">
      <methodref name="Create" visibility="public" procflags="constructor overload"/>
      <methodref name="Create" visibility="public" procflags="constructor overload"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <propertyref name="FileName" visibility="public"/>
      <ancestor name="THandleStream" namespace="System.Classes">
        <methodref name="SetSize" visibility="protected" procflags="overload override"/>
        <methodref name="SetSize" visibility="protected" procflags="overload override"/>
        <methodref name="Create" visibility="public" procflags="constructor"/>
        <methodref name="Read" visibility="public" procflags="overload override"/>
        <methodref name="Write" visibility="public" procflags="overload override"/>
        <methodref name="Seek" visibility="public" procflags="overload override"/>
        <propertyref name="Handle" visibility="public"/>
        <ancestor name="TStream" namespace="System.Classes">
          <methodref name="GetPosition" visibility="private"/>
          <methodref name="SetPosition" visibility="private"/>
          <methodref name="SetSize64" visibility="private"/>
          <methodref name="Skip" visibility="private"/>
          <methodref name="GetSize" visibility="protected" procflags="virtual"/>
          <methodref name="SetSize" visibility="protected" procflags="overload virtual" symflags="deprecated">
          </methodref>
          <methodref name="SetSize" visibility="protected" procflags="overload virtual"/>
          <methodref name="GetByteCount" visibility="protected"/>
          <methodref name="GetByteCount64" visibility="protected"/>
          <methodref name="Read" visibility="public" procflags="overload virtual"/>
          <methodref name="Write" visibility="public" procflags="overload virtual"/>
          <methodref name="Read" visibility="public" procflags="overload virtual"/>
          <methodref name="Write" visibility="public" procflags="overload virtual"/>
          <methodref name="Read" visibility="public" procflags="overload"/>
          <methodref name="Write" visibility="public" procflags="overload"/>
          <methodref name="Read64" visibility="public" procflags="virtual"/>
          <methodref name="Write64" visibility="public" procflags="virtual"/>
          <methodref name="ReadData" visibility="public" procflags="overload">
          </methodref>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload">
          </methodref>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload">
          </methodref>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload">
          </methodref>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="Seek32" visibility="public" procflags="overload inline"/>
          <methodref name="Seek" visibility="public" procflags="overload virtual"/>
          <methodref name="Seek" visibility="public" procflags="overload virtual"/>
          <methodref name="Seek" visibility="public" procflags="overload inline"/>
          <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
          <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
          <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload">
          </methodref>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload">
          </methodref>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
          <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
          <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
          <methodref name="WriteBufferData" visibility="public" procflags="overload"/>
          <methodref name="CopyFrom" visibility="public"/>
          <methodref name="ReadComponent" visibility="public"/>
          <methodref name="ReadComponentRes" visibility="public"/>
          <methodref name="WriteComponent" visibility="public"/>
          <methodref name="WriteComponentRes" visibility="public"/>
          <methodref name="WriteDescendent" visibility="public"/>
          <methodref name="WriteDescendentRes" visibility="public"/>
          <methodref name="WriteResourceHeader" visibility="public"/>
          <methodref name="FixupResourceHeader" visibility="public"/>
          <methodref name="ReadResHeader" visibility="public"/>
          <propertyref name="Position" visibility="public"/>
          <propertyref name="Size" visibility="public"/>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FFilePos" type="Int64" visibility="private" size="8" offset="16" file="System.Classes.pas" line="1133"/>
      <field name="FBufStartPos" type="Int64" visibility="private" size="8" offset="24" file="System.Classes.pas" line="1133"/>
      <field name="FBufEndPos" type="Int64" visibility="private" size="8" offset="32" file="System.Classes.pas" line="1133"/>
      <field name="FBuffer" type="PByte" visibility="private" size="4" offset="40" file="System.Classes.pas" line="1134"/>
      <field name="FBufferSize" type="Integer" visibility="private" size="4" offset="44" file="System.Classes.pas" line="1135"/>
      <field name="FModified" type="Boolean" visibility="private" size="1" offset="48" file="System.Classes.pas" line="1136"/>
      <field name="FBuffered" type="Boolean" visibility="private" size="1" offset="49" file="System.Classes.pas" line="1137"/>
      <procedure name="SetSize" visibility="protected" procflags="overload override" file="System.Classes.pas" line="1139">
        <parameters>
          <parameter name="NewSize" type="Int64" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Sets the end of the file marker to truncate the resource at the indicated position.
System.Classes.TBufferedFileStream.SetSize inherits from System.Classes.THandleStream.SetSize. All content below this line refers to System.Classes.THandleStream.SetSize.
Sets the end of the file marker to truncate the resource at the indicated position.
Call SetSize to set the size of the resource. SetSize calls Seek to go to the indicated position, and then writes an end of file marker. If the size of the resource cannot be changed, an exception is raised. For example, calling SetSize for a file handle that was opened in fmOpenRead mode will raise an exception.
</summary></devnotes></procedure>
      <procedure name="SyncBuffer" visibility="protected" file="System.Classes.pas" line="1146">
        <devnotes><summary>
Writes the buffered data that have not yet been written to the file.
When using a buffered file stream, call SyncBuffer to empty the buffer and write to the file the buffered data that are still not written. 
The ReRead parameter specifies whether the buffer is repopulated or not before the call to SyncBuffer. The possible ReRead values are:

True -- The buffer is refilled with the corresponding data from the file.
False -- The buffer will remain empty until the next read or write operation.</summary></devnotes>
        <parameters>
          <parameter name="ReRead" type="Boolean"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1148">
        <parameters>
          <parameter name="AFileName" type="string" paramflags="const"/>
          <parameter name="Mode" type="Word"/>
          <parameter name="BufferSize" type="Integer">
            <value>
              $8000
            </value>
          </parameter>
        </parameters>
      <devnotes><summary>
Creates an instance of TBufferedFileStream.
Call Create to instantiate a file stream for reading from or writing to the named file. Specify the name of the file and the way the file should be opened as parameters. 
The Mode parameter indicates how the file is to be opened. The Mode parameter consists of an open mode and (possibly) a share mode or'ed together. The open mode must be one of the following values:



Value

Meaning

Declared In



fmCreate



Create a file with the given name. If a file with the given name exists, override the existing file and open it in write mode.



System.Classes




fmOpenRead



Open the file for reading only.



System.SysUtils




fmOpenWrite



Open the file for writing only. Writing to the file completely replaces the current contents.



System.SysUtils




fmOpenReadWrite



Open the file to modify the current contents rather than replace them.



System.SysUtils



The share mode must be one of the following values:



Value

Meaning

Declared In



fmShareCompat



Sharing is compatible with the way FCBs are opened.



System.SysUtils




fmShareExclusive



Other applications cannot open the file for any reason.



System.SysUtils




fmShareDenyWrite



Other applications can open the file for reading but not for writing.



System.SysUtils




fmShareDenyRead



Other applications can open the file for writing but not for reading.



System.SysUtils




fmShareDenyNone



No attempt is made to prevent other applications from reading from or writing to the file.



System.SysUtils


Note: On Windows, the Rights parameter is ignored.
The BufferSize parameter determines the size of the buffer used to read from or write to the file.
If the file cannot be opened, Create raises an exception. 
</summary></devnotes></constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1149">
        <parameters>
          <parameter name="AFileName" type="string" paramflags="const"/>
          <parameter name="Mode" type="Word"/>
          <parameter name="Rights" type="Cardinal"/>
          <parameter name="BufferSize" type="Integer">
            <value>
              $8000
            </value>
          </parameter>
        </parameters>
      <devnotes><summary>
Creates an instance of TBufferedFileStream.
Call Create to instantiate a file stream for reading from or writing to the named file. Specify the name of the file and the way the file should be opened as parameters. 
The Mode parameter indicates how the file is to be opened. The Mode parameter consists of an open mode and (possibly) a share mode or'ed together. The open mode must be one of the following values:



Value

Meaning

Declared In



fmCreate



Create a file with the given name. If a file with the given name exists, override the existing file and open it in write mode.



System.Classes




fmOpenRead



Open the file for reading only.



System.SysUtils




fmOpenWrite



Open the file for writing only. Writing to the file completely replaces the current contents.



System.SysUtils




fmOpenReadWrite



Open the file to modify the current contents rather than replace them.



System.SysUtils



The share mode must be one of the following values:



Value

Meaning

Declared In



fmShareCompat



Sharing is compatible with the way FCBs are opened.



System.SysUtils




fmShareExclusive



Other applications cannot open the file for any reason.



System.SysUtils




fmShareDenyWrite



Other applications can open the file for reading but not for writing.



System.SysUtils




fmShareDenyRead



Other applications can open the file for writing but not for reading.



System.SysUtils




fmShareDenyNone



No attempt is made to prevent other applications from reading from or writing to the file.



System.SysUtils


Note: On Windows, the Rights parameter is ignored.
The BufferSize parameter determines the size of the buffer used to read from or write to the file.
If the file cannot be opened, Create raises an exception. 
</summary></devnotes></constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="1150">
        <parameters>
        </parameters>
      <devnotes><summary>
Destroys this instance of TBufferedFileStream.
</summary></devnotes></destructor>
      <procedure name="FlushBuffer" visibility="public" procflags="inline" file="System.Classes.pas" line="1154">
        <devnotes><summary>
Writes the buffered data that have not yet been written to the file.
When using a buffered file stream, call FlushBuffer to write to the file the data from the buffer that are still not written.
Once you call FlushBuffer, the buffer will remain empty until the next read or write operation.
</summary></devnotes>
      </procedure>
      <function name="Read" visibility="public" procflags="overload override" file="System.Classes.pas" line="1155">
        <parameters>
          <parameter name="Buffer" paramflags="var"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Reads up to Count bytes of data from the resource associated with the handle stream into Buffer.
System.Classes.TBufferedFileStream.Read inherits from System.Classes.THandleStream.Read. All content below this line refers to System.Classes.THandleStream.Read.
Reads up to Count bytes of data from the resource associated with the handle stream into Buffer.
Use Read to read data from the resource associated with the handle stream when the number of bytes in the file is not known. Read transfers up to Count bytes from the resource, starting at the current position, and then advances the current position in the resource by the number of bytes actually transferred. Read returns the number of bytes actually transferred, which may be less than Count if the end of file marker is encountered.
All other data-reading methods of a handle stream (ReadBuffer, ReadComponent) call Read to do the actual reading.
</summary></devnotes></function>
      <function name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="1156">
        <parameters>
          <parameter name="Buffer" paramflags="const"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Writes Count bytes from the Buffer to the current position in the resource.
System.Classes.TBufferedFileStream.Write inherits from System.Classes.THandleStream.Write. All content below this line refers to System.Classes.THandleStream.Write.
Writes Count bytes from the Buffer to the current position in the resource.
Use Write to write Count bytes to the resource associated with the handle stream, starting at the current position. After writing to the resource, Write advances the current position by the number bytes written, and returns the number of bytes written.
All other data-writing methods of a handle stream (WriteBuffer, WriteComponent) call Write to do the actual writing.
</summary></devnotes></function>
      <function name="Seek" visibility="public" procflags="overload override" file="System.Classes.pas" line="1157">
        <parameters>
          <parameter name="Offset" type="Int64" paramflags="const"/>
          <parameter name="Origin" type="TSeekOrigin"/>
          <retval type="Int64"/>
        </parameters>
      <devnotes><summary>
Resets the current position of the handle stream.
System.Classes.TBufferedFileStream.Seek inherits from System.Classes.THandleStream.Seek. All content below this line refers to System.Classes.THandleStream.Seek.
Resets the current position of the handle stream.
Use Seek to move the current position within the resource associated with the handle stream by the indicated offset. Seek allows an application to read from or write to a particular location within the resource.
The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:



Value

Meaning



soFromBeginning



Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be &gt;= 0.




soFromCurrent



Offset is from the current position in the resource. Seek moves to Position + Offset.




soFromEnd



Offset is from the end of the resource. Offset must be &lt;= 0 to indicate a number of bytes before the end of the file.


Or you can also use TSeekOrigin and its values to indicate where to start a seek operation.
Seek returns the new value of the Position property, the new current position in the resource.
</summary></devnotes></function>
    </members>
  </class>
  <class name="TCustomMemoryStream" file="System.Classes.pas" line="1162">
    <ancestor name="TStream" namespace="System.Classes">
      <methodref name="GetPosition" visibility="private"/>
      <methodref name="SetPosition" visibility="private"/>
      <methodref name="SetSize64" visibility="private"/>
      <methodref name="Skip" visibility="private"/>
      <methodref name="GetSize" visibility="protected" procflags="virtual"/>
      <methodref name="SetSize" visibility="protected" procflags="overload virtual" symflags="deprecated">
      </methodref>
      <methodref name="SetSize" visibility="protected" procflags="overload virtual"/>
      <methodref name="GetByteCount" visibility="protected"/>
      <methodref name="GetByteCount64" visibility="protected"/>
      <methodref name="Read" visibility="public" procflags="overload virtual"/>
      <methodref name="Write" visibility="public" procflags="overload virtual"/>
      <methodref name="Read" visibility="public" procflags="overload virtual"/>
      <methodref name="Write" visibility="public" procflags="overload virtual"/>
      <methodref name="Read" visibility="public" procflags="overload"/>
      <methodref name="Write" visibility="public" procflags="overload"/>
      <methodref name="Read64" visibility="public" procflags="virtual"/>
      <methodref name="Write64" visibility="public" procflags="virtual"/>
      <methodref name="ReadData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="Seek32" visibility="public" procflags="overload inline"/>
      <methodref name="Seek" visibility="public" procflags="overload virtual"/>
      <methodref name="Seek" visibility="public" procflags="overload virtual"/>
      <methodref name="Seek" visibility="public" procflags="overload inline"/>
      <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
      <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
      <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
      <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
      <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
      <methodref name="WriteBufferData" visibility="public" procflags="overload"/>
      <methodref name="CopyFrom" visibility="public"/>
      <methodref name="ReadComponent" visibility="public"/>
      <methodref name="ReadComponentRes" visibility="public"/>
      <methodref name="WriteComponent" visibility="public"/>
      <methodref name="WriteComponentRes" visibility="public"/>
      <methodref name="WriteDescendent" visibility="public"/>
      <methodref name="WriteDescendentRes" visibility="public"/>
      <methodref name="WriteResourceHeader" visibility="public"/>
      <methodref name="FixupResourceHeader" visibility="public"/>
      <methodref name="ReadResHeader" visibility="public"/>
      <propertyref name="Position" visibility="public"/>
      <propertyref name="Size" visibility="public"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FMemory" type="Pointer" visibility="private" size="4" offset="4" file="System.Classes.pas" line="1164"/>
      <field name="FSize" type="NativeInt" visibility="private" size="4" offset="8" file="System.Classes.pas" line="1165"/>
      <field name="FPosition" type="NativeInt" visibility="private" size="4" offset="12" file="System.Classes.pas" line="1165"/>
      <procedure name="SetPointer" visibility="protected" file="System.Classes.pas" line="1167">
        <parameters>
          <parameter name="Ptr" type="Pointer"/>
          <parameter name="Size" type="NativeInt" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Replaces the memory buffer associated with the memory stream.
Use SetPointer to set the internal memory buffer, Memory, to be the value passed in by Ptr. Size is the number of bytes Ptr points to.
Descendants of TCustomMemoryStream should use SetPointer to associate the memory stream with the memory buffer that holds the data for the memory stream.

Note: SetPointer does not free the existing value of Memory, if any, when it replaces the memory buffer. Descendants of TCustomMemoryStream that use SetPointer to replace the stream's memory pool should free the memory pointed to by the Memory property before calling SetPointer to replace the memory buffer.</summary></devnotes></procedure>
      <function name="Read" visibility="public" procflags="overload override" file="System.Classes.pas" line="1169">
        <parameters>
          <parameter name="Buffer" paramflags="var"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Reads up to Count bytes from the memory stream into Buffer and advances the current position of the stream by the number of bytes read.
Use Read to read the contents of the memory stream into a buffer, starting at the current position. Read will read up to Count bytes from the current position in Memory. If Count bytes extends beyond the end of the memory buffer, Read will only transfer the data up to the end of the associated memory buffer. Read returns the number of bytes actually transferred to Buffer, and advances the current position accordingly. If the return value is less than Count, it means that reading reached the end of the stream data.
All the other data-reading methods of the memory stream (ReadBuffer, ReadComponent) call Read to do the actual reading.

Note: Read treats Count as an upper bound. The ReadBuffer method, by contrast, raises an exception if Count bytes cannot be read.</summary></devnotes></function>
      <function name="Seek" visibility="public" procflags="overload override" file="System.Classes.pas" line="1170">
        <parameters>
          <parameter name="Offset" type="Int64" paramflags="const"/>
          <parameter name="Origin" type="TSeekOrigin"/>
          <retval type="Int64"/>
        </parameters>
      <devnotes><summary>
Moves the current position of the stream by Offset bytes, relative to the origin specified by Origin.
Use Seek to move the current position within the memory stream by the indicated offset. Seek allows an application to read from or write to a particular location within the Memory associated with the memory stream.
If Offset is a negative number, the seeking is backward from the specified origin. The following table shows the different values of Origin and their meanings for seeking:



Value

Meaning



soBeginning



Offset is from the beginning of Memory. Seek moves to the position Offset. Offset must be &gt;= 0.




soCurrent



Offset is from the current position. Seek moves to Position + Offset.




soEnd



Offset is from the end of Memory. Offset must be &lt;= 0 to indicate a number of bytes before the end of the memory buffer.


Seek returns the new value of the Position property.

Note: Seek does no error checking on the value provided for Offset. Do not call Seek with an offset that would move the current position less than 0 (before the start of Memory) or greater than Size (beyond the end of the memory buffer).</summary></devnotes></function>
      <procedure name="SaveToStream" visibility="public" procflags="virtual" file="System.Classes.pas" line="1171">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Writes the entire contents of the memory stream to the stream object specified by Stream.
Use SaveToStream to copy data that is stored in memory into another storage medium. SaveToStream writes the entire contents of Memory into the indicated stream object, starting at the current position in the stream that was passed as a parameter.
When the Stream parameter is a TFileStream object, SaveToStream does much the same thing as the SaveToFile method. However, SaveToStream writes to the current position in the target stream. Thus, for example, SaveToStream can be used to append the contents of Memory to a file stream, rather than replace the contents of the file the way SaveToFile does.
If the entire contents of the memory stream cannot be written to the target stream, SaveToStream raises an EWriteError exception.
</summary></devnotes></procedure>
      <procedure name="SaveToFile" visibility="public" file="System.Classes.pas" line="1172">
        <parameters>
          <parameter name="FileName" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Writes the entire contents of the memory stream to the file with a given file name.
Use SaveToFile to write the contents of Memory to a file. SaveToFile allows an application to write out the contents of the memory stream without having to explicitly create and free a file stream object. In case the file already exists, the current file contents will be completely replaced with the new. If the named file cannot be created or opened, SaveToFile raises an EFCreateError exception.
</summary></devnotes></procedure>
      <property name="Memory" visibility="public" read="FMemory" type="Pointer" file="System.Classes.pas" line="1173"><devnotes><summary>
Provides direct access to the memory pool allocated for the memory stream.
Use Memory to get access to the memory for the stream. The memory for the stream holds the data that is being transferred by means of the memory stream. Size is the number of bytes of Memory that were allocated, and Position is the current position within Memory.

Note: Memory is a read-only property. Memory can be used to change the contents of the memory, but to set the actual memory the stream works with, descendants of TCustomMemoryStream must assign a pointer to a memory buffer by calling the SetPointer method.</summary></devnotes></property>
    </members>
  <devnotes><summary>
TCustomMemoryStream is an abstract base class used as the common ancestor for memory streams.
Use TCustomMemoryStream as a base class when defining a stream object that can transfer data that is stored in memory. Memory streams are useful for providing file-like access to data that is stored in a less accessible medium. Data can be moved to an internal memory buffer when the memory stream is created. After manipulating the data in a memory stream, the data can be written out to its actual storage medium when the memory stream is destroyed.
Do not instantiate an instance of TCustomMemoryStream. It is an abstract class that implements behavior common to all memory streams. To work with an instance of a memory stream, use one of the descendants of TCustomMemoryStream, such as TMemoryStream or TResourceStream.
</summary></devnotes></class>
  <class name="TMemoryStream" file="System.Classes.pas" line="1178">
    <ancestor name="TCustomMemoryStream" namespace="System.Classes">
      <methodref name="SetPointer" visibility="protected"/>
      <methodref name="Read" visibility="public" procflags="overload override"/>
      <methodref name="Seek" visibility="public" procflags="overload override"/>
      <methodref name="SaveToStream" visibility="public" procflags="virtual"/>
      <methodref name="SaveToFile" visibility="public"/>
      <propertyref name="Memory" visibility="public"/>
      <ancestor name="TStream" namespace="System.Classes">
        <methodref name="GetPosition" visibility="private"/>
        <methodref name="SetPosition" visibility="private"/>
        <methodref name="SetSize64" visibility="private"/>
        <methodref name="Skip" visibility="private"/>
        <methodref name="GetSize" visibility="protected" procflags="virtual"/>
        <methodref name="SetSize" visibility="protected" procflags="overload virtual" symflags="deprecated">
        </methodref>
        <methodref name="SetSize" visibility="protected" procflags="overload virtual"/>
        <methodref name="GetByteCount" visibility="protected"/>
        <methodref name="GetByteCount64" visibility="protected"/>
        <methodref name="Read" visibility="public" procflags="overload virtual"/>
        <methodref name="Write" visibility="public" procflags="overload virtual"/>
        <methodref name="Read" visibility="public" procflags="overload virtual"/>
        <methodref name="Write" visibility="public" procflags="overload virtual"/>
        <methodref name="Read" visibility="public" procflags="overload"/>
        <methodref name="Write" visibility="public" procflags="overload"/>
        <methodref name="Read64" visibility="public" procflags="virtual"/>
        <methodref name="Write64" visibility="public" procflags="virtual"/>
        <methodref name="ReadData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="Seek32" visibility="public" procflags="overload inline"/>
        <methodref name="Seek" visibility="public" procflags="overload virtual"/>
        <methodref name="Seek" visibility="public" procflags="overload virtual"/>
        <methodref name="Seek" visibility="public" procflags="overload inline"/>
        <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
        <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
        <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
        <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
        <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
        <methodref name="WriteBufferData" visibility="public" procflags="overload"/>
        <methodref name="CopyFrom" visibility="public"/>
        <methodref name="ReadComponent" visibility="public"/>
        <methodref name="ReadComponentRes" visibility="public"/>
        <methodref name="WriteComponent" visibility="public"/>
        <methodref name="WriteComponentRes" visibility="public"/>
        <methodref name="WriteDescendent" visibility="public"/>
        <methodref name="WriteDescendentRes" visibility="public"/>
        <methodref name="WriteResourceHeader" visibility="public"/>
        <methodref name="FixupResourceHeader" visibility="public"/>
        <methodref name="ReadResHeader" visibility="public"/>
        <propertyref name="Position" visibility="public"/>
        <propertyref name="Size" visibility="public"/>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FCapacity" type="NativeInt" visibility="private" size="4" offset="16" file="System.Classes.pas" line="1180"/>
      <procedure name="SetCapacity" visibility="protected" procflags="virtual" file="System.Classes.pas" line="1182">
        <parameters>
          <parameter name="NewCapacity" type="NativeInt"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></procedure>
      <function name="Realloc" visibility="protected" procflags="virtual" file="System.Classes.pas" line="1183">
        <parameters>
          <parameter name="NewCapacity" type="NativeInt" paramflags="var"/>
          <retval type="Pointer"/>
        </parameters>
      <devnotes><summary>
Sets the size of the internal buffer to the given capacity.
Realloc is used by the memory stream to resize the internal buffer to the new capacity. Realloc requires a parameter that specifies the new capacity of the internal buffer. A pointer to the start of the internal buffer is returned. If Realloc cannot resize the memory block, an EStreamError error is raised. 
</summary></devnotes></function>
      <property name="Capacity" visibility="protected" read="FCapacity" write="SetCapacity" type="NativeInt" file="System.Classes.pas" line="1184"><devnotes><summary>
Specifies the buffer size allocated for the memory stream.
Use the Capacity property to read or change the capacity of the memory stream. 
Capacity is different from the Size property, which is the size of the stream, in bytes. The value of Capacity is always greater than or equal to the value of Size. 
</summary></devnotes></property>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="1186">
        <parameters>
        </parameters>
      <devnotes><summary>
Destroys an instance of TMemoryStream.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TMemoryStream reference is not nil, and only then calls Destroy.
Destroy a TMemoryStream object when it is no longer needed to store or write data. Destroy calls Clear to free the memory buffer before calling the inherited destructor.
</summary></devnotes></destructor>
      <procedure name="Clear" visibility="public" file="System.Classes.pas" line="1187">
      <devnotes><summary>
Frees the memory buffer, discarding all data associated with the memory stream.
Use Clear to empty the memory buffer for the memory stream and free all associated memory. In addition to freeing the memory associated with the memory buffer, Clear:

Sets the Memory property to nil (Delphi) or NULL (C++).
Sets the Position property to 0.
Sets the Size property to 0.</summary></devnotes></procedure>
      <procedure name="LoadFromStream" visibility="public" file="System.Classes.pas" line="1188">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Loads the entire contents of a stream into the memory buffer.
Use LoadFromStream to fill the memory stream with the contents of the stream specified by the Stream parameter. LoadFromStream always sets the Position of the source stream to 0, before streaming in the number of bytes indicated by the source stream's Size property.
LoadFromStream reallocates the memory buffer so that the contents of the source stream will exactly fit. It sets the Size property accordingly, and then reads the entire contents of the source stream into the memory buffer. Thus, LoadFromStream will discard any pre-existing data stored in the memory stream.
If the source stream is a TFileStream object, LoadFromStream does the same thing as LoadFromFile, except that the application must create and free the TFileStream object. LoadFromStream also allows applications to fill a memory stream object from other types of stream objects.
</summary></devnotes></procedure>
      <procedure name="LoadFromFile" visibility="public" file="System.Classes.pas" line="1189">
        <parameters>
          <parameter name="FileName" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Loads the entire contents of a file into the memory buffer.
Use LoadFromFile to fill the memory stream with the contents of a file. Pass the name of the file as the FileName parameter. LoadFromFile allows an application to read the contents of a file into the memory stream without having to explicitly create and free a file stream object.
LoadFromFile reallocates the memory buffer so that the contents of the file will exactly fit. It sets the Size property accordingly, and then reads the entire contents of the file into the memory buffer. Thus, LoadFromFile will discard any pre-existing data stored in the memory stream.
</summary></devnotes></procedure>
      <procedure name="SetSize" visibility="public" procflags="overload override" file="System.Classes.pas" line="1190">
        <parameters>
          <parameter name="NewSize" type="Int64" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Sets the Size property of the memory stream.
Use SetSize to set the Size of a memory stream before filling it with data. SetSize allocates the memory buffer to hold NewSize bytes, preserving as much of the existing data as possible.
Use SetSize before filling the memory buffer with data from various sources, or from a portion of another stream. If the intended contents of the memory stream is exactly the same as the contents of another stream or file, use LoadFromStream or LoadFromFile instead.
</summary></devnotes></procedure>
      <procedure name="SetSize" visibility="public" procflags="overload override" file="System.Classes.pas" line="1191">
        <parameters>
          <parameter name="NewSize" type="Integer"/>
        </parameters>
      <devnotes><summary>
Sets the Size property of the memory stream.
Use SetSize to set the Size of a memory stream before filling it with data. SetSize allocates the memory buffer to hold NewSize bytes, preserving as much of the existing data as possible.
Use SetSize before filling the memory buffer with data from various sources, or from a portion of another stream. If the intended contents of the memory stream is exactly the same as the contents of another stream or file, use LoadFromStream or LoadFromFile instead.
</summary></devnotes></procedure>
      <function name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="1192">
        <parameters>
          <parameter name="Buffer" paramflags="const"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Writes Count bytes from Buffer to the current position in the memory buffer and updates the current position by Count bytes.
Use Write to insert Count bytes into the memory buffer of the memory stream, starting at the current position. Write will increase the size of the memory buffer, if necessary, to accommodate the data being written in. If the current position is not the end of the memory buffer, Write will overwrite the data following the current position.
Write updates the Size property to Position + Count, and sets the Position property to the new value of Size. Thus, any data that was stored in the memory stream in the Count bytes after the current position is lost when calling Write.
Write always writes the Count bytes in the Buffer, unless there is a memory failure. Thus, for TMemoryStream, Write is equivalent to the WriteBuffer method.
All other data-writing methods of a memory stream (WriteBuffer, WriteComponent) call Write to do the actual writing.
</summary></devnotes></function>
    </members>
  <devnotes><summary>
TMemoryStream is a stream that stores its data in dynamic memory.
Use TMemoryStream to store data in a dynamic memory buffer that is enhanced with file-like access capabilities. TMemoryStream provides the general I/O capabilities of a stream object while introducing methods and properties to manage a dynamic memory buffer.
Memory streams are useful as intermediary objects that can hold information as well as read it from or write it to another storage medium. They provide a useful format for comparing the contents of streams, or for manipulating data that is stored in a less accessible medium.
</summary></devnotes></class>
  <class name="TBytesStream" file="System.Classes.pas" line="1197">
    <ancestor name="TMemoryStream" namespace="System.Classes">
      <methodref name="SetCapacity" visibility="protected" procflags="virtual"/>
      <methodref name="Realloc" visibility="protected" procflags="virtual"/>
      <propertyref name="Capacity" visibility="protected"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="Clear" visibility="public"/>
      <methodref name="LoadFromStream" visibility="public"/>
      <methodref name="LoadFromFile" visibility="public"/>
      <methodref name="SetSize" visibility="public" procflags="overload override"/>
      <methodref name="SetSize" visibility="public" procflags="overload override"/>
      <methodref name="Write" visibility="public" procflags="overload override"/>
      <ancestor name="TCustomMemoryStream" namespace="System.Classes">
        <methodref name="SetPointer" visibility="protected"/>
        <methodref name="Read" visibility="public" procflags="overload override"/>
        <methodref name="Seek" visibility="public" procflags="overload override"/>
        <methodref name="SaveToStream" visibility="public" procflags="virtual"/>
        <methodref name="SaveToFile" visibility="public"/>
        <propertyref name="Memory" visibility="public"/>
        <ancestor name="TStream" namespace="System.Classes">
          <methodref name="GetPosition" visibility="private"/>
          <methodref name="SetPosition" visibility="private"/>
          <methodref name="SetSize64" visibility="private"/>
          <methodref name="Skip" visibility="private"/>
          <methodref name="GetSize" visibility="protected" procflags="virtual"/>
          <methodref name="SetSize" visibility="protected" procflags="overload virtual" symflags="deprecated">
          </methodref>
          <methodref name="SetSize" visibility="protected" procflags="overload virtual"/>
          <methodref name="GetByteCount" visibility="protected"/>
          <methodref name="GetByteCount64" visibility="protected"/>
          <methodref name="Read" visibility="public" procflags="overload virtual"/>
          <methodref name="Write" visibility="public" procflags="overload virtual"/>
          <methodref name="Read" visibility="public" procflags="overload virtual"/>
          <methodref name="Write" visibility="public" procflags="overload virtual"/>
          <methodref name="Read" visibility="public" procflags="overload"/>
          <methodref name="Write" visibility="public" procflags="overload"/>
          <methodref name="Read64" visibility="public" procflags="virtual"/>
          <methodref name="Write64" visibility="public" procflags="virtual"/>
          <methodref name="ReadData" visibility="public" procflags="overload">
          </methodref>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload">
          </methodref>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="ReadData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload">
          </methodref>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload">
          </methodref>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="WriteData" visibility="public" procflags="overload"/>
          <methodref name="Seek32" visibility="public" procflags="overload inline"/>
          <methodref name="Seek" visibility="public" procflags="overload virtual"/>
          <methodref name="Seek" visibility="public" procflags="overload virtual"/>
          <methodref name="Seek" visibility="public" procflags="overload inline"/>
          <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
          <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
          <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload">
          </methodref>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload">
          </methodref>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
          <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
          <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
          <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
          <methodref name="WriteBufferData" visibility="public" procflags="overload"/>
          <methodref name="CopyFrom" visibility="public"/>
          <methodref name="ReadComponent" visibility="public"/>
          <methodref name="ReadComponentRes" visibility="public"/>
          <methodref name="WriteComponent" visibility="public"/>
          <methodref name="WriteComponentRes" visibility="public"/>
          <methodref name="WriteDescendent" visibility="public"/>
          <methodref name="WriteDescendentRes" visibility="public"/>
          <methodref name="WriteResourceHeader" visibility="public"/>
          <methodref name="FixupResourceHeader" visibility="public"/>
          <methodref name="ReadResHeader" visibility="public"/>
          <propertyref name="Position" visibility="public"/>
          <propertyref name="Size" visibility="public"/>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FBytes" type="TBytes" visibility="private" size="4" offset="20" file="System.Classes.pas" line="1199"/>
      <function name="Realloc" visibility="protected" procflags="override" file="System.Classes.pas" line="1201">
        <parameters>
          <parameter name="NewCapacity" type="NativeInt" paramflags="var"/>
          <retval type="Pointer"/>
        </parameters>
      <devnotes><summary>
Sets the size of the internal buffer to the given capacity.
Realloc is used by the memory stream to resize the internal buffer to the new capacity. Realloc requires a parameter that specifies the new capacity of the internal buffer. A pointer to the resized stream of bytes is returned. If Realloc cannot resize the memory block, an EStreamError error is raised. 
</summary></devnotes></function>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1203">
        <parameters>
          <parameter name="ABytes" type="TBytes" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Constructs an object and initializes its data before the object is first used.
System.Classes.TBytesStream.Create inherits from System.TObject.Create. All content below this line refers to System.TObject.Create.
Constructs an object and initializes its data before the object is first used.
Create constructs an object. The purpose, size, and behavior of objects differ greatly. The Create constructor defined by TObject allocates memory but does not initialize data. 
Descendant objects usually define a constructor that creates the particular kind of object and initializes its data.

Note: If an exception escapes from a constructor, the object's destructor is called to clean up the failed instance.</summary></devnotes></constructor>
      <property name="Bytes" visibility="public" read="FBytes" type="TArray&lt;System.Byte&gt;" hoisted="true" file="System.Classes.pas" line="1204"><devnotes><summary>
Specifies the stored data.
The Bytes property returns the buffer in which the data is stored. Use the Size property to find the actual amount of data in the buffer. 
</summary></devnotes></property>
    </members>
  <devnotes><summary>
TBytesStream is a stream that stores its data in bytes.
Use TBytesStream to store data as bytes in a memory buffer. 
Memory streams are useful as intermediary objects that can hold information as well as read it from or write it to another storage medium. They provide a useful format for comparing the contents of streams, or for manipulating data that is stored in a less accessible medium.
</summary></devnotes></class>
  <class name="TStringStream" file="System.Classes.pas" line="1209">
    <ancestor name="TBytesStream" namespace="System.Classes">
      <methodref name="Realloc" visibility="protected" procflags="override"/>
      <methodref name="Create" visibility="public" procflags="constructor overload"/>
      <propertyref name="Bytes" visibility="public"/>
      <ancestor name="TMemoryStream" namespace="System.Classes">
        <methodref name="SetCapacity" visibility="protected" procflags="virtual"/>
        <methodref name="Realloc" visibility="protected" procflags="virtual"/>
        <propertyref name="Capacity" visibility="protected"/>
        <methodref name="Destroy" visibility="public" procflags="destructor override"/>
        <methodref name="Clear" visibility="public"/>
        <methodref name="LoadFromStream" visibility="public"/>
        <methodref name="LoadFromFile" visibility="public"/>
        <methodref name="SetSize" visibility="public" procflags="overload override"/>
        <methodref name="SetSize" visibility="public" procflags="overload override"/>
        <methodref name="Write" visibility="public" procflags="overload override"/>
        <ancestor name="TCustomMemoryStream" namespace="System.Classes">
          <methodref name="SetPointer" visibility="protected"/>
          <methodref name="Read" visibility="public" procflags="overload override"/>
          <methodref name="Seek" visibility="public" procflags="overload override"/>
          <methodref name="SaveToStream" visibility="public" procflags="virtual"/>
          <methodref name="SaveToFile" visibility="public"/>
          <propertyref name="Memory" visibility="public"/>
          <ancestor name="TStream" namespace="System.Classes">
            <methodref name="GetPosition" visibility="private"/>
            <methodref name="SetPosition" visibility="private"/>
            <methodref name="SetSize64" visibility="private"/>
            <methodref name="Skip" visibility="private"/>
            <methodref name="GetSize" visibility="protected" procflags="virtual"/>
            <methodref name="SetSize" visibility="protected" procflags="overload virtual" symflags="deprecated">
            </methodref>
            <methodref name="SetSize" visibility="protected" procflags="overload virtual"/>
            <methodref name="GetByteCount" visibility="protected"/>
            <methodref name="GetByteCount64" visibility="protected"/>
            <methodref name="Read" visibility="public" procflags="overload virtual"/>
            <methodref name="Write" visibility="public" procflags="overload virtual"/>
            <methodref name="Read" visibility="public" procflags="overload virtual"/>
            <methodref name="Write" visibility="public" procflags="overload virtual"/>
            <methodref name="Read" visibility="public" procflags="overload"/>
            <methodref name="Write" visibility="public" procflags="overload"/>
            <methodref name="Read64" visibility="public" procflags="virtual"/>
            <methodref name="Write64" visibility="public" procflags="virtual"/>
            <methodref name="ReadData" visibility="public" procflags="overload">
            </methodref>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload">
            </methodref>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="ReadData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload">
            </methodref>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload">
            </methodref>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="WriteData" visibility="public" procflags="overload"/>
            <methodref name="Seek32" visibility="public" procflags="overload inline"/>
            <methodref name="Seek" visibility="public" procflags="overload virtual"/>
            <methodref name="Seek" visibility="public" procflags="overload virtual"/>
            <methodref name="Seek" visibility="public" procflags="overload inline"/>
            <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
            <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
            <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload">
            </methodref>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload">
            </methodref>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
            <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
            <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
            <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
            <methodref name="WriteBufferData" visibility="public" procflags="overload"/>
            <methodref name="CopyFrom" visibility="public"/>
            <methodref name="ReadComponent" visibility="public"/>
            <methodref name="ReadComponentRes" visibility="public"/>
            <methodref name="WriteComponent" visibility="public"/>
            <methodref name="WriteComponentRes" visibility="public"/>
            <methodref name="WriteDescendent" visibility="public"/>
            <methodref name="WriteDescendentRes" visibility="public"/>
            <methodref name="WriteResourceHeader" visibility="public"/>
            <methodref name="FixupResourceHeader" visibility="public"/>
            <methodref name="ReadResHeader" visibility="public"/>
            <propertyref name="Position" visibility="public"/>
            <propertyref name="Size" visibility="public"/>
            <ancestor name="TObject" namespace="System">
              <methodref name="Create" visibility="public" procflags="constructor">
              </methodref>
              <methodref name="Free" visibility="public">
              </methodref>
              <methodref name="DisposeOf" visibility="public" procflags="inline">
              </methodref>
              <methodref name="InitInstance" visibility="public" procflags="class">
              </methodref>
              <methodref name="CleanupInstance" visibility="public">
              </methodref>
              <methodref name="ClassType" visibility="public" procflags="inline">
              </methodref>
              <methodref name="ClassName" visibility="public" procflags="class">
              </methodref>
              <methodref name="ClassNameIs" visibility="public" procflags="class">
              </methodref>
              <methodref name="ClassParent" visibility="public" procflags="class inline">
              </methodref>
              <methodref name="ClassInfo" visibility="public" procflags="class inline">
              </methodref>
              <methodref name="InstanceSize" visibility="public" procflags="class inline">
              </methodref>
              <methodref name="InheritsFrom" visibility="public" procflags="class">
              </methodref>
              <methodref name="MethodAddress" visibility="public" procflags="class overload">
              </methodref>
              <methodref name="MethodAddress" visibility="public" procflags="class overload">
              </methodref>
              <methodref name="MethodName" visibility="public" procflags="class">
              </methodref>
              <methodref name="QualifiedClassName" visibility="public" procflags="class">
              </methodref>
              <methodref name="FieldAddress" visibility="public" procflags="overload">
              </methodref>
              <methodref name="FieldAddress" visibility="public" procflags="overload">
              </methodref>
              <methodref name="GetInterface" visibility="public">
              </methodref>
              <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
              </methodref>
              <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
              </methodref>
              <methodref name="UnitName" visibility="public" procflags="class">
              </methodref>
              <methodref name="UnitScope" visibility="public" procflags="class">
              </methodref>
              <methodref name="Equals" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="GetHashCode" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="ToString" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="SafeCallException" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="AfterConstruction" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="Dispatch" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="DefaultHandler" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="NewInstance" visibility="public" procflags="class virtual">
              </methodref>
              <methodref name="FreeInstance" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="Destroy" visibility="public" procflags="destructor virtual">
              </methodref>
              <methodref name="GetDisposed" visibility="protected" procflags="inline">
              </methodref>
              <methodref name="CheckDisposed" visibility="protected" procflags="inline">
              </methodref>
              <propertyref name="Disposed" visibility="protected">
              </propertyref>
            </ancestor>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FEncoding" type="TEncoding" visibility="private" size="4" offset="24" file="System.Classes.pas" line="1211"/>
      <field name="FOwnsEncoding" type="Boolean" visibility="private" size="1" offset="28" file="System.Classes.pas" line="1212"/>
      <function name="GetDataString" visibility="private" file="System.Classes.pas" line="1213">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1215">
        <parameters>
        </parameters>
      <devnotes><summary>
Creates an instance of TStringStream.
Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.
</summary></devnotes></constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1216">
        <parameters>
          <parameter name="AString" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Creates an instance of TStringStream.
Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.
</summary></devnotes></constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1218">
        <parameters>
          <parameter name="AString" type="RawByteString" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Creates an instance of TStringStream.
Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.
</summary></devnotes></constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1220">
        <devnotes><summary>
Creates an instance of TStringStream.
Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.
</summary></devnotes>
        <parameters>
          <parameter name="AString" type="string" paramflags="const"/>
          <parameter name="AEncoding" type="TEncoding"/>
          <parameter name="AOwnsEncoding" type="Boolean">
            <value>
              True
            </value>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1221">
        <parameters>
          <parameter name="AString" type="string" paramflags="const"/>
          <parameter name="ACodePage" type="Integer"/>
        </parameters>
      <devnotes><summary>
Creates an instance of TStringStream.
Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.
</summary></devnotes></constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1222">
        <parameters>
          <parameter name="ABytes" type="TBytes" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Creates an instance of TStringStream.
Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.
</summary></devnotes></constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="1223">
        <devnotes><summary>
Destroys an instance of TMemoryStream.
System.Classes.TStringStream.Destroy inherits from System.Classes.TMemoryStream.Destroy. All content below this line refers to System.Classes.TMemoryStream.Destroy.
Destroys an instance of TMemoryStream.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TMemoryStream reference is not nil, and only then calls Destroy.
Destroy a TMemoryStream object when it is no longer needed to store or write data. Destroy calls Clear to free the memory buffer before calling the inherited destructor.
</summary></devnotes>
        <parameters>
        </parameters>
      </destructor>
      <function name="ReadString" visibility="public" file="System.Classes.pas" line="1224">
        <parameters>
          <parameter name="Count" type="Integer"/>
          <retval type="string"/>
        </parameters>
      <devnotes><summary>
Returns a string that consists of up to Count bytes from the current position in the string stream, and advances the current position of the stream by the number of bytes read.
Use Read to read the contents of the string stream into a string, starting at the current position. If Count extends beyond the end of the DataString, the returned string will only contain the characters up to the end of DataString, and the current position is advanced accordingly.

Note: ReadString does the same thing as Read, except that it returns a string rather than filling a buffer.</summary></devnotes></function>
      <procedure name="WriteString" visibility="public" file="System.Classes.pas" line="1225">
        <parameters>
          <parameter name="AString" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Concatenates a specified string to the current position in the string stream, and updates the current position accordingly.
Use WriteString to replace the end of the string from the current position on with the string specified by the AString parameter. WriteString changes the Size property to reflect the new length of the DataString.
</summary></devnotes></procedure>
      <property name="DataString" visibility="public" read="GetDataString" type="string" default="0" file="System.Classes.pas" line="1226"><devnotes><summary>
Provides direct access to the string that stores the text represented by the TStringStream object.
Use DataString to get access to the text of the stream. The text represents the information that is being transferred by means of the string stream. Size is the number of bytes in the string, and Position is the current position within DataString.

Note: DataString is a read-only property. DataString can be used to change the contents of the string, but applications can't change the DataString itself.</summary></devnotes></property>
      <property name="Encoding" visibility="public" read="FEncoding" type="TEncoding" file="System.Classes.pas" line="1227"><devnotes><summary>
Represents the encoding used internally by the TStringStream instance to store the data.
Encoding represents the encoding that is used to get the corresponding array of bytes from a given string, or to obtain the corresponding string from the contained array of bytes. (A string stream contains an array of bytes.)
The encoding of a stream string is set in the constructor (you can specify what encoding to use).
</summary></devnotes></property>
    </members>
  <devnotes><summary>
TStringStream provides file-like access to information stored as a long string.
Use TStringStream to store data as a long string enhanced with I/O capabilities. TStringStream is useful as an intermediary object that can hold text as well as read it from or write it to another storage medium. TStringStream provides a mechanism for manipulating text that is obtained from a less accessible medium.
</summary></devnotes></class>
  <class name="TResourceStream" file="System.Classes.pas" line="1232">
    <ancestor name="TCustomMemoryStream" namespace="System.Classes">
      <methodref name="SetPointer" visibility="protected"/>
      <methodref name="Read" visibility="public" procflags="overload override"/>
      <methodref name="Seek" visibility="public" procflags="overload override"/>
      <methodref name="SaveToStream" visibility="public" procflags="virtual"/>
      <methodref name="SaveToFile" visibility="public"/>
      <propertyref name="Memory" visibility="public"/>
      <ancestor name="TStream" namespace="System.Classes">
        <methodref name="GetPosition" visibility="private"/>
        <methodref name="SetPosition" visibility="private"/>
        <methodref name="SetSize64" visibility="private"/>
        <methodref name="Skip" visibility="private"/>
        <methodref name="GetSize" visibility="protected" procflags="virtual"/>
        <methodref name="SetSize" visibility="protected" procflags="overload virtual" symflags="deprecated">
        </methodref>
        <methodref name="SetSize" visibility="protected" procflags="overload virtual"/>
        <methodref name="GetByteCount" visibility="protected"/>
        <methodref name="GetByteCount64" visibility="protected"/>
        <methodref name="Read" visibility="public" procflags="overload virtual"/>
        <methodref name="Write" visibility="public" procflags="overload virtual"/>
        <methodref name="Read" visibility="public" procflags="overload virtual"/>
        <methodref name="Write" visibility="public" procflags="overload virtual"/>
        <methodref name="Read" visibility="public" procflags="overload"/>
        <methodref name="Write" visibility="public" procflags="overload"/>
        <methodref name="Read64" visibility="public" procflags="virtual"/>
        <methodref name="Write64" visibility="public" procflags="virtual"/>
        <methodref name="ReadData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="Seek32" visibility="public" procflags="overload inline"/>
        <methodref name="Seek" visibility="public" procflags="overload virtual"/>
        <methodref name="Seek" visibility="public" procflags="overload virtual"/>
        <methodref name="Seek" visibility="public" procflags="overload inline"/>
        <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
        <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
        <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
        <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
        <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
        <methodref name="WriteBufferData" visibility="public" procflags="overload"/>
        <methodref name="CopyFrom" visibility="public"/>
        <methodref name="ReadComponent" visibility="public"/>
        <methodref name="ReadComponentRes" visibility="public"/>
        <methodref name="WriteComponent" visibility="public"/>
        <methodref name="WriteComponentRes" visibility="public"/>
        <methodref name="WriteDescendent" visibility="public"/>
        <methodref name="WriteDescendentRes" visibility="public"/>
        <methodref name="WriteResourceHeader" visibility="public"/>
        <methodref name="FixupResourceHeader" visibility="public"/>
        <methodref name="ReadResHeader" visibility="public"/>
        <propertyref name="Position" visibility="public"/>
        <propertyref name="Size" visibility="public"/>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="HResInfo" type="NativeUInt" visibility="private" size="4" offset="16" file="System.Classes.pas" line="1234"/>
      <field name="HGlobal" type="NativeUInt" visibility="private" size="4" offset="20" file="System.Classes.pas" line="1235"/>
      <procedure name="Initialize" visibility="private" file="System.Classes.pas" line="1236">
        <parameters>
          <parameter name="Instance" type="NativeUInt"/>
          <parameter name="Name" type="PWideChar"/>
          <parameter name="ResType" type="PWideChar"/>
          <parameter name="FromID" type="Boolean"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1238">
        <parameters>
          <parameter name="Instance" type="NativeUInt"/>
          <parameter name="ResName" type="string" paramflags="const"/>
          <parameter name="ResType" type="PWideChar"/>
        </parameters>
      <devnotes><summary>
Creates an instance of TResourceStream associated with a particular resource name and type.
Call Create to instantiate a TResourceStream, passing in parameters that identify the resource in a specified instance. TResourceStream finds the resource data and loads it into the Memory buffer for the TResourceStream.
The Instance parameter is the instance handle associated with the executable or shared library that contains the resource.
In the first constructor syntax, the ResName is the string associated with the resource in the .rc file that was compiled with the application. If the resource is associated with an integer ID rather than a string, use the string representation of the integer after a pound sign. Thus, for example, a resource with an integer identifier of 128 be identified by a ResName of #128.

Note:  Specifying resources by ID requires less memory than specifying resources by name.
The ResType parameter is a string identifying the type of the resource. Applications can define their own resource types and identify them by name in the .rc file. In addition, there are a number of predefined resource types (which reflect Windows resource types). To identify a resource that is one of the predefined resource types, set ResType to the appropriate value from the following table:





ResType

Type of resource



RT_ACCELERATOR



Accelerator table




RT_BITMAP



Bitmap resource




RT_DIALOG



Dialog box




RT_FONT



Font resource




RT_FONTDIR



Font directory resource




RT_MENU



Menu resource




RT_RCDATA



Application-defined resource (raw data)




RT_STRING



String-table entry




RT_MESSAGETABLE



Message-table entry




RT_CURSOR



Hardware-dependent cursor resource




RT_GROUP_CURSOR



Hardware-independent cursor resource




RT_ICON



Hardware-dependent icon resource




RT_GROUP_ICON



Hardware-independent icon resource




RT_VERSION



Version resource




</summary></devnotes></constructor>
      <constructor name="CreateFromID" visibility="public" file="System.Classes.pas" line="1239">
        <parameters>
          <parameter name="Instance" type="NativeUInt"/>
          <parameter name="ResID" type="Integer"/>
          <parameter name="ResType" type="PWideChar"/>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="1240">
        <parameters>
        </parameters>
      <devnotes><summary>
Destroys an instance of TResourceStream.
Do not call Destroy directly in an application to destroy an instance of TResourceStream. Instead, call Free. Free verifies that the TResourceStream reference is not nil, and only then calls Destroy.
Destroy frees the memory buffer that stores the resource before calling the inherited destructor.
</summary></devnotes></destructor>
      <function name="Write" visibility="public" procflags="overload final override" file="System.Classes.pas" line="1241">
        <parameters>
          <parameter name="Buffer" paramflags="const"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Overrides the inherited method to raise an exception when an attempt is made to write the resource back to the application.
Applications should not use a TResourceStream to write the resources of the running application. Write overrides the inherited method to raise an EStreamError exception when an application tries to write to the application's resources.
As all other data-writing methods of TResourceStream (WriteBuffer, WriteComponent) call Write to do the actual writing, calling any of the data-writing methods of TResourceStream will raise an exception.
</summary></devnotes></function>
    </members>
  <devnotes><summary>
TResourceStream is a memory stream that provides access to the compiled resources in an application.
Use TResourceStream to read the resources of an application. An instance of TResourceStream holds the value of a single resource in a memory buffer where it is accessible to the application.
The global ReadComponentRes function uses TResourceStream to access the compiled resources used by the application.
</summary></devnotes></class>
  <class name="TPointerStream" file="System.Classes.pas" line="1246">
    <ancestor name="TCustomMemoryStream" namespace="System.Classes">
      <methodref name="SetPointer" visibility="protected"/>
      <methodref name="Read" visibility="public" procflags="overload override"/>
      <methodref name="Seek" visibility="public" procflags="overload override"/>
      <methodref name="SaveToStream" visibility="public" procflags="virtual"/>
      <methodref name="SaveToFile" visibility="public"/>
      <propertyref name="Memory" visibility="public"/>
      <ancestor name="TStream" namespace="System.Classes">
        <methodref name="GetPosition" visibility="private"/>
        <methodref name="SetPosition" visibility="private"/>
        <methodref name="SetSize64" visibility="private"/>
        <methodref name="Skip" visibility="private"/>
        <methodref name="GetSize" visibility="protected" procflags="virtual"/>
        <methodref name="SetSize" visibility="protected" procflags="overload virtual" symflags="deprecated">
        </methodref>
        <methodref name="SetSize" visibility="protected" procflags="overload virtual"/>
        <methodref name="GetByteCount" visibility="protected"/>
        <methodref name="GetByteCount64" visibility="protected"/>
        <methodref name="Read" visibility="public" procflags="overload virtual"/>
        <methodref name="Write" visibility="public" procflags="overload virtual"/>
        <methodref name="Read" visibility="public" procflags="overload virtual"/>
        <methodref name="Write" visibility="public" procflags="overload virtual"/>
        <methodref name="Read" visibility="public" procflags="overload"/>
        <methodref name="Write" visibility="public" procflags="overload"/>
        <methodref name="Read64" visibility="public" procflags="virtual"/>
        <methodref name="Write64" visibility="public" procflags="virtual"/>
        <methodref name="ReadData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="ReadData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="WriteData" visibility="public" procflags="overload"/>
        <methodref name="Seek32" visibility="public" procflags="overload inline"/>
        <methodref name="Seek" visibility="public" procflags="overload virtual"/>
        <methodref name="Seek" visibility="public" procflags="overload virtual"/>
        <methodref name="Seek" visibility="public" procflags="overload inline"/>
        <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
        <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
        <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload">
        </methodref>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
        <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
        <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
        <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
        <methodref name="WriteBufferData" visibility="public" procflags="overload"/>
        <methodref name="CopyFrom" visibility="public"/>
        <methodref name="ReadComponent" visibility="public"/>
        <methodref name="ReadComponentRes" visibility="public"/>
        <methodref name="WriteComponent" visibility="public"/>
        <methodref name="WriteComponentRes" visibility="public"/>
        <methodref name="WriteDescendent" visibility="public"/>
        <methodref name="WriteDescendentRes" visibility="public"/>
        <methodref name="WriteResourceHeader" visibility="public"/>
        <methodref name="FixupResourceHeader" visibility="public"/>
        <methodref name="ReadResHeader" visibility="public"/>
        <propertyref name="Position" visibility="public"/>
        <propertyref name="Size" visibility="public"/>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FReadOnly" type="Boolean" visibility="private" size="1" offset="16" file="System.Classes.pas" line="1248"/>
      <procedure name="SetSize" visibility="protected" procflags="overload override" file="System.Classes.pas" line="1250">
        <parameters>
          <parameter name="NewSize" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="SetSize" visibility="protected" procflags="overload override" file="System.Classes.pas" line="1251">
        <parameters>
          <parameter name="NewSize" type="Int64" paramflags="const"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1253">
        <parameters>
          <parameter name="Ptr" type="Pointer"/>
          <parameter name="Size" type="NativeInt" paramflags="const"/>
          <parameter name="ReadOnly" type="Boolean">
            <value>
              False
            </value>
          </parameter>
        </parameters>
      </constructor>
      <procedure name="SetPointer" visibility="public" file="System.Classes.pas" line="1254">
        <parameters>
          <parameter name="Ptr" type="Pointer"/>
          <parameter name="Size" type="NativeInt" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="1255">
        <parameters>
          <parameter name="Buffer" paramflags="const"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
    </members>
  </class>
  <enum name="TStreamOwnership" file="System.Classes.pas" line="1261">
    <element value="0" name="soReference" file="System.Classes.pas" line="1261"/>
    <element value="1" name="soOwned" file="System.Classes.pas" line="1261"/>
  </enum>
  <class name="TStreamAdapter" file="System.Classes.pas" line="1263">
    <ancestor name="TInterfacedObject" namespace="System">
      <interfaces>
        <implements name="IInterface"/>
      </interfaces>
      <methodref name="GetRefCount" visibility="private" procflags="inline">
      </methodref>
      <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
      </methodref>
      <methodref name="QueryInterface" visibility="protected">
      </methodref>
      <methodref name="_AddRef" visibility="protected">
      </methodref>
      <methodref name="_Release" visibility="protected">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="override">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="override">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class override">
      </methodref>
      <propertyref name="RefCount" visibility="public">
      </propertyref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <interfaces>
      <implements name="IStream"/>
    </interfaces>
    <members>
      <field name="FStream" type="TStream" visibility="private" size="4" offset="12" file="System.Classes.pas" line="1265"/>
      <field name="FOwnership" type="TStreamOwnership" visibility="private" size="1" offset="16" file="System.Classes.pas" line="1266"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1268">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="Ownership" type="TStreamOwnership">
            <value>
              soReference
            </value>
          </parameter>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="1269">
        <parameters>
        </parameters>
      </destructor>
      <function name="Read" visibility="public" procflags="virtual" callconv="stdcall" file="System.Classes.pas" line="1270">
        <parameters>
          <parameter name="pv" type="Pointer"/>
          <parameter name="cb" type="Cardinal"/>
          <parameter name="pcbRead" type="PFixedUInt"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="Write" visibility="public" procflags="virtual" callconv="stdcall" file="System.Classes.pas" line="1271">
        <parameters>
          <parameter name="pv" type="Pointer"/>
          <parameter name="cb" type="Cardinal"/>
          <parameter name="pcbWritten" type="PFixedUInt"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="Seek" visibility="public" procflags="virtual" callconv="stdcall" file="System.Classes.pas" line="1272">
        <parameters>
          <parameter name="dlibMove" type="Int64"/>
          <parameter name="dwOrigin" type="Cardinal"/>
          <parameter name="libNewPosition" type="UInt64" paramflags="out"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="SetSize" visibility="public" procflags="virtual" callconv="stdcall" file="System.Classes.pas" line="1273">
        <parameters>
          <parameter name="libNewSize" type="UInt64"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="CopyTo" visibility="public" procflags="virtual" callconv="stdcall" file="System.Classes.pas" line="1274">
        <parameters>
          <parameter name="stm" type="IStream"/>
          <parameter name="cb" type="UInt64"/>
          <parameter name="cbRead" type="UInt64" paramflags="out"/>
          <parameter name="cbWritten" type="UInt64" paramflags="out"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="Commit" visibility="public" procflags="virtual" callconv="stdcall" file="System.Classes.pas" line="1275">
        <parameters>
          <parameter name="grfCommitFlags" type="Cardinal"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="Revert" visibility="public" procflags="virtual" callconv="stdcall" file="System.Classes.pas" line="1276">
        <parameters>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="LockRegion" visibility="public" procflags="virtual" callconv="stdcall" file="System.Classes.pas" line="1277">
        <parameters>
          <parameter name="libOffset" type="UInt64"/>
          <parameter name="cb" type="UInt64"/>
          <parameter name="dwLockType" type="Cardinal"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="UnlockRegion" visibility="public" procflags="virtual" callconv="stdcall" file="System.Classes.pas" line="1278">
        <parameters>
          <parameter name="libOffset" type="UInt64"/>
          <parameter name="cb" type="UInt64"/>
          <parameter name="dwLockType" type="Cardinal"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="Stat" visibility="public" procflags="virtual" callconv="stdcall" file="System.Classes.pas" line="1279">
        <parameters>
          <parameter name="statstg" type="tagSTATSTG" paramflags="out"/>
          <parameter name="grfStatFlag" type="Cardinal"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="Clone" visibility="public" procflags="virtual" callconv="stdcall" file="System.Classes.pas" line="1280">
        <parameters>
          <parameter name="stm" type="IStream" paramflags="out"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <property name="Stream" visibility="public" read="FStream" type="TStream" file="System.Classes.pas" line="1281"/>
      <property name="StreamOwnership" visibility="public" read="FOwnership" write="FOwnership" type="TStreamOwnership" file="System.Classes.pas" line="1282"/>
    </members>
  </class>
  <type name="TGetClass" file="System.Classes.pas" line="1287" procflags="closure">
  </type>
  <class name="TClassFinder" file="System.Classes.pas" line="1289">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FGroups" type="TList&lt;System.TObject&gt;" visibility="private" size="4" offset="4" file="System.Classes.pas" line="1291"/>
      <field name="FClass" type="TPersistentClass" visibility="private" size="4" offset="8" file="System.Classes.pas" line="1292"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1294">
        <parameters>
          <parameter name="AClass" type="TPersistentClass">
            <value>
              nil
            </value>
          </parameter>
          <parameter name="AIncludeActiveGroups" type="Boolean">
            <value>
              False
            </value>
          </parameter>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="1296">
        <parameters>
        </parameters>
      </destructor>
      <function name="GetClass" visibility="public" file="System.Classes.pas" line="1298">
        <parameters>
          <parameter name="AClassName" type="string" paramflags="const"/>
          <retval type="TPersistentClass"/>
        </parameters>
      </function>
      <procedure name="GetClasses" visibility="public" file="System.Classes.pas" line="1299">
        <parameters>
          <parameter name="Proc" type="TGetClass"/>
        </parameters>
      </procedure>
      <property name="FinderClass" visibility="public" read="FClass" type="TPersistentClass" file="System.Classes.pas" line="1301"/>
    </members>
  </class>
  <enum name="TValueType" file="System.Classes.pas" line="1306">
    <element value="0" name="vaNull" file="System.Classes.pas" line="1306"/>
    <element value="1" name="vaList" file="System.Classes.pas" line="1306"/>
    <element value="2" name="vaInt8" file="System.Classes.pas" line="1306"/>
    <element value="3" name="vaInt16" file="System.Classes.pas" line="1306"/>
    <element value="4" name="vaInt32" file="System.Classes.pas" line="1306"/>
    <element value="5" name="vaExtended" file="System.Classes.pas" line="1306"/>
    <element value="6" name="vaString" file="System.Classes.pas" line="1307"/>
    <element value="7" name="vaIdent" file="System.Classes.pas" line="1307"/>
    <element value="8" name="vaFalse" file="System.Classes.pas" line="1307"/>
    <element value="9" name="vaTrue" file="System.Classes.pas" line="1307"/>
    <element value="10" name="vaBinary" file="System.Classes.pas" line="1307"/>
    <element value="11" name="vaSet" file="System.Classes.pas" line="1307"/>
    <element value="12" name="vaLString" file="System.Classes.pas" line="1307"/>
    <element value="13" name="vaNil" file="System.Classes.pas" line="1308"/>
    <element value="14" name="vaCollection" file="System.Classes.pas" line="1308"/>
    <element value="15" name="vaSingle" file="System.Classes.pas" line="1308"/>
    <element value="16" name="vaCurrency" file="System.Classes.pas" line="1308"/>
    <element value="17" name="vaDate" file="System.Classes.pas" line="1308"/>
    <element value="18" name="vaWString" file="System.Classes.pas" line="1308"/>
    <element value="19" name="vaInt64" file="System.Classes.pas" line="1309"/>
    <element value="20" name="vaUTF8String" file="System.Classes.pas" line="1309"/>
    <element value="21" name="vaDouble" file="System.Classes.pas" line="1309"/>
  </enum>
  <enum name="TFilerFlag" file="System.Classes.pas" line="1311">
    <element value="0" name="ffInherited" file="System.Classes.pas" line="1311"/>
    <element value="1" name="ffChildPos" file="System.Classes.pas" line="1311"/>
    <element value="2" name="ffInline" file="System.Classes.pas" line="1311"/>
  </enum>
  <set name="TFilerFlags" type="TFilerFlag" file="System.Classes.pas" line="1312">
    <element name="ffInherited"/>
    <element name="ffChildPos"/>
    <element name="ffInline"/>
  </set>
  <type name="TReaderProc" file="System.Classes.pas" line="1314" procflags="closure">
  </type>
  <type name="TWriterProc" file="System.Classes.pas" line="1315" procflags="closure">
  </type>
  <type name="TStreamProc" file="System.Classes.pas" line="1316" procflags="closure">
  </type>
  <interface name="IInterfaceComponentReference" GUID="{E28B1858-EC86-4559-8FCD-6B4F824151ED}" ancestor="IInterface" file="System.Classes.pas" line="1318">
    <function name="GetComponent" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1320">
      <parameters>
        <retval type="TComponent"/>
      </parameters>
    </function>
  </interface>
  <class name="TFiler" file="System.Classes.pas" line="1323">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FStream" type="TStream" visibility="private" size="4" offset="4" file="System.Classes.pas" line="1325"/>
      <field name="FBuffer" type="TBytes" visibility="private" size="4" offset="8" file="System.Classes.pas" line="1326"/>
      <field name="FBufSize" type="NativeInt" visibility="private" size="4" offset="12" file="System.Classes.pas" line="1327"/>
      <field name="FBufPos" type="NativeInt" visibility="private" size="4" offset="16" file="System.Classes.pas" line="1328"/>
      <field name="FBufEnd" type="NativeInt" visibility="private" size="4" offset="20" file="System.Classes.pas" line="1329"/>
      <field name="FRoot" type="TComponent" visibility="private" size="4" offset="24" file="System.Classes.pas" line="1330"/>
      <field name="FLookupRoot" type="TComponent" visibility="private" size="4" offset="28" file="System.Classes.pas" line="1331"/>
      <field name="FAncestor" type="TPersistent" visibility="private" size="4" offset="32" file="System.Classes.pas" line="1332"/>
      <field name="FIgnoreChildren" type="Boolean" visibility="private" size="1" offset="36" file="System.Classes.pas" line="1333"/>
      <procedure name="SetRoot" visibility="protected" procflags="virtual" file="System.Classes.pas" line="1335">
        <parameters>
          <parameter name="Value" type="TComponent"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1337">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="BufSize" type="Integer"/>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="1338">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="DefineProperty" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1339">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <parameter name="ReadData" type="TReaderProc"/>
          <parameter name="WriteData" type="TWriterProc"/>
          <parameter name="HasData" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="DefineBinaryProperty" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1342">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <parameter name="ReadData" type="TStreamProc"/>
          <parameter name="WriteData" type="TStreamProc"/>
          <parameter name="HasData" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="FlushBuffer" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1345">
      </procedure>
      <property name="Root" visibility="public" read="FRoot" write="SetRoot" type="TComponent" file="System.Classes.pas" line="1346"/>
      <property name="LookupRoot" visibility="public" read="FLookupRoot" type="TComponent" file="System.Classes.pas" line="1347"/>
      <property name="Ancestor" visibility="public" read="FAncestor" write="FAncestor" type="TPersistent" file="System.Classes.pas" line="1348"/>
      <property name="IgnoreChildren" visibility="public" read="FIgnoreChildren" write="FIgnoreChildren" type="Boolean" file="System.Classes.pas" line="1349"/>
    </members>
  </class>
  <classref name="TComponentClass" ref="TComponent" file="System.Classes.pas" line="1354"/>
  <interface name="IVarStreamable" GUID="{D60BA026-5E42-4C2A-BB01-3F1C8F30A28E}" ancestor="IInterface" file="System.Classes.pas" line="1358">
    <procedure name="StreamIn" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1360">
      <parameters>
        <parameter name="Dest" type="TVarData" paramflags="var"/>
        <parameter name="Stream" type="TStream" paramflags="const"/>
      </parameters>
    </procedure>
    <procedure name="StreamOut" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1361">
      <parameters>
        <parameter name="Source" type="TVarData" paramflags="const"/>
        <parameter name="Stream" type="TStream" paramflags="const"/>
      </parameters>
    </procedure>
  </interface>
  <type name="TFindMethodEvent" file="System.Classes.pas" line="1366" procflags="closure">
  </type>
  <type name="TSetNameEvent" file="System.Classes.pas" line="1368" procflags="closure">
  </type>
  <type name="TReferenceNameEvent" file="System.Classes.pas" line="1370" procflags="closure">
  </type>
  <type name="TAncestorNotFoundEvent" file="System.Classes.pas" line="1371" procflags="closure">
  </type>
  <type name="TReadComponentsProc" file="System.Classes.pas" line="1373" procflags="closure">
  </type>
  <type name="TReaderError" file="System.Classes.pas" line="1374" procflags="closure">
  </type>
  <type name="TFindComponentClassEvent" file="System.Classes.pas" line="1375" procflags="closure">
  </type>
  <type name="TCreateComponentEvent" file="System.Classes.pas" line="1377" procflags="closure">
  </type>
  <type name="TFindMethodInstanceEvent" file="System.Classes.pas" line="1379" procflags="closure">
  </type>
  <type name="TFindComponentInstanceEvent" file="System.Classes.pas" line="1381" procflags="closure">
  </type>
  <class name="TReader" file="System.Classes.pas" line="1384">
    <ancestor name="TFiler" namespace="System.Classes">
      <methodref name="SetRoot" visibility="protected" procflags="virtual"/>
      <methodref name="Create" visibility="public" procflags="constructor"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="DefineProperty" visibility="public" procflags="abstract virtual"/>
      <methodref name="DefineBinaryProperty" visibility="public" procflags="abstract virtual"/>
      <methodref name="FlushBuffer" visibility="public" procflags="abstract virtual"/>
      <propertyref name="Root" visibility="public"/>
      <propertyref name="LookupRoot" visibility="public"/>
      <propertyref name="Ancestor" visibility="public"/>
      <propertyref name="IgnoreChildren" visibility="public"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FOwner" type="TComponent" visibility="private" size="4" offset="40" file="System.Classes.pas" line="1386"/>
      <field name="FParent" type="TComponent" visibility="private" size="4" offset="44" file="System.Classes.pas" line="1387"/>
      <field name="FFixups" type="TList&lt;System.TObject&gt;" visibility="private" size="4" offset="48" file="System.Classes.pas" line="1388"/>
      <field name="FLoaded" type="TList&lt;System.Classes.TComponent&gt;" visibility="private" size="4" offset="52" file="System.Classes.pas" line="1389"/>
      <field name="FOnFindMethod" type="TFindMethodEvent" visibility="private" size="8" offset="56" file="System.Classes.pas" line="1390"/>
      <field name="FOnFindMethodInstance" type="TFindMethodInstanceEvent" visibility="private" size="8" offset="64" file="System.Classes.pas" line="1391"/>
      <field name="FOnSetName" type="TSetNameEvent" visibility="private" size="8" offset="72" file="System.Classes.pas" line="1392"/>
      <field name="FOnReferenceName" type="TReferenceNameEvent" visibility="private" size="8" offset="80" file="System.Classes.pas" line="1393"/>
      <field name="FOnAncestorNotFound" type="TAncestorNotFoundEvent" visibility="private" size="8" offset="88" file="System.Classes.pas" line="1394"/>
      <field name="FOnError" type="TReaderError" visibility="private" size="8" offset="96" file="System.Classes.pas" line="1395"/>
      <field name="FOnFindComponentClass" type="TFindComponentClassEvent" visibility="private" size="8" offset="104" file="System.Classes.pas" line="1396"/>
      <field name="FOnCreateComponent" type="TCreateComponentEvent" visibility="private" size="8" offset="112" file="System.Classes.pas" line="1397"/>
      <field name="FOnFindComponentInstance" type="TFindComponentInstanceEvent" visibility="private" size="8" offset="120" file="System.Classes.pas" line="1398"/>
      <field name="FPropName" type="string" visibility="private" size="4" offset="128" file="System.Classes.pas" line="1399"/>
      <field name="FFinder" type="TClassFinder" visibility="private" size="4" offset="132" file="System.Classes.pas" line="1400"/>
      <field name="FCanHandleExcepts" type="Boolean" visibility="private" size="1" offset="136" file="System.Classes.pas" line="1401"/>
      <procedure name="DoFixupReferences" visibility="private" file="System.Classes.pas" line="1402">
      </procedure>
      <procedure name="EnsureAtLeast" visibility="private" file="System.Classes.pas" line="1403">
        <parameters>
          <parameter name="NumBytes" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="FreeFixups" visibility="private" file="System.Classes.pas" line="1404">
      </procedure>
      <function name="GetFieldClass" visibility="private" file="System.Classes.pas" line="1405">
        <parameters>
          <parameter name="Instance" type="TObject" paramflags="const"/>
          <parameter name="ClassName" type="string" paramflags="const"/>
          <retval type="TPersistentClass"/>
        </parameters>
      </function>
      <function name="GetPosition" visibility="private" file="System.Classes.pas" line="1406">
        <parameters>
          <retval type="NativeInt"/>
        </parameters>
      </function>
      <procedure name="ReadBuffer" visibility="private" file="System.Classes.pas" line="1407">
        <parameters>
          <parameter name="Keeping" type="Integer">
            <value>
              $0
            </value>
          </parameter>
          <parameter name="MoveBuffer" type="Boolean">
            <value>
              True
            </value>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="ReadDataInner" visibility="private" file="System.Classes.pas" line="1408">
        <parameters>
          <parameter name="Instance" type="TComponent" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="FindComponentClass" visibility="private" file="System.Classes.pas" line="1409">
        <parameters>
          <parameter name="ClassName" type="string" paramflags="const"/>
          <retval type="TComponentClass"/>
        </parameters>
      </function>
      <function name="Error" visibility="protected" procflags="virtual" file="System.Classes.pas" line="1411">
        <parameters>
          <parameter name="Message" type="string" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="FindAncestorComponent" visibility="protected" procflags="virtual" file="System.Classes.pas" line="1412">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <parameter name="ComponentClass" type="TPersistentClass"/>
          <retval type="TComponent"/>
        </parameters>
      </function>
      <function name="FindMethodInstance" visibility="protected" procflags="virtual" file="System.Classes.pas" line="1414">
        <parameters>
          <parameter name="Root" type="TComponent"/>
          <parameter name="MethodName" type="string" paramflags="const"/>
          <retval type="TMethod"/>
        </parameters>
      </function>
      <function name="FindMethod" visibility="protected" procflags="virtual" file="System.Classes.pas" line="1415">
        <parameters>
          <parameter name="Root" type="TComponent"/>
          <parameter name="MethodName" type="string" paramflags="const"/>
          <retval type="Pointer"/>
        </parameters>
      </function>
      <procedure name="SetName" visibility="protected" procflags="virtual" file="System.Classes.pas" line="1416">
        <parameters>
          <parameter name="Component" type="TComponent"/>
          <parameter name="Name" type="string" paramflags="var"/>
        </parameters>
      </procedure>
      <procedure name="ReadProperty" visibility="protected" file="System.Classes.pas" line="1417">
        <parameters>
          <parameter name="AInstance" type="TPersistent"/>
        </parameters>
      </procedure>
      <procedure name="ReadPropValue" visibility="protected" file="System.Classes.pas" line="1418">
        <parameters>
          <parameter name="Instance" type="TPersistent" paramflags="const"/>
          <parameter name="PropInfo" type="Pointer"/>
        </parameters>
      </procedure>
      <procedure name="ReferenceName" visibility="protected" procflags="virtual" file="System.Classes.pas" line="1419">
        <parameters>
          <parameter name="Name" type="string" paramflags="var"/>
        </parameters>
      </procedure>
      <procedure name="PropertyError" visibility="protected" file="System.Classes.pas" line="1420">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="ReadData" visibility="protected" file="System.Classes.pas" line="1421">
        <parameters>
          <parameter name="Instance" type="TComponent" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="ReadSet" visibility="protected" file="System.Classes.pas" line="1422">
        <parameters>
          <parameter name="SetType" type="Pointer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="SetPosition" visibility="protected" file="System.Classes.pas" line="1423">
        <parameters>
          <parameter name="Value" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="SkipBytes" visibility="protected" file="System.Classes.pas" line="1424">
        <parameters>
          <parameter name="Count" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="SkipSetBody" visibility="protected" file="System.Classes.pas" line="1425">
      </procedure>
      <procedure name="SkipProperty" visibility="protected" file="System.Classes.pas" line="1426">
      </procedure>
      <procedure name="SkipComponent" visibility="protected" file="System.Classes.pas" line="1427">
        <parameters>
          <parameter name="SkipHeader" type="Boolean"/>
        </parameters>
      </procedure>
      <property name="PropName" visibility="protected" read="FPropName" type="string" default="0" file="System.Classes.pas" line="1428"/>
      <property name="CanHandleExceptions" visibility="protected" read="FCanHandleExcepts" type="Boolean" file="System.Classes.pas" line="1429"/>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="1431">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="BeginReferences" visibility="public" file="System.Classes.pas" line="1432">
      </procedure>
      <procedure name="CheckValue" visibility="public" file="System.Classes.pas" line="1433">
        <parameters>
          <parameter name="Value" type="TValueType"/>
        </parameters>
      </procedure>
      <procedure name="DefineProperty" visibility="public" procflags="override" file="System.Classes.pas" line="1434">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <parameter name="ReadData" type="TReaderProc"/>
          <parameter name="WriteData" type="TWriterProc"/>
          <parameter name="HasData" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="DefineBinaryProperty" visibility="public" procflags="override" file="System.Classes.pas" line="1437">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <parameter name="ReadData" type="TStreamProc"/>
          <parameter name="WriteData" type="TStreamProc"/>
          <parameter name="HasData" type="Boolean"/>
        </parameters>
      </procedure>
      <function name="EndOfList" visibility="public" file="System.Classes.pas" line="1440">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="EndReferences" visibility="public" file="System.Classes.pas" line="1441">
      </procedure>
      <procedure name="FixupReferences" visibility="public" file="System.Classes.pas" line="1442">
      </procedure>
      <procedure name="FlushBuffer" visibility="public" procflags="override" file="System.Classes.pas" line="1443">
      </procedure>
      <function name="NextValue" visibility="public" file="System.Classes.pas" line="1444">
        <parameters>
          <retval type="TValueType"/>
        </parameters>
      </function>
      <procedure name="Read" visibility="public" procflags="overload" file="System.Classes.pas" line="1446">
        <parameters>
          <parameter name="Buffer" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="Read" visibility="public" procflags="overload" file="System.Classes.pas" line="1448">
        <parameters>
          <parameter name="Buffer" type="TBytes"/>
          <parameter name="Offset" type="NativeInt"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="Read" visibility="public" procflags="overload" file="System.Classes.pas" line="1449">
        <parameters>
          <parameter name="Buffer" type="TBytes"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1453">
        <devnotes>
          NEXTGEN
        </devnotes>
        <parameters>
          <parameter name="Buffer" type="AnsiChar" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1455">
        <devnotes>
          NEXTGEN
        </devnotes>
        <parameters>
          <parameter name="Buffer" type="Char" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1456">
        <parameters>
          <parameter name="Buffer" type="ShortInt" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1457">
        <parameters>
          <parameter name="Buffer" type="Byte" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1458">
        <parameters>
          <parameter name="Buffer" type="SmallInt" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1459">
        <parameters>
          <parameter name="Buffer" type="Word" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1460">
        <parameters>
          <parameter name="Buffer" type="Integer" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1461">
        <parameters>
          <parameter name="Buffer" type="Cardinal" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1462">
        <parameters>
          <parameter name="Buffer" type="Int64" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1463">
        <parameters>
          <parameter name="Buffer" type="UInt64" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1465">
        <parameters>
          <parameter name="Buffer" type="Single" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1466">
        <parameters>
          <parameter name="Buffer" type="Double" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1467">
        <parameters>
          <parameter name="Buffer" type="Extended" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="ReadVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1468">
        <parameters>
          <parameter name="Buffer" type="TExtended80Rec" paramflags="var"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <function name="ReadBoolean" visibility="public" file="System.Classes.pas" line="1470">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="ReadChar" visibility="public" file="System.Classes.pas" line="1471">
        <parameters>
          <retval type="Char"/>
        </parameters>
      </function>
      <function name="ReadWideChar" visibility="public" file="System.Classes.pas" line="1473" symflags="deprecated">
        <parameters>
          <retval type="Char"/>
        </parameters>
      </function>
      <procedure name="ReadCollection" visibility="public" file="System.Classes.pas" line="1475">
        <devnotes>
          NEXTGEN
        </devnotes>
        <parameters>
          <parameter name="Collection" type="TCollection" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="ReadComponent" visibility="public" file="System.Classes.pas" line="1476">
        <parameters>
          <parameter name="Component" type="TComponent"/>
          <retval type="TComponent"/>
        </parameters>
      </function>
      <procedure name="ReadComponents" visibility="public" file="System.Classes.pas" line="1477">
        <parameters>
          <parameter name="AOwner" type="TComponent" paramflags="const"/>
          <parameter name="AParent" type="TComponent" paramflags="const"/>
          <parameter name="Proc" type="TReadComponentsProc"/>
        </parameters>
      </procedure>
      <function name="ReadFloat" visibility="public" file="System.Classes.pas" line="1479">
        <parameters>
          <retval type="Extended"/>
        </parameters>
      </function>
      <function name="ReadSingle" visibility="public" file="System.Classes.pas" line="1480">
        <parameters>
          <retval type="Single"/>
        </parameters>
      </function>
      <function name="ReadDouble" visibility="public" file="System.Classes.pas" line="1481">
        <devnotes>
          EXTENDEDIS10BYTES
        </devnotes>
        <parameters>
          <retval type="Double"/>
        </parameters>
      </function>
      <function name="ReadCurrency" visibility="public" file="System.Classes.pas" line="1482">
        <parameters>
          <retval type="Currency"/>
        </parameters>
      </function>
      <function name="ReadDate" visibility="public" file="System.Classes.pas" line="1483">
        <parameters>
          <retval type="TDateTime"/>
        </parameters>
      </function>
      <function name="ReadIdent" visibility="public" file="System.Classes.pas" line="1484">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="ReadInteger" visibility="public" file="System.Classes.pas" line="1485">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="ReadInt64" visibility="public" file="System.Classes.pas" line="1486">
        <parameters>
          <retval type="Int64"/>
        </parameters>
      </function>
      <procedure name="ReadListBegin" visibility="public" procflags="inline" file="System.Classes.pas" line="1487">
        <devnotes>
          NEXTGEN
        </devnotes>
      </procedure>
      <procedure name="ReadListEnd" visibility="public" procflags="inline" file="System.Classes.pas" line="1488">
      </procedure>
      <procedure name="ReadPrefix" visibility="public" procflags="virtual" file="System.Classes.pas" line="1489">
        <parameters>
          <parameter name="Flags" type="TFilerFlags" paramflags="var"/>
          <parameter name="AChildPos" type="Integer" paramflags="var"/>
        </parameters>
      </procedure>
      <function name="ReadRootComponent" visibility="public" file="System.Classes.pas" line="1490">
        <parameters>
          <parameter name="Root" type="TComponent" paramflags="const"/>
          <retval type="TComponent"/>
        </parameters>
      </function>
      <procedure name="ReadSignature" visibility="public" file="System.Classes.pas" line="1491">
      </procedure>
      <function name="ReadStr" visibility="public" file="System.Classes.pas" line="1492">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="ReadString" visibility="public" file="System.Classes.pas" line="1493">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="ReadWideString" visibility="public" file="System.Classes.pas" line="1495" symflags="deprecated">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="ReadValue" visibility="public" file="System.Classes.pas" line="1497">
        <devnotes>
          NEXTGEN
        </devnotes>
        <parameters>
          <retval type="TValueType"/>
        </parameters>
      </function>
      <function name="ReadVariant" visibility="public" file="System.Classes.pas" line="1498">
        <parameters>
          <retval type="Variant"/>
        </parameters>
      </function>
      <procedure name="CopyValue" visibility="public" file="System.Classes.pas" line="1499">
        <parameters>
          <parameter name="Writer" type="TWriter" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SkipValue" visibility="public" file="System.Classes.pas" line="1500">
      </procedure>
      <property name="Owner" visibility="public" read="FOwner" write="FOwner" type="TComponent" file="System.Classes.pas" line="1501"/>
      <property name="Parent" visibility="public" read="FParent" write="FParent" type="TComponent" file="System.Classes.pas" line="1502"/>
      <property name="Position" visibility="public" read="GetPosition" write="SetPosition" type="NativeInt" file="System.Classes.pas" line="1503"/>
      <event name="OnError" visibility="public" read="FOnError" write="FOnError" type="TReaderError" file="System.Classes.pas" line="1504"/>
      <event name="OnFindMethod" visibility="public" read="FOnFindMethod" write="FOnFindMethod" type="TFindMethodEvent" file="System.Classes.pas" line="1505"/>
      <event name="OnFindMethodInstance" visibility="public" read="FOnFindMethodInstance" write="FOnFindMethodInstance" type="TFindMethodInstanceEvent" file="System.Classes.pas" line="1506"/>
      <event name="OnSetName" visibility="public" read="FOnSetName" write="FOnSetName" type="TSetNameEvent" file="System.Classes.pas" line="1507"/>
      <event name="OnReferenceName" visibility="public" read="FOnReferenceName" write="FOnReferenceName" type="TReferenceNameEvent" file="System.Classes.pas" line="1508"/>
      <event name="OnAncestorNotFound" visibility="public" read="FOnAncestorNotFound" write="FOnAncestorNotFound" type="TAncestorNotFoundEvent" file="System.Classes.pas" line="1509"/>
      <event name="OnCreateComponent" visibility="public" read="FOnCreateComponent" write="FOnCreateComponent" type="TCreateComponentEvent" file="System.Classes.pas" line="1510"/>
      <event name="OnFindComponentClass" visibility="public" read="FOnFindComponentClass" write="FOnFindComponentClass" type="TFindComponentClassEvent" file="System.Classes.pas" line="1511"/>
      <event name="OnFindComponentInstance" visibility="public" read="FOnFindComponentInstance" write="FOnFindComponentInstance" type="TFindComponentInstanceEvent" file="System.Classes.pas" line="1512"/>
    </members>
  </class>
  <type name="TFindAncestorEvent" file="System.Classes.pas" line="1517" procflags="closure">
  </type>
  <type name="TFindMethodNameEvent" file="System.Classes.pas" line="1519" procflags="closure">
  </type>
  <type name="TGetLookupInfoEvent" file="System.Classes.pas" line="1521" procflags="closure">
  </type>
  <class name="TWriter" file="System.Classes.pas" line="1524">
    <ancestor name="TFiler" namespace="System.Classes">
      <methodref name="SetRoot" visibility="protected" procflags="virtual"/>
      <methodref name="Create" visibility="public" procflags="constructor"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="DefineProperty" visibility="public" procflags="abstract virtual"/>
      <methodref name="DefineBinaryProperty" visibility="public" procflags="abstract virtual"/>
      <methodref name="FlushBuffer" visibility="public" procflags="abstract virtual"/>
      <propertyref name="Root" visibility="public"/>
      <propertyref name="LookupRoot" visibility="public"/>
      <propertyref name="Ancestor" visibility="public"/>
      <propertyref name="IgnoreChildren" visibility="public"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FRootAncestor" type="TComponent" visibility="private" size="4" offset="40" file="System.Classes.pas" line="1526"/>
      <field name="FPropPath" type="string" visibility="private" size="4" offset="44" file="System.Classes.pas" line="1527"/>
      <field name="FAncestorList" type="TList&lt;System.Classes.TComponent&gt;" visibility="private" size="4" offset="48" file="System.Classes.pas" line="1528"/>
      <field name="FAncestorPos" type="Integer" visibility="private" size="4" offset="52" file="System.Classes.pas" line="1529"/>
      <field name="FChildPos" type="Integer" visibility="private" size="4" offset="56" file="System.Classes.pas" line="1530"/>
      <field name="FOnFindAncestor" type="TFindAncestorEvent" visibility="private" size="8" offset="64" file="System.Classes.pas" line="1531"/>
      <field name="FOnFindMethodName" type="TFindMethodNameEvent" visibility="private" size="8" offset="72" file="System.Classes.pas" line="1532"/>
      <field name="FUseQualifiedNames" type="Boolean" visibility="private" size="1" offset="80" file="System.Classes.pas" line="1533"/>
      <procedure name="AddAncestor" visibility="private" file="System.Classes.pas" line="1534">
        <parameters>
          <parameter name="Component" type="TComponent"/>
        </parameters>
      </procedure>
      <procedure name="EnsureAtLeast" visibility="private" file="System.Classes.pas" line="1535">
        <parameters>
          <parameter name="Amount" type="Integer"/>
        </parameters>
      </procedure>
      <function name="GetPosition" visibility="private" file="System.Classes.pas" line="1536">
        <parameters>
          <retval type="NativeInt"/>
        </parameters>
      </function>
      <procedure name="SetPosition" visibility="private" file="System.Classes.pas" line="1537">
        <parameters>
          <parameter name="Value" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteBuffer" visibility="private" file="System.Classes.pas" line="1538">
      </procedure>
      <procedure name="WriteData" visibility="private" procflags="virtual" file="System.Classes.pas" line="1539">
        <parameters>
          <parameter name="Instance" type="TComponent"/>
        </parameters>
      </procedure>
      <procedure name="GetLookupInfo" visibility="private" file="System.Classes.pas" line="1540">
        <parameters>
          <parameter name="Ancestor" type="TPersistent" paramflags="var"/>
          <parameter name="Root" type="TComponent" paramflags="var"/>
          <parameter name="LookupRoot" type="TComponent" paramflags="var"/>
          <parameter name="RootAncestor" type="TComponent" paramflags="var"/>
        </parameters>
      </procedure>
      <function name="FindMethodName" visibility="protected" procflags="virtual" file="System.Classes.pas" line="1543">
        <parameters>
          <parameter name="AMethod" type="TMethod"/>
          <retval type="string"/>
        </parameters>
      </function>
      <procedure name="SetRoot" visibility="protected" procflags="override" file="System.Classes.pas" line="1544">
        <parameters>
          <parameter name="Value" type="TComponent"/>
        </parameters>
      </procedure>
      <procedure name="WriteBinary" visibility="protected" file="System.Classes.pas" line="1545">
        <parameters>
          <parameter name="WriteData" type="TStreamProc"/>
        </parameters>
      </procedure>
      <procedure name="WritePrefix" visibility="protected" file="System.Classes.pas" line="1546">
        <parameters>
          <parameter name="Flags" type="TFilerFlags"/>
          <parameter name="AChildPos" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="WriteProperty" visibility="protected" file="System.Classes.pas" line="1547">
        <parameters>
          <parameter name="Instance" type="TPersistent" paramflags="const"/>
          <parameter name="PropInfo" type="PPropInfo"/>
        </parameters>
      </procedure>
      <procedure name="WritePropName" visibility="protected" file="System.Classes.pas" line="1548">
        <parameters>
          <parameter name="PropName" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteValue" visibility="protected" file="System.Classes.pas" line="1549">
        <devnotes>
          NEXTGEN
        </devnotes>
        <parameters>
          <parameter name="Value" type="TValueType"/>
        </parameters>
      </procedure>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="1551">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="DefineProperty" visibility="public" procflags="override" file="System.Classes.pas" line="1552">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <parameter name="ReadData" type="TReaderProc"/>
          <parameter name="WriteData" type="TWriterProc"/>
          <parameter name="HasData" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="DefineBinaryProperty" visibility="public" procflags="override" file="System.Classes.pas" line="1555">
        <parameters>
          <parameter name="Name" type="string" paramflags="const"/>
          <parameter name="ReadData" type="TStreamProc"/>
          <parameter name="WriteData" type="TStreamProc"/>
          <parameter name="HasData" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="FlushBuffer" visibility="public" procflags="override" file="System.Classes.pas" line="1558">
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload" file="System.Classes.pas" line="1560">
        <parameters>
          <parameter name="Buffer" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload" file="System.Classes.pas" line="1562">
        <parameters>
          <parameter name="Buffer" type="TBytes"/>
          <parameter name="Offset" type="NativeInt"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload" file="System.Classes.pas" line="1563">
        <parameters>
          <parameter name="Buffer" type="TBytes"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1567">
        <devnotes>
          EXTENDEDHAS10BYTES
          NEXTGEN
        </devnotes>
        <parameters>
          <parameter name="Buffer" type="AnsiChar" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1569">
        <devnotes>
          NEXTGEN
        </devnotes>
        <parameters>
          <parameter name="Buffer" type="Char" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1570">
        <parameters>
          <parameter name="Buffer" type="ShortInt" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1571">
        <parameters>
          <parameter name="Buffer" type="Byte" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1572">
        <parameters>
          <parameter name="Buffer" type="SmallInt" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1573">
        <parameters>
          <parameter name="Buffer" type="Word" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1574">
        <parameters>
          <parameter name="Buffer" type="Integer" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1575">
        <parameters>
          <parameter name="Buffer" type="Cardinal" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1576">
        <parameters>
          <parameter name="Buffer" type="Int64" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1577">
        <parameters>
          <parameter name="Buffer" type="UInt64" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1579">
        <parameters>
          <parameter name="Buffer" type="Single" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1580">
        <parameters>
          <parameter name="Buffer" type="Double" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1581">
        <parameters>
          <parameter name="Buffer" type="Extended" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteVar" visibility="public" procflags="overload" file="System.Classes.pas" line="1582">
        <parameters>
          <parameter name="Buffer" type="TExtended80Rec" paramflags="const"/>
          <parameter name="Count" type="NativeInt"/>
        </parameters>
      </procedure>
      <procedure name="WriteBoolean" visibility="public" file="System.Classes.pas" line="1584">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="WriteCollection" visibility="public" file="System.Classes.pas" line="1585">
        <parameters>
          <parameter name="Value" type="TCollection" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteComponent" visibility="public" file="System.Classes.pas" line="1586">
        <parameters>
          <parameter name="Component" type="TComponent"/>
        </parameters>
      </procedure>
      <procedure name="WriteChar" visibility="public" file="System.Classes.pas" line="1587">
        <parameters>
          <parameter name="Value" type="Char"/>
        </parameters>
      </procedure>
      <procedure name="WriteWideChar" visibility="public" file="System.Classes.pas" line="1589" symflags="deprecated">
        <parameters>
          <parameter name="Value" type="Char"/>
        </parameters>
      </procedure>
      <procedure name="WriteDescendent" visibility="public" file="System.Classes.pas" line="1591">
        <devnotes>
          NEXTGEN
        </devnotes>
        <parameters>
          <parameter name="Root" type="TComponent" paramflags="const"/>
          <parameter name="AAncestor" type="TComponent" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteFloat" visibility="public" file="System.Classes.pas" line="1592">
        <parameters>
          <parameter name="Value" type="Extended" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteSingle" visibility="public" file="System.Classes.pas" line="1593">
        <devnotes>
          EXTENDEDIS10BYTES
        </devnotes>
        <parameters>
          <parameter name="Value" type="Single" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteDouble" visibility="public" file="System.Classes.pas" line="1594">
        <parameters>
          <parameter name="Value" type="Double" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteCurrency" visibility="public" file="System.Classes.pas" line="1595">
        <parameters>
          <parameter name="Value" type="Currency" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteDate" visibility="public" file="System.Classes.pas" line="1596">
        <parameters>
          <parameter name="Value" type="TDateTime" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteIdent" visibility="public" file="System.Classes.pas" line="1597">
        <parameters>
          <parameter name="Ident" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteInteger" visibility="public" procflags="overload" file="System.Classes.pas" line="1599">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="WriteInteger" visibility="public" procflags="overload" file="System.Classes.pas" line="1600">
        <parameters>
          <parameter name="Value" type="Int64"/>
        </parameters>
      </procedure>
      <procedure name="WriteListBegin" visibility="public" procflags="inline" file="System.Classes.pas" line="1601">
        <devnotes>
          NEXTGEN
        </devnotes>
      </procedure>
      <procedure name="WriteListEnd" visibility="public" procflags="inline" file="System.Classes.pas" line="1602">
      </procedure>
      <procedure name="WriteProperties" visibility="public" file="System.Classes.pas" line="1603">
        <parameters>
          <parameter name="Instance" type="TPersistent" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteRootComponent" visibility="public" file="System.Classes.pas" line="1604">
        <parameters>
          <parameter name="Root" type="TComponent" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteSignature" visibility="public" file="System.Classes.pas" line="1605">
      </procedure>
      <procedure name="WriteStr" visibility="public" file="System.Classes.pas" line="1609">
        <devnotes>
          NEXTGEN
        </devnotes>
        <parameters>
          <parameter name="Value" type="AnsiString" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteUTF8Str" visibility="public" file="System.Classes.pas" line="1611">
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteString" visibility="public" file="System.Classes.pas" line="1612">
        <devnotes>
          NEXTGEN
        </devnotes>
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteWideString" visibility="public" file="System.Classes.pas" line="1614" symflags="deprecated">
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteVariant" visibility="public" file="System.Classes.pas" line="1616">
        <devnotes>
          NEXTGEN
        </devnotes>
        <parameters>
          <parameter name="Value" type="Variant" paramflags="const"/>
        </parameters>
      </procedure>
      <property name="Position" visibility="public" read="GetPosition" write="SetPosition" type="NativeInt" file="System.Classes.pas" line="1617"/>
      <property name="RootAncestor" visibility="public" read="FRootAncestor" write="FRootAncestor" type="TComponent" file="System.Classes.pas" line="1618"/>
      <event name="OnFindAncestor" visibility="public" read="FOnFindAncestor" write="FOnFindAncestor" type="TFindAncestorEvent" file="System.Classes.pas" line="1619"/>
      <event name="OnFindMethodName" visibility="public" read="FOnFindMethodName" write="FOnFindMethodName" type="TFindMethodNameEvent" file="System.Classes.pas" line="1620"/>
      <property name="UseQualifiedNames" visibility="public" read="FUseQualifiedNames" write="FUseQualifiedNames" type="Boolean" file="System.Classes.pas" line="1621"/>
    </members>
  </class>
  <type name="TParserErrorEvent" file="System.Classes.pas" line="1626" procflags="closure">
  </type>
  <class name="TParser" file="System.Classes.pas" line="1628">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <enum name="TCharType" visibility="private" alias="System.Classes.TCharType" file="System.Classes.pas" line="1630">
        <element value="0" name="ctOther" file="System.Classes.pas" line="1630"/>
        <element value="1" name="ctLetterStart" file="System.Classes.pas" line="1630"/>
        <element value="2" name="ctLetterNumber" file="System.Classes.pas" line="1630"/>
        <element value="3" name="ctNumber" file="System.Classes.pas" line="1630"/>
        <element value="4" name="ctHash" file="System.Classes.pas" line="1630"/>
        <element value="5" name="ctQuote" file="System.Classes.pas" line="1630"/>
        <element value="6" name="ctDollar" file="System.Classes.pas" line="1630"/>
        <element value="7" name="ctDash" file="System.Classes.pas" line="1630"/>
      </enum>
      <field name="FStream" type="TStream" visibility="private" size="4" offset="4" file="System.Classes.pas" line="1632"/>
      <field name="FOrigin" type="NativeInt" visibility="private" size="4" offset="8" file="System.Classes.pas" line="1633"/>
      <field name="FBuffer" type="TBytes" visibility="private" size="4" offset="12" file="System.Classes.pas" line="1634"/>
      <field name="FBufPtr" type="NativeInt" visibility="private" size="4" offset="16" file="System.Classes.pas" line="1635"/>
      <field name="FBufEnd" type="NativeInt" visibility="private" size="4" offset="20" file="System.Classes.pas" line="1636"/>
      <field name="FSourcePtr" type="NativeInt" visibility="private" size="4" offset="24" file="System.Classes.pas" line="1637"/>
      <field name="FSourceEnd" type="NativeInt" visibility="private" size="4" offset="28" file="System.Classes.pas" line="1638"/>
      <field name="FTokenPtr" type="NativeInt" visibility="private" size="4" offset="32" file="System.Classes.pas" line="1639"/>
      <field name="FStringPtr" type="NativeInt" visibility="private" size="4" offset="36" file="System.Classes.pas" line="1640"/>
      <field name="FSourceLine" type="Integer" visibility="private" size="4" offset="40" file="System.Classes.pas" line="1641"/>
      <field name="FSaveChar" type="Byte" visibility="private" size="1" offset="44" file="System.Classes.pas" line="1642"/>
      <field name="FToken" type="Char" visibility="private" size="2" offset="46" file="System.Classes.pas" line="1643"/>
      <field name="FFloatType" type="Char" visibility="private" size="2" offset="48" file="System.Classes.pas" line="1644"/>
      <field name="FWideStr" type="TCharArray" visibility="private" size="4" offset="52" file="System.Classes.pas" line="1645"/>
      <field name="FOnError" type="TParserErrorEvent" visibility="private" size="8" offset="56" file="System.Classes.pas" line="1646"/>
      <field name="FEncoding" type="TEncoding" visibility="private" size="4" offset="64" file="System.Classes.pas" line="1647"/>
      <field name="FFormatSettings" type="TFormatSettings" visibility="private" size="204" offset="68" file="System.Classes.pas" line="1648"/>
      <procedure name="ReadBuffer" visibility="private" file="System.Classes.pas" line="1649">
      </procedure>
      <procedure name="SkipBlanks" visibility="private" file="System.Classes.pas" line="1650">
      </procedure>
      <function name="CharType" visibility="private" file="System.Classes.pas" line="1651">
        <parameters>
          <parameter name="ABufPos" type="NativeInt" paramflags="var"/>
          <retval type="TParser.TCharType"/>
        </parameters>
      </function>
      <function name="GetLinePos" visibility="protected" file="System.Classes.pas" line="1653">
        <parameters>
          <retval type="NativeInt"/>
        </parameters>
      </function>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1655">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="AOnError" type="TParserErrorEvent">
            <value>
              nil
            </value>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1656">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="FormatSettings" type="TFormatSettings" paramflags="const"/>
          <parameter name="AOnError" type="TParserErrorEvent">
            <value>
              nil
            </value>
          </parameter>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="1657">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="CheckToken" visibility="public" file="System.Classes.pas" line="1658">
        <parameters>
          <parameter name="T" type="Char"/>
        </parameters>
      </procedure>
      <procedure name="CheckTokenSymbol" visibility="public" file="System.Classes.pas" line="1659">
        <parameters>
          <parameter name="S" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Error" visibility="public" procflags="overload" file="System.Classes.pas" line="1660">
        <parameters>
          <parameter name="Ident" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Error" visibility="public" procflags="overload" file="System.Classes.pas" line="1661">
        <parameters>
          <parameter name="IdentRes" type="PResStringRec" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="ErrorFmt" visibility="public" procflags="overload" file="System.Classes.pas" line="1662">
        <parameters>
          <parameter name="Ident" type="string" paramflags="const"/>
          <parameter name="Args" paramflags="const">
            <array name="Args" file="System.Classes.pas" line="14286">
              <element type="TVarRec"/>
            </array>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="ErrorFmt" visibility="public" procflags="overload" file="System.Classes.pas" line="1663">
        <parameters>
          <parameter name="IdentRes" type="PResStringRec" paramflags="const"/>
          <parameter name="Args" paramflags="const">
            <array name="Args" file="System.Classes.pas" line="14291">
              <element type="TVarRec"/>
            </array>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="ErrorStr" visibility="public" file="System.Classes.pas" line="1664">
        <parameters>
          <parameter name="Message" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="HexToBinary" visibility="public" file="System.Classes.pas" line="1665">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      </procedure>
      <function name="NextToken" visibility="public" file="System.Classes.pas" line="1666">
        <parameters>
          <retval type="Char"/>
        </parameters>
      </function>
      <function name="SourcePos" visibility="public" file="System.Classes.pas" line="1667">
        <parameters>
          <retval type="NativeInt"/>
        </parameters>
      </function>
      <function name="TokenComponentIdent" visibility="public" file="System.Classes.pas" line="1668">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="TokenFloat" visibility="public" file="System.Classes.pas" line="1669">
        <parameters>
          <retval type="Extended"/>
        </parameters>
      </function>
      <function name="TokenInt" visibility="public" file="System.Classes.pas" line="1670">
        <parameters>
          <retval type="Int64"/>
        </parameters>
      </function>
      <function name="TokenString" visibility="public" file="System.Classes.pas" line="1671">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="TokenWideString" visibility="public" file="System.Classes.pas" line="1672">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="TokenSymbolIs" visibility="public" file="System.Classes.pas" line="1673">
        <parameters>
          <parameter name="S" type="string" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <property name="FloatType" visibility="public" read="FFloatType" type="Char" file="System.Classes.pas" line="1674"/>
      <property name="SourceLine" visibility="public" read="FSourceLine" type="Integer" file="System.Classes.pas" line="1675"/>
      <property name="LinePos" visibility="public" read="GetLinePos" type="NativeInt" file="System.Classes.pas" line="1676"/>
      <property name="Token" visibility="public" read="FToken" type="Char" file="System.Classes.pas" line="1677"/>
      <event name="OnError" visibility="public" read="FOnError" write="FOnError" type="TParserErrorEvent" file="System.Classes.pas" line="1678"/>
    </members>
  </class>
  <class name="EThread" file="System.Classes.pas" line="1683">
    <ancestor name="Exception" namespace="System.SysUtils">
      <methodref name="Create@" visibility="class private" procflags="class constructor noself">
      </methodref>
      <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
      </methodref>
      <methodref name="SetInnerException" visibility="protected">
      </methodref>
      <methodref name="SetStackInfo" visibility="protected">
      </methodref>
      <methodref name="GetStackTrace" visibility="protected">
      </methodref>
      <methodref name="RaisingException" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmt" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="GetBaseException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="override">
      </methodref>
      <propertyref name="BaseException" visibility="public">
      </propertyref>
      <propertyref name="HelpContext" visibility="public">
      </propertyref>
      <propertyref name="InnerException" visibility="public">
      </propertyref>
      <propertyref name="Message" visibility="public">
      </propertyref>
      <propertyref name="StackTrace" visibility="public">
      </propertyref>
      <propertyref name="StackInfo" visibility="public">
      </propertyref>
      <methodref name="RaiseOuterException" visibility="public" procflags="static">
      </methodref>
      <methodref name="ThrowOuterException" visibility="public" procflags="static">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
  </class>
  <class name="EThreadExternalException" file="System.Classes.pas" line="1684">
    <ancestor name="EThread" namespace="System.Classes">
      <ancestor name="Exception" namespace="System.SysUtils">
        <methodref name="Create@" visibility="class private" procflags="class constructor noself">
        </methodref>
        <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
        </methodref>
        <methodref name="SetInnerException" visibility="protected">
        </methodref>
        <methodref name="SetStackInfo" visibility="protected">
        </methodref>
        <methodref name="GetStackTrace" visibility="protected">
        </methodref>
        <methodref name="RaisingException" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="CreateFmt" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="CreateRes" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateRes" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateHelp" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor override">
        </methodref>
        <methodref name="GetBaseException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="override">
        </methodref>
        <propertyref name="BaseException" visibility="public">
        </propertyref>
        <propertyref name="HelpContext" visibility="public">
        </propertyref>
        <propertyref name="InnerException" visibility="public">
        </propertyref>
        <propertyref name="Message" visibility="public">
        </propertyref>
        <propertyref name="StackTrace" visibility="public">
        </propertyref>
        <propertyref name="StackInfo" visibility="public">
        </propertyref>
        <methodref name="RaiseOuterException" visibility="public" procflags="static">
        </methodref>
        <methodref name="ThrowOuterException" visibility="public" procflags="static">
        </methodref>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
  </class>
  <type name="TThreadMethod" file="System.Classes.pas" line="1686" procflags="closure">
  </type>
  <anonMethod name="TThreadProcedure" file="System.Classes.pas" line="1687">
    <procedure name="Invoke" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1687">
    </procedure>
  </anonMethod>
  <enum name="TThreadPriority" file="System.Classes.pas" line="1690" symflags="platform">
    <element value="0" name="tpIdle" file="System.Classes.pas" line="1690"/>
    <element value="1" name="tpLowest" file="System.Classes.pas" line="1690"/>
    <element value="2" name="tpLower" file="System.Classes.pas" line="1690"/>
    <element value="3" name="tpNormal" file="System.Classes.pas" line="1690"/>
    <element value="4" name="tpHigher" file="System.Classes.pas" line="1690"/>
    <element value="5" name="tpHighest" file="System.Classes.pas" line="1690"/>
    <element value="6" name="tpTimeCritical" file="System.Classes.pas" line="1691"/>
  </enum>
  <class name="TThread" file="System.Classes.pas" line="1698">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <pointer name="PSynchronizeRecord" alias="System.Classes.PSynchronizeRecord" type="TSynchronizeRecord" indircnt="1" file="System.Classes.pas" line="1700"/>
      <struct name="TSynchronizeRecord" visibility="private" alias="System.Classes.TSynchronizeRecord" size="32" file="System.Classes.pas" line="1701">
        <field name="FThread" type="TObject" visibility="public" size="4" offset="0" file="System.Classes.pas" line="1702"/>
        <field name="FMethod" type="TThreadMethod" visibility="public" size="8" offset="8" file="System.Classes.pas" line="1703"/>
        <field name="FProcedure" type="TThreadProcedure" visibility="public" size="4" offset="16" file="System.Classes.pas" line="1704"/>
        <field name="FSynchronizeException" type="TObject" visibility="public" size="4" offset="20" file="System.Classes.pas" line="1705"/>
        <field name="FExecuteAfterTimestamp" type="Int64" visibility="public" size="8" offset="24" file="System.Classes.pas" line="1706"/>
        <procedure name="Init" visibility="public" procflags="overload" file="System.Classes.pas" line="1707">
          <parameters>
            <parameter name="AThread" type="TObject"/>
            <parameter name="AMethod" type="TThreadMethod" paramflags="const"/>
          </parameters>
        </procedure>
        <procedure name="Init" visibility="public" procflags="overload" file="System.Classes.pas" line="1708">
          <parameters>
            <parameter name="AThread" type="TObject"/>
            <parameter name="AProcedure" type="TThreadProcedure" paramflags="const"/>
          </parameters>
        </procedure>
      </struct>
      <anonMethod name="TOnSynchronizeProc" visibility="private" alias="System.Classes.TOnSynchronizeProc" file="System.Classes.pas" line="1710">
        <procedure name="Invoke" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1710">
          <parameters>
            <parameter name="AThreadID" type="Cardinal"/>
            <parameter name="AQueueEvent" type="Boolean" paramflags="var"/>
            <parameter name="AForceQueue" type="Boolean" paramflags="var"/>
            <parameter name="AMethod" type="TThreadMethod" paramflags="var"/>
            <parameter name="AProcedure" type="TThreadProcedure" paramflags="var"/>
          </parameters>
        </procedure>
      </anonMethod>
      <field name="FProcessorCount" type="Integer" visibility="private" varflags="class" file="System.Classes.pas" line="1713"/>
      <field name="FOnSynchronize" type="TThread.TOnSynchronizeProc" visibility="private" varflags="class" file="System.Classes.pas" line="1714"/>
      <field name="FThreadID" type="Cardinal" visibility="private" size="4" offset="4" file="System.Classes.pas" line="1716"/>
      <field name="FHandle" type="NativeUInt" visibility="private" size="4" offset="8" file="System.Classes.pas" line="1718" symflags="platform">
      </field>
      <field name="FStarted" type="Boolean" visibility="private" size="1" offset="12" file="System.Classes.pas" line="1724"/>
      <field name="FCreateSuspended" type="Boolean" visibility="private" size="1" offset="13" file="System.Classes.pas" line="1725"/>
      <field name="FTerminated" type="Boolean" visibility="private" size="1" offset="14" file="System.Classes.pas" line="1727">
        <attributes>
          <attribute name="HPPGENAttribute"/>
        </attributes>
      </field>
      <field name="FSuspended" type="Boolean" visibility="private" size="1" offset="15" file="System.Classes.pas" line="1728"/>
      <field name="FFreeOnTerminate" type="Boolean" visibility="private" size="1" offset="16" file="System.Classes.pas" line="1729"/>
      <field name="FFinished" type="Boolean" visibility="private" size="1" offset="17" file="System.Classes.pas" line="1731">
        <attributes>
          <attribute name="HPPGENAttribute"/>
        </attributes>
      </field>
      <field name="FReturnValue" type="Integer" visibility="private" size="4" offset="20" file="System.Classes.pas" line="1732"/>
      <field name="FOnTerminate" type="TNotifyEvent" visibility="private" size="8" offset="24" file="System.Classes.pas" line="1733"/>
      <field name="FFatalException" type="TObject" visibility="private" size="4" offset="32" file="System.Classes.pas" line="1734"/>
      <field name="FExternalThread" type="Boolean" visibility="private" size="1" offset="36" file="System.Classes.pas" line="1735"/>
      <field name="FShutdown" type="Boolean" visibility="private" size="1" offset="37" file="System.Classes.pas" line="1736"/>
      <procedure name="Create@" visibility="class private" procflags="class constructor noself" file="System.Classes.pas" line="1737">
      </procedure>
      <procedure name="Destroy@" visibility="class private" procflags="class destructor noself" file="System.Classes.pas" line="1738">
      </procedure>
      <procedure name="CallOnTerminate" visibility="private" file="System.Classes.pas" line="1739">
      </procedure>
      <procedure name="Synchronize" visibility="private" procflags="class overload" file="System.Classes.pas" line="1740">
        <parameters>
          <parameter name="ASyncRec" type="TThread.PSynchronizeRecord"/>
          <parameter name="QueueEvent" type="Boolean">
            <value>
              False
            </value>
          </parameter>
          <parameter name="ForceQueue" type="Boolean">
            <value>
              False
            </value>
          </parameter>
        </parameters>
      </procedure>
      <function name="GetCurrentThread" visibility="private" procflags="static" file="System.Classes.pas" line="1742">
        <parameters>
          <retval type="TThread"/>
        </parameters>
      </function>
      <function name="GetIsSingleProcessor" visibility="private" procflags="static inline" file="System.Classes.pas" line="1743">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="InternalStart" visibility="private" file="System.Classes.pas" line="1744">
        <parameters>
          <parameter name="Force" type="Boolean"/>
        </parameters>
      </procedure>
      <function name="GetPriority" visibility="private" file="System.Classes.pas" line="1746" symflags="platform">
        <parameters>
          <retval type="TThreadPriority" symflags="platform">
          </retval>
        </parameters>
      </function>
      <procedure name="SetPriority" visibility="private" file="System.Classes.pas" line="1747" symflags="platform">
        <parameters>
          <parameter name="Value" type="TThreadPriority"/>
        </parameters>
      </procedure>
      <procedure name="SetSuspended" visibility="private" file="System.Classes.pas" line="1754">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <field name="FCurrentThread" type="TThread" visibility="private" varflags="threadvar" file="System.Classes.pas" line="1756">
        <attributes>
          <attribute name="TObject"/>
        </attributes>
      </field>
      <procedure name="CheckThreadError" visibility="protected" procflags="overload" file="System.Classes.pas" line="1758">
        <parameters>
          <parameter name="ErrCode" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="CheckThreadError" visibility="protected" procflags="overload" file="System.Classes.pas" line="1759">
        <parameters>
          <parameter name="Success" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="DoTerminate" visibility="protected" procflags="virtual" file="System.Classes.pas" line="1760">
      </procedure>
      <procedure name="TerminatedSet" visibility="protected" procflags="virtual" file="System.Classes.pas" line="1761">
      </procedure>
      <procedure name="Execute" visibility="protected" procflags="abstract virtual" file="System.Classes.pas" line="1762">
      </procedure>
      <procedure name="Queue" visibility="protected" procflags="overload inline" file="System.Classes.pas" line="1763">
        <parameters>
          <parameter name="AMethod" type="TThreadMethod"/>
        </parameters>
      </procedure>
      <procedure name="Synchronize" visibility="protected" procflags="overload inline" file="System.Classes.pas" line="1764">
        <parameters>
          <parameter name="AMethod" type="TThreadMethod"/>
        </parameters>
      </procedure>
      <procedure name="Queue" visibility="protected" procflags="overload inline" file="System.Classes.pas" line="1765">
        <parameters>
          <parameter name="AThreadProc" type="TThreadProcedure"/>
        </parameters>
      </procedure>
      <procedure name="Synchronize" visibility="protected" procflags="overload inline" file="System.Classes.pas" line="1766">
        <parameters>
          <parameter name="AThreadProc" type="TThreadProcedure"/>
        </parameters>
      </procedure>
      <procedure name="SetFreeOnTerminate" visibility="protected" file="System.Classes.pas" line="1767">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="ShutdownThread" visibility="protected" procflags="virtual" file="System.Classes.pas" line="1768">
      </procedure>
      <procedure name="InitializeExternalThreadsList" visibility="protected" procflags="class" file="System.Classes.pas" line="1769">
      </procedure>
      <property name="ReturnValue" visibility="protected" read="FReturnValue" write="FReturnValue" type="Integer" file="System.Classes.pas" line="1770"/>
      <property name="Terminated" visibility="protected" read="FTerminated" type="Boolean" file="System.Classes.pas" line="1771"/>
      <struct name="TSystemTimes" visibility="public" alias="System.Classes.TSystemTimes" size="32" file="System.Classes.pas" line="1773">
        <field name="IdleTime" type="UInt64" visibility="public" size="8" offset="0" file="System.Classes.pas" line="1774"/>
        <field name="UserTime" type="UInt64" visibility="public" size="8" offset="8" file="System.Classes.pas" line="1774"/>
        <field name="KernelTime" type="UInt64" visibility="public" size="8" offset="16" file="System.Classes.pas" line="1774"/>
        <field name="NiceTime" type="UInt64" visibility="public" size="8" offset="24" file="System.Classes.pas" line="1774"/>
      </struct>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1777">
        <parameters>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1778">
        <parameters>
          <parameter name="CreateSuspended" type="Boolean"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1780">
        <parameters>
          <parameter name="CreateSuspended" type="Boolean"/>
          <parameter name="ReservedStackSize" type="NativeUInt"/>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="1782">
        <parameters>
        </parameters>
      </destructor>
      <function name="CreateAnonymousThread" visibility="public" procflags="static" file="System.Classes.pas" line="1788">
        <parameters>
          <parameter name="ThreadProc" type="TProc" paramflags="const"/>
          <retval type="TThread"/>
        </parameters>
      </function>
      <procedure name="AfterConstruction" visibility="public" procflags="override" file="System.Classes.pas" line="1789">
      </procedure>
      <procedure name="BeforeDestruction" visibility="public" procflags="override" file="System.Classes.pas" line="1790">
      </procedure>
      <procedure name="Resume" visibility="public" file="System.Classes.pas" line="1792" symflags="deprecated">
      </procedure>
      <procedure name="Start" visibility="public" file="System.Classes.pas" line="1794">
      </procedure>
      <procedure name="Suspend" visibility="public" file="System.Classes.pas" line="1796" symflags="deprecated">
      </procedure>
      <procedure name="Terminate" visibility="public" file="System.Classes.pas" line="1797">
      </procedure>
      <function name="WaitFor" visibility="public" file="System.Classes.pas" line="1798">
        <parameters>
          <retval type="Cardinal"/>
        </parameters>
      </function>
      <function name="CheckTerminated" visibility="public" procflags="static" file="System.Classes.pas" line="1809">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="SetReturnValue" visibility="public" procflags="static" file="System.Classes.pas" line="1812">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Queue" visibility="public" procflags="static overload" file="System.Classes.pas" line="1813">
        <parameters>
          <parameter name="AThread" type="TThread" paramflags="const"/>
          <parameter name="AMethod" type="TThreadMethod"/>
        </parameters>
      </procedure>
      <procedure name="Queue" visibility="public" procflags="static overload" file="System.Classes.pas" line="1814">
        <parameters>
          <parameter name="AThread" type="TThread" paramflags="const"/>
          <parameter name="AThreadProc" type="TThreadProcedure"/>
        </parameters>
      </procedure>
      <procedure name="RemoveQueuedEvents" visibility="public" procflags="static overload" file="System.Classes.pas" line="1815">
        <parameters>
          <parameter name="AThread" type="TThread" paramflags="const"/>
          <parameter name="AMethod" type="TThreadMethod"/>
        </parameters>
      </procedure>
      <procedure name="StaticQueue" visibility="public" procflags="static" file="System.Classes.pas" line="1816" symflags="deprecated">
        <parameters>
          <parameter name="AThread" type="TThread" paramflags="const"/>
          <parameter name="AMethod" type="TThreadMethod"/>
        </parameters>
      </procedure>
      <procedure name="Synchronize" visibility="public" procflags="static overload" file="System.Classes.pas" line="1817">
        <parameters>
          <parameter name="AThread" type="TThread" paramflags="const"/>
          <parameter name="AMethod" type="TThreadMethod"/>
        </parameters>
      </procedure>
      <procedure name="Synchronize" visibility="public" procflags="static overload" file="System.Classes.pas" line="1818">
        <parameters>
          <parameter name="AThread" type="TThread" paramflags="const"/>
          <parameter name="AThreadProc" type="TThreadProcedure"/>
        </parameters>
      </procedure>
      <procedure name="StaticSynchronize" visibility="public" procflags="static" file="System.Classes.pas" line="1819" symflags="deprecated">
        <parameters>
          <parameter name="AThread" type="TThread" paramflags="const"/>
          <parameter name="AMethod" type="TThreadMethod"/>
        </parameters>
      </procedure>
      <procedure name="ForceQueue" visibility="public" procflags="static overload" file="System.Classes.pas" line="1824">
        <devnotes>
           <summary>
              Queue the method to delay its  synchronous execution. Unlike the Queue method, this will queue it even
              if the caller is in the main thread.
           </summary>
        </devnotes>
        <parameters>
          <parameter name="AThread" type="TThread" paramflags="const"/>
          <parameter name="AMethod" type="TThreadMethod" paramflags="const"/>
          <parameter name="ADelay" type="Integer">
            <value>
              $0
            </value>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="ForceQueue" visibility="public" procflags="static overload" file="System.Classes.pas" line="1829">
        <devnotes>
           <summary>
              Queue the procedure to delay its synchronous execution. Unlike the Queue method, this will queue it even
              if the caller is in the main thread.
           </summary>
        </devnotes>
        <parameters>
          <parameter name="AThread" type="TThread" paramflags="const"/>
          <parameter name="AThreadProc" type="TThreadProcedure" paramflags="const"/>
          <parameter name="ADelay" type="Integer">
            <value>
              $0
            </value>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="RemoveQueuedEvents" visibility="public" procflags="static overload" file="System.Classes.pas" line="1830">
        <parameters>
          <parameter name="AThread" type="TThread" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="RemoveQueuedEvents" visibility="public" procflags="static overload inline" file="System.Classes.pas" line="1831">
        <parameters>
          <parameter name="AMethod" type="TThreadMethod"/>
        </parameters>
      </procedure>
      <procedure name="NameThreadForDebugging" visibility="public" procflags="static overload" file="System.Classes.pas" line="1833">
        <devnotes>
          NEXTGEN
        </devnotes>
        <parameters>
          <parameter name="AThreadName" type="AnsiString"/>
          <parameter name="AThreadID" type="Cardinal">
            <value>
              $FFFFFFFF
            </value>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="NameThreadForDebugging" visibility="public" procflags="static overload" file="System.Classes.pas" line="1835">
        <devnotes>
          NEXTGEN
        </devnotes>
        <parameters>
          <parameter name="AThreadName" type="string"/>
          <parameter name="AThreadID" type="Cardinal">
            <value>
              $FFFFFFFF
            </value>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="SpinWait" visibility="public" procflags="static" file="System.Classes.pas" line="1836">
        <parameters>
          <parameter name="Iterations" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Sleep" visibility="public" procflags="static" file="System.Classes.pas" line="1837">
        <parameters>
          <parameter name="Timeout" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Yield" visibility="public" procflags="static" file="System.Classes.pas" line="1838">
      </procedure>
      <function name="GetSystemTimes" visibility="public" procflags="static" file="System.Classes.pas" line="1842">
        <parameters>
          <parameter name="SystemTimes" type="TThread.TSystemTimes" paramflags="out"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="GetCPUUsage" visibility="public" procflags="static" file="System.Classes.pas" line="1847">
        <parameters>
          <parameter name="PrevSystemTimes" type="TThread.TSystemTimes" paramflags="var"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetTickCount" visibility="public" procflags="static" file="System.Classes.pas" line="1849">
        <parameters>
          <retval type="Cardinal"/>
        </parameters>
      </function>
      <function name="GetTickCount64" visibility="public" procflags="static" file="System.Classes.pas" line="1851">
        <parameters>
          <retval type="UInt64"/>
        </parameters>
      </function>
      <function name="IsTimeout" visibility="public" procflags="static" file="System.Classes.pas" line="1856">
        <devnotes>
           <summary>
              Returns True if after AStartTime the specified ATimeout is passed.
              When ATimeout &lt;= 0, then timeout is inifinite and function always returns False.
           </summary>
        </devnotes>
        <parameters>
          <parameter name="AStartTime" type="Cardinal"/>
          <parameter name="ATimeout" type="Integer"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <property name="ExternalThread" visibility="public" read="FExternalThread" type="Boolean" file="System.Classes.pas" line="1857"/>
      <property name="FatalException" visibility="public" read="FFatalException" type="TObject" file="System.Classes.pas" line="1858"/>
      <property name="FreeOnTerminate" visibility="public" read="FFreeOnTerminate" write="SetFreeOnTerminate" type="Boolean" file="System.Classes.pas" line="1859"/>
      <property name="Finished" visibility="public" read="FFinished" type="Boolean" file="System.Classes.pas" line="1860"/>
      <property name="Handle" visibility="public" read="FHandle" type="NativeUInt" file="System.Classes.pas" line="1862"/>
      <property name="Priority" visibility="public" read="GetPriority" write="SetPriority" type="TThreadPriority" file="System.Classes.pas" line="1863"/>
      <property name="Started" visibility="public" read="FStarted" type="Boolean" file="System.Classes.pas" line="1870"/>
      <property name="Suspended" visibility="public" read="FSuspended" write="SetSuspended" type="Boolean" file="System.Classes.pas" line="1871"/>
      <property name="ThreadID" visibility="public" read="FThreadID" type="Cardinal" file="System.Classes.pas" line="1872"/>
      <event name="OnTerminate" visibility="public" read="FOnTerminate" write="FOnTerminate" type="TNotifyEvent" file="System.Classes.pas" line="1873"/>
      <property name="Current" visibility="public" read="GetCurrentThread" type="TThread" file="System.Classes.pas" line="1877">
        <devnotes>
           <summary>
              The currently executing thread. This is the same as TThread.CurrentThread.
           </summary>
        </devnotes>
      </property>
      <property name="CurrentThread" visibility="public" read="GetCurrentThread" type="TThread" file="System.Classes.pas" line="1882">
        <devnotes>
           <summary>
              The currently executing thread. This is the same as TThread.Current.
              Please use TThread.Current, which is more clear and less redundant.
           </summary>
        </devnotes>
      </property>
      <property name="ProcessorCount" visibility="public" read="FProcessorCount" type="Integer" file="System.Classes.pas" line="1888">
        <devnotes>
           <summary>
              The number of processor cores on which this application is running. This will include virtual
              &quot;Hyper-threading&quot; cores on many modern Intel CPUs. It is ultimately based on what the underlying
              operating system reports.
           </summary>
        </devnotes>
      </property>
      <property name="IsSingleProcessor" visibility="public" read="GetIsSingleProcessor" type="Boolean" file="System.Classes.pas" line="1892">
        <devnotes>
           <summary>
              Simple Boolean property to quickly determine wether running on a single CPU based system.
           </summary>
        </devnotes>
      </property>
      <property name="OnSynchronize" visibility="public" read="FOnSynchronize" write="FOnSynchronize" type="TThread.TOnSynchronizeProc" file="System.Classes.pas" line="1896">
        <devnotes>
           <summary>
              Event handler, which is called before each Synchronize or Queue call.
           </summary>
        </devnotes>
      </property>
    </members>
  </class>
  <class name="TComponentEnumerator" file="System.Classes.pas" line="1901">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FIndex" type="Integer" visibility="private" size="4" offset="4" file="System.Classes.pas" line="1903"/>
      <field name="FComponent" type="TComponent" visibility="private" size="4" offset="8" file="System.Classes.pas" line="1904"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1906">
        <parameters>
          <parameter name="AComponent" type="TComponent"/>
        </parameters>
      </constructor>
      <function name="GetCurrent" visibility="public" procflags="inline" file="System.Classes.pas" line="1907">
        <parameters>
          <retval type="TComponent"/>
        </parameters>
      </function>
      <function name="MoveNext" visibility="public" procflags="inline" file="System.Classes.pas" line="1908">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <property name="Current" visibility="public" read="GetCurrent" type="TComponent" file="System.Classes.pas" line="1909"/>
    </members>
  </class>
  <enum name="TOperation" file="System.Classes.pas" line="1914">
    <element value="0" name="opInsert" file="System.Classes.pas" line="1914"/>
    <element value="1" name="opRemove" file="System.Classes.pas" line="1914"/>
  </enum>
  <set name="TComponentState" file="System.Classes.pas" line="1915">
    <element name="csLoading"/>
    <element name="csReading"/>
    <element name="csWriting"/>
    <element name="csDestroying"/>
    <element name="csDesigning"/>
    <element name="csAncestor"/>
    <element name="csUpdating"/>
    <element name="csFixups"/>
    <element name="csFreeNotification"/>
    <element name="csInline"/>
    <element name="csDesignInstance"/>
  </set>
  <set name="TComponentStyle" file="System.Classes.pas" line="1918">
    <element name="csInheritable"/>
    <element name="csCheckPropAvail"/>
    <element name="csSubComponent"/>
    <element name="csTransient"/>
  </set>
  <type name="TGetChildProc" file="System.Classes.pas" line="1920" procflags="closure">
  </type>
  <type name="TGetStreamProc" file="System.Classes.pas" line="1921" procflags="closure">
  </type>
  <type name="TGetDeltaStreamsEvent" file="System.Classes.pas" line="1922" procflags="closure">
  </type>
  <type name="TComponentName" type="UnicodeString" file="System.Classes.pas" line="1924"/>
  <interface name="IVCLComObject" GUID="{E07892A0-F52F-11CF-BD2F-0020AF0E5B81}" ancestor="IInterface" file="System.Classes.pas" line="1926">
    <function name="GetTypeInfoCount" visibility="public" procflags="abstract virtual" callconv="stdcall" file="System.Classes.pas" line="1928">
      <parameters>
        <parameter name="Count" type="Integer" paramflags="out"/>
        <retval type="HRESULT"/>
      </parameters>
    </function>
    <function name="GetTypeInfo" visibility="public" procflags="abstract virtual" callconv="stdcall" file="System.Classes.pas" line="1929">
      <parameters>
        <parameter name="Index" type="Integer"/>
        <parameter name="LocaleID" type="Integer"/>
        <parameter name="TypeInfo" paramflags="out"/>
        <retval type="HRESULT"/>
      </parameters>
    </function>
    <function name="GetIDsOfNames" visibility="public" procflags="abstract virtual" callconv="stdcall" file="System.Classes.pas" line="1930">
      <parameters>
        <parameter name="IID" type="TGUID" paramflags="const"/>
        <parameter name="Names" type="Pointer"/>
        <parameter name="NameCount" type="Integer"/>
        <parameter name="LocaleID" type="Integer"/>
        <parameter name="DispIDs" type="Pointer"/>
        <retval type="HRESULT"/>
      </parameters>
    </function>
    <function name="Invoke" visibility="public" procflags="abstract virtual" callconv="stdcall" file="System.Classes.pas" line="1932">
      <parameters>
        <parameter name="DispID" type="Integer"/>
        <parameter name="IID" type="TGUID" paramflags="const"/>
        <parameter name="LocaleID" type="Integer"/>
        <parameter name="Flags" type="Word"/>
        <parameter name="Params" paramflags="var"/>
        <parameter name="VarResult" type="Pointer"/>
        <parameter name="ExcepInfo" type="Pointer"/>
        <parameter name="ArgErr" type="Pointer"/>
        <retval type="HRESULT"/>
      </parameters>
    </function>
    <function name="SafeCallException" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1934">
      <parameters>
        <parameter name="ExceptObject" type="TObject"/>
        <parameter name="ExceptAddr" type="Pointer"/>
        <retval type="HRESULT"/>
      </parameters>
    </function>
    <procedure name="FreeOnRelease" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1936">
    </procedure>
  </interface>
  <interface name="IDesignerNotify" GUID="{B971E807-E3A6-11D1-AAB1-00C04FB16FBC}" ancestor="IInterface" file="System.Classes.pas" line="1939">
    <procedure name="Modified" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1941">
    </procedure>
    <procedure name="Notification" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1942">
      <parameters>
        <parameter name="AnObject" type="TPersistent"/>
        <parameter name="Operation" type="TOperation"/>
      </parameters>
    </procedure>
    <procedure name="CanInsertComponent" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1943">
      <parameters>
        <parameter name="AComponent" type="TComponent"/>
      </parameters>
    </procedure>
  </interface>
  <class name="ComponentPlatformsAttribute" file="System.Classes.pas" line="1948">
    <ancestor name="TCustomAttribute" namespace="System">
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FPlatforms" type="Cardinal" visibility="private" size="4" offset="4" file="System.Classes.pas" line="1950"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="1952">
        <parameters>
          <parameter name="Platforms" type="Cardinal" paramflags="const"/>
        </parameters>
      </constructor>
      <property name="Platforms" visibility="public" read="FPlatforms" write="FPlatforms" type="Cardinal" file="System.Classes.pas" line="1953"/>
    </members>
  </class>
  <anonMethod name="TObserverToggleEvent" file="System.Classes.pas" line="1957">
    <procedure name="Invoke" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1957">
      <parameters>
        <parameter name="AObserver" type="IObserver" paramflags="const"/>
        <parameter name="Value" type="Boolean" paramflags="const"/>
      </parameters>
    </procedure>
  </anonMethod>
  <interface name="IObserver" GUID="{B03253D8-7720-4B68-B10A-E3E79B91ECD3}" ancestor="IInterface" file="System.Classes.pas" line="1958">
    <procedure name="Removed" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1960">
    </procedure>
    <function name="GetActive" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1961">
      <parameters>
        <retval type="Boolean"/>
      </parameters>
    </function>
    <procedure name="SetActive" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1962">
      <parameters>
        <parameter name="Value" type="Boolean"/>
      </parameters>
    </procedure>
    <function name="GetOnObserverToggle" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1963">
      <parameters>
        <retval type="TObserverToggleEvent"/>
      </parameters>
    </function>
    <procedure name="SetOnObserverToggle" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1964">
      <parameters>
        <parameter name="AEvent" type="TObserverToggleEvent"/>
      </parameters>
    </procedure>
    <property name="OnObserverToggle" visibility="public" read="GetOnObserverToggle" write="SetOnObserverToggle" type="TObserverToggleEvent" file="System.Classes.pas" line="1965"/>
    <property name="Active" visibility="public" read="GetActive" write="SetActive" type="Boolean" file="System.Classes.pas" line="1966"/>
  </interface>
  <interface name="ISingleCastObserver" GUID="{D0395F17-52AA-4515-93A5-5B292F03AA7B}" ancestor="IObserver" file="System.Classes.pas" line="1969">
  </interface>
  <interface name="IMultiCastObserver" GUID="{C19CB01E-1233-4405-8A30-7987DF2C3690}" ancestor="IObserver" file="System.Classes.pas" line="1973">
  </interface>
  <interface name="IEditFormatLink" GUID="{D1CE0112-FA41-4922-A9F1-D4641C02AA05}" ancestor="IInterface" file="System.Classes.pas" line="1977">
    <function name="GetDisplayName" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1979">
      <parameters>
        <retval type="string"/>
      </parameters>
    </function>
    <function name="GetDisplayWidth" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1980">
      <parameters>
        <retval type="Integer"/>
      </parameters>
    </function>
    <function name="GetDisplayTextWidth" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1981">
      <parameters>
        <retval type="Integer"/>
      </parameters>
    </function>
    <function name="GetReadOnly" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1982">
      <parameters>
        <retval type="Boolean"/>
      </parameters>
    </function>
    <function name="GetVisible" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1983">
      <parameters>
        <retval type="Boolean"/>
      </parameters>
    </function>
    <function name="GetCurrency" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1984">
      <parameters>
        <retval type="Boolean"/>
      </parameters>
    </function>
    <function name="GetEditMask" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1985">
      <parameters>
        <retval type="string"/>
      </parameters>
    </function>
    <function name="GetAlignment" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1986">
      <parameters>
        <retval type="TAlignment"/>
      </parameters>
    </function>
    <function name="GetMaxLength" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="1987">
      <parameters>
        <retval type="Integer"/>
      </parameters>
    </function>
    <property name="DisplayName" visibility="public" read="GetDisplayName" type="string" default="0" file="System.Classes.pas" line="1988"/>
    <property name="DisplayWidth" visibility="public" read="GetDisplayWidth" type="Integer" file="System.Classes.pas" line="1989"/>
    <property name="DisplayTextWidth" visibility="public" read="GetDisplayTextWidth" type="Integer" file="System.Classes.pas" line="1990"/>
    <property name="ReadOnly" visibility="public" read="GetReadOnly" type="Boolean" file="System.Classes.pas" line="1991"/>
    <property name="Visible" visibility="public" read="GetVisible" type="Boolean" file="System.Classes.pas" line="1992"/>
    <property name="Currency" visibility="public" read="GetCurrency" type="Boolean" file="System.Classes.pas" line="1993"/>
    <property name="EditMask" visibility="public" read="GetEditMask" type="string" default="0" file="System.Classes.pas" line="1994"/>
    <property name="Alignment" visibility="public" read="GetAlignment" type="TAlignment" file="System.Classes.pas" line="1995"/>
    <property name="MaxLength" visibility="public" read="GetMaxLength" type="Integer" file="System.Classes.pas" line="1996"/>
  </interface>
  <interface name="IEditLinkObserver" GUID="{E88C2705-7C5A-4E66-9B81-447D05D5E640}" ancestor="ISingleCastObserver" file="System.Classes.pas" line="1999">
    <procedure name="Update" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2001">
    </procedure>
    <function name="Edit" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2002">
      <parameters>
        <retval type="Boolean"/>
      </parameters>
    </function>
    <procedure name="Reset" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2003">
    </procedure>
    <procedure name="Modified" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2004">
    </procedure>
    <function name="IsModified" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2005">
      <parameters>
        <retval type="Boolean"/>
      </parameters>
    </function>
    <function name="IsValidChar" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2006">
      <parameters>
        <parameter name="AKey" type="Char"/>
        <retval type="Boolean"/>
      </parameters>
    </function>
    <function name="IsRequired" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2007">
      <parameters>
        <retval type="Boolean"/>
      </parameters>
    </function>
    <function name="GetIsReadOnly" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2008">
      <parameters>
        <retval type="Boolean"/>
      </parameters>
    </function>
    <procedure name="SetIsReadOnly" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2009">
      <parameters>
        <parameter name="Value" type="Boolean"/>
      </parameters>
    </procedure>
    <property name="IsReadOnly" visibility="public" read="GetIsReadOnly" write="SetIsReadOnly" type="Boolean" file="System.Classes.pas" line="2010"/>
    <function name="GetIsEditing" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2011">
      <parameters>
        <retval type="Boolean"/>
      </parameters>
    </function>
    <property name="IsEditing" visibility="public" read="GetIsEditing" type="Boolean" file="System.Classes.pas" line="2012"/>
    <procedure name="BeginUpdate" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2013">
    </procedure>
    <procedure name="EndUpdate" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2014">
    </procedure>
    <function name="GetUpdating" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2015">
      <parameters>
        <retval type="Boolean"/>
      </parameters>
    </function>
    <property name="Updating" visibility="public" read="GetUpdating" type="Boolean" file="System.Classes.pas" line="2016"/>
    <function name="GetFormatLink" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2017">
      <parameters>
        <retval type="IEditFormatLink"/>
      </parameters>
    </function>
    <property name="FormatLink" visibility="public" read="GetFormatLink" type="IEditFormatLink" file="System.Classes.pas" line="2018"/>
  </interface>
  <anonMethod name="TObserverGetCurrentEvent" file="System.Classes.pas" line="2021">
    <function name="Invoke" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2021">
      <parameters>
        <retval type="TVarRec"/>
      </parameters>
    </function>
  </anonMethod>
  <interface name="IEditGridLinkObserver" GUID="{A911B648-E1E5-4EEC-9FEE-D8E62FFA0E71}" ancestor="IEditLinkObserver" file="System.Classes.pas" line="2022">
    <function name="GetCurrent" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2024">
      <parameters>
        <retval type="TVarRec"/>
      </parameters>
    </function>
    <property name="Current" visibility="public" read="GetCurrent" type="TVarRec" file="System.Classes.pas" line="2025"/>
    <function name="GetOnObserverCurrent" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2026">
      <parameters>
        <retval type="TObserverGetCurrentEvent"/>
      </parameters>
    </function>
    <procedure name="SetOnObserverCurrent" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2027">
      <parameters>
        <parameter name="AEvent" type="TObserverGetCurrentEvent"/>
      </parameters>
    </procedure>
    <property name="OnObserverCurrent" visibility="public" read="GetOnObserverCurrent" write="SetOnObserverCurrent" type="TObserverGetCurrentEvent" file="System.Classes.pas" line="2028"/>
  </interface>
  <interface name="IPositionLinkObserver170" GUID="{FA45CF0C-E8DB-4F9E-B53F-E072C94659F6}" ancestor="IInterface" file="System.Classes.pas" line="2031">
    <procedure name="PosChanged" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2033">
    </procedure>
  </interface>
  <interface name="IPositionLinkObserver" GUID="{E78B0035-6802-447C-A80A-0AEC04AD851F}" ancestor="IPositionLinkObserver170" file="System.Classes.pas" line="2036">
    <procedure name="PosChanging" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2038">
    </procedure>
  </interface>
  <interface name="IControlValueObserver" GUID="{61DAC12C-B950-43CA-86B5-43D8E78012E8}" ancestor="IInterface" file="System.Classes.pas" line="2041">
    <procedure name="ValueModified" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2043">
    </procedure>
    <procedure name="ValueUpdate" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2044">
    </procedure>
  </interface>
  <interface name="IObserverTrack" GUID="{8B9F22C3-FDA3-45FD-99E1-5A88481A9F95}" ancestor="IInterface" file="System.Classes.pas" line="2048">
    <function name="GetTrack" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2050">
      <parameters>
        <retval type="Boolean"/>
      </parameters>
    </function>
    <property name="Track" visibility="public" read="GetTrack" type="Boolean" file="System.Classes.pas" line="2051"/>
  </interface>
  <interface name="IIteratorLinkObserver" GUID="{8429848A-4447-4211-93D2-745543C7AB57}" ancestor="IInterface" file="System.Classes.pas" line="2054">
    <procedure name="StartFrom" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2056">
      <parameters>
        <parameter name="APosition" type="Integer"/>
      </parameters>
    </procedure>
    <function name="MoveNext" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2057">
      <parameters>
        <retval type="Boolean"/>
      </parameters>
    </function>
    <procedure name="UpdateControlComponent" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2058">
      <parameters>
        <parameter name="AControl" type="TComponent"/>
      </parameters>
    </procedure>
    <procedure name="Finish" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2059">
    </procedure>
  </interface>
  <class name="TObservers" file="System.Classes.pas" line="2062">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <anonMethod name="TCanObserveEvent" visibility="public" alias="System.Classes.TCanObserveEvent" file="System.Classes.pas" line="2064">
        <function name="Invoke" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2064">
          <parameters>
            <parameter name="ID" type="Integer" paramflags="const"/>
            <retval type="Boolean"/>
          </parameters>
        </function>
      </anonMethod>
      <anonMethod name="TObserverAddedEvent" visibility="public" alias="System.Classes.TObserverAddedEvent" file="System.Classes.pas" line="2065">
        <procedure name="Invoke" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2065">
          <parameters>
            <parameter name="ID" type="Integer" paramflags="const"/>
            <parameter name="Observer" type="IObserver" paramflags="const"/>
          </parameters>
        </procedure>
      </anonMethod>
      <field name="FObservers" type="TDictionary&lt;System.Integer,System.Classes.IInterfaceList&gt;" visibility="private" size="4" offset="4" file="System.Classes.pas" line="2067"/>
      <field name="FCanObserve" type="TObservers.TCanObserveEvent" visibility="private" size="4" offset="8" file="System.Classes.pas" line="2068"/>
      <field name="FObserverAdded" type="TObservers.TObserverAddedEvent" visibility="private" size="4" offset="12" file="System.Classes.pas" line="2069"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2071">
        <parameters>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="2072">
        <parameters>
        </parameters>
      </destructor>
      <property name="OnCanObserve" visibility="public" read="FCanObserve" write="FCanObserve" type="TObservers.TCanObserveEvent" file="System.Classes.pas" line="2073"/>
      <property name="OnObserverAdded" visibility="public" read="FObserverAdded" write="FObserverAdded" type="TObservers.TObserverAddedEvent" file="System.Classes.pas" line="2074"/>
      <function name="CanObserve" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="2076">
        <parameters>
          <parameter name="ID" type="Integer" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="AddObserver" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="2077">
        <parameters>
          <parameter name="ID" type="Integer" paramflags="const"/>
          <parameter name="AIntf" type="IInterface" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="AddObserver" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="2078">
        <parameters>
          <parameter name="IDs" paramflags="const">
            <array name="IDs" file="System.Classes.pas" line="20599">
              <element type="Integer"/>
            </array>
          </parameter>
          <parameter name="AIntf" type="IInterface" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="RemoveObserver" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="2079">
        <parameters>
          <parameter name="ID" type="Integer" paramflags="const"/>
          <parameter name="AIntf" type="IInterface" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="RemoveObserver" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="2080">
        <parameters>
          <parameter name="IDs" paramflags="const">
            <array name="IDs" file="System.Classes.pas" line="20748">
              <element type="Integer"/>
            </array>
          </parameter>
          <parameter name="AIntf" type="IInterface" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="IsObserving" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="2081">
        <parameters>
          <parameter name="ID" type="Integer" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="TryIsObserving" visibility="public" procflags="virtual" file="System.Classes.pas" line="2082">
        <parameters>
          <parameter name="ID" type="Integer" paramflags="const"/>
          <parameter name="AIntf" type="IInterface" paramflags="out"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="GetSingleCastObserver" visibility="public" procflags="virtual" file="System.Classes.pas" line="2083">
        <parameters>
          <parameter name="ID" type="Integer" paramflags="const"/>
          <retval type="IInterface"/>
        </parameters>
      </function>
      <function name="GetMultiCastObserver" visibility="public" procflags="virtual" file="System.Classes.pas" line="2084">
        <parameters>
          <parameter name="ID" type="Integer" paramflags="const"/>
          <retval type="IInterfaceList"/>
        </parameters>
      </function>
    </members>
  </class>
  <class name="TLinkObservers" file="System.Classes.pas" line="2087">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <function name="GetEditGridLink" visibility="public" procflags="static" file="System.Classes.pas" line="2089">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <retval type="IEditGridLinkObserver"/>
        </parameters>
      </function>
      <function name="GetEditLink" visibility="public" procflags="static" file="System.Classes.pas" line="2090">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <retval type="IEditLinkObserver"/>
        </parameters>
      </function>
      <procedure name="EditLinkUpdate" visibility="public" procflags="static inline" file="System.Classes.pas" line="2091">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="EditLinkTrackUpdate" visibility="public" procflags="static" file="System.Classes.pas" line="2092">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="EditLinkReset" visibility="public" procflags="static inline" file="System.Classes.pas" line="2093">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="EditLinkModified" visibility="public" procflags="static inline" file="System.Classes.pas" line="2094">
        <parameters>
          <parameter name="AObservers" type="TObservers"/>
        </parameters>
      </procedure>
      <function name="EditLinkIsModified" visibility="public" procflags="static inline" file="System.Classes.pas" line="2095">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="EditLinkIsValidChar" visibility="public" procflags="static inline" file="System.Classes.pas" line="2096">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <parameter name="AKey" type="Char"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="EditLinkIsEditing" visibility="public" procflags="static inline" file="System.Classes.pas" line="2097">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="EditLinkEdit" visibility="public" procflags="static inline" file="System.Classes.pas" line="2098">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="EditLinkSetIsReadOnly" visibility="public" procflags="static inline" file="System.Classes.pas" line="2099">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <parameter name="AValue" type="Boolean"/>
        </parameters>
      </procedure>
      <function name="EditLinkIsReadOnly" visibility="public" procflags="static inline" file="System.Classes.pas" line="2100">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="EditGridLinkUpdate" visibility="public" procflags="static inline" file="System.Classes.pas" line="2102">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="EditGridLinkReset" visibility="public" procflags="static inline" file="System.Classes.pas" line="2103">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="EditGridLinkModified" visibility="public" procflags="static inline" file="System.Classes.pas" line="2104">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="EditGridLinkIsModified" visibility="public" procflags="static inline" file="System.Classes.pas" line="2105">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="EditGridLinkIsValidChar" visibility="public" procflags="static inline" file="System.Classes.pas" line="2106">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <parameter name="AKey" type="Char"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="EditGridLinkIsEditing" visibility="public" procflags="static inline" file="System.Classes.pas" line="2107">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="EditGridLinkEdit" visibility="public" procflags="static inline" file="System.Classes.pas" line="2108">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="EditGridLinkIsReadOnly" visibility="public" procflags="static inline" file="System.Classes.pas" line="2109">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="EditGridLinkSetIsReadOnly" visibility="public" procflags="static inline" file="System.Classes.pas" line="2110">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <parameter name="AValue" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="PositionLinkPosChanged" visibility="public" procflags="static" file="System.Classes.pas" line="2112">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="PositionLinkPosChanging" visibility="public" procflags="static" file="System.Classes.pas" line="2113">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="ListSelectionChanged" visibility="public" procflags="static" file="System.Classes.pas" line="2114">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="ControlValueUpdate" visibility="public" procflags="static" file="System.Classes.pas" line="2115">
        <parameters>
          <parameter name="AObservers" type="TObservers"/>
        </parameters>
      </procedure>
      <procedure name="ControlValueModified" visibility="public" procflags="static" file="System.Classes.pas" line="2116">
        <parameters>
          <parameter name="AObservers" type="TObservers"/>
        </parameters>
      </procedure>
      <function name="ControlValueTrackUpdate" visibility="public" procflags="static" file="System.Classes.pas" line="2117">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="AllowControlChange" visibility="public" procflags="static" file="System.Classes.pas" line="2118">
        <parameters>
          <parameter name="AControl" type="TComponent" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="ControlChanged" visibility="public" procflags="static" file="System.Classes.pas" line="2119">
        <parameters>
          <parameter name="AControl" type="TComponent" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="IteratorLinkStartFrom" visibility="public" procflags="static" file="System.Classes.pas" line="2121">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <parameter name="APosition" type="Integer"/>
        </parameters>
      </procedure>
      <function name="IteratorLinkMoveNext" visibility="public" procflags="static" file="System.Classes.pas" line="2122">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="IteratorLinkUpdateControlComponent" visibility="public" procflags="static" file="System.Classes.pas" line="2123">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
          <parameter name="AControl" type="TComponent"/>
        </parameters>
      </procedure>
      <procedure name="IteratorLinkFinish" visibility="public" procflags="static" file="System.Classes.pas" line="2124">
        <parameters>
          <parameter name="AObservers" type="TObservers" paramflags="const"/>
        </parameters>
      </procedure>
    </members>
  </class>
  <class name="TObserverMapping" file="System.Classes.pas" line="2127">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <const name="EditLinkID" visibility="public" type="Integer" file="System.Classes.pas" line="2129">
        <value>
          $1
        </value>
      </const>
      <const name="EditGridLinkID" visibility="public" type="Integer" file="System.Classes.pas" line="2130">
        <value>
          $2
        </value>
      </const>
      <const name="PositionLinkID" visibility="public" type="Integer" file="System.Classes.pas" line="2131">
        <value>
          $3
        </value>
      </const>
      <const name="ControlValueID" visibility="public" type="Integer" file="System.Classes.pas" line="2132">
        <value>
          $4
        </value>
      </const>
      <const name="IteratorLinkID" visibility="public" type="Integer" file="System.Classes.pas" line="2133">
        <value>
          $5
        </value>
      </const>
      <const name="MappedID" visibility="public" type="Integer" file="System.Classes.pas" line="2134">
        <value>
          $64
        </value>
      </const>
      <field name="FMappings" type="TStringList" visibility="private" size="4" offset="4" file="System.Classes.pas" line="2136"/>
      <field name="FInstance" type="TObserverMapping" visibility="private" varflags="class" file="System.Classes.pas" line="2138"/>
      <function name="Instance" visibility="protected" procflags="class" file="System.Classes.pas" line="2140">
        <parameters>
          <retval type="TObserverMapping"/>
        </parameters>
      </function>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2142">
        <parameters>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="2143">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Destroy@" visibility="class private" procflags="class destructor noself" file="System.Classes.pas" line="2144">
      </procedure>
      <function name="GetObserverID" visibility="public" procflags="class" file="System.Classes.pas" line="2145">
        <parameters>
          <parameter name="Key" type="string" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="Create@" visibility="class private" procflags="class constructor noself" generated="true">
      </procedure>
    </members>
  </class>
  <class name="EObserverException" file="System.Classes.pas" line="2148">
    <ancestor name="Exception" namespace="System.SysUtils">
      <methodref name="Create@" visibility="class private" procflags="class constructor noself">
      </methodref>
      <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
      </methodref>
      <methodref name="SetInnerException" visibility="protected">
      </methodref>
      <methodref name="SetStackInfo" visibility="protected">
      </methodref>
      <methodref name="GetStackTrace" visibility="protected">
      </methodref>
      <methodref name="RaisingException" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmt" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="GetBaseException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="override">
      </methodref>
      <propertyref name="BaseException" visibility="public">
      </propertyref>
      <propertyref name="HelpContext" visibility="public">
      </propertyref>
      <propertyref name="InnerException" visibility="public">
      </propertyref>
      <propertyref name="Message" visibility="public">
      </propertyref>
      <propertyref name="StackTrace" visibility="public">
      </propertyref>
      <propertyref name="StackInfo" visibility="public">
      </propertyref>
      <methodref name="RaiseOuterException" visibility="public" procflags="static">
      </methodref>
      <methodref name="ThrowOuterException" visibility="public" procflags="static">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
  </class>
  <class name="TDefaultAttributeBase" file="System.Classes.pas" line="2150">
    <ancestor name="TCustomAttribute" namespace="System">
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FValue" type="Variant" visibility="class protected" size="16" offset="8" file="System.Classes.pas" line="2152"/>
      <property name="Value" visibility="public" read="FValue" type="Variant" default="0" file="System.Classes.pas" line="2154"/>
    </members>
  </class>
  <class name="DefaultAttribute" file="System.Classes.pas" line="2157">
    <ancestor name="TDefaultAttributeBase" namespace="System.Classes">
      <propertyref name="Value" visibility="public"/>
      <ancestor name="TCustomAttribute" namespace="System">
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2159">
        <devnotes>
          NEXTGEN
          MSWINDOWS
        </devnotes>
        <parameters>
          <parameter name="DefaultValue" type="Boolean" paramflags="const"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2161">
        <parameters>
          <parameter name="DefaultValue" type="AnsiChar" paramflags="const"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2163">
        <devnotes>
          NEXTGEN
        </devnotes>
        <parameters>
          <parameter name="DefaultValue" type="Char" paramflags="const"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2164">
        <parameters>
          <parameter name="DefaultValue" type="Integer" paramflags="const"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2165">
        <parameters>
          <parameter name="DefaultValue" type="Cardinal" paramflags="const"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2166">
        <parameters>
          <parameter name="DefaultValue" type="Int64" paramflags="const"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2167">
        <parameters>
          <parameter name="DefaultValue" type="UInt64" paramflags="const"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2168">
        <parameters>
          <parameter name="DefaultValue" type="string" paramflags="const"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2169">
        <parameters>
          <parameter name="DefaultValue" type="Extended" paramflags="const"/>
        </parameters>
      </constructor>
    </members>
  </class>
  <class name="NoDefaultAttribute" file="System.Classes.pas" line="2172">
    <ancestor name="TDefaultAttributeBase" namespace="System.Classes">
      <propertyref name="Value" visibility="public"/>
      <ancestor name="TCustomAttribute" namespace="System">
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2174">
        <parameters>
        </parameters>
      </constructor>
    </members>
  </class>
  <class name="StoredAttribute" alias="System.StoredAttribute" file="System.Classes.pas" line="2177">
    <ancestor name="TCustomAttribute" namespace="System">
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FFlag" type="Boolean" visibility="class protected" size="1" offset="4" file="System.pas" line="756">
      </field>
      <field name="_FName" type="string" visibility="class protected" size="4" offset="8" file="System.pas" line="757">
      </field>
      <constructor name="Create" visibility="public" file="System.pas" line="759">
        <parameters>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.pas" line="760">
        <parameters>
          <parameter name="StorageHandlerFlag" type="Boolean" paramflags="const"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.pas" line="761">
        <parameters>
          <parameter name="StorageHandlerName" type="string" paramflags="const"/>
        </parameters>
      </constructor>
      <property name="Flag" visibility="public" read="FFlag" type="Boolean" file="System.pas" line="762">
      </property>
      <property name="Name" visibility="public" read="_FName" type="string" default="0" file="System.pas" line="763">
      </property>
    </members>
  </class>
  <class name="ObservableMemberAttribute" file="System.Classes.pas" line="2180">
    <ancestor name="TCustomAttribute" namespace="System">
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FMemberName" type="string" visibility="class protected" size="4" offset="4" file="System.Classes.pas" line="2182"/>
      <field name="FFramework" type="string" visibility="class protected" size="4" offset="8" file="System.Classes.pas" line="2183"/>
      <field name="FTrack" type="Boolean" visibility="class protected" size="1" offset="12" file="System.Classes.pas" line="2184"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2186">
        <parameters>
          <parameter name="AMemberName" type="string" paramflags="const"/>
          <parameter name="AFramework" type="string" paramflags="const"/>
          <parameter name="ATrack" type="Boolean"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2187">
        <parameters>
          <parameter name="AMemberName" type="string" paramflags="const"/>
          <parameter name="ATrack" type="Boolean"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2188">
        <parameters>
          <parameter name="AMemberName" type="string" paramflags="const"/>
        </parameters>
      </constructor>
      <property name="MemberName" visibility="public" read="FMemberName" type="string" default="0" file="System.Classes.pas" line="2189"/>
      <property name="Framework" visibility="public" read="FFramework" type="string" default="0" file="System.Classes.pas" line="2190"/>
      <property name="Track" visibility="public" read="FTrack" type="Boolean" file="System.Classes.pas" line="2191"/>
    </members>
  </class>
  <type name="TDesignInfo" type="integer" loBound="-2147483648" hiBound="2147483647" file="System.pas" line="12"/>
  <class name="TBaseAsyncResult" file="System.Classes.pas" line="2204">
    <devnotes>
       <summary>
          Base class used for implementing all asynchronous procedure calls. Never pass this instance around as
          an instance reference. The intent is that this object is only ever referenced through the IAsyncResult
          interface. Failure to heed this warning will result in unpredictable behavior. See the information about the
          Invoke method.
       </summary>
    </devnotes>
    <ancestor name="TInterfacedObject" namespace="System">
      <interfaces>
        <implements name="IInterface"/>
      </interfaces>
      <methodref name="GetRefCount" visibility="private" procflags="inline">
      </methodref>
      <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
      </methodref>
      <methodref name="QueryInterface" visibility="protected">
      </methodref>
      <methodref name="_AddRef" visibility="protected">
      </methodref>
      <methodref name="_Release" visibility="protected">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="override">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="override">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class override">
      </methodref>
      <propertyref name="RefCount" visibility="public">
      </propertyref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <interfaces>
      <implements name="IAsyncResult"/>
    </interfaces>
    <members>
      <enum name="TAsyncFlag" visibility="private" alias="System.Classes.TAsyncFlag" file="System.Classes.pas" line="2206">
        <element value="0" name="Completed" file="System.Classes.pas" line="2206"/>
        <element value="1" name="Synchronous" file="System.Classes.pas" line="2206"/>
        <element value="2" name="Invoked" file="System.Classes.pas" line="2206"/>
        <element value="3" name="Cancelled" file="System.Classes.pas" line="2206"/>
        <element value="31" name="ForceSize" file="System.Classes.pas" line="2206"/>
      </enum>
      <set name="TAsyncFlags" visibility="private" alias="System.Classes.TAsyncFlags" type="TBaseAsyncResult.TAsyncFlag" file="System.Classes.pas" line="2207">
        <element name="Completed"/>
        <element name="Synchronous"/>
        <element name="Invoked"/>
        <element name="Cancelled"/>
        <element name="ForceSize"/>
      </set>
      <procedure name="Create@" visibility="class private" procflags="class constructor noself" file="System.Classes.pas" line="2209">
      </procedure>
      <procedure name="Destroy@" visibility="class private" procflags="class destructor noself" file="System.Classes.pas" line="2210">
      </procedure>
      <field name="FContext" type="TObject" visibility="private" size="4" offset="12" file="System.Classes.pas" line="2212"/>
      <field name="FAsyncFlags" type="TBaseAsyncResult.TAsyncFlags" visibility="private" size="4" offset="16" file="System.Classes.pas" line="2213"/>
      <field name="FInvokingThread" type="Cardinal" visibility="private" size="4" offset="20" file="System.Classes.pas" line="2214"/>
      <field name="FAsyncHandle" type="TMultiWaitEvent" visibility="private" size="4" offset="24" file="System.Classes.pas" line="2215"/>
      <procedure name="SetFlagsAtomic" visibility="private" file="System.Classes.pas" line="2216">
        <parameters>
          <parameter name="Value" type="TBaseAsyncResult.TAsyncFlags"/>
          <parameter name="Mask" type="TBaseAsyncResult.TAsyncFlags"/>
        </parameters>
      </procedure>
      <function name="GetAsyncContext" visibility="private" file="System.Classes.pas" line="2217">
        <parameters>
          <retval type="TObject"/>
        </parameters>
      </function>
      <function name="GetAsyncWaitEvent" visibility="private" file="System.Classes.pas" line="2218">
        <parameters>
          <retval type="TMultiWaitEvent"/>
        </parameters>
      </function>
      <function name="GetCompletedSynchronously" visibility="private" file="System.Classes.pas" line="2219">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="GetIsCompleted" visibility="private" file="System.Classes.pas" line="2220">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="GetIsCancelled" visibility="private" file="System.Classes.pas" line="2221">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <property name="AsyncWaitEvent" visibility="private" read="GetAsyncWaitEvent" type="TMultiWaitEvent" file="System.Classes.pas" line="2223"/>
      <field name="FInvokingException" type="TObject" visibility="protected" size="4" offset="28" file="System.Classes.pas" line="2229">
        <devnotes>
           <summary>
              This field will hold the acquired exception instance raised from the execution of the async method call.
              It will be re-raised in the context of the invoking thread when the corresponding EndXXXX method is called.
           </summary>
        </devnotes>
      </field>
      <procedure name="AsyncDispatch" visibility="protected" procflags="abstract virtual" file="System.Classes.pas" line="2234">
        <devnotes>
           <summary>
              Override this method to dispatch the actual asynchronous procedure call. Descendants will use whatever context
              or other state information contained in the instance to pass along to the procedure or function.
           </summary>
        </devnotes>
      </procedure>
      <procedure name="Complete" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2240">
        <devnotes>
           <summary>
              Override this method to perform any extra state or signaling required by the descendant. The descendant must
              call this inherited method in order to properly set the completion and possibly signal the FAsyncHandle if
              previously created. Failure to call this method can result in a dead lock or hang.
           </summary>
        </devnotes>
      </procedure>
      <procedure name="DoAsyncDispatch" visibility="protected" file="System.Classes.pas" line="2246">
        <devnotes>
           <summary>
              Calls the actual target asynchronous method within the context of however it is scheduled. This could be
              in the context of the main or GUI thread, or within a background thread. This depends on the implementation
              of a specific asynchronous BeginXXXX method call.
           </summary>
        </devnotes>
      </procedure>
      <procedure name="Schedule" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2253">
        <devnotes>
           <summary>
              Override this method to schedule the asynchronous procedure call in the manner specific to
              a given instance, component or class. By default, this will schedule the async procedure onto
              the main thread or execute the procedure synchronously if already on the main thread.
              Other classes may schedule the procedure call into a separate thread or thread pool.
           </summary>
        </devnotes>
      </procedure>
      <constructor name="Create" visibility="protected" file="System.Classes.pas" line="2257">
        <devnotes>
           <summary>
              This constructor must be called from a descendent protected constructor.
           </summary>
        </devnotes>
        <parameters>
          <parameter name="AContext" type="TObject" paramflags="const"/>
        </parameters>
      </constructor>
      <property name="Context" visibility="protected" read="FContext" type="TObject" file="System.Classes.pas" line="2262">
        <devnotes>
           <summary>
              Opaque user-supplied context. This context is available via the IAsyncResult.GetAsyncContext and descendents
              if this class.
           </summary>
        </devnotes>
      </property>
      <function name="DoCancel" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2270">
        <devnotes>
            <summary>
              Returns true if the operation can be cancelled. When cancelling the async operation, do any additional processing.
            </summary>
            <remarks>
              By default, all Async cannot be cancelled. If descendants support cancelling asynchronous tasks,
            they must override this behaviour and do the required processing;
            </remarks>
        </devnotes>
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2276">
        <devnotes>
           <summary>
              This constructor should never be called directly. Only descendents should be constructed using the
              protected Create constructor above. Calling this constructor will raise an exception.
           </summary>
        </devnotes>
        <parameters>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="2277">
        <parameters>
        </parameters>
      </destructor>
      <function name="Cancel" visibility="public" file="System.Classes.pas" line="2282">
        <devnotes>
            <summary>
              Cancels the async operation. Returns True when the asynchronous operation can be cancelled.
            </summary>
        </devnotes>
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="Invoke" visibility="public" file="System.Classes.pas" line="2287">
        <devnotes>
           <summary>
              This method must be called prior in order to return itself as an IAsyncResult and actually schedule/invoke the
              async call.
           </summary>
        </devnotes>
        <parameters>
          <retval type="IAsyncResult"/>
        </parameters>
      </function>
      <procedure name="WaitForCompletion" visibility="public" file="System.Classes.pas" line="2294">
        <devnotes>
           <summary>
              As long as the rules for only ever accessing this object through the IAsynsResult interface, this method
              should only ever be called by a given &quot;EndInvoke&quot; method by casting the IAsyncResult interface instance
              back to a specific descendant instance of this class. Never call this method directly outside the context
              of an &quot;EndInvoke&quot; style method.
           </summary>
        </devnotes>
      </procedure>
      <procedure name="Dispatch" visibility="public" procflags="static inline" file="System.Classes.pas" line="2300">
        <devnotes>
           <summary>
              This method is called from VCL.TControl (and possibly other similar) descendants in order to call the
              asynchronous procedure/function as a result of a posted Window message.
           </summary>
        </devnotes>
        <parameters>
          <parameter name="AsyncResult" type="TBaseAsyncResult" paramflags="const"/>
        </parameters>
      </procedure>
      <property name="IsCancelled" visibility="public" read="GetIsCancelled" type="Boolean" file="System.Classes.pas" line="2305">
        <devnotes>
            <summary>
              Set to True when the asynchronous call has been cancelled.
            </summary>
        </devnotes>
      </property>
    </members>
  </class>
  <type name="TAsyncProcedureEvent" file="System.Classes.pas" line="2308" procflags="closure">
  </type>
  <type name="TAsyncFunctionEvent" file="System.Classes.pas" line="2309" procflags="closure">
  </type>
  <type name="TAsyncConstArrayProcedureEvent" file="System.Classes.pas" line="2310" procflags="closure">
  </type>
  <type name="TAsyncConstArrayFunctionEvent" file="System.Classes.pas" line="2311" procflags="closure">
  </type>
  <anonMethod name="TAsyncConstArrayProc" file="System.Classes.pas" line="2312">
    <procedure name="Invoke" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2312">
      <parameters>
        <parameter name="Params" paramflags="const">
          <array name="Params">
            <element type="TVarRec"/>
          </array>
        </parameter>
      </parameters>
    </procedure>
  </anonMethod>
  <anonMethod name="TAsyncConstArrayFunc`1" file="System.Classes.pas" line="2313">
    <function name="Invoke" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2313">
      <parameters>
        <parameter name="Params" paramflags="const">
          <array name="Params">
            <element type="TVarRec"/>
          </array>
        </parameter>
        <retval type="TResult"/>
      </parameters>
    </function>
  </anonMethod>
  <anonMethod name="TAsyncCallback" file="System.Classes.pas" line="2315">
    <procedure name="Invoke" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2315">
      <parameters>
        <parameter name="ASyncResult" type="IAsyncResult" paramflags="const"/>
      </parameters>
    </procedure>
  </anonMethod>
  <type name="TAsyncProcedureEvent" file="System.Classes.pas" line="2308" procflags="closure">
  </type>
  <class name="TComponent" file="System.Classes.pas" line="2318">
    <ancestor name="TPersistent" namespace="System.Classes">
      <methodref name="AssignError" visibility="private"/>
      <methodref name="AssignTo" visibility="protected" procflags="virtual"/>
      <methodref name="DefineProperties" visibility="protected" procflags="virtual"/>
      <methodref name="GetOwner" visibility="protected" procflags="dynamic"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="Assign" visibility="public" procflags="virtual"/>
      <methodref name="GetNamePath" visibility="public" procflags="dynamic"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <interfaces>
      <implements name="IInterfaceComponentReference"/>
      <implements name="IInterface"/>
    </interfaces>
    <members>
      <class name="TComponentAsyncResult" visibility="protected" alias="System.Classes.TComponentAsyncResult" file="System.Classes.pas" line="2320">
        <ancestor name="TBaseAsyncResult" namespace="System.Classes">
          <interfaces>
            <implements name="IAsyncResult"/>
          </interfaces>
          <methodref name="Create@" visibility="class private" procflags="class constructor noself"/>
          <methodref name="Destroy@" visibility="class private" procflags="class destructor noself"/>
          <methodref name="SetFlagsAtomic" visibility="private"/>
          <methodref name="GetAsyncContext" visibility="private"/>
          <methodref name="GetAsyncWaitEvent" visibility="private"/>
          <methodref name="GetCompletedSynchronously" visibility="private"/>
          <methodref name="GetIsCompleted" visibility="private"/>
          <methodref name="GetIsCancelled" visibility="private"/>
          <propertyref name="AsyncWaitEvent" visibility="private"/>
          <methodref name="AsyncDispatch" visibility="protected" procflags="abstract virtual">
          </methodref>
          <methodref name="Complete" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="DoAsyncDispatch" visibility="protected">
          </methodref>
          <methodref name="Schedule" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="Create" visibility="protected" procflags="constructor overload">
          </methodref>
          <propertyref name="Context" visibility="protected">
          </propertyref>
          <methodref name="DoCancel" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override"/>
          <methodref name="Cancel" visibility="public">
          </methodref>
          <methodref name="Invoke" visibility="public">
          </methodref>
          <methodref name="WaitForCompletion" visibility="public">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="static inline">
          </methodref>
          <propertyref name="IsCancelled" visibility="public">
          </propertyref>
          <ancestor name="TInterfacedObject" namespace="System">
            <interfaces>
              <implements name="IInterface"/>
            </interfaces>
            <methodref name="GetRefCount" visibility="private" procflags="inline">
            </methodref>
            <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
            </methodref>
            <methodref name="QueryInterface" visibility="protected">
            </methodref>
            <methodref name="_AddRef" visibility="protected">
            </methodref>
            <methodref name="_Release" visibility="protected">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="override">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="override">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class override">
            </methodref>
            <propertyref name="RefCount" visibility="public">
            </propertyref>
            <ancestor name="TObject" namespace="System">
              <methodref name="Create" visibility="public" procflags="constructor">
              </methodref>
              <methodref name="Free" visibility="public">
              </methodref>
              <methodref name="DisposeOf" visibility="public" procflags="inline">
              </methodref>
              <methodref name="InitInstance" visibility="public" procflags="class">
              </methodref>
              <methodref name="CleanupInstance" visibility="public">
              </methodref>
              <methodref name="ClassType" visibility="public" procflags="inline">
              </methodref>
              <methodref name="ClassName" visibility="public" procflags="class">
              </methodref>
              <methodref name="ClassNameIs" visibility="public" procflags="class">
              </methodref>
              <methodref name="ClassParent" visibility="public" procflags="class inline">
              </methodref>
              <methodref name="ClassInfo" visibility="public" procflags="class inline">
              </methodref>
              <methodref name="InstanceSize" visibility="public" procflags="class inline">
              </methodref>
              <methodref name="InheritsFrom" visibility="public" procflags="class">
              </methodref>
              <methodref name="MethodAddress" visibility="public" procflags="class overload">
              </methodref>
              <methodref name="MethodAddress" visibility="public" procflags="class overload">
              </methodref>
              <methodref name="MethodName" visibility="public" procflags="class">
              </methodref>
              <methodref name="QualifiedClassName" visibility="public" procflags="class">
              </methodref>
              <methodref name="FieldAddress" visibility="public" procflags="overload">
              </methodref>
              <methodref name="FieldAddress" visibility="public" procflags="overload">
              </methodref>
              <methodref name="GetInterface" visibility="public">
              </methodref>
              <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
              </methodref>
              <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
              </methodref>
              <methodref name="UnitName" visibility="public" procflags="class">
              </methodref>
              <methodref name="UnitScope" visibility="public" procflags="class">
              </methodref>
              <methodref name="Equals" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="GetHashCode" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="ToString" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="SafeCallException" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="AfterConstruction" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="Dispatch" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="DefaultHandler" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="NewInstance" visibility="public" procflags="class virtual">
              </methodref>
              <methodref name="FreeInstance" visibility="public" procflags="virtual">
              </methodref>
              <methodref name="Destroy" visibility="public" procflags="destructor virtual">
              </methodref>
              <methodref name="GetDisposed" visibility="protected" procflags="inline">
              </methodref>
              <methodref name="CheckDisposed" visibility="protected" procflags="inline">
              </methodref>
              <propertyref name="Disposed" visibility="protected">
              </propertyref>
            </ancestor>
          </ancestor>
        </ancestor>
        <members>
          <field name="FComponent" type="TComponent" visibility="private" size="4" offset="36" file="System.Classes.pas" line="2322"/>
          <procedure name="Schedule" visibility="protected" procflags="override" file="System.Classes.pas" line="2324">
          </procedure>
          <constructor name="Create" visibility="protected" file="System.Classes.pas" line="2325">
            <parameters>
              <parameter name="AContext" type="TObject" paramflags="const"/>
              <parameter name="AComponent" type="TComponent" paramflags="const"/>
            </parameters>
          </constructor>
        </members>
      </class>
      <class name="TAsyncConstArrayResult" visibility="protected" alias="System.Classes.TAsyncConstArrayResult" file="System.Classes.pas" line="2327">
        <ancestor name="TComponent.TComponentAsyncResult" namespace="System.Classes">
          <methodref name="Schedule" visibility="protected" procflags="override"/>
          <methodref name="Create" visibility="protected" procflags="constructor"/>
          <ancestor name="TBaseAsyncResult" namespace="System.Classes">
            <interfaces>
              <implements name="IAsyncResult"/>
            </interfaces>
            <methodref name="Create@" visibility="class private" procflags="class constructor noself"/>
            <methodref name="Destroy@" visibility="class private" procflags="class destructor noself"/>
            <methodref name="SetFlagsAtomic" visibility="private"/>
            <methodref name="GetAsyncContext" visibility="private"/>
            <methodref name="GetAsyncWaitEvent" visibility="private"/>
            <methodref name="GetCompletedSynchronously" visibility="private"/>
            <methodref name="GetIsCompleted" visibility="private"/>
            <methodref name="GetIsCancelled" visibility="private"/>
            <propertyref name="AsyncWaitEvent" visibility="private"/>
            <methodref name="AsyncDispatch" visibility="protected" procflags="abstract virtual">
            </methodref>
            <methodref name="Complete" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="DoAsyncDispatch" visibility="protected">
            </methodref>
            <methodref name="Schedule" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="Create" visibility="protected" procflags="constructor overload">
            </methodref>
            <propertyref name="Context" visibility="protected">
            </propertyref>
            <methodref name="DoCancel" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="Create" visibility="public" procflags="constructor overload">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor override"/>
            <methodref name="Cancel" visibility="public">
            </methodref>
            <methodref name="Invoke" visibility="public">
            </methodref>
            <methodref name="WaitForCompletion" visibility="public">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="static inline">
            </methodref>
            <propertyref name="IsCancelled" visibility="public">
            </propertyref>
            <ancestor name="TInterfacedObject" namespace="System">
              <interfaces>
                <implements name="IInterface"/>
              </interfaces>
              <methodref name="GetRefCount" visibility="private" procflags="inline">
              </methodref>
              <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
              </methodref>
              <methodref name="QueryInterface" visibility="protected">
              </methodref>
              <methodref name="_AddRef" visibility="protected">
              </methodref>
              <methodref name="_Release" visibility="protected">
              </methodref>
              <methodref name="AfterConstruction" visibility="public" procflags="override">
              </methodref>
              <methodref name="BeforeDestruction" visibility="public" procflags="override">
              </methodref>
              <methodref name="NewInstance" visibility="public" procflags="class override">
              </methodref>
              <propertyref name="RefCount" visibility="public">
              </propertyref>
              <ancestor name="TObject" namespace="System">
                <methodref name="Create" visibility="public" procflags="constructor">
                </methodref>
                <methodref name="Free" visibility="public">
                </methodref>
                <methodref name="DisposeOf" visibility="public" procflags="inline">
                </methodref>
                <methodref name="InitInstance" visibility="public" procflags="class">
                </methodref>
                <methodref name="CleanupInstance" visibility="public">
                </methodref>
                <methodref name="ClassType" visibility="public" procflags="inline">
                </methodref>
                <methodref name="ClassName" visibility="public" procflags="class">
                </methodref>
                <methodref name="ClassNameIs" visibility="public" procflags="class">
                </methodref>
                <methodref name="ClassParent" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="ClassInfo" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="InstanceSize" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="InheritsFrom" visibility="public" procflags="class">
                </methodref>
                <methodref name="MethodAddress" visibility="public" procflags="class overload">
                </methodref>
                <methodref name="MethodAddress" visibility="public" procflags="class overload">
                </methodref>
                <methodref name="MethodName" visibility="public" procflags="class">
                </methodref>
                <methodref name="QualifiedClassName" visibility="public" procflags="class">
                </methodref>
                <methodref name="FieldAddress" visibility="public" procflags="overload">
                </methodref>
                <methodref name="FieldAddress" visibility="public" procflags="overload">
                </methodref>
                <methodref name="GetInterface" visibility="public">
                </methodref>
                <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
                </methodref>
                <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="UnitName" visibility="public" procflags="class">
                </methodref>
                <methodref name="UnitScope" visibility="public" procflags="class">
                </methodref>
                <methodref name="Equals" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="GetHashCode" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="ToString" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="SafeCallException" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="AfterConstruction" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="Dispatch" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="DefaultHandler" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="NewInstance" visibility="public" procflags="class virtual">
                </methodref>
                <methodref name="FreeInstance" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="Destroy" visibility="public" procflags="destructor virtual">
                </methodref>
                <methodref name="GetDisposed" visibility="protected" procflags="inline">
                </methodref>
                <methodref name="CheckDisposed" visibility="protected" procflags="inline">
                </methodref>
                <propertyref name="Disposed" visibility="protected">
                </propertyref>
              </ancestor>
            </ancestor>
          </ancestor>
        </ancestor>
        <members>
          <field name="FParams" type="TArray&lt;System.Rtti.TValue&gt;" visibility="protected" size="4" offset="40" file="System.Classes.pas" line="2329"/>
          <constructor name="Create" visibility="protected" file="System.Classes.pas" line="2330">
            <parameters>
              <parameter name="AContext" type="TObject" paramflags="const"/>
              <parameter name="AComponent" type="TComponent" paramflags="const"/>
              <parameter name="Params" paramflags="const">
                <array name="Params" file="System.Classes.pas" line="18708">
                  <element type="TVarRec"/>
                </array>
              </parameter>
            </parameters>
          </constructor>
        </members>
      </class>
      <class name="TAsyncConstArrayProcResult" sealed="true" visibility="protected" alias="System.Classes.TAsyncConstArrayProcResult" file="System.Classes.pas" line="2332">
        <ancestor name="TComponent.TAsyncConstArrayResult" namespace="System.Classes">
          <methodref name="Create" visibility="protected" procflags="constructor"/>
          <ancestor name="TComponent.TComponentAsyncResult" namespace="System.Classes">
            <methodref name="Schedule" visibility="protected" procflags="override"/>
            <methodref name="Create" visibility="protected" procflags="constructor"/>
            <ancestor name="TBaseAsyncResult" namespace="System.Classes">
              <interfaces>
                <implements name="IAsyncResult"/>
              </interfaces>
              <methodref name="Create@" visibility="class private" procflags="class constructor noself"/>
              <methodref name="Destroy@" visibility="class private" procflags="class destructor noself"/>
              <methodref name="SetFlagsAtomic" visibility="private"/>
              <methodref name="GetAsyncContext" visibility="private"/>
              <methodref name="GetAsyncWaitEvent" visibility="private"/>
              <methodref name="GetCompletedSynchronously" visibility="private"/>
              <methodref name="GetIsCompleted" visibility="private"/>
              <methodref name="GetIsCancelled" visibility="private"/>
              <propertyref name="AsyncWaitEvent" visibility="private"/>
              <methodref name="AsyncDispatch" visibility="protected" procflags="abstract virtual">
              </methodref>
              <methodref name="Complete" visibility="protected" procflags="virtual">
              </methodref>
              <methodref name="DoAsyncDispatch" visibility="protected">
              </methodref>
              <methodref name="Schedule" visibility="protected" procflags="virtual">
              </methodref>
              <methodref name="Create" visibility="protected" procflags="constructor overload">
              </methodref>
              <propertyref name="Context" visibility="protected">
              </propertyref>
              <methodref name="DoCancel" visibility="protected" procflags="virtual">
              </methodref>
              <methodref name="Create" visibility="public" procflags="constructor overload">
              </methodref>
              <methodref name="Destroy" visibility="public" procflags="destructor override"/>
              <methodref name="Cancel" visibility="public">
              </methodref>
              <methodref name="Invoke" visibility="public">
              </methodref>
              <methodref name="WaitForCompletion" visibility="public">
              </methodref>
              <methodref name="Dispatch" visibility="public" procflags="static inline">
              </methodref>
              <propertyref name="IsCancelled" visibility="public">
              </propertyref>
              <ancestor name="TInterfacedObject" namespace="System">
                <interfaces>
                  <implements name="IInterface"/>
                </interfaces>
                <methodref name="GetRefCount" visibility="private" procflags="inline">
                </methodref>
                <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
                </methodref>
                <methodref name="QueryInterface" visibility="protected">
                </methodref>
                <methodref name="_AddRef" visibility="protected">
                </methodref>
                <methodref name="_Release" visibility="protected">
                </methodref>
                <methodref name="AfterConstruction" visibility="public" procflags="override">
                </methodref>
                <methodref name="BeforeDestruction" visibility="public" procflags="override">
                </methodref>
                <methodref name="NewInstance" visibility="public" procflags="class override">
                </methodref>
                <propertyref name="RefCount" visibility="public">
                </propertyref>
                <ancestor name="TObject" namespace="System">
                  <methodref name="Create" visibility="public" procflags="constructor">
                  </methodref>
                  <methodref name="Free" visibility="public">
                  </methodref>
                  <methodref name="DisposeOf" visibility="public" procflags="inline">
                  </methodref>
                  <methodref name="InitInstance" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="CleanupInstance" visibility="public">
                  </methodref>
                  <methodref name="ClassType" visibility="public" procflags="inline">
                  </methodref>
                  <methodref name="ClassName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="ClassNameIs" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="ClassParent" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="ClassInfo" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="InstanceSize" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="InheritsFrom" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="MethodAddress" visibility="public" procflags="class overload">
                  </methodref>
                  <methodref name="MethodAddress" visibility="public" procflags="class overload">
                  </methodref>
                  <methodref name="MethodName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="QualifiedClassName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="FieldAddress" visibility="public" procflags="overload">
                  </methodref>
                  <methodref name="FieldAddress" visibility="public" procflags="overload">
                  </methodref>
                  <methodref name="GetInterface" visibility="public">
                  </methodref>
                  <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="UnitName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="UnitScope" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="Equals" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="GetHashCode" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="ToString" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="SafeCallException" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="AfterConstruction" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="Dispatch" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="DefaultHandler" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="NewInstance" visibility="public" procflags="class virtual">
                  </methodref>
                  <methodref name="FreeInstance" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="Destroy" visibility="public" procflags="destructor virtual">
                  </methodref>
                  <methodref name="GetDisposed" visibility="protected" procflags="inline">
                  </methodref>
                  <methodref name="CheckDisposed" visibility="protected" procflags="inline">
                  </methodref>
                  <propertyref name="Disposed" visibility="protected">
                  </propertyref>
                </ancestor>
              </ancestor>
            </ancestor>
          </ancestor>
        </ancestor>
        <members>
          <field name="FAsyncProcedure" type="TAsyncConstArrayProc" visibility="private" size="4" offset="44" file="System.Classes.pas" line="2334"/>
          <procedure name="AsyncDispatch" visibility="protected" procflags="override" file="System.Classes.pas" line="2336">
          </procedure>
          <constructor name="Create" visibility="protected" file="System.Classes.pas" line="2337">
            <parameters>
              <parameter name="AAsyncProcedure" type="TAsyncConstArrayProc" paramflags="const"/>
              <parameter name="AContext" type="TObject" paramflags="const"/>
              <parameter name="AComponent" type="TComponent" paramflags="const"/>
              <parameter name="Params" paramflags="const">
                <array name="Params" file="System.Classes.pas" line="18722">
                  <element type="TVarRec"/>
                </array>
              </parameter>
            </parameters>
          </constructor>
        </members>
      </class>
      <class name="TAsyncConstArrayFuncResult`1" sealed="true" visibility="protected" alias="System.Classes.TAsyncConstArrayFuncResult`1" file="System.Classes.pas" line="2339">
        <ancestor name="TComponent.TAsyncConstArrayResult" namespace="System.Classes">
          <methodref name="Create" visibility="protected" procflags="constructor"/>
          <ancestor name="TComponent.TComponentAsyncResult" namespace="System.Classes">
            <methodref name="Schedule" visibility="protected" procflags="override"/>
            <methodref name="Create" visibility="protected" procflags="constructor"/>
            <ancestor name="TBaseAsyncResult" namespace="System.Classes">
              <interfaces>
                <implements name="IAsyncResult"/>
              </interfaces>
              <methodref name="Create@" visibility="class private" procflags="class constructor noself"/>
              <methodref name="Destroy@" visibility="class private" procflags="class destructor noself"/>
              <methodref name="SetFlagsAtomic" visibility="private"/>
              <methodref name="GetAsyncContext" visibility="private"/>
              <methodref name="GetAsyncWaitEvent" visibility="private"/>
              <methodref name="GetCompletedSynchronously" visibility="private"/>
              <methodref name="GetIsCompleted" visibility="private"/>
              <methodref name="GetIsCancelled" visibility="private"/>
              <propertyref name="AsyncWaitEvent" visibility="private"/>
              <methodref name="AsyncDispatch" visibility="protected" procflags="abstract virtual">
              </methodref>
              <methodref name="Complete" visibility="protected" procflags="virtual">
              </methodref>
              <methodref name="DoAsyncDispatch" visibility="protected">
              </methodref>
              <methodref name="Schedule" visibility="protected" procflags="virtual">
              </methodref>
              <methodref name="Create" visibility="protected" procflags="constructor overload">
              </methodref>
              <propertyref name="Context" visibility="protected">
              </propertyref>
              <methodref name="DoCancel" visibility="protected" procflags="virtual">
              </methodref>
              <methodref name="Create" visibility="public" procflags="constructor overload">
              </methodref>
              <methodref name="Destroy" visibility="public" procflags="destructor override"/>
              <methodref name="Cancel" visibility="public">
              </methodref>
              <methodref name="Invoke" visibility="public">
              </methodref>
              <methodref name="WaitForCompletion" visibility="public">
              </methodref>
              <methodref name="Dispatch" visibility="public" procflags="static inline">
              </methodref>
              <propertyref name="IsCancelled" visibility="public">
              </propertyref>
              <ancestor name="TInterfacedObject" namespace="System">
                <interfaces>
                  <implements name="IInterface"/>
                </interfaces>
                <methodref name="GetRefCount" visibility="private" procflags="inline">
                </methodref>
                <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
                </methodref>
                <methodref name="QueryInterface" visibility="protected">
                </methodref>
                <methodref name="_AddRef" visibility="protected">
                </methodref>
                <methodref name="_Release" visibility="protected">
                </methodref>
                <methodref name="AfterConstruction" visibility="public" procflags="override">
                </methodref>
                <methodref name="BeforeDestruction" visibility="public" procflags="override">
                </methodref>
                <methodref name="NewInstance" visibility="public" procflags="class override">
                </methodref>
                <propertyref name="RefCount" visibility="public">
                </propertyref>
                <ancestor name="TObject" namespace="System">
                  <methodref name="Create" visibility="public" procflags="constructor">
                  </methodref>
                  <methodref name="Free" visibility="public">
                  </methodref>
                  <methodref name="DisposeOf" visibility="public" procflags="inline">
                  </methodref>
                  <methodref name="InitInstance" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="CleanupInstance" visibility="public">
                  </methodref>
                  <methodref name="ClassType" visibility="public" procflags="inline">
                  </methodref>
                  <methodref name="ClassName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="ClassNameIs" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="ClassParent" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="ClassInfo" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="InstanceSize" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="InheritsFrom" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="MethodAddress" visibility="public" procflags="class overload">
                  </methodref>
                  <methodref name="MethodAddress" visibility="public" procflags="class overload">
                  </methodref>
                  <methodref name="MethodName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="QualifiedClassName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="FieldAddress" visibility="public" procflags="overload">
                  </methodref>
                  <methodref name="FieldAddress" visibility="public" procflags="overload">
                  </methodref>
                  <methodref name="GetInterface" visibility="public">
                  </methodref>
                  <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="UnitName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="UnitScope" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="Equals" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="GetHashCode" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="ToString" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="SafeCallException" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="AfterConstruction" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="Dispatch" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="DefaultHandler" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="NewInstance" visibility="public" procflags="class virtual">
                  </methodref>
                  <methodref name="FreeInstance" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="Destroy" visibility="public" procflags="destructor virtual">
                  </methodref>
                  <methodref name="GetDisposed" visibility="protected" procflags="inline">
                  </methodref>
                  <methodref name="CheckDisposed" visibility="protected" procflags="inline">
                  </methodref>
                  <propertyref name="Disposed" visibility="protected">
                  </propertyref>
                </ancestor>
              </ancestor>
            </ancestor>
          </ancestor>
        </ancestor>
        <members>
          <field name="FRetVal" type="TResult" visibility="private" size="1" offset="44" file="System.Classes.pas" line="2341"/>
          <field name="FAsyncFunction" visibility="private" size="4" offset="48" file="System.Classes.pas" line="2342">
          </field>
          <constructor name="Create" visibility="protected" file="System.Classes.pas" line="2344">
            <parameters>
              <parameter name="AAsyncFunction" paramflags="const">
              </parameter>
              <parameter name="AContext" type="TObject" paramflags="const"/>
              <parameter name="AComponent" type="TComponent" paramflags="const"/>
              <parameter name="Params" paramflags="const">
                <array name="Params" file="System.Classes.pas" line="18736">
                  <element type="TVarRec"/>
                </array>
              </parameter>
            </parameters>
          </constructor>
          <procedure name="AsyncDispatch" visibility="protected" procflags="override" file="System.Classes.pas" line="2345">
          </procedure>
          <function name="GetRetVal" visibility="protected" file="System.Classes.pas" line="2346">
            <parameters>
              <retval type="TResult"/>
            </parameters>
          </function>
        </members>
      </class>
      <class name="TAsyncConstArrayProcedureResult" sealed="true" visibility="protected" alias="System.Classes.TAsyncConstArrayProcedureResult" file="System.Classes.pas" line="2348">
        <ancestor name="TComponent.TAsyncConstArrayResult" namespace="System.Classes">
          <methodref name="Create" visibility="protected" procflags="constructor"/>
          <ancestor name="TComponent.TComponentAsyncResult" namespace="System.Classes">
            <methodref name="Schedule" visibility="protected" procflags="override"/>
            <methodref name="Create" visibility="protected" procflags="constructor"/>
            <ancestor name="TBaseAsyncResult" namespace="System.Classes">
              <interfaces>
                <implements name="IAsyncResult"/>
              </interfaces>
              <methodref name="Create@" visibility="class private" procflags="class constructor noself"/>
              <methodref name="Destroy@" visibility="class private" procflags="class destructor noself"/>
              <methodref name="SetFlagsAtomic" visibility="private"/>
              <methodref name="GetAsyncContext" visibility="private"/>
              <methodref name="GetAsyncWaitEvent" visibility="private"/>
              <methodref name="GetCompletedSynchronously" visibility="private"/>
              <methodref name="GetIsCompleted" visibility="private"/>
              <methodref name="GetIsCancelled" visibility="private"/>
              <propertyref name="AsyncWaitEvent" visibility="private"/>
              <methodref name="AsyncDispatch" visibility="protected" procflags="abstract virtual">
              </methodref>
              <methodref name="Complete" visibility="protected" procflags="virtual">
              </methodref>
              <methodref name="DoAsyncDispatch" visibility="protected">
              </methodref>
              <methodref name="Schedule" visibility="protected" procflags="virtual">
              </methodref>
              <methodref name="Create" visibility="protected" procflags="constructor overload">
              </methodref>
              <propertyref name="Context" visibility="protected">
              </propertyref>
              <methodref name="DoCancel" visibility="protected" procflags="virtual">
              </methodref>
              <methodref name="Create" visibility="public" procflags="constructor overload">
              </methodref>
              <methodref name="Destroy" visibility="public" procflags="destructor override"/>
              <methodref name="Cancel" visibility="public">
              </methodref>
              <methodref name="Invoke" visibility="public">
              </methodref>
              <methodref name="WaitForCompletion" visibility="public">
              </methodref>
              <methodref name="Dispatch" visibility="public" procflags="static inline">
              </methodref>
              <propertyref name="IsCancelled" visibility="public">
              </propertyref>
              <ancestor name="TInterfacedObject" namespace="System">
                <interfaces>
                  <implements name="IInterface"/>
                </interfaces>
                <methodref name="GetRefCount" visibility="private" procflags="inline">
                </methodref>
                <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
                </methodref>
                <methodref name="QueryInterface" visibility="protected">
                </methodref>
                <methodref name="_AddRef" visibility="protected">
                </methodref>
                <methodref name="_Release" visibility="protected">
                </methodref>
                <methodref name="AfterConstruction" visibility="public" procflags="override">
                </methodref>
                <methodref name="BeforeDestruction" visibility="public" procflags="override">
                </methodref>
                <methodref name="NewInstance" visibility="public" procflags="class override">
                </methodref>
                <propertyref name="RefCount" visibility="public">
                </propertyref>
                <ancestor name="TObject" namespace="System">
                  <methodref name="Create" visibility="public" procflags="constructor">
                  </methodref>
                  <methodref name="Free" visibility="public">
                  </methodref>
                  <methodref name="DisposeOf" visibility="public" procflags="inline">
                  </methodref>
                  <methodref name="InitInstance" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="CleanupInstance" visibility="public">
                  </methodref>
                  <methodref name="ClassType" visibility="public" procflags="inline">
                  </methodref>
                  <methodref name="ClassName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="ClassNameIs" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="ClassParent" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="ClassInfo" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="InstanceSize" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="InheritsFrom" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="MethodAddress" visibility="public" procflags="class overload">
                  </methodref>
                  <methodref name="MethodAddress" visibility="public" procflags="class overload">
                  </methodref>
                  <methodref name="MethodName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="QualifiedClassName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="FieldAddress" visibility="public" procflags="overload">
                  </methodref>
                  <methodref name="FieldAddress" visibility="public" procflags="overload">
                  </methodref>
                  <methodref name="GetInterface" visibility="public">
                  </methodref>
                  <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="UnitName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="UnitScope" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="Equals" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="GetHashCode" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="ToString" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="SafeCallException" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="AfterConstruction" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="Dispatch" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="DefaultHandler" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="NewInstance" visibility="public" procflags="class virtual">
                  </methodref>
                  <methodref name="FreeInstance" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="Destroy" visibility="public" procflags="destructor virtual">
                  </methodref>
                  <methodref name="GetDisposed" visibility="protected" procflags="inline">
                  </methodref>
                  <methodref name="CheckDisposed" visibility="protected" procflags="inline">
                  </methodref>
                  <propertyref name="Disposed" visibility="protected">
                  </propertyref>
                </ancestor>
              </ancestor>
            </ancestor>
          </ancestor>
        </ancestor>
        <members>
          <field name="FAsyncProcedure" type="TAsyncConstArrayProcedureEvent" visibility="private" size="8" offset="48" file="System.Classes.pas" line="2350"/>
          <procedure name="AsyncDispatch" visibility="protected" procflags="override" file="System.Classes.pas" line="2352">
          </procedure>
          <constructor name="Create" visibility="protected" file="System.Classes.pas" line="2353">
            <parameters>
              <parameter name="AAsyncProcedure" type="TAsyncConstArrayProcedureEvent" paramflags="const"/>
              <parameter name="AContext" type="TObject" paramflags="const"/>
              <parameter name="AComponent" type="TComponent" paramflags="const"/>
              <parameter name="Params" paramflags="const">
                <array name="Params" file="System.Classes.pas" line="18756">
                  <element type="TVarRec"/>
                </array>
              </parameter>
            </parameters>
          </constructor>
        </members>
      </class>
      <class name="TAsyncConstArrayFunctionResult" sealed="true" visibility="protected" alias="System.Classes.TAsyncConstArrayFunctionResult" file="System.Classes.pas" line="2355">
        <ancestor name="TComponent.TAsyncConstArrayResult" namespace="System.Classes">
          <methodref name="Create" visibility="protected" procflags="constructor"/>
          <ancestor name="TComponent.TComponentAsyncResult" namespace="System.Classes">
            <methodref name="Schedule" visibility="protected" procflags="override"/>
            <methodref name="Create" visibility="protected" procflags="constructor"/>
            <ancestor name="TBaseAsyncResult" namespace="System.Classes">
              <interfaces>
                <implements name="IAsyncResult"/>
              </interfaces>
              <methodref name="Create@" visibility="class private" procflags="class constructor noself"/>
              <methodref name="Destroy@" visibility="class private" procflags="class destructor noself"/>
              <methodref name="SetFlagsAtomic" visibility="private"/>
              <methodref name="GetAsyncContext" visibility="private"/>
              <methodref name="GetAsyncWaitEvent" visibility="private"/>
              <methodref name="GetCompletedSynchronously" visibility="private"/>
              <methodref name="GetIsCompleted" visibility="private"/>
              <methodref name="GetIsCancelled" visibility="private"/>
              <propertyref name="AsyncWaitEvent" visibility="private"/>
              <methodref name="AsyncDispatch" visibility="protected" procflags="abstract virtual">
              </methodref>
              <methodref name="Complete" visibility="protected" procflags="virtual">
              </methodref>
              <methodref name="DoAsyncDispatch" visibility="protected">
              </methodref>
              <methodref name="Schedule" visibility="protected" procflags="virtual">
              </methodref>
              <methodref name="Create" visibility="protected" procflags="constructor overload">
              </methodref>
              <propertyref name="Context" visibility="protected">
              </propertyref>
              <methodref name="DoCancel" visibility="protected" procflags="virtual">
              </methodref>
              <methodref name="Create" visibility="public" procflags="constructor overload">
              </methodref>
              <methodref name="Destroy" visibility="public" procflags="destructor override"/>
              <methodref name="Cancel" visibility="public">
              </methodref>
              <methodref name="Invoke" visibility="public">
              </methodref>
              <methodref name="WaitForCompletion" visibility="public">
              </methodref>
              <methodref name="Dispatch" visibility="public" procflags="static inline">
              </methodref>
              <propertyref name="IsCancelled" visibility="public">
              </propertyref>
              <ancestor name="TInterfacedObject" namespace="System">
                <interfaces>
                  <implements name="IInterface"/>
                </interfaces>
                <methodref name="GetRefCount" visibility="private" procflags="inline">
                </methodref>
                <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
                </methodref>
                <methodref name="QueryInterface" visibility="protected">
                </methodref>
                <methodref name="_AddRef" visibility="protected">
                </methodref>
                <methodref name="_Release" visibility="protected">
                </methodref>
                <methodref name="AfterConstruction" visibility="public" procflags="override">
                </methodref>
                <methodref name="BeforeDestruction" visibility="public" procflags="override">
                </methodref>
                <methodref name="NewInstance" visibility="public" procflags="class override">
                </methodref>
                <propertyref name="RefCount" visibility="public">
                </propertyref>
                <ancestor name="TObject" namespace="System">
                  <methodref name="Create" visibility="public" procflags="constructor">
                  </methodref>
                  <methodref name="Free" visibility="public">
                  </methodref>
                  <methodref name="DisposeOf" visibility="public" procflags="inline">
                  </methodref>
                  <methodref name="InitInstance" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="CleanupInstance" visibility="public">
                  </methodref>
                  <methodref name="ClassType" visibility="public" procflags="inline">
                  </methodref>
                  <methodref name="ClassName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="ClassNameIs" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="ClassParent" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="ClassInfo" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="InstanceSize" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="InheritsFrom" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="MethodAddress" visibility="public" procflags="class overload">
                  </methodref>
                  <methodref name="MethodAddress" visibility="public" procflags="class overload">
                  </methodref>
                  <methodref name="MethodName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="QualifiedClassName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="FieldAddress" visibility="public" procflags="overload">
                  </methodref>
                  <methodref name="FieldAddress" visibility="public" procflags="overload">
                  </methodref>
                  <methodref name="GetInterface" visibility="public">
                  </methodref>
                  <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
                  </methodref>
                  <methodref name="UnitName" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="UnitScope" visibility="public" procflags="class">
                  </methodref>
                  <methodref name="Equals" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="GetHashCode" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="ToString" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="SafeCallException" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="AfterConstruction" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="Dispatch" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="DefaultHandler" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="NewInstance" visibility="public" procflags="class virtual">
                  </methodref>
                  <methodref name="FreeInstance" visibility="public" procflags="virtual">
                  </methodref>
                  <methodref name="Destroy" visibility="public" procflags="destructor virtual">
                  </methodref>
                  <methodref name="GetDisposed" visibility="protected" procflags="inline">
                  </methodref>
                  <methodref name="CheckDisposed" visibility="protected" procflags="inline">
                  </methodref>
                  <propertyref name="Disposed" visibility="protected">
                  </propertyref>
                </ancestor>
              </ancestor>
            </ancestor>
          </ancestor>
        </ancestor>
        <members>
          <field name="FRetVal" type="TObject" visibility="private" size="4" offset="44" file="System.Classes.pas" line="2357"/>
          <field name="FAsyncFunction" type="TAsyncConstArrayFunctionEvent" visibility="private" size="8" offset="48" file="System.Classes.pas" line="2358"/>
          <constructor name="Create" visibility="protected" file="System.Classes.pas" line="2360">
            <parameters>
              <parameter name="AAsyncFunction" type="TAsyncConstArrayFunctionEvent" paramflags="const"/>
              <parameter name="AContext" type="TObject" paramflags="const"/>
              <parameter name="AComponent" type="TComponent" paramflags="const"/>
              <parameter name="Params" paramflags="const">
                <array name="Params" file="System.Classes.pas" line="18770">
                  <element type="TVarRec"/>
                </array>
              </parameter>
            </parameters>
          </constructor>
          <procedure name="AsyncDispatch" visibility="protected" procflags="override" file="System.Classes.pas" line="2361">
          </procedure>
          <function name="GetRetVal" visibility="protected" file="System.Classes.pas" line="2362">
            <parameters>
              <retval type="TObject"/>
            </parameters>
          </function>
        </members>
      </class>
      <class name="TAsyncProcedureResult" sealed="true" visibility="protected" alias="System.Classes.TAsyncProcedureResult" file="System.Classes.pas" line="2364">
        <ancestor name="TComponent.TComponentAsyncResult" namespace="System.Classes">
          <methodref name="Schedule" visibility="protected" procflags="override"/>
          <methodref name="Create" visibility="protected" procflags="constructor"/>
          <ancestor name="TBaseAsyncResult" namespace="System.Classes">
            <interfaces>
              <implements name="IAsyncResult"/>
            </interfaces>
            <methodref name="Create@" visibility="class private" procflags="class constructor noself"/>
            <methodref name="Destroy@" visibility="class private" procflags="class destructor noself"/>
            <methodref name="SetFlagsAtomic" visibility="private"/>
            <methodref name="GetAsyncContext" visibility="private"/>
            <methodref name="GetAsyncWaitEvent" visibility="private"/>
            <methodref name="GetCompletedSynchronously" visibility="private"/>
            <methodref name="GetIsCompleted" visibility="private"/>
            <methodref name="GetIsCancelled" visibility="private"/>
            <propertyref name="AsyncWaitEvent" visibility="private"/>
            <methodref name="AsyncDispatch" visibility="protected" procflags="abstract virtual">
            </methodref>
            <methodref name="Complete" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="DoAsyncDispatch" visibility="protected">
            </methodref>
            <methodref name="Schedule" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="Create" visibility="protected" procflags="constructor overload">
            </methodref>
            <propertyref name="Context" visibility="protected">
            </propertyref>
            <methodref name="DoCancel" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="Create" visibility="public" procflags="constructor overload">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor override"/>
            <methodref name="Cancel" visibility="public">
            </methodref>
            <methodref name="Invoke" visibility="public">
            </methodref>
            <methodref name="WaitForCompletion" visibility="public">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="static inline">
            </methodref>
            <propertyref name="IsCancelled" visibility="public">
            </propertyref>
            <ancestor name="TInterfacedObject" namespace="System">
              <interfaces>
                <implements name="IInterface"/>
              </interfaces>
              <methodref name="GetRefCount" visibility="private" procflags="inline">
              </methodref>
              <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
              </methodref>
              <methodref name="QueryInterface" visibility="protected">
              </methodref>
              <methodref name="_AddRef" visibility="protected">
              </methodref>
              <methodref name="_Release" visibility="protected">
              </methodref>
              <methodref name="AfterConstruction" visibility="public" procflags="override">
              </methodref>
              <methodref name="BeforeDestruction" visibility="public" procflags="override">
              </methodref>
              <methodref name="NewInstance" visibility="public" procflags="class override">
              </methodref>
              <propertyref name="RefCount" visibility="public">
              </propertyref>
              <ancestor name="TObject" namespace="System">
                <methodref name="Create" visibility="public" procflags="constructor">
                </methodref>
                <methodref name="Free" visibility="public">
                </methodref>
                <methodref name="DisposeOf" visibility="public" procflags="inline">
                </methodref>
                <methodref name="InitInstance" visibility="public" procflags="class">
                </methodref>
                <methodref name="CleanupInstance" visibility="public">
                </methodref>
                <methodref name="ClassType" visibility="public" procflags="inline">
                </methodref>
                <methodref name="ClassName" visibility="public" procflags="class">
                </methodref>
                <methodref name="ClassNameIs" visibility="public" procflags="class">
                </methodref>
                <methodref name="ClassParent" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="ClassInfo" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="InstanceSize" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="InheritsFrom" visibility="public" procflags="class">
                </methodref>
                <methodref name="MethodAddress" visibility="public" procflags="class overload">
                </methodref>
                <methodref name="MethodAddress" visibility="public" procflags="class overload">
                </methodref>
                <methodref name="MethodName" visibility="public" procflags="class">
                </methodref>
                <methodref name="QualifiedClassName" visibility="public" procflags="class">
                </methodref>
                <methodref name="FieldAddress" visibility="public" procflags="overload">
                </methodref>
                <methodref name="FieldAddress" visibility="public" procflags="overload">
                </methodref>
                <methodref name="GetInterface" visibility="public">
                </methodref>
                <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
                </methodref>
                <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="UnitName" visibility="public" procflags="class">
                </methodref>
                <methodref name="UnitScope" visibility="public" procflags="class">
                </methodref>
                <methodref name="Equals" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="GetHashCode" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="ToString" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="SafeCallException" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="AfterConstruction" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="Dispatch" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="DefaultHandler" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="NewInstance" visibility="public" procflags="class virtual">
                </methodref>
                <methodref name="FreeInstance" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="Destroy" visibility="public" procflags="destructor virtual">
                </methodref>
                <methodref name="GetDisposed" visibility="protected" procflags="inline">
                </methodref>
                <methodref name="CheckDisposed" visibility="protected" procflags="inline">
                </methodref>
                <propertyref name="Disposed" visibility="protected">
                </propertyref>
              </ancestor>
            </ancestor>
          </ancestor>
        </ancestor>
        <members>
          <field name="FAsyncProcedure" type="TProc" visibility="private" size="4" offset="40" file="System.Classes.pas" line="2366"/>
          <constructor name="Create" visibility="protected" file="System.Classes.pas" line="2368">
            <parameters>
              <parameter name="AAsyncProcedure" type="TProc" paramflags="const"/>
              <parameter name="AContext" type="TObject" paramflags="const"/>
              <parameter name="AComponent" type="TComponent" paramflags="const"/>
            </parameters>
          </constructor>
          <procedure name="AsyncDispatch" visibility="protected" procflags="override" file="System.Classes.pas" line="2369">
          </procedure>
        </members>
      </class>
      <class name="TAsyncFunctionResult`1" sealed="true" visibility="protected" alias="System.Classes.TAsyncFunctionResult`1" file="System.Classes.pas" line="2371">
        <ancestor name="TComponent.TComponentAsyncResult" namespace="System.Classes">
          <methodref name="Schedule" visibility="protected" procflags="override"/>
          <methodref name="Create" visibility="protected" procflags="constructor"/>
          <ancestor name="TBaseAsyncResult" namespace="System.Classes">
            <interfaces>
              <implements name="IAsyncResult"/>
            </interfaces>
            <methodref name="Create@" visibility="class private" procflags="class constructor noself"/>
            <methodref name="Destroy@" visibility="class private" procflags="class destructor noself"/>
            <methodref name="SetFlagsAtomic" visibility="private"/>
            <methodref name="GetAsyncContext" visibility="private"/>
            <methodref name="GetAsyncWaitEvent" visibility="private"/>
            <methodref name="GetCompletedSynchronously" visibility="private"/>
            <methodref name="GetIsCompleted" visibility="private"/>
            <methodref name="GetIsCancelled" visibility="private"/>
            <propertyref name="AsyncWaitEvent" visibility="private"/>
            <methodref name="AsyncDispatch" visibility="protected" procflags="abstract virtual">
            </methodref>
            <methodref name="Complete" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="DoAsyncDispatch" visibility="protected">
            </methodref>
            <methodref name="Schedule" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="Create" visibility="protected" procflags="constructor overload">
            </methodref>
            <propertyref name="Context" visibility="protected">
            </propertyref>
            <methodref name="DoCancel" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="Create" visibility="public" procflags="constructor overload">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor override"/>
            <methodref name="Cancel" visibility="public">
            </methodref>
            <methodref name="Invoke" visibility="public">
            </methodref>
            <methodref name="WaitForCompletion" visibility="public">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="static inline">
            </methodref>
            <propertyref name="IsCancelled" visibility="public">
            </propertyref>
            <ancestor name="TInterfacedObject" namespace="System">
              <interfaces>
                <implements name="IInterface"/>
              </interfaces>
              <methodref name="GetRefCount" visibility="private" procflags="inline">
              </methodref>
              <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
              </methodref>
              <methodref name="QueryInterface" visibility="protected">
              </methodref>
              <methodref name="_AddRef" visibility="protected">
              </methodref>
              <methodref name="_Release" visibility="protected">
              </methodref>
              <methodref name="AfterConstruction" visibility="public" procflags="override">
              </methodref>
              <methodref name="BeforeDestruction" visibility="public" procflags="override">
              </methodref>
              <methodref name="NewInstance" visibility="public" procflags="class override">
              </methodref>
              <propertyref name="RefCount" visibility="public">
              </propertyref>
              <ancestor name="TObject" namespace="System">
                <methodref name="Create" visibility="public" procflags="constructor">
                </methodref>
                <methodref name="Free" visibility="public">
                </methodref>
                <methodref name="DisposeOf" visibility="public" procflags="inline">
                </methodref>
                <methodref name="InitInstance" visibility="public" procflags="class">
                </methodref>
                <methodref name="CleanupInstance" visibility="public">
                </methodref>
                <methodref name="ClassType" visibility="public" procflags="inline">
                </methodref>
                <methodref name="ClassName" visibility="public" procflags="class">
                </methodref>
                <methodref name="ClassNameIs" visibility="public" procflags="class">
                </methodref>
                <methodref name="ClassParent" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="ClassInfo" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="InstanceSize" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="InheritsFrom" visibility="public" procflags="class">
                </methodref>
                <methodref name="MethodAddress" visibility="public" procflags="class overload">
                </methodref>
                <methodref name="MethodAddress" visibility="public" procflags="class overload">
                </methodref>
                <methodref name="MethodName" visibility="public" procflags="class">
                </methodref>
                <methodref name="QualifiedClassName" visibility="public" procflags="class">
                </methodref>
                <methodref name="FieldAddress" visibility="public" procflags="overload">
                </methodref>
                <methodref name="FieldAddress" visibility="public" procflags="overload">
                </methodref>
                <methodref name="GetInterface" visibility="public">
                </methodref>
                <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
                </methodref>
                <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="UnitName" visibility="public" procflags="class">
                </methodref>
                <methodref name="UnitScope" visibility="public" procflags="class">
                </methodref>
                <methodref name="Equals" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="GetHashCode" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="ToString" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="SafeCallException" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="AfterConstruction" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="Dispatch" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="DefaultHandler" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="NewInstance" visibility="public" procflags="class virtual">
                </methodref>
                <methodref name="FreeInstance" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="Destroy" visibility="public" procflags="destructor virtual">
                </methodref>
                <methodref name="GetDisposed" visibility="protected" procflags="inline">
                </methodref>
                <methodref name="CheckDisposed" visibility="protected" procflags="inline">
                </methodref>
                <propertyref name="Disposed" visibility="protected">
                </propertyref>
              </ancestor>
            </ancestor>
          </ancestor>
        </ancestor>
        <members>
          <field name="FRetVal" type="TResult" visibility="private" size="1" offset="40" file="System.Classes.pas" line="2373"/>
          <field name="FAsyncFunction" visibility="private" size="4" offset="44" file="System.Classes.pas" line="2374">
          </field>
          <constructor name="Create" visibility="protected" file="System.Classes.pas" line="2376">
            <parameters>
              <parameter name="AAsyncFunction" paramflags="const">
              </parameter>
              <parameter name="AContext" type="TObject" paramflags="const"/>
              <parameter name="AComponent" type="TComponent" paramflags="const"/>
            </parameters>
          </constructor>
          <procedure name="AsyncDispatch" visibility="protected" procflags="override" file="System.Classes.pas" line="2377">
          </procedure>
          <function name="GetRetVal" visibility="protected" file="System.Classes.pas" line="2378">
            <parameters>
              <retval type="TResult"/>
            </parameters>
          </function>
        </members>
      </class>
      <class name="TAsyncProcedureResultEvent" sealed="true" visibility="protected" alias="System.Classes.TAsyncProcedureResultEvent" file="System.Classes.pas" line="2380">
        <ancestor name="TComponent.TComponentAsyncResult" namespace="System.Classes">
          <methodref name="Schedule" visibility="protected" procflags="override"/>
          <methodref name="Create" visibility="protected" procflags="constructor"/>
          <ancestor name="TBaseAsyncResult" namespace="System.Classes">
            <interfaces>
              <implements name="IAsyncResult"/>
            </interfaces>
            <methodref name="Create@" visibility="class private" procflags="class constructor noself"/>
            <methodref name="Destroy@" visibility="class private" procflags="class destructor noself"/>
            <methodref name="SetFlagsAtomic" visibility="private"/>
            <methodref name="GetAsyncContext" visibility="private"/>
            <methodref name="GetAsyncWaitEvent" visibility="private"/>
            <methodref name="GetCompletedSynchronously" visibility="private"/>
            <methodref name="GetIsCompleted" visibility="private"/>
            <methodref name="GetIsCancelled" visibility="private"/>
            <propertyref name="AsyncWaitEvent" visibility="private"/>
            <methodref name="AsyncDispatch" visibility="protected" procflags="abstract virtual">
            </methodref>
            <methodref name="Complete" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="DoAsyncDispatch" visibility="protected">
            </methodref>
            <methodref name="Schedule" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="Create" visibility="protected" procflags="constructor overload">
            </methodref>
            <propertyref name="Context" visibility="protected">
            </propertyref>
            <methodref name="DoCancel" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="Create" visibility="public" procflags="constructor overload">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor override"/>
            <methodref name="Cancel" visibility="public">
            </methodref>
            <methodref name="Invoke" visibility="public">
            </methodref>
            <methodref name="WaitForCompletion" visibility="public">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="static inline">
            </methodref>
            <propertyref name="IsCancelled" visibility="public">
            </propertyref>
            <ancestor name="TInterfacedObject" namespace="System">
              <interfaces>
                <implements name="IInterface"/>
              </interfaces>
              <methodref name="GetRefCount" visibility="private" procflags="inline">
              </methodref>
              <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
              </methodref>
              <methodref name="QueryInterface" visibility="protected">
              </methodref>
              <methodref name="_AddRef" visibility="protected">
              </methodref>
              <methodref name="_Release" visibility="protected">
              </methodref>
              <methodref name="AfterConstruction" visibility="public" procflags="override">
              </methodref>
              <methodref name="BeforeDestruction" visibility="public" procflags="override">
              </methodref>
              <methodref name="NewInstance" visibility="public" procflags="class override">
              </methodref>
              <propertyref name="RefCount" visibility="public">
              </propertyref>
              <ancestor name="TObject" namespace="System">
                <methodref name="Create" visibility="public" procflags="constructor">
                </methodref>
                <methodref name="Free" visibility="public">
                </methodref>
                <methodref name="DisposeOf" visibility="public" procflags="inline">
                </methodref>
                <methodref name="InitInstance" visibility="public" procflags="class">
                </methodref>
                <methodref name="CleanupInstance" visibility="public">
                </methodref>
                <methodref name="ClassType" visibility="public" procflags="inline">
                </methodref>
                <methodref name="ClassName" visibility="public" procflags="class">
                </methodref>
                <methodref name="ClassNameIs" visibility="public" procflags="class">
                </methodref>
                <methodref name="ClassParent" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="ClassInfo" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="InstanceSize" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="InheritsFrom" visibility="public" procflags="class">
                </methodref>
                <methodref name="MethodAddress" visibility="public" procflags="class overload">
                </methodref>
                <methodref name="MethodAddress" visibility="public" procflags="class overload">
                </methodref>
                <methodref name="MethodName" visibility="public" procflags="class">
                </methodref>
                <methodref name="QualifiedClassName" visibility="public" procflags="class">
                </methodref>
                <methodref name="FieldAddress" visibility="public" procflags="overload">
                </methodref>
                <methodref name="FieldAddress" visibility="public" procflags="overload">
                </methodref>
                <methodref name="GetInterface" visibility="public">
                </methodref>
                <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
                </methodref>
                <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="UnitName" visibility="public" procflags="class">
                </methodref>
                <methodref name="UnitScope" visibility="public" procflags="class">
                </methodref>
                <methodref name="Equals" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="GetHashCode" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="ToString" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="SafeCallException" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="AfterConstruction" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="Dispatch" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="DefaultHandler" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="NewInstance" visibility="public" procflags="class virtual">
                </methodref>
                <methodref name="FreeInstance" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="Destroy" visibility="public" procflags="destructor virtual">
                </methodref>
                <methodref name="GetDisposed" visibility="protected" procflags="inline">
                </methodref>
                <methodref name="CheckDisposed" visibility="protected" procflags="inline">
                </methodref>
                <propertyref name="Disposed" visibility="protected">
                </propertyref>
              </ancestor>
            </ancestor>
          </ancestor>
        </ancestor>
        <members>
          <field name="FAsyncProcedure" type="TAsyncProcedureEvent" visibility="private" size="8" offset="40" file="System.Classes.pas" line="2382"/>
          <constructor name="Create" visibility="protected" file="System.Classes.pas" line="2384">
            <parameters>
              <parameter name="AAsyncProcedure" type="TAsyncProcedureEvent" paramflags="const"/>
              <parameter name="AContext" type="TObject" paramflags="const"/>
              <parameter name="AComponent" type="TComponent" paramflags="const"/>
            </parameters>
          </constructor>
          <procedure name="AsyncDispatch" visibility="protected" procflags="override" file="System.Classes.pas" line="2385">
          </procedure>
        </members>
      </class>
      <class name="TAsyncFunctionResultEvent" sealed="true" visibility="protected" alias="System.Classes.TAsyncFunctionResultEvent" file="System.Classes.pas" line="2387">
        <ancestor name="TComponent.TComponentAsyncResult" namespace="System.Classes">
          <methodref name="Schedule" visibility="protected" procflags="override"/>
          <methodref name="Create" visibility="protected" procflags="constructor"/>
          <ancestor name="TBaseAsyncResult" namespace="System.Classes">
            <interfaces>
              <implements name="IAsyncResult"/>
            </interfaces>
            <methodref name="Create@" visibility="class private" procflags="class constructor noself"/>
            <methodref name="Destroy@" visibility="class private" procflags="class destructor noself"/>
            <methodref name="SetFlagsAtomic" visibility="private"/>
            <methodref name="GetAsyncContext" visibility="private"/>
            <methodref name="GetAsyncWaitEvent" visibility="private"/>
            <methodref name="GetCompletedSynchronously" visibility="private"/>
            <methodref name="GetIsCompleted" visibility="private"/>
            <methodref name="GetIsCancelled" visibility="private"/>
            <propertyref name="AsyncWaitEvent" visibility="private"/>
            <methodref name="AsyncDispatch" visibility="protected" procflags="abstract virtual">
            </methodref>
            <methodref name="Complete" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="DoAsyncDispatch" visibility="protected">
            </methodref>
            <methodref name="Schedule" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="Create" visibility="protected" procflags="constructor overload">
            </methodref>
            <propertyref name="Context" visibility="protected">
            </propertyref>
            <methodref name="DoCancel" visibility="protected" procflags="virtual">
            </methodref>
            <methodref name="Create" visibility="public" procflags="constructor overload">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor override"/>
            <methodref name="Cancel" visibility="public">
            </methodref>
            <methodref name="Invoke" visibility="public">
            </methodref>
            <methodref name="WaitForCompletion" visibility="public">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="static inline">
            </methodref>
            <propertyref name="IsCancelled" visibility="public">
            </propertyref>
            <ancestor name="TInterfacedObject" namespace="System">
              <interfaces>
                <implements name="IInterface"/>
              </interfaces>
              <methodref name="GetRefCount" visibility="private" procflags="inline">
              </methodref>
              <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
              </methodref>
              <methodref name="QueryInterface" visibility="protected">
              </methodref>
              <methodref name="_AddRef" visibility="protected">
              </methodref>
              <methodref name="_Release" visibility="protected">
              </methodref>
              <methodref name="AfterConstruction" visibility="public" procflags="override">
              </methodref>
              <methodref name="BeforeDestruction" visibility="public" procflags="override">
              </methodref>
              <methodref name="NewInstance" visibility="public" procflags="class override">
              </methodref>
              <propertyref name="RefCount" visibility="public">
              </propertyref>
              <ancestor name="TObject" namespace="System">
                <methodref name="Create" visibility="public" procflags="constructor">
                </methodref>
                <methodref name="Free" visibility="public">
                </methodref>
                <methodref name="DisposeOf" visibility="public" procflags="inline">
                </methodref>
                <methodref name="InitInstance" visibility="public" procflags="class">
                </methodref>
                <methodref name="CleanupInstance" visibility="public">
                </methodref>
                <methodref name="ClassType" visibility="public" procflags="inline">
                </methodref>
                <methodref name="ClassName" visibility="public" procflags="class">
                </methodref>
                <methodref name="ClassNameIs" visibility="public" procflags="class">
                </methodref>
                <methodref name="ClassParent" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="ClassInfo" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="InstanceSize" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="InheritsFrom" visibility="public" procflags="class">
                </methodref>
                <methodref name="MethodAddress" visibility="public" procflags="class overload">
                </methodref>
                <methodref name="MethodAddress" visibility="public" procflags="class overload">
                </methodref>
                <methodref name="MethodName" visibility="public" procflags="class">
                </methodref>
                <methodref name="QualifiedClassName" visibility="public" procflags="class">
                </methodref>
                <methodref name="FieldAddress" visibility="public" procflags="overload">
                </methodref>
                <methodref name="FieldAddress" visibility="public" procflags="overload">
                </methodref>
                <methodref name="GetInterface" visibility="public">
                </methodref>
                <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
                </methodref>
                <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
                </methodref>
                <methodref name="UnitName" visibility="public" procflags="class">
                </methodref>
                <methodref name="UnitScope" visibility="public" procflags="class">
                </methodref>
                <methodref name="Equals" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="GetHashCode" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="ToString" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="SafeCallException" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="AfterConstruction" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="Dispatch" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="DefaultHandler" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="NewInstance" visibility="public" procflags="class virtual">
                </methodref>
                <methodref name="FreeInstance" visibility="public" procflags="virtual">
                </methodref>
                <methodref name="Destroy" visibility="public" procflags="destructor virtual">
                </methodref>
                <methodref name="GetDisposed" visibility="protected" procflags="inline">
                </methodref>
                <methodref name="CheckDisposed" visibility="protected" procflags="inline">
                </methodref>
                <propertyref name="Disposed" visibility="protected">
                </propertyref>
              </ancestor>
            </ancestor>
          </ancestor>
        </ancestor>
        <members>
          <field name="FRetVal" type="TObject" visibility="private" size="4" offset="40" file="System.Classes.pas" line="2389"/>
          <field name="FAsyncFunction" type="TAsyncFunctionEvent" visibility="private" size="8" offset="48" file="System.Classes.pas" line="2390"/>
          <constructor name="Create" visibility="protected" file="System.Classes.pas" line="2392">
            <parameters>
              <parameter name="AAsyncFunction" type="TAsyncFunctionEvent" paramflags="const"/>
              <parameter name="AContext" type="TObject" paramflags="const"/>
              <parameter name="AComponent" type="TComponent" paramflags="const"/>
            </parameters>
          </constructor>
          <procedure name="AsyncDispatch" visibility="protected" procflags="override" file="System.Classes.pas" line="2393">
          </procedure>
          <function name="GetRetVal" visibility="protected" file="System.Classes.pas" line="2394">
            <parameters>
              <retval type="TObject"/>
            </parameters>
          </function>
        </members>
      </class>
      <field name="FOwner" type="TComponent" visibility="private" size="4" offset="4" file="System.Classes.pas" line="2397"/>
      <field name="FName" type="TComponentName" visibility="private" size="4" offset="8" file="System.Classes.pas" line="2398"/>
      <field name="FTag" type="NativeInt" visibility="private" size="4" offset="12" file="System.Classes.pas" line="2399"/>
      <field name="FComponents" type="TList&lt;System.Classes.TComponent&gt;" visibility="private" size="4" offset="16" file="System.Classes.pas" line="2400"/>
      <field name="FFreeNotifies" type="TList&lt;System.Classes.TComponent&gt;" visibility="private" size="4" offset="20" file="System.Classes.pas" line="2401"/>
      <field name="FDesignInfo" type="Integer" visibility="private" size="4" offset="24" file="System.Classes.pas" line="2403"/>
      <field name="FComponentState" type="TComponentState" visibility="private" size="2" offset="28" file="System.Classes.pas" line="2404"/>
      <field name="FVCLComObject" type="Pointer" visibility="private" size="4" offset="32" file="System.Classes.pas" line="2405"/>
      <field name="FObservers" type="TObservers" visibility="private" size="4" offset="36" file="System.Classes.pas" line="2406"/>
      <field name="FOnGetDeltaStreams" type="TGetDeltaStreamsEvent" visibility="private" size="8" offset="40" file="System.Classes.pas" line="2407"/>
      <function name="GetComObject" visibility="private" file="System.Classes.pas" line="2408">
        <parameters>
          <retval type="IInterface"/>
        </parameters>
      </function>
      <function name="GetComponent" visibility="private" file="System.Classes.pas" line="2409">
        <parameters>
          <parameter name="AIndex" type="Integer"/>
          <retval type="TComponent"/>
        </parameters>
      </function>
      <function name="GetComponentCount" visibility="private" file="System.Classes.pas" line="2410">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetComponentIndex" visibility="private" file="System.Classes.pas" line="2411">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="Insert" visibility="private" file="System.Classes.pas" line="2412">
        <parameters>
          <parameter name="AComponent" type="TComponent"/>
        </parameters>
      </procedure>
      <procedure name="ReadLeft" visibility="private" file="System.Classes.pas" line="2413">
        <parameters>
          <parameter name="Reader" type="TReader"/>
        </parameters>
      </procedure>
      <procedure name="ReadTop" visibility="private" file="System.Classes.pas" line="2414">
        <parameters>
          <parameter name="Reader" type="TReader"/>
        </parameters>
      </procedure>
      <procedure name="Remove" visibility="private" file="System.Classes.pas" line="2415">
        <parameters>
          <parameter name="AComponent" type="TComponent"/>
        </parameters>
      </procedure>
      <procedure name="RemoveNotification" visibility="private" file="System.Classes.pas" line="2416">
        <parameters>
          <parameter name="AComponent" type="TComponent" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetComponentIndex" visibility="private" file="System.Classes.pas" line="2417">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="SetReference" visibility="private" file="System.Classes.pas" line="2418">
        <parameters>
          <parameter name="Enable" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="WriteLeft" visibility="private" file="System.Classes.pas" line="2419">
        <parameters>
          <parameter name="Writer" type="TWriter"/>
        </parameters>
      </procedure>
      <procedure name="WriteTop" visibility="private" file="System.Classes.pas" line="2420">
        <parameters>
          <parameter name="Writer" type="TWriter"/>
        </parameters>
      </procedure>
      <function name="IntfGetComponent" visibility="private" file="System.Classes.pas" line="2423">
        <parameters>
          <retval type="TComponent"/>
        </parameters>
      </function>
      <procedure name="DoGetDeltaStreams" visibility="private" file="System.Classes.pas" line="2424">
        <parameters>
          <parameter name="Proc" type="TGetStreamProc"/>
          <parameter name="Handled" type="Boolean" paramflags="var"/>
        </parameters>
      </procedure>
      <procedure name="ReadDeltaStream" visibility="private" file="System.Classes.pas" line="2425">
        <parameters>
          <parameter name="S" type="TStream" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="ReadDeltaState" visibility="private" file="System.Classes.pas" line="2426">
      </procedure>
      <field name="FComponentStyle" type="TComponentStyle" visibility="protected" size="1" offset="48" file="System.Classes.pas" line="2428"/>
      <field name="FSortedComponents" type="TList&lt;System.Classes.TComponent&gt;" visibility="private" size="4" offset="52" file="System.Classes.pas" line="2430"/>
      <function name="FindSortedComponent" visibility="private" file="System.Classes.pas" line="2431">
        <parameters>
          <parameter name="AName" type="string" paramflags="const"/>
          <parameter name="Index" type="Integer" paramflags="var"/>
          <retval type="TComponent"/>
        </parameters>
      </function>
      <procedure name="AddSortedComponent" visibility="private" file="System.Classes.pas" line="2432">
        <parameters>
          <parameter name="AComponent" type="TComponent" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="RemoveSortedComponent" visibility="private" procflags="inline" file="System.Classes.pas" line="2433">
        <parameters>
          <parameter name="AComponent" type="TComponent" paramflags="const"/>
        </parameters>
      </procedure>
      <field name="FComparer" type="IComparer&lt;System.Classes.TComponent&gt;" visibility="private" varflags="class" file="System.Classes.pas" line="2435"/>
      <procedure name="Create@" visibility="class private" procflags="class constructor noself" file="System.Classes.pas" line="2436">
      </procedure>
      <procedure name="AsyncSchedule" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2443">
        <devnotes><summary>
Schedules asynch method calls.
By default, AsyncSchedule uses Queue in order to queue the asynch method call with the main thread.
Override AsyncSchedule in descendant components in order to modify the management of the asynchronous scheduling.
</summary></devnotes>
        <parameters>
          <parameter name="ASyncResult" type="TBaseAsyncResult" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="ChangeName" visibility="protected" file="System.Classes.pas" line="2444">
        <parameters>
          <parameter name="NewName" type="TComponentName" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Sets the private, internal storage for the Name property to the string passed in NewName.
Do not use ChangeName directly in an application. Instead, use the Name property.

Note: The property setter for Name -- SetName-- uses ChangeName to change the component's name. ChangeName is not virtual; do not override it.</summary></devnotes></procedure>
      <procedure name="DefineProperties" visibility="protected" procflags="override" file="System.Classes.pas" line="2445">
        <parameters>
          <parameter name="Filer" type="TFiler"/>
        </parameters>
      <devnotes><summary>
Designates methods for storing an object's unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.
</summary></devnotes></procedure>
      <procedure name="GetChildren" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="2446">
        <parameters>
          <parameter name="Proc" type="TGetChildProc"/>
          <parameter name="Root" type="TComponent"/>
        </parameters>
      <devnotes><summary>
Enumerates all child components.
GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
GetChildren expects a TGetChildProc routine that receives all enumerated components. 
Root represents the owner of the components that will be enumerated.
This method does nothing in TComponent and is expected to be overridden in descendants. 
</summary></devnotes></procedure>
      <function name="GetChildOwner" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="2447">
        <parameters>
          <retval type="TComponent"/>
        </parameters>
      <devnotes><summary>
Returns the owner of a child component being read from a stream.
GetChildOwner is used internally by the component streaming system. It is rarely necessary to call it directly.
In TComponent, GetChildOwner always returns nil (Delphi) or NULL (C++), indicating that the owner is the root component currently being read (usually a form or data module). The Owner of a component is responsible for destroying it.
</summary></devnotes></function>
      <function name="GetChildParent" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="2448">
        <parameters>
          <retval type="TComponent"/>
        </parameters>
      <devnotes><summary>
Returns the parent or, if there is no parent, returns the owner of a child component being read from a stream.
GetChildParent is used internally in the component streaming system. It is not necessary to call it directly.
As implemented in TComponent, GetChildParent returns Self (Delphi) or this (C++). If GetChildParent returns nil (Delphi) or NULL (C++), the parent is assumed to be the root component currently being read (usually a form).
</summary></devnotes></function>
      <function name="GetOwner" visibility="protected" procflags="override" file="System.Classes.pas" line="2449">
        <parameters>
          <retval type="TPersistent"/>
        </parameters>
      <devnotes><summary>
Returns the owner of a component.
GetOwner is called by GetNamePath to find the owner of a component. GetNamePath and GetOwner are introduced in TPersistent so descendants such as collections can appear in the Object Inspector. For TComponent, GetOwner returns the value of the Owner property.
</summary></devnotes></function>
      <procedure name="Loaded" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2450">
      <devnotes><summary>
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component's form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</summary></devnotes></procedure>
      <procedure name="Notification" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2451">
        <parameters>
          <parameter name="AComponent" type="TComponent"/>
          <parameter name="Operation" type="TOperation"/>
        </parameters>
      <devnotes><summary>
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</summary></devnotes></procedure>
      <procedure name="GetDeltaStreams" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="2452">
        <parameters>
          <parameter name="Proc" type="TGetStreamProc"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></procedure>
      <procedure name="ReadState" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2453">
        <parameters>
          <parameter name="Reader" type="TReader"/>
        </parameters>
      <devnotes><summary>
Reads the state of the component.
ReadState is used internally in the component streaming system. It is not necessary to call it directly. 
ReadState expects a TReader object, which is used for reading the state of the component. 
</summary></devnotes></procedure>
      <function name="CanObserve" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2454">
        <parameters>
          <parameter name="ID" type="Integer" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></function>
      <procedure name="ObserverAdded" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2455">
        <parameters>
          <parameter name="ID" type="Integer" paramflags="const"/>
          <parameter name="Observer" type="IObserver" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></procedure>
      <function name="GetObservers" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2456">
        <parameters>
          <retval type="TObservers"/>
        </parameters>
      <devnotes><summary>
Getter of Observers.


</summary></devnotes></function>
      <procedure name="SetAncestor" visibility="protected" file="System.Classes.pas" line="2457">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      <devnotes><summary>
Clears or sets csAncestor state in the component's ComponentState property.
SetAncestor is used internally in the component streaming system. It is not necessary to call it directly. 
If Value is set to True, the csAncestor flag is included into the component state; otherwise, it is excluded.
</summary></devnotes></procedure>
      <procedure name="SetDesigning" visibility="protected" file="System.Classes.pas" line="2458">
        <parameters>
          <parameter name="Value" type="Boolean"/>
          <parameter name="SetChildren" type="Boolean">
            <value>
              True
            </value>
          </parameter>
        </parameters>
      <devnotes><summary>
Ensures that components inserted at design time have their design-mode flag set.
SetDesigning is used internally by the Form designer. Do not call SetDesigning directly.
SetDesigning sets the csDesigning flag in the ComponentState property if Value is True; otherwise, it removes csDesigning. 
If the SetChildren parameter is True, SetDesigning then calls the SetDesigning methods of any owned components, passing Value, so that the owned components' ComponentState properties are synchronized with the owner's.
The InsertComponent and RemoveComponent methods call SetDesigning for inserted or removed components to ensure that their design-mode flags are set properly.
</summary></devnotes></procedure>
      <procedure name="SetInline" visibility="protected" file="System.Classes.pas" line="2459">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      <devnotes><summary>
Sets the csInline bit of the component's ComponentState property.
SetInline is used internally to indicate whether the component can act as a root component in the designer but also be embedded in a form.
SetInline sets the csInline flag in the ComponentState property if Value is True; otherwise, it removes csInline. 
</summary></devnotes></procedure>
      <procedure name="SetDesignInstance" visibility="protected" file="System.Classes.pas" line="2460">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      <devnotes><summary>
Ensures that components inserted at design time have their design-mode flag set.
SetDesignInstance is used internally by the Form designer to identify objects that act as a design surface. Do not call SetDesignInstance directly.
SetDesignInstance sets the csDesignInstance flag in the ComponentState property if Value is 
True; otherwise, it removes csDesignInstance. 
</summary></devnotes></procedure>
      <procedure name="SetName" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2461">
        <parameters>
          <parameter name="NewName" type="TComponentName" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Sets the value of the Name property.
SetName is the virtual property setter for the Name property. It calls the ChangeName method, which performs the actual name change.
ChangeName is not virtual; override SetName instead when modifying the behavior of the Name property.

Warning: Using SetName to change the name of a component at run time causes any references to the old name to become undefined. Any subsequent code that uses the old name will cause an exception.</summary></devnotes></procedure>
      <procedure name="SetChildOrder" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="2462">
        <parameters>
          <parameter name="Child" type="TComponent"/>
          <parameter name="Order" type="Integer"/>
        </parameters>
      <devnotes><summary>
Sets the visual ordering of a child control.
SetChildOrder is used internally in the component streaming system. It is not necessary to call it directly. 
Derived classes override this method to actually implement the ordering. TWinControl uses this ordering information to Z-align the controls. 
</summary></devnotes></procedure>
      <procedure name="SetParentComponent" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="2463">
        <parameters>
          <parameter name="Value" type="TComponent"/>
        </parameters>
      <devnotes><summary>
Sets the parent component.
SetParentComponent is used internally in the component streaming system. It is not necessary to call it directly. 
Derived classes override this method to implement proper handling for parenting.
</summary></devnotes></procedure>
      <procedure name="Updating" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="2464">
      <devnotes><summary>
Sets the csUpdating state in the component's ComponentState property.
Do not call Updating directly. It is used internally to indicate that the component is about to be updated. A call to Updating, which sets the csUpdating flag, is always followed by a call to Updated, which clears the flag.
</summary></devnotes></procedure>
      <procedure name="Updated" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="2465">
      <devnotes><summary>
Clears the csUpdating state in the component's ComponentState property when the component finishes updating.
Do not call Updated directly. It is used internally to clear the csUpdating flag of the ComponentState property. A call to Updated always follows a call to Updating, which sets the flag.
</summary></devnotes></procedure>
      <procedure name="UpdateRegistry" visibility="protected" procflags="class virtual" file="System.Classes.pas" line="2466">
        <parameters>
          <parameter name="Register" type="Boolean"/>
          <parameter name="ClassID" type="string" paramflags="const"/>
          <parameter name="ProgID" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Provides the interface for a method that adds type library and version information to the Registry on components that implement COM interfaces.
Do not call UpdateRegistry directly. It is for internal use only.


</summary></devnotes></procedure>
      <procedure name="ValidateRename" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2467">
        <parameters>
          <parameter name="AComponent" type="TComponent"/>
          <parameter name="CurName" type="string" paramflags="const"/>
          <parameter name="NewName" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Ensures that renaming an owned component does not create a name conflict.
ValidateRename checks whether a component can rename one of its owned components, passed in AComponent, from its current name (CurName) to the string passed in NewName. If AComponent is nil (Delphi) or NULL (C++) or NewName is already the name of a component in the Components list, ValidateRename raises an EComponentError exception.
ValidateRename is used internally when the Name property is modified. It is not necessary to call it directly.
</summary></devnotes></procedure>
      <procedure name="ValidateContainer" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="2468">
        <parameters>
          <parameter name="AComponent" type="TComponent"/>
        </parameters>
      <devnotes><summary>
Determines whether an object can be inserted into a container.
ValidateContainer is called by a component when it is about to be inserted into a container object. By default, ValidateContainer calls the ValidateInsert method of the component specified by the AComponent parameter. 
Descendent components can override ValidateContainer to disallow a component from being inserted into specific containers. To disallow an insertion, raise an exception in the derived method.
</summary></devnotes></procedure>
      <procedure name="ValidateInsert" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="2469">
        <parameters>
          <parameter name="AComponent" type="TComponent"/>
        </parameters>
      <devnotes><summary>
Provides the interface for a method that validates a child component before it is inserted.
ValidateInsert does nothing in TComponent. Descendent classes can override it to disallow a component from accepting an object as a child. By default, ValidateInsert allows any object to be inserted into the component. 
If a component needs to validate only certain objects, descendent classes can override ValidateInsert to filter out those objects. To disallow an insertion, raise an exception in the derived method.
</summary></devnotes></procedure>
      <procedure name="WriteState" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2470">
        <parameters>
          <parameter name="Writer" type="TWriter"/>
        </parameters>
      <devnotes><summary>
Writes the state of the component.
WriteState is used internally in the component streaming system. It is not necessary to call it directly. 
This method expects a TWriter object that is used for storing the state of the component. 
</summary></devnotes></procedure>
      <procedure name="RemoveFreeNotifications" visibility="protected" file="System.Classes.pas" line="2471">
      <devnotes><summary>
Notifies all owned components of the owner component's imminent destruction.
The RemoveFreeNotifications method notifies all owned components of the owner component's imminent destruction. RemoveFreeNotifications is called automatically when the component is destroyed.


</summary></devnotes></procedure>
      <function name="QueryInterface" visibility="protected" procflags="virtual" callconv="stdcall" file="System.Classes.pas" line="2473">
        <parameters>
          <parameter name="IID" type="TGUID" paramflags="const"/>
          <parameter name="Obj" paramflags="out"/>
          <retval type="HRESULT"/>
        </parameters>
      <devnotes><summary>
Returns a reference to a specified interface if the current component supports that interface.
QueryInterface checks whether the component supports the interface specified by IID and, if so, returns a reference to that interface as the Obj parameter. If the component does not support the interface, the Obj parameter returns nil (Delphi) or NULL (C++).
QueryInterface returns the S_OK execution code on success. HResult type 
defines the following execution codes: S_OK, S_FALSE, E_NOINTERFACE, E_UNEXPECTED, and E_NOTIMPL.

Note: For components that act as COM object wrappers, QueryInterface calls the QueryInterface method of the internal COM object.</summary></devnotes></function>
      <function name="_AddRef" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="2474">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Called when an application uses a component interface.
_AddRef is a basic implementation of the IInterface method, _AddRef.

Note: If the component is a wrapper for a COM object, _AddRef calls the _AddRef method of that COM object, and returns the resulting reference count.
In all other cases, _AddRef simply returns 1 and takes no action. This allows the component to implement interfaces where reference counting is not required. More sophisticated components should override _AddRef to implement reference counting.
</summary></devnotes></function>
      <function name="_Release" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="2475">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Called when an application releases a component interface.
_Release is a basic implementation of the IInterface method, _Release.
_Release returns the resulting value of the reference count for the component's interface.

Note: In all other cases, _Release simply returns 1 and takes no action. This allows the component to implement interfaces where reference counting is not required. More sophisticated components should override _Release to implement reference counting.</summary></devnotes></function>
      <function name="GetTypeInfoCount" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="2477">
        <parameters>
          <parameter name="Count" type="Integer" paramflags="out"/>
          <retval type="HRESULT"/>
        </parameters>
      <devnotes><summary>
Returns the number of type information interfaces that an object provides (either 0 or 1).
GetTypeInfoCount implements the IDispatch interface GetTypeInfoCount method. For components that support interfaces, GetTypeInfoCount calls this method for the interface supported by the component. The Count parameter points to a location that receives the number of type information interfaces provided by the object. If the object provides type information, this number is 1; otherwise the number is 0.
</summary></devnotes></function>
      <function name="GetTypeInfo" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="2478">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="LocaleID" type="Integer"/>
          <parameter name="TypeInfo" paramflags="out"/>
          <retval type="HRESULT"/>
        </parameters>
      <devnotes><summary>
Retrieves the type information for an object.
GetTypeInfo implements the IDispatch interface GetTypeInfo method. For components that support interfaces, GetTypeInfo calls the GetTypeInfo method for the interface supported by the component, passing it the specified parameters. Use the returned value to get the type information for an interface implemented by the component.
</summary></devnotes></function>
      <function name="GetIDsOfNames" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="2479">
        <parameters>
          <parameter name="IID" type="TGUID" paramflags="const"/>
          <parameter name="Names" type="Pointer"/>
          <parameter name="NameCount" type="Integer"/>
          <parameter name="LocaleID" type="Integer"/>
          <parameter name="DispIDs" type="Pointer"/>
          <retval type="HRESULT"/>
        </parameters>
      <devnotes><summary>
Maps a single member and an optional set of argument names to a corresponding set of integer dispatch identifiers (dispIDs).
GetIDsOfNames implements the IDispatch interface GetIDsOfNames method. For components that support interfaces, GetIDsOfNames calls this method for the interface supported by the component, passing the specified parameters. The returned value can be used on subsequent calls to the Invoke method.
</summary></devnotes></function>
      <function name="Invoke" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="2481">
        <parameters>
          <parameter name="DispID" type="Integer"/>
          <parameter name="IID" type="TGUID" paramflags="const"/>
          <parameter name="LocaleID" type="Integer"/>
          <parameter name="Flags" type="Word"/>
          <parameter name="Params" paramflags="var"/>
          <parameter name="VarResult" type="Pointer"/>
          <parameter name="ExcepInfo" type="Pointer"/>
          <parameter name="ArgErr" type="Pointer"/>
          <retval type="HRESULT"/>
        </parameters>
      <devnotes><summary>
Provides access to Automation properties and methods when the component wraps an Automation object.
Invoke is the standard mechanism for accessing the exposed properties and methods of an Automation object. For components that wrap the IDispatch interface of an Automation object, Invoke calls the Invoke method for the interface supported by the component, passing it the parameters specified by the function.
</summary></devnotes></function>
      <event name="OnGetDeltaStreams" visibility="protected" read="FOnGetDeltaStreams" write="FOnGetDeltaStreams" type="TGetDeltaStreamsEvent" file="System.Classes.pas" line="2483"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2485">
        <parameters>
          <parameter name="AOwner" type="TComponent"/>
        </parameters>
      <devnotes><summary>
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor.</summary></devnotes></constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="2486">
        <parameters>
        </parameters>
      <devnotes><summary>
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</summary></devnotes></destructor>
      <procedure name="BeforeDestruction" visibility="public" procflags="override" file="System.Classes.pas" line="2487">
      <devnotes><summary>
Performs any necessary actions before the first destructor is called.
BeforeDestruction is called automatically immediately before the component's first destructor executes. Do not call it explicitly in your applications.
As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place.
</summary></devnotes></procedure>
      <function name="BeginInvoke" visibility="public" procflags="overload" file="System.Classes.pas" line="2493">
        <devnotes><summary>
Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.
</summary></devnotes>
        <parameters>
          <parameter name="AProc" type="TProc" paramflags="const"/>
          <parameter name="AContext" type="TObject" paramflags="const">
            <value>
              nil
            </value>
          </parameter>
          <retval type="IAsyncResult"/>
        </parameters>
      </function>
      <function name="BeginInvoke" visibility="public" procflags="overload" file="System.Classes.pas" line="2494">
        <parameters>
          <parameter name="AProc" type="TAsyncProcedureEvent" paramflags="const"/>
          <parameter name="AContext" type="TObject" paramflags="const">
            <value>
              nil
            </value>
          </parameter>
          <retval type="IAsyncResult"/>
        </parameters>
      <devnotes><summary>
Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.
</summary></devnotes></function>
      <function name="BeginInvoke" visibility="public" procflags="overload" file="System.Classes.pas" line="2495">
        <parameters>
          <parameter name="AFunc" type="TFunc&lt;System.Classes.TComponent.BeginInvoke.TResult&gt;" paramflags="const"/>
          <parameter name="AContext" type="TObject" paramflags="const">
            <value>
              nil
            </value>
          </parameter>
          <retval type="IAsyncResult"/>
        </parameters>
      <devnotes><summary>
Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.
</summary></devnotes></function>
      <function name="BeginInvoke" visibility="public" procflags="overload" file="System.Classes.pas" line="2496">
        <parameters>
          <parameter name="AProc" type="TAsyncConstArrayProc" paramflags="const"/>
          <parameter name="Params" paramflags="const">
            <array name="Params" file="System.Classes.pas" line="17035">
              <element type="TVarRec"/>
            </array>
          </parameter>
          <parameter name="AContext" type="TObject" paramflags="const">
            <value>
              nil
            </value>
          </parameter>
          <retval type="IAsyncResult"/>
        </parameters>
      <devnotes><summary>
Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.
</summary></devnotes></function>
      <function name="BeginInvoke" visibility="public" procflags="overload" file="System.Classes.pas" line="2497">
        <parameters>
          <parameter name="AFunc" type="TAsyncConstArrayFunc&lt;System.Classes.TComponent.BeginInvoke.TResult&gt;" paramflags="const"/>
          <parameter name="Params" paramflags="const">
            <array name="Params" file="System.Classes.pas" line="17041">
              <element type="TVarRec"/>
            </array>
          </parameter>
          <parameter name="AContext" type="TObject" paramflags="const">
            <value>
              nil
            </value>
          </parameter>
          <retval type="IAsyncResult"/>
        </parameters>
      <devnotes><summary>
Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.
</summary></devnotes></function>
      <function name="BeginInvoke" visibility="public" procflags="overload" file="System.Classes.pas" line="2498">
        <parameters>
          <parameter name="AProc" type="TAsyncConstArrayProcedureEvent" paramflags="const"/>
          <parameter name="Params" paramflags="const">
            <array name="Params" file="System.Classes.pas" line="17023">
              <element type="TVarRec"/>
            </array>
          </parameter>
          <parameter name="AContext" type="TObject" paramflags="const">
            <value>
              nil
            </value>
          </parameter>
          <retval type="IAsyncResult"/>
        </parameters>
      <devnotes><summary>
Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.
</summary></devnotes></function>
      <function name="BeginInvoke" visibility="public" procflags="overload" file="System.Classes.pas" line="2499">
        <parameters>
          <parameter name="AFunc" type="TAsyncConstArrayFunctionEvent" paramflags="const"/>
          <parameter name="Params" paramflags="const">
            <array name="Params" file="System.Classes.pas" line="17029">
              <element type="TVarRec"/>
            </array>
          </parameter>
          <parameter name="AContext" type="TObject" paramflags="const">
            <value>
              nil
            </value>
          </parameter>
          <retval type="IAsyncResult"/>
        </parameters>
      <devnotes><summary>
Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.
</summary></devnotes></function>
      <function name="BeginInvoke" visibility="public" procflags="overload" file="System.Classes.pas" line="2500">
        <parameters>
          <parameter name="AFunc" type="TAsyncFunctionEvent" paramflags="const"/>
          <parameter name="AContext" type="TObject" paramflags="const">
            <value>
              nil
            </value>
          </parameter>
          <retval type="IAsyncResult"/>
        </parameters>
      <devnotes><summary>
Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.
</summary></devnotes></function>
      <procedure name="EndInvoke" visibility="public" procflags="overload" file="System.Classes.pas" line="2506">
        <devnotes><summary>
Blocks the caller until the specified ASyncResult completes.
Returns the result from the method that BeginInvoke asynchronously executes. This result is immediately returned after the given IAsyncResult finishes. 
EndInvoke raises any exception that may occur while the asynchronous method executes.
</summary></devnotes>
        <parameters>
          <parameter name="ASyncResult" type="IAsyncResult" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="EndInvoke" visibility="public" procflags="overload" file="System.Classes.pas" line="2512">
        <devnotes><summary>
Blocks the caller until the specified ASyncResult completes.
Returns the result from the method that BeginInvoke asynchronously executes. This result is immediately returned after the given IAsyncResult finishes. 
EndInvoke raises any exception that may occur while the asynchronous method executes.
</summary></devnotes>
        <parameters>
          <parameter name="AsyncResult" type="IAsyncResult" paramflags="const"/>
          <retval type="TResult"/>
        </parameters>
      </function>
      <function name="EndFunctionInvoke" visibility="public" file="System.Classes.pas" line="2518">
        <devnotes><summary>
Blocks the caller until the specified ASyncResult completes.
Returns the result from the method that BeginInvoke asynchronously executes. This result is immediately returned after the given IAsyncResult finishes. The result type corresponds to a TObject class type.
EndInvoke raises any exception that may occur while the asynchronous method executes.
</summary></devnotes>
        <parameters>
          <parameter name="AsyncResult" type="IAsyncResult" paramflags="const"/>
          <retval type="TObject"/>
        </parameters>
      </function>
      <procedure name="DestroyComponents" visibility="public" file="System.Classes.pas" line="2519">
      <devnotes><summary>
Destroys all owned components.
DestroyComponents iterates through the components owned by the component, removing each from the list of owned components and destroying it.
It is not necessary to call DestroyComponents directly. DestroyComponents is automatically called when the component is destroyed.
</summary></devnotes></procedure>
      <procedure name="Destroying" visibility="public" file="System.Classes.pas" line="2520">
      <devnotes><summary>
Indicates that the component and its owned components are about to be destroyed.
Destroying sets the csDestroying flag in the ComponentState property. It then calls the Destroying method for each owned component so that its csDestroying flag is also set. If csDestroying is already set, Destroying does nothing.
It is not necessary to call Destroying directly. Destroying is automatically called when the component is destroyed.
</summary></devnotes></procedure>
      <function name="ExecuteAction" visibility="public" procflags="dynamic" file="System.Classes.pas" line="2521">
        <parameters>
          <parameter name="Action" type="TBasicAction"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Executes an action.
ExecuteAction executes an action for the component. Action is a TBasicAction or any descendant of TBasicAction. 
ExecuteAction first checks whether the provided action is compatible with the component and then executes the action. The return value is a Boolean. A value of True is returned if the action was executed; otherwise, False is returned. 
Derived classes can override this method to implement a distinct way of handling actions.
</summary></devnotes></function>
      <function name="FindComponent" visibility="public" file="System.Classes.pas" line="2522">
        <parameters>
          <parameter name="AName" type="string" paramflags="const"/>
          <retval type="TComponent"/>
        </parameters>
      <devnotes><summary>
Indicates whether a given component is owned by the component.
FindComponent returns the component in the Components property array with the name that matches the string in the AName parameter. Use FindComponent to determine whether a given component is owned by another.
Component name matches are not case sensitive.
</summary></devnotes></function>
      <procedure name="FreeNotification" visibility="public" file="System.Classes.pas" line="2523">
        <parameters>
          <parameter name="AComponent" type="TComponent"/>
        </parameters>
      <devnotes><summary>
Ensures that AComponent is notified that the component is going to be destroyed.
Use FreeNotification to register AComponent as a component that should be notified when the component is about to be destroyed. It is only necessary to register components this way when they are in a different form or have a different owner. For example, if AComponent is in another form and uses the component to implement a property, it must call FreeNotification so that its Notification method is called when the component is destroyed.
For components with the same owner, the Notification method is called automatically when an application explicitly frees the component. This notification is not sent out when components are freed implicitly, because the Owner is already being freed.
</summary></devnotes></procedure>
      <procedure name="RemoveFreeNotification" visibility="public" file="System.Classes.pas" line="2524">
        <parameters>
          <parameter name="AComponent" type="TComponent"/>
        </parameters>
      <devnotes><summary>
Disables the destruction notification that was enabled by FreeNotification.
RemoveFreeNotification removes the component specified by the AComponent parameter from the internal list of objects to be notified that the component is about to be destroyed. AComponent is added to this list by a previous call to the FreeNotification method.
Most applications have no need to call RemoveFreeNotification. It is used by TComponent to detect loops where two components are notifying each other of their impending destruction.
</summary></devnotes></procedure>
      <procedure name="FreeOnRelease" visibility="public" file="System.Classes.pas" line="2525">
      <devnotes><summary>
Frees the interface reference for components that were created from COM classes.
FreeOnRelease is called when an interface implemented by the component is released. FreeOnRelease is used internally and calls the corresponding interface method. It should not be necessary to call FreeOnRelease directly.
</summary></devnotes></procedure>
      <function name="GetEnumerator" visibility="public" procflags="inline" file="System.Classes.pas" line="2526">
        <parameters>
          <retval type="TComponentEnumerator"/>
        </parameters>
      <devnotes><summary>
Returns a TComponent enumerator.
GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop. 
</summary></devnotes></function>
      <function name="GetParentComponent" visibility="public" procflags="dynamic" file="System.Classes.pas" line="2527">
        <parameters>
          <retval type="TComponent"/>
        </parameters>
      <devnotes><summary>
Returns the containing component.
GetParentComponent returns a reference to the component that contains the current component, or nil if there is no container. Use HasParent to determine whether a component has a containing component. 
For example, a button on a panel on a form returns the panel, the panel returns the form, and the form returns nil.
</summary></devnotes></function>
      <function name="GetNamePath" visibility="public" procflags="override" file="System.Classes.pas" line="2528">
        <parameters>
          <retval type="string"/>
        </parameters>
      <devnotes><summary>
Returns a string used by the Object Inspector.
GetNamePath is used to determine the text to display in the Object Inspector for the name of the object being edited. GetNamePath is introduced in TPersistent so descendants such as collections can appear in the Object Inspector. TComponent overrides GetNamePath to return the component's name. Do not call GetNamePath directly.
</summary></devnotes></function>
      <function name="HasParent" visibility="public" procflags="dynamic" file="System.Classes.pas" line="2529">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Verifies whether the component has a parent.
Call HasParent to determine whether a specific component has a parent. 
Derived classes override this method to implement proper handling for parenting.
Use GetParentComponent to retrieve the component reference.
</summary></devnotes></function>
      <procedure name="InsertComponent" visibility="public" file="System.Classes.pas" line="2530">
        <parameters>
          <parameter name="AComponent" type="TComponent" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Establishes the component as the owner of a specified component.
InsertComponent adds the component passed in the AComponent parameter to the end of the Components array property. The inserted component must have no name (no specified Name property value), or the name must be unique among all others in the Components list.
When the owning component is destroyed, AComponent is also destroyed.
Components are automatically inserted and removed when visually manipulating them in the form designer. Use InsertComponent when manually adding components to another Owner component's Components list.
</summary></devnotes></procedure>
      <procedure name="RemoveComponent" visibility="public" file="System.Classes.pas" line="2531">
        <parameters>
          <parameter name="AComponent" type="TComponent" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Removes a specified component specified from the component's Components list.
Components are automatically inserted and removed when visually manipulating them in the form designer. Use RemoveComponent to programmatically delete the component specified by AComponent from its Owner component.
</summary></devnotes></procedure>
      <procedure name="SetSubComponent" visibility="public" file="System.Classes.pas" line="2532">
        <parameters>
          <parameter name="IsSubComponent" type="Boolean"/>
        </parameters>
      <devnotes><summary>
Identifies whether the component is a subcomponent.
Call SetSubComponent to indicate whether this component is a subcomponent. A subcomponent is a component whose Owner is a component other than the form or data module in which it resides. Unless such a component calls SetSubComponent with IsSubComponent set to True, its published properties will not be saved to the form file.
IsSubComponent indicates whether the component is a subcomponent (True) or not (False).
SetSubComponent is called at design time:

Either from the constructor of a component that always acts as a subcomponent. In this case, the component calls its own SetSubComponent method from the constructor with IsSubComponent set to True.
Or immediately after constructing an instance of the subcomponent. In this case, the Owner calls the SetSubComponent method of a component it has just instantiated, with IsSubComponent set to True.</summary></devnotes></procedure>
      <function name="SafeCallException" visibility="public" procflags="override" file="System.Classes.pas" line="2533">
        <parameters>
          <parameter name="ExceptObject" type="TObject"/>
          <parameter name="ExceptAddr" type="Pointer"/>
          <retval type="HRESULT"/>
        </parameters>
      <devnotes><summary>
Handles exceptions in methods declared using the safecall calling convention.
SafeCallException handles exceptions in methods that use the safecall calling convention. Some classes that implement interfaces override this method to handle errors that might occur. TComponent calls the implementation of this method for the interface supported by the component, if it exists. If the component does not support interfaces, this method calls the SafeCallException method inherited from TObject, which returns E_UNEXPECTED. This is a default return value that is appropriate for classes that do not support any interfaces.
</summary></devnotes></function>
      <function name="UpdateAction" visibility="public" procflags="virtual" file="System.Classes.pas" line="2534">
        <parameters>
          <parameter name="Action" type="TBasicAction"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Updates the state of an action.
UpdateAction is used to update the state of an action. Action is a TBasicAction or any descendant. 
UpdateAction first checks whether the provided action is compatible with the component and then updates it. The return value is a Boolean. A value of True is returned if the action was updated, and a value of False, otherwise. 
Derived classes can override this method to implement a distinct way of handling action updates.
</summary></devnotes></function>
      <function name="IsImplementorOf" visibility="public" file="System.Classes.pas" line="2535">
        <parameters>
          <parameter name="I" type="IInterface" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Indicates whether the component implements a specified interface.
Call IsImplementorOf to determine whether the component (or, if the component aggregates its interface with other components, whether the controlling component) supports the interface specified by I. IsImplementorOf is similar to the QueryInterface method, but it can handle a request for a nil (Delphi) or NULL (C++) interface, and it does not return an interface pointer.
The streaming system that loads and saves components uses IsImplementorOf to resolve property values that are interfaces.
</summary></devnotes></function>
      <function name="ReferenceInterface" visibility="public" file="System.Classes.pas" line="2536">
        <parameters>
          <parameter name="I" type="IInterface" paramflags="const"/>
          <parameter name="Operation" type="TOperation"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Establishes or removes internal links that cause this component to be notified when the implementer of a specified interface is destroyed.
Component writers use ReferenceInterface to ensure that properties whose values are interfaces are informed when the objects that implement those interfaces are destroyed. This notification must be in place for a property whose value is an interface to be saved with the component in a form file (that is, for such a property to persist as a published property).
I is an interface pointer that is the value of the published property of interest.
Operation indicates whether the notification link to the implementer of the interface should be established (opInsert) or removed (opRemove).
ReferenceInterface returns True if it is successful in establishing or removing the notification link. If ReferenceInterface returns False when called with Operation set to opInsert, the specified interface cannot be stored as the value of a published property.

Note: A result of False does not necessarily indicate an error, merely that the interface cannot be stored by the property streaming system. For example, ReferenceInterface returns False when the specified interface employs true reference counting, independent of component lifetimes.</summary></devnotes></function>
      <property name="ComObject" visibility="public" read="GetComObject" type="IInterface" file="System.Classes.pas" line="2537"><devnotes><summary>
Specifies the interface reference implemented by the component.
Use ComObject to assign a COM interface implemented by a component to an interface reference. This property is used by components that support COM interfaces. 
If the component is not a wrapper for a COM component, trying to read ComObject causes TComponent to raise an EComponentError exception.
</summary></devnotes></property>
      <property name="Components[Index]" visibility="public" read="GetComponent" type="TComponent" file="System.Classes.pas" line="2538"/>
      <property name="ComponentCount" visibility="public" read="GetComponentCount" type="Integer" file="System.Classes.pas" line="2539"><devnotes><summary>
Indicates the number of components owned by the component.
Use the ComponentCount property to determine the number of components owned by a component, for example, when iterating through the components list to perform an action on all owned components. The ComponentCount property equals the number of items in the components list. This value is one more than the highest Components index, because the first components index is 0.
</summary></devnotes></property>
      <property name="ComponentIndex" visibility="public" read="GetComponentIndex" write="SetComponentIndex" type="Integer" file="System.Classes.pas" line="2540"><devnotes><summary>
Indicates the position of the component in its owner's Components property array.
Use ComponentIndex when iterating through the Components list of the component's owner to perform an action on owned components. It can be used in conjunction with ComponentCount. ComponentIndex is used internally for iterative assignment procedures. 

Note:  The first component in the list has a ComponentIndex value of 0, the second has a value of 1, and so on. Therefore, when using ComponentIndex with ComponentCount, note that ComponentCount is always 1 more than the highest Components index.</summary></devnotes></property>
      <property name="ComponentState" visibility="public" read="FComponentState" type="TComponentState" file="System.Classes.pas" line="2541"><devnotes><summary>
Describes the current state of the component, indicating when a component needs to avoid certain actions.
ComponentState is a set of constants defined in the TComponentState type.
Components use the ComponentState property to detect states in which certain kinds of actions are allowed or disallowed. For example, if a component needs to avoid certain behaviors at design time that it performs at run time, it can check for the csDesigning flag. 
ComponentState is read-only and its flags are set automatically when appropriate. 
</summary></devnotes></property>
      <property name="ComponentStyle" visibility="public" read="FComponentStyle" type="TComponentStyle" file="System.Classes.pas" line="2542"><devnotes><summary>
Governs the behavior of the component.
ComponentStyle governs how the component interacts with the streaming system and the Object Inspector. ComponentStyle is a read-only property. Typically, the value of the various component style flags are part of a component definition, specified in a component constructor. The one exception to this is the csSubComponent style, which can be set by calling the SetSubComponent method.
</summary></devnotes></property>
      <property name="DesignInfo" visibility="public" read="FDesignInfo" write="FDesignInfo" type="Integer" file="System.Classes.pas" line="2543"><devnotes><summary>
Contains information used by the Form designer.
DesignInfo is used internally. Do not use this property in applications.
</summary></devnotes></property>
      <property name="Owner" visibility="public" read="FOwner" type="TComponent" file="System.Classes.pas" line="2544"><devnotes><summary>
Indicates the component that is responsible for streaming and freeing this component.
Use Owner to find the owner of a component. The Owner of a component is responsible for two things:
The memory for the owned component is freed when its owner's memory is freed. This means that when a form is destroyed, all the components on the form are also destroyed.
The Owner is responsible for loading and saving the published properties of its owned controls.
By default, a form owns all components that are on it. In turn, the form is owned by the application. Thus, when the application shuts down and its memory is freed, the memory for all forms (and all their owned components) is also freed. When a form is loaded into memory, it loads all of the components that are on it.
The owner of a component is determined by the parameter passed to the constructor when the component is created. For components created in the form designer, the form is automatically assigned as the Owner.

Warning: If a component has an Owner other than a form or data module, it will not be saved or loaded with its Owner unless you identify it as a subcomponent. To identify a component as a subcomponent, call the SetSubComponent method.</summary></devnotes></property>
      <property name="VCLComObject" visibility="public" read="FVCLComObject" write="FVCLComObject" type="Pointer" file="System.Classes.pas" line="2545"><devnotes><summary>
Represents information used internally by components that support COM.
VCLComObject is for internal use only. 
</summary></devnotes></property>
      <property name="Observers" visibility="public" read="GetObservers" type="TObservers" file="System.Classes.pas" line="2546"><devnotes><summary>
Indicates the TObservers object added to the TComponent.
Observers is a read-only property that returns the TObservers added to the TComponent, in order to use the notifications provided by the observers either with LiveBindings or for the developers' own purposes.
</summary></devnotes></property>
      <property name="Name" visibility="published" read="FName" write="SetName" stored="False" type="TComponentName" default="0" file="System.Classes.pas" line="2548"><devnotes><summary>
Specifies the name of the component as referenced in code.
Use Name to change the name of a component to reflect its purpose in the current application. By default, the IDE assigns sequential names based on the type of the component, such as 'Button1', 'Button2', and so on.
Use Name to refer to the component in code.

Warning: Changing Name at run time causes any references to the old name to become undefined. Any subsequent code that uses the old name will cause an exception.</summary></devnotes></property>
      <property name="Tag" visibility="published" read="FTag" write="FTag" type="NativeInt" default="0" file="System.Classes.pas" line="2549"><devnotes><summary>
Stores a NativeInt integral value as a part of a component.
Tag has no predefined meaning. The Tag property can store any additional integer value for the convenience of developers. Often, Tag stores a pointer. A Tag value can be typecast to the appropriate pointer type. Notice that on 64-bit platforms, all  pointer types are 8 bytes in size, while on 32-bit platforms, pointer types are 4 bytes. These pointer sizes correspond to sizes of NativeInt integral values on 64-bit and 32-bit platforms.
</summary></devnotes></property>
      <procedure name="Destroy@" visibility="class private" procflags="class destructor noself" generated="true">
      </procedure>
    </members>
  <devnotes><summary>
TComponent is the common ancestor of all component classes.
TComponent is the base class for all components. Components are persistent objects that have the following capabilities:

IDE integration. The ability to appear on an IDE palette and be manipulated in a Form Designer.
Ownership. The ability to manage other components. If component A owns component B, then A is responsible for destroying B when A is destroyed.
Streaming and filing. Enhancements of the persistence features inherited from TPersistent.
COM support. Components can be converted into ActiveX controls or other COM objects using wizards provided with Windows products. Components can serve as wrappers for COM objects.
Note: COM features are present in all implementations of TComponent, including those provided for compatibility with OS X. However, COM features are Windows only and cannot be used in multi-device (cross-platform) applications.
TComponent does not provide any user interface or display features. These features are provided by two classes that directly descend from TComponent:

TControl, in the FMX.Types unit, is the base class for visual components in applications built with the FireMonkey (FMX) framework.
TControl, in the Vcl.Controls unit, is the base class for visual components in Windows-only (VCL) applications.
Note: Only the FMX.Types unit and other FireMonkey-specific units can be used with OS X applications. That is, you cannot use VCL units in multi-device applications.
Components that can be visible at run time are sometimes called visual components. Other components, which are never visible at run time, are sometimes called non-visual components. However it is more common to refer to visual components as controls and non-visual components simply as components.
Do not create instances of TComponent. Use TComponent as a base class when declaring non-visual components that can appear on the component palette and be used in the Form Designer. Properties and methods of TComponent provide basic behavior that descendant classes inherit as well as behavior that components can override to customize their behavior.
</summary></devnotes></class>
  <class name="TComponentInterfaceDelegate" file="System.Classes.pas" line="2552">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <interfaces>
      <implements name="IVCLComObject"/>
      <implements name="IInterface"/>
    </interfaces>
    <members>
      <field name="FOwner" type="TComponent" visibility="private" size="4" offset="4" file="System.Classes.pas" line="2554">
        <attributes>
          <attribute name="TObject"/>
        </attributes>
      </field>
      <function name="QueryInterface" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="2557">
        <parameters>
          <parameter name="IID" type="TGUID" paramflags="const"/>
          <parameter name="Obj" paramflags="out"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="_AddRef" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="2558">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="_Release" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="2559">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetTypeInfoCount" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="2561">
        <parameters>
          <parameter name="Count" type="Integer" paramflags="out"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="GetTypeInfo" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="2562">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <parameter name="LocaleID" type="Integer"/>
          <parameter name="TypeInfo" paramflags="out"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="GetIDsOfNames" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="2563">
        <parameters>
          <parameter name="IID" type="TGUID" paramflags="const"/>
          <parameter name="Names" type="Pointer"/>
          <parameter name="NameCount" type="Integer"/>
          <parameter name="LocaleID" type="Integer"/>
          <parameter name="DispIDs" type="Pointer"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <function name="Invoke" visibility="protected" callconv="stdcall" file="System.Classes.pas" line="2565">
        <parameters>
          <parameter name="DispID" type="Integer"/>
          <parameter name="IID" type="TGUID" paramflags="const"/>
          <parameter name="LocaleID" type="Integer"/>
          <parameter name="Flags" type="Word"/>
          <parameter name="Params" paramflags="var"/>
          <parameter name="VarResult" type="Pointer"/>
          <parameter name="ExcepInfo" type="Pointer"/>
          <parameter name="ArgErr" type="Pointer"/>
          <retval type="HRESULT"/>
        </parameters>
      </function>
      <procedure name="FreeOnRelease" visibility="protected" file="System.Classes.pas" line="2567">
      </procedure>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2569">
        <parameters>
          <parameter name="AOwner" type="TComponent"/>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="2570">
        <parameters>
        </parameters>
      </destructor>
      <property name="Owner" visibility="public" read="FOwner" type="TComponent" file="System.Classes.pas" line="2571"/>
    </members>
  </class>
  <class name="TBasicActionLink" file="System.Classes.pas" line="2576">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FOnChange" type="TNotifyEvent" visibility="private" size="8" offset="8" file="System.Classes.pas" line="2578"/>
      <field name="FAction" type="TBasicAction" visibility="private" size="4" offset="16" file="System.Classes.pas" line="2579">
        <attributes>
          <attribute name="TObject"/>
        </attributes>
      </field>
      <procedure name="AssignClient" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2581">
        <parameters>
          <parameter name="AClient" type="TObject"/>
        </parameters>
      </procedure>
      <procedure name="Change" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2582">
      </procedure>
      <function name="IsOnExecuteLinked" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2583">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="SetAction" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2584">
        <parameters>
          <parameter name="Value" type="TBasicAction"/>
        </parameters>
      </procedure>
      <procedure name="SetOnExecute" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2585">
        <parameters>
          <parameter name="Value" type="TNotifyEvent"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2587">
        <parameters>
          <parameter name="AClient" type="TObject"/>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="2588">
        <parameters>
        </parameters>
      </destructor>
      <function name="Execute" visibility="public" procflags="virtual" file="System.Classes.pas" line="2589">
        <parameters>
          <parameter name="AComponent" type="TComponent">
            <value>
              nil
            </value>
          </parameter>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="Update" visibility="public" procflags="virtual" file="System.Classes.pas" line="2590">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <property name="Action" visibility="public" read="FAction" write="SetAction" type="TBasicAction" file="System.Classes.pas" line="2591"/>
      <event name="OnChange" visibility="public" read="FOnChange" write="FOnChange" type="TNotifyEvent" file="System.Classes.pas" line="2592"/>
    </members>
  </class>
  <classref name="TBasicActionLinkClass" ref="TBasicActionLink" file="System.Classes.pas" line="2595"/>
  <type name="TActionEvent" file="System.Classes.pas" line="2597" procflags="closure">
  </type>
  <type name="THintEvent" file="System.Classes.pas" line="2598" procflags="closure">
  </type>
  <class name="TBasicAction" file="System.Classes.pas" line="2602">
    <ancestor name="TComponent" namespace="System.Classes">
      <interfaces>
        <implements name="IInterfaceComponentReference"/>
        <implements name="IInterface"/>
      </interfaces>
      <methodref name="GetComObject" visibility="private"/>
      <methodref name="GetComponent" visibility="private"/>
      <methodref name="GetComponentCount" visibility="private"/>
      <methodref name="GetComponentIndex" visibility="private"/>
      <methodref name="Insert" visibility="private"/>
      <methodref name="ReadLeft" visibility="private"/>
      <methodref name="ReadTop" visibility="private"/>
      <methodref name="Remove" visibility="private"/>
      <methodref name="RemoveNotification" visibility="private"/>
      <methodref name="SetComponentIndex" visibility="private"/>
      <methodref name="SetReference" visibility="private"/>
      <methodref name="WriteLeft" visibility="private"/>
      <methodref name="WriteTop" visibility="private"/>
      <methodref name="IntfGetComponent" visibility="private"/>
      <methodref name="DoGetDeltaStreams" visibility="private"/>
      <methodref name="ReadDeltaStream" visibility="private"/>
      <methodref name="ReadDeltaState" visibility="private"/>
      <methodref name="FindSortedComponent" visibility="private"/>
      <methodref name="AddSortedComponent" visibility="private"/>
      <methodref name="RemoveSortedComponent" visibility="private" procflags="inline"/>
      <methodref name="Create@" visibility="class private" procflags="class constructor noself"/>
      <methodref name="AsyncSchedule" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="ChangeName" visibility="protected"/>
      <methodref name="DefineProperties" visibility="protected" procflags="override"/>
      <methodref name="GetChildren" visibility="protected" procflags="dynamic"/>
      <methodref name="GetChildOwner" visibility="protected" procflags="dynamic"/>
      <methodref name="GetChildParent" visibility="protected" procflags="dynamic"/>
      <methodref name="GetOwner" visibility="protected" procflags="override"/>
      <methodref name="Loaded" visibility="protected" procflags="virtual"/>
      <methodref name="Notification" visibility="protected" procflags="virtual"/>
      <methodref name="GetDeltaStreams" visibility="protected" procflags="dynamic"/>
      <methodref name="ReadState" visibility="protected" procflags="virtual"/>
      <methodref name="CanObserve" visibility="protected" procflags="virtual"/>
      <methodref name="ObserverAdded" visibility="protected" procflags="virtual"/>
      <methodref name="GetObservers" visibility="protected" procflags="virtual"/>
      <methodref name="SetAncestor" visibility="protected"/>
      <methodref name="SetDesigning" visibility="protected"/>
      <methodref name="SetInline" visibility="protected"/>
      <methodref name="SetDesignInstance" visibility="protected"/>
      <methodref name="SetName" visibility="protected" procflags="virtual"/>
      <methodref name="SetChildOrder" visibility="protected" procflags="dynamic"/>
      <methodref name="SetParentComponent" visibility="protected" procflags="dynamic"/>
      <methodref name="Updating" visibility="protected" procflags="dynamic"/>
      <methodref name="Updated" visibility="protected" procflags="dynamic"/>
      <methodref name="UpdateRegistry" visibility="protected" procflags="class virtual"/>
      <methodref name="ValidateRename" visibility="protected" procflags="virtual"/>
      <methodref name="ValidateContainer" visibility="protected" procflags="dynamic"/>
      <methodref name="ValidateInsert" visibility="protected" procflags="dynamic"/>
      <methodref name="WriteState" visibility="protected" procflags="virtual"/>
      <methodref name="RemoveFreeNotifications" visibility="protected"/>
      <methodref name="QueryInterface" visibility="protected" procflags="virtual"/>
      <methodref name="_AddRef" visibility="protected"/>
      <methodref name="_Release" visibility="protected"/>
      <methodref name="GetTypeInfoCount" visibility="protected"/>
      <methodref name="GetTypeInfo" visibility="protected"/>
      <methodref name="GetIDsOfNames" visibility="protected"/>
      <methodref name="Invoke" visibility="protected"/>
      <eventref name="OnGetDeltaStreams" visibility="protected"/>
      <methodref name="Create" visibility="public" procflags="constructor virtual"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="BeforeDestruction" visibility="public" procflags="override"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload">
      </methodref>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="EndInvoke" visibility="public" procflags="overload">
      </methodref>
      <methodref name="EndInvoke" visibility="public" procflags="overload">
      </methodref>
      <methodref name="EndFunctionInvoke" visibility="public">
      </methodref>
      <methodref name="DestroyComponents" visibility="public"/>
      <methodref name="Destroying" visibility="public"/>
      <methodref name="ExecuteAction" visibility="public" procflags="dynamic"/>
      <methodref name="FindComponent" visibility="public"/>
      <methodref name="FreeNotification" visibility="public"/>
      <methodref name="RemoveFreeNotification" visibility="public"/>
      <methodref name="FreeOnRelease" visibility="public"/>
      <methodref name="GetEnumerator" visibility="public" procflags="inline"/>
      <methodref name="GetParentComponent" visibility="public" procflags="dynamic"/>
      <methodref name="GetNamePath" visibility="public" procflags="override"/>
      <methodref name="HasParent" visibility="public" procflags="dynamic"/>
      <methodref name="InsertComponent" visibility="public"/>
      <methodref name="RemoveComponent" visibility="public"/>
      <methodref name="SetSubComponent" visibility="public"/>
      <methodref name="SafeCallException" visibility="public" procflags="override"/>
      <methodref name="UpdateAction" visibility="public" procflags="virtual"/>
      <methodref name="IsImplementorOf" visibility="public"/>
      <methodref name="ReferenceInterface" visibility="public"/>
      <propertyref name="ComObject" visibility="public"/>
      <propertyref name="Components" visibility="public"/>
      <propertyref name="ComponentCount" visibility="public"/>
      <propertyref name="ComponentIndex" visibility="public"/>
      <propertyref name="ComponentState" visibility="public"/>
      <propertyref name="ComponentStyle" visibility="public"/>
      <propertyref name="DesignInfo" visibility="public"/>
      <propertyref name="Owner" visibility="public"/>
      <propertyref name="VCLComObject" visibility="public"/>
      <propertyref name="Observers" visibility="public"/>
      <propertyref name="Name" visibility="published"/>
      <propertyref name="Tag" visibility="published"/>
      <ancestor name="TPersistent" namespace="System.Classes">
        <methodref name="AssignError" visibility="private"/>
        <methodref name="AssignTo" visibility="protected" procflags="virtual"/>
        <methodref name="DefineProperties" visibility="protected" procflags="virtual"/>
        <methodref name="GetOwner" visibility="protected" procflags="dynamic"/>
        <methodref name="Destroy" visibility="public" procflags="destructor override"/>
        <methodref name="Assign" visibility="public" procflags="virtual"/>
        <methodref name="GetNamePath" visibility="public" procflags="dynamic"/>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FClients" type="TList&lt;System.Classes.TBasicActionLink&gt;" visibility="private" size="4" offset="64" file="System.Classes.pas" line="2604"/>
      <field name="FActionComponent" type="TComponent" visibility="private" size="4" offset="68" file="System.Classes.pas" line="2605">
        <attributes>
          <attribute name="TObject"/>
        </attributes>
      </field>
      <field name="FOnChange" type="TNotifyEvent" visibility="private" size="8" offset="72" file="System.Classes.pas" line="2606"/>
      <field name="FOnExecute" type="TNotifyEvent" visibility="private" size="8" offset="80" file="System.Classes.pas" line="2607"/>
      <field name="FOnUpdate" type="TNotifyEvent" visibility="private" size="8" offset="88" file="System.Classes.pas" line="2608"/>
      <function name="GetClientCount" visibility="private" file="System.Classes.pas" line="2609">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetClient" visibility="private" file="System.Classes.pas" line="2610">
        <parameters>
          <parameter name="Index" type="Integer"/>
          <retval type="TBasicActionLink"/>
        </parameters>
      </function>
      <procedure name="SetActionComponent" visibility="private" file="System.Classes.pas" line="2611">
        <parameters>
          <parameter name="Value" type="TComponent" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Change" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2613">
      <devnotes><summary>
Generates an OnChange event.
Change is called automatically when the action's properties change. This method calls the OnChange event handler, if one is assigned. 
</summary></devnotes></procedure>
      <procedure name="SetOnExecute" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2614">
        <parameters>
          <parameter name="Value" type="TNotifyEvent"/>
        </parameters>
      <devnotes><summary>
Assigns an OnExecute event handler for the action and for all clients.
SetOnExecute is the property write method for the OnExecute event. 
In addition to assigning the specified Value event handler to the OnExecute event, SetOnExecute propagates the assignment of this event handler to all clients linked to the action and generates an OnChange event.
</summary></devnotes></procedure>
      <event name="OnChange" visibility="protected" read="FOnChange" write="FOnChange" type="TNotifyEvent" file="System.Classes.pas" line="2615"><devnotes><summary>
Occurs when one of the action's properties changes.
Applications cannot use the protected OnChange event. It is used internally to manage the relationship between the properties of the action and the corresponding properties of the action's clients.
Component writers can use OnChange in descendent objects to respond when the action's properties change.
</summary></devnotes></event>
      <procedure name="Notification" visibility="protected" procflags="override" file="System.Classes.pas" line="2616">
        <parameters>
          <parameter name="AComponent" type="TComponent"/>
          <parameter name="Operation" type="TOperation"/>
        </parameters>
      <devnotes><summary>
Responds when components are created or destroyed.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. 
TBasicAction overrides the System.Classes.TComponent.Notification method. Notification checks whether the component specified by AComponent is the same as the component stored in the ActionComponent property and whether it is about to be freed. If so, Notification sets the ActionComponent property to nil (Delphi) or NULL (C++).
</summary></devnotes></procedure>
      <property name="ClientCount" visibility="protected" read="GetClientCount" type="Integer" file="System.Classes.pas" line="2617"><devnotes><summary>
Stores the number of elements in the Clients list of action links associated with the action.
</summary></devnotes></property>
      <property name="Clients[Index]" visibility="protected" read="GetClient" type="TBasicActionLink" file="System.Classes.pas" line="2618"/>
      <procedure name="RegisterChanges" visibility="protected" file="System.Classes.pas" line="2619">
        <parameters>
          <parameter name="Value" type="TBasicActionLink" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Associates the action with an action link.
RegisterChanges is called when the action and action link are connected, for example, when a new action link is set to an action. Value is the action link with which the action associates itself. The link is added to the action's client list.
</summary></devnotes></procedure>
      <procedure name="UnRegisterChanges" visibility="protected" file="System.Classes.pas" line="2620">
        <parameters>
          <parameter name="Value" type="TBasicActionLink" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Breaks the association between the action and the action link.
UnRegisterChanges is called when the action and the action link should no longer be associated. UnRegisterChanges is called, for example, in the action destructor or when the action link is unassociated from the action. Value is the action link with which the association is broken.
</summary></devnotes></procedure>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2622">
        <parameters>
          <parameter name="AOwner" type="TComponent"/>
        </parameters>
      <devnotes><summary>
Instantiates and initializes a TBasicAction object.
Applications do not need to instantiate TBasicAction directly. Actions are created automatically when you choose New Action in the Action List editor.
If you want to create an action at run time, you should call the Create constructor of a FireMonkey action (FMX.ActnList.TAction) or VCL action (Vcl.ActnList.TAction), or any of their subclasses. The Create constructors assign a TActionList component to the ActionList property of the created action.
Create calls the inherited constructor and then creates a list of clients of the created action.
</summary></devnotes></constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="2623">
        <parameters>
        </parameters>
      <devnotes><summary>
Disposes of an instance of a TBasicAction object.
You do not need to call the destructor for an action. An action is a component and is automatically destroyed by its owner, which was passed to the constructor when it is created. If you must destroy an action manually, call Free instead, which safely invokes the destructor.
</summary></devnotes></destructor>
      <function name="Suspended" visibility="public" procflags="virtual" file="System.Classes.pas" line="2624">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></function>
      <function name="HandlesTarget" visibility="public" procflags="virtual" file="System.Classes.pas" line="2625">
        <parameters>
          <parameter name="Target" type="TObject"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise.
</summary></devnotes></function>
      <procedure name="UpdateTarget" visibility="public" procflags="virtual" file="System.Classes.pas" line="2626">
        <parameters>
          <parameter name="Target" type="TObject"/>
        </parameters>
      <devnotes><summary>
Introduces an interface for a method of notifying a client when the action updates itself.
UpdateTarget does nothing in TBasicAction. UpdateTarget was introduced in TBasicAction so that descendants can override it to correspondingly update a target when the action updates. 
</summary></devnotes></procedure>
      <procedure name="ExecuteTarget" visibility="public" procflags="virtual" file="System.Classes.pas" line="2627">
        <parameters>
          <parameter name="Target" type="TObject"/>
        </parameters>
      <devnotes><summary>
Introduces an interface for invoking an action on a target client component or control.
ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard.
</summary></devnotes></procedure>
      <function name="Execute" visibility="public" procflags="dynamic" file="System.Classes.pas" line="2628">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Generates an OnExecute event.
Execute calls the OnExecute event handler, if one is assigned. Execute returns True if an event handler is called, False otherwise.
</summary></devnotes></function>
      <function name="Update" visibility="public" procflags="virtual" file="System.Classes.pas" line="2629">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.
</summary></devnotes></function>
      <property name="ActionComponent" visibility="public" read="FActionComponent" write="SetActionComponent" type="TComponent" file="System.Classes.pas" line="2630"><devnotes><summary>
Stores the client component that caused this action to execute.
Use ActionComponent to discern which client component caused this action to execute. For example, examine ActionComponent from an OnExecute event handler if you need to know what user action triggered this action.
When the user clicks a client control, that client sets ActionComponent before calling the action's Execute method. After the action executes, the action resets ActionComponent to nil (Delphi) or NULL (C++).
</summary></devnotes></property>
      <event name="OnExecute" visibility="public" read="FOnExecute" write="SetOnExecute" type="TNotifyEvent" file="System.Classes.pas" line="2631"><devnotes><summary>
Occurs when the execute event, of a client linked to the action, fires.
Write an OnExecute event handler when you want to respond when the user triggers the client object's default event (typically an OnClick event).
For most target clients, OnExecute is associated with the OnClick event. The Click method triggers the associated Action if EnableExecuteAction is True and the OnClick event handler is not assigned (or is equal to Action.OnExecute).
OnExecute is called in the Execute method. 
OnExecute also occurs when the user types the shortcut (or one of the secondary shortcuts) associated with the action or its client.

Warning:  If you assign an OnExecute event handler to a predefined action, the default behavior of that action will not occur.</summary></devnotes></event>
      <event name="OnUpdate" visibility="public" read="FOnUpdate" write="FOnUpdate" type="TNotifyEvent" file="System.Classes.pas" line="2632"><devnotes><summary>
Occurs when the application is idle or when the action list updates.
Write an OnUpdate event handler to execute centralized code while an application is idle. For example, actions may want to update enabling and disabling, or checking and unchecking of client targets.
</summary></devnotes></event>
    </members>
  <devnotes><summary>
TBasicAction is the ancestor class for all action objects.
TBasicAction introduces the fundamental behavior for an action. Descendants of TBasicAction add functionality for containment in an action list, for being categorized, and for specializing their behavior tailored to particular clients such as controls or menu items. Use TBasicAction if you want to create an action for an object that is neither a menu item nor a control.


</summary></devnotes></class>
  <classref name="TBasicActionClass" ref="TBasicAction" file="System.Classes.pas" line="2637"/>
  <class name="TDataModule" file="System.Classes.pas" line="2641">
    <ancestor name="TComponent" namespace="System.Classes">
      <interfaces>
        <implements name="IInterfaceComponentReference"/>
        <implements name="IInterface"/>
      </interfaces>
      <methodref name="GetComObject" visibility="private"/>
      <methodref name="GetComponent" visibility="private"/>
      <methodref name="GetComponentCount" visibility="private"/>
      <methodref name="GetComponentIndex" visibility="private"/>
      <methodref name="Insert" visibility="private"/>
      <methodref name="ReadLeft" visibility="private"/>
      <methodref name="ReadTop" visibility="private"/>
      <methodref name="Remove" visibility="private"/>
      <methodref name="RemoveNotification" visibility="private"/>
      <methodref name="SetComponentIndex" visibility="private"/>
      <methodref name="SetReference" visibility="private"/>
      <methodref name="WriteLeft" visibility="private"/>
      <methodref name="WriteTop" visibility="private"/>
      <methodref name="IntfGetComponent" visibility="private"/>
      <methodref name="DoGetDeltaStreams" visibility="private"/>
      <methodref name="ReadDeltaStream" visibility="private"/>
      <methodref name="ReadDeltaState" visibility="private"/>
      <methodref name="FindSortedComponent" visibility="private"/>
      <methodref name="AddSortedComponent" visibility="private"/>
      <methodref name="RemoveSortedComponent" visibility="private" procflags="inline"/>
      <methodref name="Create@" visibility="class private" procflags="class constructor noself"/>
      <methodref name="AsyncSchedule" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="ChangeName" visibility="protected"/>
      <methodref name="DefineProperties" visibility="protected" procflags="override"/>
      <methodref name="GetChildren" visibility="protected" procflags="dynamic"/>
      <methodref name="GetChildOwner" visibility="protected" procflags="dynamic"/>
      <methodref name="GetChildParent" visibility="protected" procflags="dynamic"/>
      <methodref name="GetOwner" visibility="protected" procflags="override"/>
      <methodref name="Loaded" visibility="protected" procflags="virtual"/>
      <methodref name="Notification" visibility="protected" procflags="virtual"/>
      <methodref name="GetDeltaStreams" visibility="protected" procflags="dynamic"/>
      <methodref name="ReadState" visibility="protected" procflags="virtual"/>
      <methodref name="CanObserve" visibility="protected" procflags="virtual"/>
      <methodref name="ObserverAdded" visibility="protected" procflags="virtual"/>
      <methodref name="GetObservers" visibility="protected" procflags="virtual"/>
      <methodref name="SetAncestor" visibility="protected"/>
      <methodref name="SetDesigning" visibility="protected"/>
      <methodref name="SetInline" visibility="protected"/>
      <methodref name="SetDesignInstance" visibility="protected"/>
      <methodref name="SetName" visibility="protected" procflags="virtual"/>
      <methodref name="SetChildOrder" visibility="protected" procflags="dynamic"/>
      <methodref name="SetParentComponent" visibility="protected" procflags="dynamic"/>
      <methodref name="Updating" visibility="protected" procflags="dynamic"/>
      <methodref name="Updated" visibility="protected" procflags="dynamic"/>
      <methodref name="UpdateRegistry" visibility="protected" procflags="class virtual"/>
      <methodref name="ValidateRename" visibility="protected" procflags="virtual"/>
      <methodref name="ValidateContainer" visibility="protected" procflags="dynamic"/>
      <methodref name="ValidateInsert" visibility="protected" procflags="dynamic"/>
      <methodref name="WriteState" visibility="protected" procflags="virtual"/>
      <methodref name="RemoveFreeNotifications" visibility="protected"/>
      <methodref name="QueryInterface" visibility="protected" procflags="virtual"/>
      <methodref name="_AddRef" visibility="protected"/>
      <methodref name="_Release" visibility="protected"/>
      <methodref name="GetTypeInfoCount" visibility="protected"/>
      <methodref name="GetTypeInfo" visibility="protected"/>
      <methodref name="GetIDsOfNames" visibility="protected"/>
      <methodref name="Invoke" visibility="protected"/>
      <eventref name="OnGetDeltaStreams" visibility="protected"/>
      <methodref name="Create" visibility="public" procflags="constructor virtual"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="BeforeDestruction" visibility="public" procflags="override"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload">
      </methodref>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="BeginInvoke" visibility="public" procflags="overload"/>
      <methodref name="EndInvoke" visibility="public" procflags="overload">
      </methodref>
      <methodref name="EndInvoke" visibility="public" procflags="overload">
      </methodref>
      <methodref name="EndFunctionInvoke" visibility="public">
      </methodref>
      <methodref name="DestroyComponents" visibility="public"/>
      <methodref name="Destroying" visibility="public"/>
      <methodref name="ExecuteAction" visibility="public" procflags="dynamic"/>
      <methodref name="FindComponent" visibility="public"/>
      <methodref name="FreeNotification" visibility="public"/>
      <methodref name="RemoveFreeNotification" visibility="public"/>
      <methodref name="FreeOnRelease" visibility="public"/>
      <methodref name="GetEnumerator" visibility="public" procflags="inline"/>
      <methodref name="GetParentComponent" visibility="public" procflags="dynamic"/>
      <methodref name="GetNamePath" visibility="public" procflags="override"/>
      <methodref name="HasParent" visibility="public" procflags="dynamic"/>
      <methodref name="InsertComponent" visibility="public"/>
      <methodref name="RemoveComponent" visibility="public"/>
      <methodref name="SetSubComponent" visibility="public"/>
      <methodref name="SafeCallException" visibility="public" procflags="override"/>
      <methodref name="UpdateAction" visibility="public" procflags="virtual"/>
      <methodref name="IsImplementorOf" visibility="public"/>
      <methodref name="ReferenceInterface" visibility="public"/>
      <propertyref name="ComObject" visibility="public"/>
      <propertyref name="Components" visibility="public"/>
      <propertyref name="ComponentCount" visibility="public"/>
      <propertyref name="ComponentIndex" visibility="public"/>
      <propertyref name="ComponentState" visibility="public"/>
      <propertyref name="ComponentStyle" visibility="public"/>
      <propertyref name="DesignInfo" visibility="public"/>
      <propertyref name="Owner" visibility="public"/>
      <propertyref name="VCLComObject" visibility="public"/>
      <propertyref name="Observers" visibility="public"/>
      <propertyref name="Name" visibility="published"/>
      <propertyref name="Tag" visibility="published"/>
      <ancestor name="TPersistent" namespace="System.Classes">
        <methodref name="AssignError" visibility="private"/>
        <methodref name="AssignTo" visibility="protected" procflags="virtual"/>
        <methodref name="DefineProperties" visibility="protected" procflags="virtual"/>
        <methodref name="GetOwner" visibility="protected" procflags="dynamic"/>
        <methodref name="Destroy" visibility="public" procflags="destructor override"/>
        <methodref name="Assign" visibility="public" procflags="virtual"/>
        <methodref name="GetNamePath" visibility="public" procflags="dynamic"/>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FPixelsPerInch" type="Integer" visibility="private" size="4" offset="64" file="System.Classes.pas" line="2643"/>
      <field name="FDesignSize" type="TPoint" visibility="private" size="8" offset="68" file="System.Classes.pas" line="2644"/>
      <field name="FDesignOffset" type="TPoint" visibility="private" size="8" offset="76" file="System.Classes.pas" line="2645"/>
      <field name="FOnCreate" type="TNotifyEvent" visibility="private" size="8" offset="88" file="System.Classes.pas" line="2646"/>
      <field name="FOnDestroy" type="TNotifyEvent" visibility="private" size="8" offset="96" file="System.Classes.pas" line="2647"/>
      <procedure name="ReadHeight" visibility="private" file="System.Classes.pas" line="2648">
        <parameters>
          <parameter name="Reader" type="TReader"/>
        </parameters>
      </procedure>
      <procedure name="ReadPixelsPerInch" visibility="private" file="System.Classes.pas" line="2649">
        <parameters>
          <parameter name="Reader" type="TReader"/>
        </parameters>
      </procedure>
      <procedure name="ReadHorizontalOffset" visibility="private" file="System.Classes.pas" line="2650">
        <parameters>
          <parameter name="Reader" type="TReader"/>
        </parameters>
      </procedure>
      <procedure name="ReadVerticalOffset" visibility="private" file="System.Classes.pas" line="2651">
        <parameters>
          <parameter name="Reader" type="TReader"/>
        </parameters>
      </procedure>
      <procedure name="ReadWidth" visibility="private" file="System.Classes.pas" line="2652">
        <parameters>
          <parameter name="Reader" type="TReader"/>
        </parameters>
      </procedure>
      <procedure name="WriteWidth" visibility="private" file="System.Classes.pas" line="2653">
        <parameters>
          <parameter name="Writer" type="TWriter"/>
        </parameters>
      </procedure>
      <procedure name="WritePixelsPerInch" visibility="private" file="System.Classes.pas" line="2654">
        <parameters>
          <parameter name="Writer" type="TWriter"/>
        </parameters>
      </procedure>
      <procedure name="WriteHorizontalOffset" visibility="private" file="System.Classes.pas" line="2655">
        <parameters>
          <parameter name="Writer" type="TWriter"/>
        </parameters>
      </procedure>
      <procedure name="WriteVerticalOffset" visibility="private" file="System.Classes.pas" line="2656">
        <parameters>
          <parameter name="Writer" type="TWriter"/>
        </parameters>
      </procedure>
      <procedure name="WriteHeight" visibility="private" file="System.Classes.pas" line="2657">
        <parameters>
          <parameter name="Writer" type="TWriter"/>
        </parameters>
      </procedure>
      <procedure name="IgnoreIdent" visibility="private" file="System.Classes.pas" line="2658">
        <parameters>
          <parameter name="Reader" type="TReader"/>
        </parameters>
      </procedure>
      <procedure name="DoCreate" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2660">
      </procedure>
      <procedure name="DoDestroy" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2661">
      </procedure>
      <procedure name="DefineProperties" visibility="protected" procflags="override" file="System.Classes.pas" line="2662">
        <parameters>
          <parameter name="Filer" type="TFiler"/>
        </parameters>
      </procedure>
      <procedure name="GetChildren" visibility="protected" procflags="override" file="System.Classes.pas" line="2663">
        <parameters>
          <parameter name="Proc" type="TGetChildProc"/>
          <parameter name="Root" type="TComponent"/>
        </parameters>
      </procedure>
      <function name="HandleCreateException" visibility="protected" procflags="dynamic" file="System.Classes.pas" line="2664">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2666">
        <parameters>
          <parameter name="AOwner" type="TComponent"/>
        </parameters>
      </constructor>
      <constructor name="CreateNew" visibility="public" file="System.Classes.pas" line="2667">
        <parameters>
          <parameter name="AOwner" type="TComponent"/>
          <parameter name="Dummy" type="Integer">
            <value>
              $0
            </value>
          </parameter>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="2668">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="AfterConstruction" visibility="public" procflags="override" file="System.Classes.pas" line="2669">
      </procedure>
      <procedure name="BeforeDestruction" visibility="public" procflags="override" file="System.Classes.pas" line="2670">
      </procedure>
      <property name="DesignOffset" visibility="public" read="FDesignOffset" write="FDesignOffset" type="TPoint" file="System.Classes.pas" line="2671"/>
      <property name="DesignSize" visibility="public" read="FDesignSize" write="FDesignSize" type="TPoint" file="System.Classes.pas" line="2672"/>
      <property name="PixelsPerInch" visibility="public" read="FPixelsPerInch" write="FPixelsPerInch" type="Integer" file="System.Classes.pas" line="2673"/>
      <event name="OnCreate" visibility="published" read="FOnCreate" write="FOnCreate" type="TNotifyEvent" file="System.Classes.pas" line="2675"/>
      <event name="OnDestroy" visibility="published" read="FOnDestroy" write="FOnDestroy" type="TNotifyEvent" file="System.Classes.pas" line="2676"/>
    </members>
  </class>
  <variable name="AddDataModule" type="procedure(DataModule: TDataModule)" visibility="public" file="System.Classes.pas" line="2680"/>
  <variable name="RemoveDataModule" type="procedure(DataModule: TDataModule)" visibility="public" file="System.Classes.pas" line="2681"/>
  <variable name="ApplicationHandleException" type="procedure(Sender: TObject)" visibility="public" file="System.Classes.pas" line="2682"/>
  <variable name="ApplicationShowException" type="procedure(E: Exception)" visibility="public" file="System.Classes.pas" line="2683"/>
  <variable name="RegisterComponentsProc" type="procedure(Page: string; ComponentClasses: array of TComponentClass)" visibility="public" file="System.Classes.pas" line="2687"/>
  <variable name="RegisterNoIconProc" type="procedure(ComponentClasses: array of TComponentClass)" visibility="public" file="System.Classes.pas" line="2689"/>
  <variable name="CurrentGroup" type="Integer" visibility="public" file="System.Classes.pas" line="2690"/>
  <const name="axrComponentOnly" type="TActiveXRegType" file="System.Classes.pas" line="2694">
    <value>
      axrComponentOnly
    </value>
  </const>
  <const name="axrIncludeDescendants" type="TActiveXRegType" file="System.Classes.pas" line="2694">
    <value>
      axrIncludeDescendants
    </value>
  </const>
  <enum name="TActiveXRegType" file="System.Classes.pas" line="2694">
    <element value="0" name="axrComponentOnly" file="System.Classes.pas" line="2694"/>
    <element value="1" name="axrIncludeDescendants" file="System.Classes.pas" line="2694"/>
  </enum>
  <variable name="RegisterNonActiveXProc" type="procedure(ComponentClasses: array of TComponentClass; AxRegType: TActiveXRegType)" visibility="public" file="System.Classes.pas" line="2697"/>
  <variable name="CreateVCLComObjectProc" type="procedure(Component: TComponent)" visibility="public" file="System.Classes.pas" line="2701"/>
  <variable name="GlobalNameSpace" type="IReadWriteSync" file="System.Classes.pas" line="2748"/>
  <struct name="TIdentMapEntry" size="8" file="System.Classes.pas" line="2753">
    <field name="Value" type="Integer" visibility="public" size="4" offset="0" file="System.Classes.pas" line="2754"/>
    <field name="Name" type="string" visibility="public" size="4" offset="4" file="System.Classes.pas" line="2755"/>
  </struct>
  <type name="TIdentToInt" file="System.Classes.pas" line="2759" procflags="">
  </type>
  <type name="TIntToIdent" file="System.Classes.pas" line="2760" procflags="">
  </type>
  <type name="TFindGlobalComponent" file="System.Classes.pas" line="2761" procflags="">
  </type>
  <type name="TIsUniqueGlobalComponentName" file="System.Classes.pas" line="2762" procflags="">
  </type>
  <variable name="IsUniqueGlobalComponentNameProc" type="TIsUniqueGlobalComponentName" file="System.Classes.pas" line="2765"/>
  <const name="sofUnknown" type="TStreamOriginalFormat" file="System.Classes.pas" line="2815">
    <value>
      sofUnknown
    </value>
  </const>
  <const name="sofBinary" type="TStreamOriginalFormat" file="System.Classes.pas" line="2815">
    <value>
      sofBinary
    </value>
  </const>
  <const name="sofText" type="TStreamOriginalFormat" file="System.Classes.pas" line="2815">
    <value>
      sofText
    </value>
  </const>
  <const name="sofUTF8Text" type="TStreamOriginalFormat" file="System.Classes.pas" line="2815">
    <value>
      sofUTF8Text
    </value>
  </const>
  <enum name="TStreamOriginalFormat" file="System.Classes.pas" line="2815">
    <element value="0" name="sofUnknown" file="System.Classes.pas" line="2815"/>
    <element value="1" name="sofBinary" file="System.Classes.pas" line="2815"/>
    <element value="2" name="sofText" file="System.Classes.pas" line="2815"/>
    <element value="3" name="sofUTF8Text" file="System.Classes.pas" line="2815"/>
  </enum>
  <variable name="WakeMainThread" type="TNotifyEvent" visibility="public" file="System.Classes.pas" line="2900"/>
  <variable name="SyncEvent" type="NativeUInt" file="System.Classes.pas" line="2909"/>
  <type name="TWndMethod" file="System.Classes.pas" line="2925" procflags="closure">
  </type>
  <class name="TTextReader" file="System.Classes.pas" line="2928">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <procedure name="Close" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2930">
      </procedure>
      <function name="Peek" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2931">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="Read" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2932">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="Read" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2933">
        <parameters>
          <parameter name="Buffer" type="TCharArray" paramflags="var"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="ReadBlock" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2934">
        <parameters>
          <parameter name="Buffer" type="TCharArray" paramflags="var"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="ReadLine" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2935">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="ReadToEnd" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2936">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <procedure name="Rewind" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2937">
      </procedure>
    </members>
  </class>
  <class name="TTextWriter" file="System.Classes.pas" line="2940">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <procedure name="Close" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2942">
      </procedure>
      <procedure name="Flush" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="2943">
      </procedure>
      <procedure name="Write" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2944">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2945">
        <parameters>
          <parameter name="Value" type="Char"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="2946">
        <parameters>
          <parameter name="Value" type="Char"/>
          <parameter name="Count" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2947">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2948">
        <parameters>
          <parameter name="Value" type="Double"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2949">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2950">
        <parameters>
          <parameter name="Value" type="Int64"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2951">
        <parameters>
          <parameter name="Value" type="TObject"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2952">
        <parameters>
          <parameter name="Value" type="Single"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2953">
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2954">
        <parameters>
          <parameter name="Value" type="Cardinal"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2955">
        <parameters>
          <parameter name="Value" type="UInt64"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2956">
        <parameters>
          <parameter name="Format" type="string" paramflags="const"/>
          <parameter name="Args">
            <array name="Args">
              <element type="TVarRec"/>
            </array>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2957">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2958">
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2959">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2960">
        <parameters>
          <parameter name="Value" type="Char"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2961">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2962">
        <parameters>
          <parameter name="Value" type="Double"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2963">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2964">
        <parameters>
          <parameter name="Value" type="Int64"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2965">
        <parameters>
          <parameter name="Value" type="TObject"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2966">
        <parameters>
          <parameter name="Value" type="Single"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2967">
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2968">
        <parameters>
          <parameter name="Value" type="Cardinal"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2969">
        <parameters>
          <parameter name="Value" type="UInt64"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2970">
        <parameters>
          <parameter name="Format" type="string" paramflags="const"/>
          <parameter name="Args">
            <array name="Args">
              <element type="TVarRec"/>
            </array>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="abstract overload virtual" file="System.Classes.pas" line="2971">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
        </parameters>
      </procedure>
    </members>
  </class>
  <class name="TBinaryReader" file="System.Classes.pas" line="2974">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FStream" type="TStream" visibility="class private" size="4" offset="4" file="System.Classes.pas" line="2976"/>
      <field name="FEncoding" type="TEncoding" visibility="class private" size="4" offset="8" file="System.Classes.pas" line="2977"/>
      <field name="FOwnsStream" type="Boolean" visibility="class private" size="1" offset="12" file="System.Classes.pas" line="2978"/>
      <field name="FTwoBytesPerChar" type="Boolean" visibility="class private" size="1" offset="13" file="System.Classes.pas" line="2979"/>
      <field name="FCharBytes" type="TBytes" visibility="class private" size="4" offset="16" file="System.Classes.pas" line="2980"/>
      <field name="FOneChar" type="TCharArray" visibility="class private" size="4" offset="20" file="System.Classes.pas" line="2981"/>
      <field name="FMaxCharsSize" type="Integer" visibility="class private" size="4" offset="24" file="System.Classes.pas" line="2982"/>
      <function name="InternalReadChar" visibility="class private" file="System.Classes.pas" line="2983">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="InternalReadChars" visibility="class private" file="System.Classes.pas" line="2984">
        <parameters>
          <parameter name="Chars" type="TCharArray" paramflags="const"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetBaseStream" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2986">
        <parameters>
          <retval type="TStream"/>
        </parameters>
      </function>
      <function name="Read7BitEncodedInt" visibility="protected" procflags="virtual" file="System.Classes.pas" line="2987">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2989">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="AEncoding" type="TEncoding">
            <value>
              nil
            </value>
          </parameter>
          <parameter name="AOwnsStream" type="Boolean">
            <value>
              False
            </value>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="2990">
        <parameters>
          <parameter name="Filename" type="string" paramflags="const"/>
          <parameter name="Encoding" type="TEncoding">
            <value>
              nil
            </value>
          </parameter>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="2991">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Close" visibility="public" procflags="virtual" file="System.Classes.pas" line="2992">
      </procedure>
      <function name="PeekChar" visibility="public" procflags="virtual" file="System.Classes.pas" line="2993">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="Read" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="2994">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="Read" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="2995">
        <parameters>
          <parameter name="Buffer" type="TCharArray" paramflags="var"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="Read" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="2996">
        <parameters>
          <parameter name="Buffer" type="TBytes" paramflags="const"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="ReadBoolean" visibility="public" procflags="virtual" file="System.Classes.pas" line="2997">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="ReadByte" visibility="public" procflags="virtual" file="System.Classes.pas" line="2998">
        <parameters>
          <retval type="Byte"/>
        </parameters>
      </function>
      <function name="ReadBytes" visibility="public" procflags="virtual" file="System.Classes.pas" line="2999">
        <parameters>
          <parameter name="Count" type="Integer"/>
          <retval type="TBytes"/>
        </parameters>
      </function>
      <function name="ReadChar" visibility="public" procflags="virtual" file="System.Classes.pas" line="3000">
        <parameters>
          <retval type="Char"/>
        </parameters>
      </function>
      <function name="ReadChars" visibility="public" procflags="virtual" file="System.Classes.pas" line="3001">
        <parameters>
          <parameter name="Count" type="Integer"/>
          <retval type="TCharArray"/>
        </parameters>
      </function>
      <function name="ReadDouble" visibility="public" procflags="virtual" file="System.Classes.pas" line="3002">
        <parameters>
          <retval type="Double"/>
        </parameters>
      </function>
      <function name="ReadSByte" visibility="public" procflags="inline" file="System.Classes.pas" line="3003">
        <parameters>
          <retval type="ShortInt"/>
        </parameters>
      </function>
      <function name="ReadShortInt" visibility="public" procflags="virtual" file="System.Classes.pas" line="3004">
        <parameters>
          <retval type="ShortInt"/>
        </parameters>
      </function>
      <function name="ReadSmallInt" visibility="public" procflags="virtual" file="System.Classes.pas" line="3005">
        <parameters>
          <retval type="SmallInt"/>
        </parameters>
      </function>
      <function name="ReadInt16" visibility="public" procflags="inline" file="System.Classes.pas" line="3006">
        <parameters>
          <retval type="SmallInt"/>
        </parameters>
      </function>
      <function name="ReadInteger" visibility="public" procflags="virtual" file="System.Classes.pas" line="3007">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="ReadInt32" visibility="public" procflags="inline" file="System.Classes.pas" line="3008">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="ReadInt64" visibility="public" procflags="virtual" file="System.Classes.pas" line="3009">
        <parameters>
          <retval type="Int64"/>
        </parameters>
      </function>
      <function name="ReadSingle" visibility="public" procflags="virtual" file="System.Classes.pas" line="3010">
        <parameters>
          <retval type="Single"/>
        </parameters>
      </function>
      <function name="ReadString" visibility="public" procflags="virtual" file="System.Classes.pas" line="3011">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="ReadWord" visibility="public" procflags="virtual" file="System.Classes.pas" line="3012">
        <parameters>
          <retval type="Word"/>
        </parameters>
      </function>
      <function name="ReadUInt16" visibility="public" procflags="inline" file="System.Classes.pas" line="3013">
        <parameters>
          <retval type="Word"/>
        </parameters>
      </function>
      <function name="ReadCardinal" visibility="public" procflags="virtual" file="System.Classes.pas" line="3014">
        <parameters>
          <retval type="Cardinal"/>
        </parameters>
      </function>
      <function name="ReadUInt32" visibility="public" procflags="inline" file="System.Classes.pas" line="3015">
        <parameters>
          <retval type="Cardinal"/>
        </parameters>
      </function>
      <function name="ReadUInt64" visibility="public" procflags="virtual" file="System.Classes.pas" line="3016">
        <parameters>
          <retval type="UInt64"/>
        </parameters>
      </function>
      <property name="BaseStream" visibility="public" read="GetBaseStream" type="TStream" file="System.Classes.pas" line="3017"/>
    </members>
  </class>
  <class name="TBinaryWriter" file="System.Classes.pas" line="3020">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FStream" type="TStream" visibility="class private" size="4" offset="4" file="System.Classes.pas" line="3022"/>
      <field name="FOwnsStream" type="Boolean" visibility="class private" size="1" offset="8" file="System.Classes.pas" line="3023"/>
      <field name="FEncoding" type="TEncoding" visibility="class private" size="4" offset="12" file="System.Classes.pas" line="3024"/>
      <field name="FNull" type="TBinaryWriter" visibility="class private" varflags="class" file="System.Classes.pas" line="3025"/>
      <procedure name="Destroy@" visibility="class private" procflags="class destructor noself" file="System.Classes.pas" line="3026">
      </procedure>
      <function name="GetNull" visibility="class private" procflags="static" file="System.Classes.pas" line="3027">
        <parameters>
          <retval type="TBinaryWriter"/>
        </parameters>
      </function>
      <function name="GetBaseStream" visibility="protected" procflags="virtual" file="System.Classes.pas" line="3029">
        <parameters>
          <retval type="TStream"/>
        </parameters>
      </function>
      <procedure name="Write7BitEncodedInt" visibility="protected" procflags="virtual" file="System.Classes.pas" line="3030">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="protected" file="System.Classes.pas" line="3031">
        <parameters>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3033">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3034">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="Encoding" type="TEncoding"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3035">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="Encoding" type="TEncoding"/>
          <parameter name="AOwnsStream" type="Boolean"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3036">
        <parameters>
          <parameter name="Filename" type="string" paramflags="const"/>
          <parameter name="Append" type="Boolean">
            <value>
              False
            </value>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3037">
        <parameters>
          <parameter name="Filename" type="string" paramflags="const"/>
          <parameter name="Append" type="Boolean"/>
          <parameter name="Encoding" type="TEncoding"/>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="3038">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Close" visibility="public" procflags="virtual" file="System.Classes.pas" line="3039">
      </procedure>
      <function name="Seek" visibility="public" procflags="virtual" file="System.Classes.pas" line="3040">
        <parameters>
          <parameter name="Offset" type="Int64" paramflags="const"/>
          <parameter name="Origin" type="TSeekOrigin"/>
          <retval type="Int64"/>
        </parameters>
      </function>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3041">
        <parameters>
          <parameter name="Value" type="Byte"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3042">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3043">
        <parameters>
          <parameter name="Value" type="Char"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3044">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3045">
        <parameters>
          <parameter name="Value" type="TBytes" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3046">
        <parameters>
          <parameter name="Value" type="Double"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3047">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3048">
        <parameters>
          <parameter name="Value" type="SmallInt"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3049">
        <parameters>
          <parameter name="Value" type="ShortInt"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3050">
        <parameters>
          <parameter name="Value" type="Word"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3051">
        <parameters>
          <parameter name="Value" type="Cardinal"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3052">
        <parameters>
          <parameter name="Value" type="Int64"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3053">
        <parameters>
          <parameter name="Value" type="Single"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3054">
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3055">
        <parameters>
          <parameter name="Value" type="UInt64"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3056">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload virtual" file="System.Classes.pas" line="3057">
        <parameters>
          <parameter name="Value" type="TBytes" paramflags="const"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
        </parameters>
      </procedure>
      <property name="BaseStream" visibility="public" read="GetBaseStream" type="TStream" file="System.Classes.pas" line="3058"/>
      <property name="Null" visibility="public" read="GetNull" type="TBinaryWriter" file="System.Classes.pas" line="3059"/>
      <procedure name="Create@" visibility="class private" procflags="class constructor noself" generated="true">
      </procedure>
    </members>
  </class>
  <class name="TStringReader" file="System.Classes.pas" line="3062">
    <ancestor name="TTextReader" namespace="System.Classes">
      <methodref name="Close" visibility="public" procflags="abstract virtual"/>
      <methodref name="Peek" visibility="public" procflags="abstract virtual"/>
      <methodref name="Read" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Read" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="ReadBlock" visibility="public" procflags="abstract virtual"/>
      <methodref name="ReadLine" visibility="public" procflags="abstract virtual"/>
      <methodref name="ReadToEnd" visibility="public" procflags="abstract virtual"/>
      <methodref name="Rewind" visibility="public" procflags="abstract virtual"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FData" type="string" visibility="private" size="4" offset="4" file="System.Classes.pas" line="3064"/>
      <field name="FIndex" type="Integer" visibility="private" size="4" offset="8" file="System.Classes.pas" line="3065"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3067">
        <parameters>
          <parameter name="S" type="string"/>
        </parameters>
      </constructor>
      <procedure name="Close" visibility="public" procflags="override" file="System.Classes.pas" line="3068">
      </procedure>
      <function name="Peek" visibility="public" procflags="override" file="System.Classes.pas" line="3069">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="Read" visibility="public" procflags="overload override" file="System.Classes.pas" line="3070">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="Read" visibility="public" procflags="overload override" file="System.Classes.pas" line="3071">
        <parameters>
          <parameter name="Buffer" type="TCharArray" paramflags="var"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="ReadBlock" visibility="public" procflags="override" file="System.Classes.pas" line="3072">
        <parameters>
          <parameter name="Buffer" type="TCharArray" paramflags="var"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="ReadLine" visibility="public" procflags="override" file="System.Classes.pas" line="3073">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="ReadToEnd" visibility="public" procflags="override" file="System.Classes.pas" line="3074">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <procedure name="Rewind" visibility="public" procflags="override" file="System.Classes.pas" line="3075">
      </procedure>
    </members>
  </class>
  <class name="TStringWriter" file="System.Classes.pas" line="3078">
    <ancestor name="TTextWriter" namespace="System.Classes">
      <methodref name="Close" visibility="public" procflags="abstract virtual"/>
      <methodref name="Flush" visibility="public" procflags="abstract virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FBuilder" type="TStringBuilder" visibility="private" size="4" offset="4" file="System.Classes.pas" line="3080"/>
      <field name="FOwnsBuilder" type="Boolean" visibility="private" size="1" offset="8" file="System.Classes.pas" line="3081"/>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3083">
        <parameters>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3084">
        <parameters>
          <parameter name="Builder" type="TStringBuilder"/>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="3085">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Close" visibility="public" procflags="override" file="System.Classes.pas" line="3086">
      </procedure>
      <procedure name="Flush" visibility="public" procflags="override" file="System.Classes.pas" line="3087">
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3088">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3089">
        <parameters>
          <parameter name="Value" type="Char"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3090">
        <parameters>
          <parameter name="Value" type="Char"/>
          <parameter name="Count" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3091">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3092">
        <parameters>
          <parameter name="Value" type="Double"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3093">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3094">
        <parameters>
          <parameter name="Value" type="Int64"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3095">
        <parameters>
          <parameter name="Value" type="TObject"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3096">
        <parameters>
          <parameter name="Value" type="Single"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3097">
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3098">
        <parameters>
          <parameter name="Value" type="Cardinal"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3099">
        <parameters>
          <parameter name="Value" type="UInt64"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3100">
        <parameters>
          <parameter name="Format" type="string" paramflags="const"/>
          <parameter name="Args">
            <array name="Args" file="System.Classes.pas" line="19065">
              <element type="TVarRec"/>
            </array>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3101">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3102">
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3103">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3104">
        <parameters>
          <parameter name="Value" type="Char"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3105">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3106">
        <parameters>
          <parameter name="Value" type="Double"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3107">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3108">
        <parameters>
          <parameter name="Value" type="Int64"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3109">
        <parameters>
          <parameter name="Value" type="TObject"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3110">
        <parameters>
          <parameter name="Value" type="Single"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3111">
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3112">
        <parameters>
          <parameter name="Value" type="Cardinal"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3113">
        <parameters>
          <parameter name="Value" type="UInt64"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3114">
        <parameters>
          <parameter name="Format" type="string" paramflags="const"/>
          <parameter name="Args">
            <array name="Args" file="System.Classes.pas" line="19150">
              <element type="TVarRec"/>
            </array>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3115">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
        </parameters>
      </procedure>
      <function name="ToString" visibility="public" procflags="override" file="System.Classes.pas" line="3116">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
    </members>
  </class>
  <class name="TStreamWriter" file="System.Classes.pas" line="3119">
    <ancestor name="TTextWriter" namespace="System.Classes">
      <methodref name="Close" visibility="public" procflags="abstract virtual"/>
      <methodref name="Flush" visibility="public" procflags="abstract virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Write" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="WriteLine" visibility="public" procflags="abstract overload virtual"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FStream" type="TStream" visibility="private" size="4" offset="4" file="System.Classes.pas" line="3121"/>
      <field name="FEncoding" type="TEncoding" visibility="private" size="4" offset="8" file="System.Classes.pas" line="3122"/>
      <field name="FNewLine" type="string" visibility="private" size="4" offset="12" file="System.Classes.pas" line="3123"/>
      <field name="FAutoFlush" type="Boolean" visibility="private" size="1" offset="16" file="System.Classes.pas" line="3124"/>
      <field name="FOwnsStream" type="Boolean" visibility="private" size="1" offset="17" file="System.Classes.pas" line="3125"/>
      <field name="FBufferIndex" type="Integer" visibility="protected" size="4" offset="20" file="System.Classes.pas" line="3127"/>
      <field name="FBuffer" type="TBytes" visibility="protected" size="4" offset="24" file="System.Classes.pas" line="3128"/>
      <procedure name="WriteBytes" visibility="protected" file="System.Classes.pas" line="3129">
        <parameters>
          <parameter name="Bytes" type="TBytes"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3131">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3132">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="Encoding" type="TEncoding"/>
          <parameter name="BufferSize" type="Integer">
            <value>
              $1000
            </value>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3133">
        <parameters>
          <parameter name="Filename" type="string" paramflags="const"/>
          <parameter name="Append" type="Boolean">
            <value>
              False
            </value>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3134">
        <parameters>
          <parameter name="Filename" type="string" paramflags="const"/>
          <parameter name="Append" type="Boolean"/>
          <parameter name="Encoding" type="TEncoding"/>
          <parameter name="BufferSize" type="Integer">
            <value>
              $1000
            </value>
          </parameter>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="3135">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Close" visibility="public" procflags="override" file="System.Classes.pas" line="3136">
      </procedure>
      <procedure name="Flush" visibility="public" procflags="override" file="System.Classes.pas" line="3137">
      </procedure>
      <procedure name="OwnStream" visibility="public" procflags="inline" file="System.Classes.pas" line="3138">
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3139">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3140">
        <parameters>
          <parameter name="Value" type="Char"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3141">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3142">
        <parameters>
          <parameter name="Value" type="Double"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3143">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3144">
        <parameters>
          <parameter name="Value" type="Int64"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3145">
        <parameters>
          <parameter name="Value" type="TObject"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3146">
        <parameters>
          <parameter name="Value" type="Single"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3147">
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3148">
        <parameters>
          <parameter name="Value" type="Cardinal"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3149">
        <parameters>
          <parameter name="Value" type="UInt64"/>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3150">
        <parameters>
          <parameter name="Format" type="string" paramflags="const"/>
          <parameter name="Args">
            <array name="Args" file="System.Classes.pas" line="19321">
              <element type="TVarRec"/>
            </array>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3151">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3152">
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3153">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3154">
        <parameters>
          <parameter name="Value" type="Char"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3155">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3156">
        <parameters>
          <parameter name="Value" type="Double"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3157">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3158">
        <parameters>
          <parameter name="Value" type="Int64"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3159">
        <parameters>
          <parameter name="Value" type="TObject"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3160">
        <parameters>
          <parameter name="Value" type="Single"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3161">
        <parameters>
          <parameter name="Value" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3162">
        <parameters>
          <parameter name="Value" type="Cardinal"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3163">
        <parameters>
          <parameter name="Value" type="UInt64"/>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3164">
        <parameters>
          <parameter name="Format" type="string" paramflags="const"/>
          <parameter name="Args">
            <array name="Args" file="System.Classes.pas" line="19408">
              <element type="TVarRec"/>
            </array>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="WriteLine" visibility="public" procflags="overload override" file="System.Classes.pas" line="3165">
        <parameters>
          <parameter name="Value" type="TCharArray" paramflags="const"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
        </parameters>
      </procedure>
      <property name="AutoFlush" visibility="public" read="FAutoFlush" write="FAutoFlush" type="Boolean" file="System.Classes.pas" line="3166"/>
      <property name="NewLine" visibility="public" read="FNewLine" write="FNewLine" type="string" default="0" file="System.Classes.pas" line="3167"/>
      <property name="Encoding" visibility="public" read="FEncoding" type="TEncoding" file="System.Classes.pas" line="3168"/>
      <property name="BaseStream" visibility="public" read="FStream" type="TStream" file="System.Classes.pas" line="3169"/>
    </members>
  </class>
  <class name="TStreamReader" file="System.Classes.pas" line="3172">
    <ancestor name="TTextReader" namespace="System.Classes">
      <methodref name="Close" visibility="public" procflags="abstract virtual"/>
      <methodref name="Peek" visibility="public" procflags="abstract virtual"/>
      <methodref name="Read" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Read" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="ReadBlock" visibility="public" procflags="abstract virtual"/>
      <methodref name="ReadLine" visibility="public" procflags="abstract virtual"/>
      <methodref name="ReadToEnd" visibility="public" procflags="abstract virtual"/>
      <methodref name="Rewind" visibility="public" procflags="abstract virtual"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <class name="TBufferedData" visibility="private" alias="System.Classes.TBufferedData" file="System.Classes.pas" line="3174">
        <ancestor name="TStringBuilder" namespace="System.SysUtils">
          <methodref name="GetCapacity" visibility="private" procflags="inline">
          </methodref>
          <methodref name="SetCapacity" visibility="private">
          </methodref>
          <methodref name="GetChars" visibility="private">
          </methodref>
          <methodref name="SetChars" visibility="private">
          </methodref>
          <methodref name="GetLength" visibility="private" procflags="inline">
          </methodref>
          <methodref name="SetLength" visibility="private">
          </methodref>
          <methodref name="GetMaxCapacity" visibility="private" procflags="inline">
          </methodref>
          <methodref name="ExpandCapacity" visibility="private">
          </methodref>
          <methodref name="ReduceCapacity" visibility="private">
          </methodref>
          <methodref name="CheckBounds" visibility="private">
          </methodref>
          <methodref name="_Replace" visibility="private">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Create" visibility="public" procflags="constructor overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Append" visibility="public" procflags="overload">
          </methodref>
          <methodref name="AppendFormat" visibility="public" procflags="overload">
          </methodref>
          <methodref name="AppendLine" visibility="public" procflags="overload inline">
          </methodref>
          <methodref name="AppendLine" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Clear" visibility="public">
          </methodref>
          <methodref name="CopyTo" visibility="public">
          </methodref>
          <methodref name="EnsureCapacity" visibility="public">
          </methodref>
          <methodref name="Equals" visibility="public">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Insert" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Remove" visibility="public">
          </methodref>
          <methodref name="Replace" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Replace" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Replace" visibility="public" procflags="overload">
          </methodref>
          <methodref name="Replace" visibility="public" procflags="overload">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="overload override">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="overload">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetEnumerator" visibility="public" procflags="inline">
          </methodref>
          <propertyref name="Capacity" visibility="public">
          </propertyref>
          <propertyref name="Chars" visibility="public">
          </propertyref>
          <propertyref name="Length" visibility="public">
          </propertyref>
          <propertyref name="MaxCapacity" visibility="public">
          </propertyref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
        <members>
          <field name="FStart" type="Integer" visibility="private" size="4" offset="16" file="System.Classes.pas" line="3176"/>
          <field name="FBufferSize" type="Integer" visibility="private" size="4" offset="20" file="System.Classes.pas" line="3177"/>
          <function name="GetChars" visibility="private" procflags="inline" file="System.Classes.pas" line="3178">
            <parameters>
              <parameter name="AIndex" type="Integer"/>
              <retval type="Char"/>
            </parameters>
          </function>
          <constructor name="Create" visibility="public" file="System.Classes.pas" line="3180">
            <parameters>
              <parameter name="ABufferSize" type="Integer"/>
            </parameters>
          </constructor>
          <procedure name="Clear" visibility="public" procflags="inline" file="System.Classes.pas" line="3181">
          </procedure>
          <function name="Length" visibility="public" procflags="inline" file="System.Classes.pas" line="3182">
            <parameters>
              <retval type="Integer"/>
            </parameters>
          </function>
          <function name="PeekChar" visibility="public" procflags="inline" file="System.Classes.pas" line="3183">
            <parameters>
              <retval type="Char"/>
            </parameters>
          </function>
          <function name="MoveChar" visibility="public" procflags="inline" file="System.Classes.pas" line="3184">
            <parameters>
              <retval type="Char"/>
            </parameters>
          </function>
          <procedure name="MoveArray" visibility="public" file="System.Classes.pas" line="3185">
            <parameters>
              <parameter name="DestinationIndex" type="Integer"/>
              <parameter name="Count" type="Integer"/>
              <parameter name="Destination" type="TCharArray" paramflags="var"/>
            </parameters>
          </procedure>
          <procedure name="MoveString" visibility="public" file="System.Classes.pas" line="3186">
            <parameters>
              <parameter name="Count" type="Integer"/>
              <parameter name="NewPos" type="Integer"/>
              <parameter name="Destination" type="string" paramflags="var"/>
            </parameters>
          </procedure>
          <procedure name="TrimBuffer" visibility="public" file="System.Classes.pas" line="3187">
          </procedure>
          <property name="Chars[AIndex]" visibility="public" read="TBufferedData.GetChars" type="Char" file="System.Classes.pas" line="3188"/>
        </members>
      </class>
      <field name="FBufferSize" type="Integer" visibility="private" size="4" offset="4" file="System.Classes.pas" line="3192"/>
      <field name="FDetectBOM" type="Boolean" visibility="private" size="1" offset="8" file="System.Classes.pas" line="3193"/>
      <field name="FEncoding" type="TEncoding" visibility="private" size="4" offset="12" file="System.Classes.pas" line="3194"/>
      <field name="FOwnsStream" type="Boolean" visibility="private" size="1" offset="16" file="System.Classes.pas" line="3195"/>
      <field name="FSkipPreamble" type="Boolean" visibility="private" size="1" offset="17" file="System.Classes.pas" line="3196"/>
      <field name="FStream" type="TStream" visibility="private" size="4" offset="20" file="System.Classes.pas" line="3197"/>
      <function name="DetectBOM" visibility="private" file="System.Classes.pas" line="3198">
        <parameters>
          <parameter name="Encoding" type="TEncoding" paramflags="var"/>
          <parameter name="Buffer" type="TBytes"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetEndOfStream" visibility="private" file="System.Classes.pas" line="3199">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="SkipPreamble" visibility="private" file="System.Classes.pas" line="3200">
        <parameters>
          <parameter name="Encoding" type="TEncoding"/>
          <parameter name="Buffer" type="TBytes"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <field name="FBufferedData" type="TStreamReader.TBufferedData" visibility="protected" size="4" offset="24" file="System.Classes.pas" line="3202"/>
      <field name="FNoDataInStream" type="Boolean" visibility="protected" size="1" offset="28" file="System.Classes.pas" line="3203"/>
      <procedure name="FillBuffer" visibility="protected" file="System.Classes.pas" line="3204">
        <parameters>
          <parameter name="Encoding" type="TEncoding" paramflags="var"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3206">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3207">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="DetectBOM" type="Boolean"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3208">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="Encoding" type="TEncoding"/>
          <parameter name="DetectBOM" type="Boolean">
            <value>
              False
            </value>
          </parameter>
          <parameter name="BufferSize" type="Integer">
            <value>
              $1000
            </value>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3210">
        <parameters>
          <parameter name="Filename" type="string" paramflags="const"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3211">
        <parameters>
          <parameter name="Filename" type="string" paramflags="const"/>
          <parameter name="DetectBOM" type="Boolean"/>
        </parameters>
      </constructor>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3212">
        <parameters>
          <parameter name="Filename" type="string" paramflags="const"/>
          <parameter name="Encoding" type="TEncoding"/>
          <parameter name="DetectBOM" type="Boolean">
            <value>
              False
            </value>
          </parameter>
          <parameter name="BufferSize" type="Integer">
            <value>
              $1000
            </value>
          </parameter>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="System.Classes.pas" line="3214">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Close" visibility="public" procflags="override" file="System.Classes.pas" line="3215">
      </procedure>
      <procedure name="DiscardBufferedData" visibility="public" file="System.Classes.pas" line="3216">
      </procedure>
      <procedure name="OwnStream" visibility="public" procflags="inline" file="System.Classes.pas" line="3217">
      </procedure>
      <function name="Peek" visibility="public" procflags="override" file="System.Classes.pas" line="3218">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="Read" visibility="public" procflags="overload override" file="System.Classes.pas" line="3219">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="Read" visibility="public" procflags="overload override" file="System.Classes.pas" line="3220">
        <parameters>
          <parameter name="Buffer" type="TCharArray" paramflags="var"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="ReadBlock" visibility="public" procflags="override" file="System.Classes.pas" line="3221">
        <parameters>
          <parameter name="Buffer" type="TCharArray" paramflags="var"/>
          <parameter name="Index" type="Integer"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="ReadLine" visibility="public" procflags="override" file="System.Classes.pas" line="3222">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="ReadToEnd" visibility="public" procflags="override" file="System.Classes.pas" line="3223">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <procedure name="Rewind" visibility="public" procflags="override" file="System.Classes.pas" line="3224">
      </procedure>
      <property name="BaseStream" visibility="public" read="FStream" type="TStream" file="System.Classes.pas" line="3225"/>
      <property name="CurrentEncoding" visibility="public" read="FEncoding" type="TEncoding" file="System.Classes.pas" line="3226"/>
      <property name="EndOfStream" visibility="public" read="GetEndOfStream" type="Boolean" file="System.Classes.pas" line="3227"/>
    </members>
  </class>
  <class name="ELoginCredentialError" file="System.Classes.pas" line="3230">
    <ancestor name="Exception" namespace="System.SysUtils">
      <methodref name="Create@" visibility="class private" procflags="class constructor noself">
      </methodref>
      <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
      </methodref>
      <methodref name="SetInnerException" visibility="protected">
      </methodref>
      <methodref name="SetStackInfo" visibility="protected">
      </methodref>
      <methodref name="GetStackTrace" visibility="protected">
      </methodref>
      <methodref name="RaisingException" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmt" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="GetBaseException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="override">
      </methodref>
      <propertyref name="BaseException" visibility="public">
      </propertyref>
      <propertyref name="HelpContext" visibility="public">
      </propertyref>
      <propertyref name="InnerException" visibility="public">
      </propertyref>
      <propertyref name="Message" visibility="public">
      </propertyref>
      <propertyref name="StackTrace" visibility="public">
      </propertyref>
      <propertyref name="StackInfo" visibility="public">
      </propertyref>
      <methodref name="RaiseOuterException" visibility="public" procflags="static">
      </methodref>
      <methodref name="ThrowOuterException" visibility="public" procflags="static">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
  </class>
  <class name="TLoginCredentialService" sealed="true" file="System.Classes.pas" line="3232">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <const name="Default" visibility="public" type="string" file="System.Classes.pas" line="3234">
        <value>
          
        </value>
      </const>
      <const name="DefaultUsrPw" visibility="public" type="string" file="System.Classes.pas" line="3235">
        <value>
          DefaultUsrPw
        </value>
      </const>
      <const name="DefaultUsrPwDm" visibility="public" type="string" file="System.Classes.pas" line="3236">
        <value>
          DefaultUsrPwDm
        </value>
      </const>
      <anonMethod name="TLoginFunc" visibility="public" alias="System.Classes.TLoginFunc" file="System.Classes.pas" line="3238">
        <function name="Invoke" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="3238">
          <parameters>
            <parameter name="Username" type="string" paramflags="const"/>
            <parameter name="Password" type="string" paramflags="const"/>
            <parameter name="Domain" type="string" paramflags="const"/>
            <retval type="Boolean"/>
          </parameters>
        </function>
      </anonMethod>
      <type name="TLoginEvent" file="System.Classes.pas" line="3239" procflags="closure">
      </type>
      <type name="TLoginCredentialEvent" file="System.Classes.pas" line="3240" procflags="closure">
      </type>
      <class name="TLoginCredentialEventObject" visibility="class private" alias="System.Classes.TLoginCredentialEventObject" file="System.Classes.pas" line="3242">
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
        <members>
          <field name="Handler" type="TLoginCredentialService.TLoginCredentialEvent" visibility="public" size="8" offset="8" file="System.Classes.pas" line="3243"/>
          <constructor name="Create" visibility="public" file="System.Classes.pas" line="3244">
            <parameters>
              <parameter name="NewHandler" type="TLoginCredentialService.TLoginCredentialEvent" paramflags="const"/>
            </parameters>
          </constructor>
        </members>
      </class>
      <class name="TLoginFuncProxy" visibility="class private" alias="System.Classes.TLoginFuncProxy" file="System.Classes.pas" line="3246">
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
        <members>
          <field name="FLoginFunc" type="TLoginCredentialService.TLoginFunc" visibility="private" size="4" offset="4" file="System.Classes.pas" line="3248"/>
          <procedure name="LoginEvent" visibility="private" file="System.Classes.pas" line="3249">
            <parameters>
              <parameter name="Sender" type="TObject"/>
              <parameter name="Username" type="string" paramflags="const"/>
              <parameter name="Password" type="string" paramflags="const"/>
              <parameter name="Domain" type="string" paramflags="const"/>
              <parameter name="Handled" type="Boolean" paramflags="var"/>
            </parameters>
          </procedure>
          <constructor name="Create" visibility="public" file="System.Classes.pas" line="3251">
            <parameters>
              <parameter name="ALoginFunc" type="TLoginCredentialService.TLoginFunc" paramflags="const"/>
            </parameters>
          </constructor>
        </members>
      </class>
      <field name="FLoginHandlers" type="TStringList" visibility="class private" varflags="class" file="System.Classes.pas" line="3254"/>
      <procedure name="Create@" visibility="class private" procflags="class constructor noself" file="System.Classes.pas" line="3256">
      </procedure>
      <procedure name="Destroy@" visibility="class private" procflags="class destructor noself" file="System.Classes.pas" line="3257">
      </procedure>
      <function name="IndexOfHandler" visibility="class private" procflags="class" file="System.Classes.pas" line="3258">
        <parameters>
          <parameter name="Context" type="TLoginCredentialService.TLoginCredentialEvent" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="RegisterLoginHandler" visibility="public" procflags="static" file="System.Classes.pas" line="3260">
        <parameters>
          <parameter name="Context" type="string" paramflags="const"/>
          <parameter name="HandlerEvent" type="TLoginCredentialService.TLoginCredentialEvent" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="UnregisterLoginHandler" visibility="public" procflags="static" file="System.Classes.pas" line="3261">
        <parameters>
          <parameter name="Context" type="string" paramflags="const"/>
          <parameter name="HandlerEvent" type="TLoginCredentialService.TLoginCredentialEvent" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="GetLoginCredentialEvent" visibility="public" procflags="static" file="System.Classes.pas" line="3263">
        <parameters>
          <parameter name="Context" type="string" paramflags="const"/>
          <retval type="TLoginCredentialService.TLoginCredentialEvent"/>
        </parameters>
      </function>
      <function name="GetLoginCredentials" visibility="public" procflags="static overload" file="System.Classes.pas" line="3264">
        <parameters>
          <parameter name="Context" type="string" paramflags="const"/>
          <parameter name="Sender" type="TObject"/>
          <parameter name="Callback" type="TLoginCredentialService.TLoginEvent" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="GetLoginCredentials" visibility="public" procflags="static overload" file="System.Classes.pas" line="3265">
        <parameters>
          <parameter name="Context" type="string" paramflags="const"/>
          <parameter name="Callback" type="TLoginCredentialService.TLoginFunc" paramflags="const"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="GetLoginCredentials" visibility="public" procflags="static overload" file="System.Classes.pas" line="3266">
        <parameters>
          <parameter name="Context" type="string" paramflags="const"/>
          <parameter name="Username" type="string" paramflags="var"/>
          <parameter name="Password" type="string" paramflags="var"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="GetLoginCredentials" visibility="public" procflags="static overload" file="System.Classes.pas" line="3267">
        <parameters>
          <parameter name="Context" type="string" paramflags="const"/>
          <parameter name="Username" type="string" paramflags="var"/>
          <parameter name="Password" type="string" paramflags="var"/>
          <parameter name="Domain" type="string" paramflags="var"/>
          <retval type="Boolean"/>
        </parameters>
      </function>
    </members>
  </class>
  <anonMethod name="TPostFoundCycleProc" file="System.Classes.pas" line="3270">
    <procedure name="Invoke" visibility="public" procflags="abstract virtual" file="System.Classes.pas" line="3270">
      <parameters>
        <parameter name="ClassName" type="string" paramflags="const"/>
        <parameter name="Reference" type="NativeInt"/>
        <parameter name="Stack" type="TStack&lt;System.NativeInt&gt;" paramflags="const"/>
      </parameters>
    </procedure>
  </anonMethod>
  <const name="cnAdding" type="TCollectionNotification" file="System.Classes.pas" line="3294">
    <value>
      cnAdding
    </value>
  </const>
  <const name="cnAdded" type="TCollectionNotification" file="System.Classes.pas" line="3295">
    <value>
      cnAdded
    </value>
  </const>
  <const name="cnExtracting" type="TCollectionNotification" file="System.Classes.pas" line="3296">
    <value>
      cnExtracting
    </value>
  </const>
  <const name="cnExtracted" type="TCollectionNotification" file="System.Classes.pas" line="3297">
    <value>
      cnExtracted
    </value>
  </const>
  <const name="cnDeleting" type="TCollectionNotification" file="System.Classes.pas" line="3298">
    <value>
      cnDeleting
    </value>
  </const>
  <const name="cnRemoved" type="TCollectionNotification" file="System.Classes.pas" line="3299">
    <value>
      cnRemoved
    </value>
  </const>
  <class name="TProxySubrangeStream" file="System.Classes.pas" line="3306">
    <devnotes>
       <summary> Helper class for reading/writing a segment of another stream.
        For example, it is used by TZipFile to provide access to a &quot;stored&quot; file. </summary>
    </devnotes>
    <ancestor name="TStream" namespace="System.Classes">
      <methodref name="GetPosition" visibility="private"/>
      <methodref name="SetPosition" visibility="private"/>
      <methodref name="SetSize64" visibility="private"/>
      <methodref name="Skip" visibility="private"/>
      <methodref name="GetSize" visibility="protected" procflags="virtual"/>
      <methodref name="SetSize" visibility="protected" procflags="overload virtual" symflags="deprecated">
      </methodref>
      <methodref name="SetSize" visibility="protected" procflags="overload virtual"/>
      <methodref name="GetByteCount" visibility="protected"/>
      <methodref name="GetByteCount64" visibility="protected"/>
      <methodref name="Read" visibility="public" procflags="overload virtual"/>
      <methodref name="Write" visibility="public" procflags="overload virtual"/>
      <methodref name="Read" visibility="public" procflags="overload virtual"/>
      <methodref name="Write" visibility="public" procflags="overload virtual"/>
      <methodref name="Read" visibility="public" procflags="overload"/>
      <methodref name="Write" visibility="public" procflags="overload"/>
      <methodref name="Read64" visibility="public" procflags="virtual"/>
      <methodref name="Write64" visibility="public" procflags="virtual"/>
      <methodref name="ReadData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="ReadData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="WriteData" visibility="public" procflags="overload"/>
      <methodref name="Seek32" visibility="public" procflags="overload inline"/>
      <methodref name="Seek" visibility="public" procflags="overload virtual"/>
      <methodref name="Seek" visibility="public" procflags="overload virtual"/>
      <methodref name="Seek" visibility="public" procflags="overload inline"/>
      <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
      <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
      <methodref name="ReadBuffer" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload">
      </methodref>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="ReadBufferData" visibility="public" procflags="overload"/>
      <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
      <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
      <methodref name="WriteBuffer" visibility="public" procflags="overload"/>
      <methodref name="WriteBufferData" visibility="public" procflags="overload"/>
      <methodref name="CopyFrom" visibility="public"/>
      <methodref name="ReadComponent" visibility="public"/>
      <methodref name="ReadComponentRes" visibility="public"/>
      <methodref name="WriteComponent" visibility="public"/>
      <methodref name="WriteComponentRes" visibility="public"/>
      <methodref name="WriteDescendent" visibility="public"/>
      <methodref name="WriteDescendentRes" visibility="public"/>
      <methodref name="WriteResourceHeader" visibility="public"/>
      <methodref name="FixupResourceHeader" visibility="public"/>
      <methodref name="ReadResHeader" visibility="public"/>
      <propertyref name="Position" visibility="public"/>
      <propertyref name="Size" visibility="public"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FStream" type="TStream" visibility="private" size="4" offset="4" file="System.Classes.pas" line="3308"/>
      <field name="FOffset" type="Int64" visibility="private" size="8" offset="8" file="System.Classes.pas" line="3309"/>
      <field name="FSize" type="Int64" visibility="private" size="8" offset="16" file="System.Classes.pas" line="3310"/>
      <function name="GetSize" visibility="protected" procflags="override" file="System.Classes.pas" line="3312">
        <parameters>
          <retval type="Int64"/>
        </parameters>
      </function>
      <constructor name="Create" visibility="public" file="System.Classes.pas" line="3314">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="Offset" type="Int64"/>
          <parameter name="Size" type="Int64"/>
        </parameters>
      </constructor>
      <function name="Read" visibility="public" procflags="overload override" file="System.Classes.pas" line="3315">
        <parameters>
          <parameter name="Buffer" paramflags="var"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="Write" visibility="public" procflags="overload override" file="System.Classes.pas" line="3316">
        <parameters>
          <parameter name="Buffer" paramflags="const"/>
          <parameter name="Count" type="Integer"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="Seek" visibility="public" procflags="overload override" file="System.Classes.pas" line="3317">
        <parameters>
          <parameter name="Offset" type="Int64" paramflags="const"/>
          <parameter name="Origin" type="TSeekOrigin"/>
          <retval type="Int64"/>
        </parameters>
      </function>
    </members>
  </class>
  <function name="Point" visibility="public" procflags="inline" file="System.Classes.pas" line="3354">
    <parameters>
      <parameter name="AX" type="Integer"/>
      <parameter name="AY" type="Integer"/>
      <retval type="TPoint"/>
    </parameters>
  </function>
  <function name="SmallPoint" visibility="public" procflags="inline" file="System.Classes.pas" line="3360">
    <parameters>
      <parameter name="AX" type="SmallInt"/>
      <parameter name="AY" type="SmallInt"/>
      <retval type="TSmallPoint"/>
    </parameters>
  </function>
  <function name="PointsEqual" visibility="public" procflags="overload" file="System.Classes.pas" line="3366">
    <parameters>
      <parameter name="P1" type="TPoint" paramflags="const"/>
      <parameter name="P2" type="TPoint" paramflags="const"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="PointsEqual" visibility="public" procflags="overload" file="System.Classes.pas" line="3371">
    <parameters>
      <parameter name="P1" type="TSmallPoint" paramflags="const"/>
      <parameter name="P2" type="TSmallPoint" paramflags="const"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="Rect" visibility="public" procflags="overload" file="System.Classes.pas" line="3376">
    <parameters>
      <parameter name="ALeft" type="Integer"/>
      <parameter name="ATop" type="Integer"/>
      <parameter name="ARight" type="Integer"/>
      <parameter name="ABottom" type="Integer"/>
      <retval type="TRect"/>
    </parameters>
  </function>
  <function name="Rect" visibility="public" procflags="overload" file="System.Classes.pas" line="3384">
    <parameters>
      <parameter name="ATopLeft" type="TPoint" paramflags="const"/>
      <parameter name="ABottomRight" type="TPoint" paramflags="const"/>
      <retval type="TRect"/>
    </parameters>
  </function>
  <function name="Bounds" visibility="public" file="System.Classes.pas" line="3392">
    <parameters>
      <parameter name="ALeft" type="Integer"/>
      <parameter name="ATop" type="Integer"/>
      <parameter name="AWidth" type="Integer"/>
      <parameter name="AHeight" type="Integer"/>
      <retval type="TRect"/>
    </parameters>
  </function>
  <function name="InvalidPoint" visibility="public" procflags="overload" file="System.Classes.pas" line="3397">
    <parameters>
      <parameter name="X" type="Integer"/>
      <parameter name="Y" type="Integer"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="InvalidPoint" visibility="public" procflags="overload" file="System.Classes.pas" line="3402">
    <parameters>
      <parameter name="At" type="TPoint" paramflags="const"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="InvalidPoint" visibility="public" procflags="overload" file="System.Classes.pas" line="3407">
    <parameters>
      <parameter name="At" type="TSmallPoint" paramflags="const"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="GetClass" visibility="public" file="System.Classes.pas" line="4062">
    <parameters>
      <parameter name="AClassName" type="string" paramflags="const"/>
      <retval type="TPersistentClass"/>
    </parameters>
  </function>
  <function name="FindClass" visibility="public" file="System.Classes.pas" line="4072">
    <parameters>
      <parameter name="ClassName" type="string" paramflags="const"/>
      <retval type="TPersistentClass"/>
    </parameters>
  </function>
  <procedure name="RegisterClass" visibility="public" file="System.Classes.pas" line="4078">
    <parameters>
      <parameter name="AClass" type="TPersistentClass"/>
    </parameters>
  </procedure>
  <procedure name="RegisterClasses" visibility="public" file="System.Classes.pas" line="4093">
    <parameters>
      <parameter name="AClasses" paramflags="const">
        <array name="AClasses" file="System.Classes.pas" line="4093">
          <element type="TPersistentClass"/>
        </array>
      </parameter>
    </parameters>
  </procedure>
  <procedure name="RegisterClassAlias" visibility="public" file="System.Classes.pas" line="4100">
    <parameters>
      <parameter name="AClass" type="TPersistentClass"/>
      <parameter name="Alias" type="string" paramflags="const"/>
    </parameters>
  </procedure>
  <procedure name="UnRegisterClass" visibility="public" file="System.Classes.pas" line="4110">
    <parameters>
      <parameter name="AClass" type="TPersistentClass"/>
    </parameters>
  </procedure>
  <procedure name="UnRegisterClasses" visibility="public" file="System.Classes.pas" line="4120">
    <parameters>
      <parameter name="AClasses" paramflags="const">
        <array name="AClasses" file="System.Classes.pas" line="4120">
          <element type="TPersistentClass"/>
        </array>
      </parameter>
    </parameters>
  </procedure>
  <procedure name="UnRegisterModuleClasses" visibility="public" file="System.Classes.pas" line="4127">
    <parameters>
      <parameter name="Module" type="NativeUInt"/>
    </parameters>
  </procedure>
  <procedure name="StartClassGroup" visibility="public" file="System.Classes.pas" line="4137">
    <parameters>
      <parameter name="AClass" type="TPersistentClass"/>
    </parameters>
  </procedure>
  <procedure name="GroupDescendentsWith" visibility="public" file="System.Classes.pas" line="4147">
    <parameters>
      <parameter name="AClass" type="TPersistentClass"/>
      <parameter name="AClassGroup" type="TPersistentClass"/>
    </parameters>
  </procedure>
  <function name="ActivateClassGroup" visibility="public" file="System.Classes.pas" line="4157">
    <parameters>
      <parameter name="AClass" type="TPersistentClass"/>
      <retval type="TPersistentClass"/>
    </parameters>
  </function>
  <function name="ActiveClassGroup" visibility="public" file="System.Classes.pas" line="4168">
    <parameters>
      <retval type="TPersistentClass"/>
    </parameters>
  </function>
  <function name="ClassGroupOf" visibility="public" procflags="overload" file="System.Classes.pas" line="4178">
    <parameters>
      <parameter name="AClass" type="TPersistentClass"/>
      <retval type="TPersistentClass"/>
    </parameters>
  </function>
  <function name="ClassGroupOf" visibility="public" procflags="overload" file="System.Classes.pas" line="4188">
    <parameters>
      <parameter name="Instance" type="TPersistent"/>
      <retval type="TPersistentClass"/>
    </parameters>
  </function>
  <procedure name="ReportClassGroups" visibility="public" file="System.Classes.pas" line="4206">
    <parameters>
      <parameter name="Report" type="TStrings"/>
    </parameters>
  </procedure>
  <procedure name="RegisterComponents" visibility="public" file="System.Classes.pas" line="4245">
    <parameters>
      <parameter name="Page" type="string" paramflags="const"/>
      <parameter name="ComponentClasses">
        <array name="ComponentClasses" file="System.Classes.pas" line="4245">
          <element type="TComponentClass"/>
        </array>
      </parameter>
    </parameters>
  </procedure>
  <procedure name="RegisterNoIcon" visibility="public" file="System.Classes.pas" line="4254">
    <parameters>
      <parameter name="ComponentClasses" paramflags="const">
        <array name="ComponentClasses" file="System.Classes.pas" line="4254">
          <element type="TComponentClass"/>
        </array>
      </parameter>
    </parameters>
  </procedure>
  <procedure name="RegisterNonActiveX" visibility="public" file="System.Classes.pas" line="4264">
    <parameters>
      <parameter name="ComponentClasses" paramflags="const">
        <array name="ComponentClasses" file="System.Classes.pas" line="4263">
          <element type="TComponentClass"/>
        </array>
      </parameter>
      <parameter name="AxRegType" type="TActiveXRegType"/>
    </parameters>
  </procedure>
  <procedure name="RegisterIntegerConsts" visibility="public" file="System.Classes.pas" line="4295">
    <parameters>
      <parameter name="AIntegerType" type="Pointer"/>
      <parameter name="AIdentToInt" type="TIdentToInt"/>
      <parameter name="AIntToIdent" type="TIntToIdent"/>
    </parameters>
  </procedure>
  <procedure name="UnregisterIntegerConsts" visibility="public" file="System.Classes.pas" line="4301">
    <parameters>
      <parameter name="AIntegerType" type="Pointer"/>
      <parameter name="AIdentToInt" type="TIdentToInt"/>
      <parameter name="AIntToIdent" type="TIntToIdent"/>
    </parameters>
  </procedure>
  <function name="FindIntToIdent" visibility="public" file="System.Classes.pas" line="4325">
    <parameters>
      <parameter name="AIntegerType" type="Pointer"/>
      <retval type="TIntToIdent"/>
    </parameters>
  </function>
  <function name="FindIdentToInt" visibility="public" file="System.Classes.pas" line="4348">
    <parameters>
      <parameter name="AIntegerType" type="Pointer"/>
      <retval type="TIdentToInt"/>
    </parameters>
  </function>
  <function name="IdentToInt" visibility="public" file="System.Classes.pas" line="4373">
    <parameters>
      <parameter name="Ident" type="string" paramflags="const"/>
      <parameter name="Int" type="Integer" paramflags="var"/>
      <parameter name="Map" paramflags="const">
        <array name="Map" file="System.Classes.pas" line="4373">
          <element type="TIdentMapEntry"/>
        </array>
      </parameter>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="IntToIdent" visibility="public" file="System.Classes.pas" line="4387">
    <parameters>
      <parameter name="Int" type="Integer"/>
      <parameter name="Ident" type="string" paramflags="var"/>
      <parameter name="Map" paramflags="const">
        <array name="Map" file="System.Classes.pas" line="4387">
          <element type="TIdentMapEntry"/>
        </array>
      </parameter>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <procedure name="RegisterFindGlobalComponentProc" visibility="public" file="System.Classes.pas" line="4404">
    <parameters>
      <parameter name="AFindGlobalComponent" type="TFindGlobalComponent"/>
    </parameters>
  </procedure>
  <procedure name="UnregisterFindGlobalComponentProc" visibility="public" file="System.Classes.pas" line="4412">
    <parameters>
      <parameter name="AFindGlobalComponent" type="TFindGlobalComponent"/>
    </parameters>
  </procedure>
  <function name="FindGlobalComponent" visibility="public" file="System.Classes.pas" line="4418">
    <parameters>
      <parameter name="Name" type="string" paramflags="const"/>
      <retval type="TComponent"/>
    </parameters>
  </function>
  <function name="IsUniqueGlobalComponentName" visibility="public" file="System.Classes.pas" line="4433">
    <parameters>
      <parameter name="Name" type="string" paramflags="const"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="GetComponentFieldAddress" visibility="public" file="System.Classes.pas" line="4661">
    <parameters>
      <parameter name="Instance" type="TComponent" paramflags="const"/>
      <parameter name="Name" type="string" paramflags="const"/>
      <retval type="Pointer"/>
    </parameters>
  </function>
  <procedure name="SetComponentFieldAddressCache" visibility="public" file="System.Classes.pas" line="4666">
    <parameters>
      <parameter name="Clear" type="Boolean"/>
      <parameter name="MaxClassesInCache" type="Integer"/>
    </parameters>
  </procedure>
  <procedure name="BeginGlobalLoading" visibility="public" file="System.Classes.pas" line="4678">
  </procedure>
  <procedure name="NotifyGlobalLoading" visibility="public" file="System.Classes.pas" line="4693">
  </procedure>
  <procedure name="EndGlobalLoading" visibility="public" file="System.Classes.pas" line="4703">
  </procedure>
  <function name="InitInheritedComponent" visibility="public" file="System.Classes.pas" line="4719">
    <parameters>
      <parameter name="Instance" type="TComponent"/>
      <parameter name="RootAncestor" type="TClass"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="ReadComponentDeltaRes" visibility="public" file="System.Classes.pas" line="4749">
    <parameters>
      <parameter name="Instance" type="TComponent"/>
      <parameter name="DeltaCandidates" paramflags="const">
        <array name="DeltaCandidates" file="System.Classes.pas" line="4749">
          <element type="string"/>
        </array>
      </parameter>
      <parameter name="Proc" type="TGetStreamProc" paramflags="const"/>
      <retval type="TComponent"/>
    </parameters>
  </function>
  <function name="InitComponentRes" visibility="public" file="System.Classes.pas" line="4778">
    <parameters>
      <parameter name="ResName" type="string" paramflags="const"/>
      <parameter name="Instance" type="TComponent"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="ReadComponentRes" visibility="public" file="System.Classes.pas" line="4784">
    <parameters>
      <parameter name="ResName" type="string" paramflags="const"/>
      <parameter name="Instance" type="TComponent"/>
      <retval type="TComponent"/>
    </parameters>
  </function>
  <function name="ReadComponentResEx" visibility="public" file="System.Classes.pas" line="4796">
    <parameters>
      <parameter name="HInstance" type="NativeUInt"/>
      <parameter name="ResName" type="string" paramflags="const"/>
      <retval type="TComponent"/>
    </parameters>
  </function>
  <function name="ReadComponentResFile" visibility="public" file="System.Classes.pas" line="4806">
    <parameters>
      <parameter name="FileName" type="string" paramflags="const"/>
      <parameter name="Instance" type="TComponent" paramflags="const"/>
      <retval type="TComponent"/>
    </parameters>
  </function>
  <procedure name="WriteComponentResFile" visibility="public" file="System.Classes.pas" line="4818">
    <parameters>
      <parameter name="FileName" type="string" paramflags="const"/>
      <parameter name="Instance" type="TComponent" paramflags="const"/>
    </parameters>
  </procedure>
  <function name="CollectionsEqual" visibility="public" file="System.Classes.pas" line="4830">
    <parameters>
      <parameter name="C1" type="TCollection" paramflags="const"/>
      <parameter name="C2" type="TCollection" paramflags="const"/>
      <parameter name="Owner1" type="TComponent" paramflags="const"/>
      <parameter name="Owner2" type="TComponent" paramflags="const"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="LineStart" visibility="public" procflags="overload" file="System.Classes.pas" line="4868">
    <devnotes>
      NEXTGEN
    </devnotes>
    <parameters>
      <parameter name="Buffer" type="TBytes" paramflags="const"/>
      <parameter name="BufPos" type="NativeInt"/>
      <retval type="NativeInt"/>
    </parameters>
  </function>
  <function name="LineStart" visibility="public" procflags="overload" file="System.Classes.pas" line="4880">
    <parameters>
      <parameter name="Buffer" type="PAnsiChar"/>
      <parameter name="BufPos" type="PAnsiChar"/>
      <retval type="PAnsiChar"/>
    </parameters>
  </function>
  <function name="LineStart" visibility="public" procflags="overload" file="System.Classes.pas" line="4915">
    <devnotes>
      NEXTGEN
    </devnotes>
    <parameters>
      <parameter name="Buffer" type="PWideChar"/>
      <parameter name="BufPos" type="PWideChar"/>
      <retval type="PWideChar"/>
    </parameters>
  </function>
  <function name="ExtractStrings" visibility="public" file="System.Classes.pas" line="4952">
    <parameters>
      <parameter name="Separators" type="TSysCharSet"/>
      <parameter name="WhiteSpace" type="TSysCharSet"/>
      <parameter name="Content" type="PWideChar"/>
      <parameter name="Strings" type="TStrings"/>
      <retval type="Integer"/>
    </parameters>
  </function>
  <function name="FindRootDesigner" visibility="public" file="System.Classes.pas" line="6095">
    <parameters>
      <parameter name="Obj" type="TPersistent"/>
      <retval type="IDesignerNotify"/>
    </parameters>
  </function>
  <function name="CountGenerations" visibility="public" file="System.Classes.pas" line="6107">
    <parameters>
      <parameter name="Ancestor" type="TClass"/>
      <parameter name="Descendent" type="TClass"/>
      <retval type="Integer"/>
    </parameters>
  </function>
  <function name="GetUltimateOwner" visibility="public" procflags="overload" file="System.Classes.pas" line="6546">
    <parameters>
      <parameter name="ACollectionItem" type="TCollectionItem" paramflags="const"/>
      <retval type="TPersistent"/>
    </parameters>
  </function>
  <function name="GetUltimateOwner" visibility="public" procflags="overload" file="System.Classes.pas" line="6553">
    <parameters>
      <parameter name="ACollection" type="TCollection" paramflags="const"/>
      <retval type="TPersistent"/>
    </parameters>
  </function>
  <function name="GetUltimateOwner" visibility="public" procflags="overload" file="System.Classes.pas" line="6560">
    <parameters>
      <parameter name="APersistent" type="TPersistent" paramflags="const"/>
      <retval type="TPersistent"/>
    </parameters>
  </function>
  <function name="FindNestedComponent" visibility="public" file="System.Classes.pas" line="10280">
    <parameters>
      <parameter name="Root" type="TComponent" paramflags="const"/>
      <parameter name="NamePath" type="string" paramflags="const"/>
      <retval type="TComponent"/>
    </parameters>
  </function>
  <procedure name="GlobalFixupReferences" visibility="public" file="System.Classes.pas" line="10307">
  </procedure>
  <procedure name="GetFixupReferenceNames" visibility="public" file="System.Classes.pas" line="10423">
    <parameters>
      <parameter name="Root" type="TComponent" paramflags="const"/>
      <parameter name="Names" type="TStrings" paramflags="const"/>
    </parameters>
  </procedure>
  <procedure name="RedirectFixupReferences" visibility="public" file="System.Classes.pas" line="10444">
    <parameters>
      <parameter name="Root" type="TComponent" paramflags="const"/>
      <parameter name="OldRootName" type="string" paramflags="const"/>
      <parameter name="NewRootName" type="string" paramflags="const"/>
    </parameters>
  </procedure>
  <procedure name="RemoveFixupReferences" visibility="public" file="System.Classes.pas" line="10465">
    <parameters>
      <parameter name="Root" type="TComponent" paramflags="const"/>
      <parameter name="RootName" type="string" paramflags="const"/>
    </parameters>
  </procedure>
  <procedure name="RemoveFixups" visibility="public" file="System.Classes.pas" line="10489">
    <parameters>
      <parameter name="Instance" type="TPersistent" paramflags="const"/>
    </parameters>
  </procedure>
  <procedure name="GetFixupInstanceNames" visibility="public" file="System.Classes.pas" line="10512">
    <parameters>
      <parameter name="Root" type="TComponent" paramflags="const"/>
      <parameter name="ReferenceRootName" type="string" paramflags="const"/>
      <parameter name="Names" type="TStrings"/>
    </parameters>
  </procedure>
  <function name="AncestorIsValid" visibility="public" file="System.Classes.pas" line="13119">
    <parameters>
      <parameter name="Ancestor" type="TPersistent" paramflags="const"/>
      <parameter name="Root" type="TComponent" paramflags="const"/>
      <parameter name="RootAncestor" type="TComponent" paramflags="const"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="IsDefaultPropertyValue" visibility="public" file="System.Classes.pas" line="13127">
    <parameters>
      <parameter name="Instance" type="TObject" paramflags="const"/>
      <parameter name="PropInfo" type="PPropInfo"/>
      <parameter name="OnGetLookupInfo" type="TGetLookupInfoEvent"/>
      <parameter name="Writer" type="TWriter">
        <value>
          nil
        </value>
      </parameter>
      <parameter name="OnFindMethodName" type="TFindMethodNameEvent">
        <value>
          nil
        </value>
      </parameter>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <procedure name="BinToHex" visibility="public" procflags="overload" file="System.Classes.pas" line="13947">
    <devnotes>
      NEXTGEN
    </devnotes>
    <parameters>
      <parameter name="Buffer" type="TBytes" paramflags="const"/>
      <parameter name="BufOffset" type="Integer"/>
      <parameter name="Text" type="TBytes" paramflags="var"/>
      <parameter name="TextOffset" type="Integer"/>
      <parameter name="Count" type="Integer"/>
    </parameters>
  </procedure>
  <function name="HexToBin" visibility="public" procflags="overload" file="System.Classes.pas" line="13959">
    <devnotes>
      NEXTGEN
    </devnotes>
    <parameters>
      <parameter name="Text" type="PWideChar" paramflags="const"/>
      <parameter name="TextOffset" type="Integer"/>
      <parameter name="Buffer" type="TBytes" paramflags="var"/>
      <parameter name="BufOffset" type="Integer"/>
      <parameter name="Count" type="Integer"/>
      <retval type="Integer"/>
    </parameters>
  </function>
  <function name="HexToBin" visibility="public" procflags="overload" file="System.Classes.pas" line="13986">
    <parameters>
      <parameter name="Text" type="TBytes" paramflags="const"/>
      <parameter name="TextOffset" type="Integer"/>
      <parameter name="Buffer" type="TBytes" paramflags="var"/>
      <parameter name="BufOffset" type="Integer"/>
      <parameter name="Count" type="Integer"/>
      <retval type="Integer"/>
    </parameters>
  </function>
  <procedure name="BinToHex" visibility="public" procflags="overload" file="System.Classes.pas" line="14010">
    <parameters>
      <parameter name="Buffer" type="Pointer"/>
      <parameter name="Text" type="PWideChar"/>
      <parameter name="BufSize" type="Integer"/>
    </parameters>
  </procedure>
  <procedure name="BinToHex" visibility="public" procflags="overload inline" file="System.Classes.pas" line="14022">
    <parameters>
      <parameter name="Buffer" paramflags="const"/>
      <parameter name="Text" type="PWideChar"/>
      <parameter name="BufSize" type="Integer"/>
    </parameters>
  </procedure>
  <function name="HexToBin" visibility="public" procflags="overload" file="System.Classes.pas" line="14027">
    <parameters>
      <parameter name="Text" type="PWideChar"/>
      <parameter name="Buffer" type="Pointer"/>
      <parameter name="BufSize" type="Integer"/>
      <retval type="Integer"/>
    </parameters>
  </function>
  <function name="HexToBin" visibility="public" procflags="overload inline" file="System.Classes.pas" line="14049">
    <parameters>
      <parameter name="Text" type="PWideChar" paramflags="const"/>
      <parameter name="Buffer" paramflags="var"/>
      <parameter name="BufSize" type="Integer"/>
      <retval type="Integer"/>
    </parameters>
  </function>
  <procedure name="BinToHex" visibility="public" procflags="overload" file="System.Classes.pas" line="14055">
    <parameters>
      <parameter name="Buffer" type="PAnsiChar"/>
      <parameter name="Text" type="PAnsiChar"/>
      <parameter name="BufSize" type="Integer"/>
    </parameters>
  </procedure>
  <procedure name="BinToHex" visibility="public" procflags="overload inline" file="System.Classes.pas" line="14067">
    <parameters>
      <parameter name="Buffer" type="PAnsiChar"/>
      <parameter name="Text" type="PWideChar"/>
      <parameter name="BufSize" type="Integer"/>
    </parameters>
  </procedure>
  <procedure name="BinToHex" visibility="public" procflags="overload inline" file="System.Classes.pas" line="14072">
    <parameters>
      <parameter name="Buffer" paramflags="const"/>
      <parameter name="Text" type="PAnsiChar"/>
      <parameter name="BufSize" type="Integer"/>
    </parameters>
  </procedure>
  <procedure name="BinToHex" visibility="public" procflags="overload inline" file="System.Classes.pas" line="14077">
    <parameters>
      <parameter name="Buffer" type="Pointer"/>
      <parameter name="Text" type="PAnsiChar"/>
      <parameter name="BufSize" type="Integer"/>
    </parameters>
  </procedure>
  <function name="HexToBin" visibility="public" procflags="overload" file="System.Classes.pas" line="14082">
    <parameters>
      <parameter name="Text" type="PAnsiChar"/>
      <parameter name="Buffer" type="PAnsiChar"/>
      <parameter name="BufSize" type="Integer"/>
      <retval type="Integer"/>
    </parameters>
  </function>
  <function name="HexToBin" visibility="public" procflags="overload inline" file="System.Classes.pas" line="14102">
    <parameters>
      <parameter name="Text" type="PWideChar"/>
      <parameter name="Buffer" type="PAnsiChar"/>
      <parameter name="BufSize" type="Integer"/>
      <retval type="Integer"/>
    </parameters>
  </function>
  <function name="HexToBin" visibility="public" procflags="overload inline" file="System.Classes.pas" line="14107">
    <parameters>
      <parameter name="Text" type="PAnsiChar"/>
      <parameter name="Buffer" paramflags="var"/>
      <parameter name="BufSize" type="Integer"/>
      <retval type="Integer"/>
    </parameters>
  </function>
  <function name="HexToBin" visibility="public" procflags="overload inline" file="System.Classes.pas" line="14112">
    <parameters>
      <parameter name="Text" type="PAnsiChar" paramflags="const"/>
      <parameter name="Buffer" type="Pointer"/>
      <parameter name="BufSize" type="Integer"/>
      <retval type="Integer"/>
    </parameters>
  </function>
  <function name="SwapHexEndianness" visibility="public" file="System.Classes.pas" line="14118">
    <devnotes>
      NEXTGEN
    </devnotes>
    <parameters>
      <parameter name="Text" type="string" paramflags="const"/>
      <retval type="string"/>
    </parameters>
  </function>
  <procedure name="ObjectBinaryToText" visibility="public" procflags="overload" file="System.Classes.pas" line="14653">
    <parameters>
      <parameter name="Input" type="TStream" paramflags="const"/>
      <parameter name="Output" type="TStream" paramflags="const"/>
    </parameters>
  </procedure>
  <procedure name="ObjectBinaryToText" visibility="public" procflags="overload" file="System.Classes.pas" line="15137">
    <parameters>
      <parameter name="Input" type="TStream" paramflags="const"/>
      <parameter name="Output" type="TStream" paramflags="const"/>
      <parameter name="OriginalFormat" type="TStreamOriginalFormat" paramflags="var"/>
    </parameters>
  </procedure>
  <procedure name="ObjectTextToBinary" visibility="public" procflags="overload" file="System.Classes.pas" line="15144">
    <parameters>
      <parameter name="Input" type="TStream" paramflags="const"/>
      <parameter name="Output" type="TStream" paramflags="const"/>
    </parameters>
  </procedure>
  <procedure name="ObjectTextToBinary" visibility="public" procflags="overload" file="System.Classes.pas" line="15357">
    <parameters>
      <parameter name="Input" type="TStream" paramflags="const"/>
      <parameter name="Output" type="TStream" paramflags="const"/>
      <parameter name="OriginalFormat" type="TStreamOriginalFormat" paramflags="var"/>
    </parameters>
  </procedure>
  <procedure name="ObjectResourceToText" visibility="public" procflags="overload" file="System.Classes.pas" line="15371">
    <parameters>
      <parameter name="Input" type="TStream" paramflags="const"/>
      <parameter name="Output" type="TStream" paramflags="const"/>
    </parameters>
  </procedure>
  <procedure name="ObjectResourceToText" visibility="public" procflags="overload" file="System.Classes.pas" line="15377">
    <parameters>
      <parameter name="Input" type="TStream" paramflags="const"/>
      <parameter name="Output" type="TStream" paramflags="const"/>
      <parameter name="OriginalFormat" type="TStreamOriginalFormat" paramflags="var"/>
    </parameters>
  </procedure>
  <procedure name="ObjectTextToResource" visibility="public" procflags="overload" file="System.Classes.pas" line="15384">
    <parameters>
      <parameter name="Input" type="TStream" paramflags="const"/>
      <parameter name="Output" type="TStream" paramflags="const"/>
      <parameter name="Name" type="string" paramflags="const">
        <value>
          
        </value>
      </parameter>
    </parameters>
  </procedure>
  <procedure name="ObjectTextToResource" visibility="public" procflags="overload" file="System.Classes.pas" line="15401">
    <parameters>
      <parameter name="Input" type="TStream" paramflags="const"/>
      <parameter name="Output" type="TStream" paramflags="const"/>
      <parameter name="OriginalFormat" type="TStreamOriginalFormat" paramflags="var"/>
      <parameter name="Name" type="string" paramflags="const">
        <value>
          
        </value>
      </parameter>
    </parameters>
  </procedure>
  <function name="TestStreamFormat" visibility="public" file="System.Classes.pas" line="15406">
    <parameters>
      <parameter name="Stream" type="TStream" paramflags="const"/>
      <retval type="TStreamOriginalFormat"/>
    </parameters>
  </function>
  <function name="GetResourceName" visibility="public" file="System.Classes.pas" line="15426">
    <parameters>
      <parameter name="ObjStream" type="TStream" paramflags="const"/>
      <parameter name="AName" type="string" paramflags="var"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <procedure name="WriteObjectResourceHeader" visibility="public" file="System.Classes.pas" line="15472">
    <parameters>
      <parameter name="ObjStream" type="TStream" paramflags="const"/>
      <parameter name="Output" type="TStream" paramflags="const"/>
      <parameter name="Name" type="string" paramflags="const">
        <value>
          
        </value>
      </parameter>
    </parameters>
  </procedure>
  <procedure name="Write16bitResourceHeader" visibility="public" file="System.Classes.pas" line="15507">
    <parameters>
      <parameter name="AName" type="TBytes" paramflags="const"/>
      <parameter name="DataSize" type="Integer"/>
      <parameter name="Output" type="TStream" paramflags="const"/>
    </parameters>
  </procedure>
  <procedure name="Write32bitResourceHeader" visibility="public" file="System.Classes.pas" line="15530">
    <parameters>
      <parameter name="AName" type="TBytes" paramflags="const"/>
      <parameter name="DataSize" type="Integer"/>
      <parameter name="Output" type="TStream" paramflags="const"/>
    </parameters>
  </procedure>
  <function name="CheckSynchronize" visibility="public" file="System.Classes.pas" line="15727">
    <parameters>
      <parameter name="Timeout" type="Integer">
        <value>
          $0
        </value>
      </parameter>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="MakeObjectInstance" visibility="public" file="System.Classes.pas" line="18519">
    <parameters>
      <parameter name="AMethod" type="TWndMethod" paramflags="const"/>
      <retval type="Pointer"/>
    </parameters>
  </function>
  <procedure name="FreeObjectInstance" visibility="public" file="System.Classes.pas" line="18562">
    <parameters>
      <parameter name="ObjectInstance" type="Pointer"/>
    </parameters>
  </procedure>
  <function name="AllocateHWnd" visibility="public" file="System.Classes.pas" line="18661">
    <parameters>
      <parameter name="AMethod" type="TWndMethod" paramflags="const"/>
      <retval type="HWND"/>
    </parameters>
  </function>
  <procedure name="DeallocateHWnd" visibility="public" file="System.Classes.pas" line="18681">
    <parameters>
      <parameter name="Wnd" type="HWND"/>
    </parameters>
  </procedure>
  <procedure name="CheckForCycles" visibility="public" procflags="overload" file="System.Classes.pas" line="21090">
    <parameters>
      <parameter name="Obj" type="TObject" paramflags="const"/>
      <parameter name="PostFoundCycle" type="TPostFoundCycleProc" paramflags="const"/>
    </parameters>
  </procedure>
  <procedure name="CheckForCycles" visibility="public" procflags="overload" file="System.Classes.pas" line="21276">
    <parameters>
      <parameter name="Intf" type="IInterface" paramflags="const"/>
      <parameter name="PostFoundCycle" type="TPostFoundCycleProc" paramflags="const"/>
    </parameters>
  </procedure>
</namespace>