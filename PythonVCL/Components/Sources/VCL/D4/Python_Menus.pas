////
//  This file was generated by VCL Generator
//  Copyright 1998 - Morgan Martinet
//  06/07/1999 07:58:59
//  it declares the content of the module _Menus
////

unit Python_Menus;

interface

uses
   Windows,
   Graphics,
   ImgList,
   ActnList,
   Menus,
   Messages,
   Classes,
   SysUtils,
   PythonEngine;

type
  TModule_Menus = class( TPythonModule )
  public
    procedure Initialize; override;
  end;

  function TMenuActionLink_ReadAttribute( Self : TMenuActionLink; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TMenuActionLink_WriteAttribute( Self : TMenuActionLink; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TMenuItem_ReadAttribute( Self : TMenuItem; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TMenuItem_WriteAttribute( Self : TMenuItem; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TMenu_ReadAttribute( Self : TMenu; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TMenu_WriteAttribute( Self : TMenu; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TMainMenu_ReadAttribute( Self : TMainMenu; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TMainMenu_WriteAttribute( Self : TMainMenu; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TPopupMenu_ReadAttribute( Self : TPopupMenu; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TPopupMenu_WriteAttribute( Self : TPopupMenu; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;

  procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 

implementation

uses
   Delphi_Classes,
   Python_Classes,
   Delphi_Graphics,
   Python_Graphics,
   Delphi_ImgList,
   Python_ImgList,
   Delphi_ActnList,
   Python_ActnList,
   Delphi_System,
   Delphi_Menus,
   Python_System,
   Py_Misc,
   PyRecords,
   PyDelphiAssoc;

var
  IsInitialized : Boolean;
  gMenus : TModule_Menus;
  gEMenuError : TMethodsContainer;
  gTMenuActionLink : TMethodsContainer;
  gTMenuItem : TMethodsContainer;
  gTMenu : TMethodsContainer;
  gTMainMenu : TMethodsContainer;
  gTPopupMenu : TMethodsContainer;

procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 
begin
  if IsInitialized then
    Exit;
  IsInitialized := True;
  gMenus := TModule_Menus.Create( AOwner );
  with gMenus do
    begin
      Engine := AEngine;
      ModuleName := '_Menus';
    end;
  gEMenuError := TMethodsContainer.Create( AOwner );
  gTMenuActionLink := TMethodsContainer.Create( AOwner );
  gTMenuItem := TMethodsContainer.Create( AOwner );
  gTMenu := TMethodsContainer.Create( AOwner );
  gTMainMenu := TMethodsContainer.Create( AOwner );
  gTPopupMenu := TMethodsContainer.Create( AOwner );
end;

///////////// Functions for class TMenuActionLink //////////////////

function TMenuActionLink_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyMenuActionLink;
  _argSelf : PPyObject;
  _argAClient : PPyObject;
  _objAClient : TObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TMenuActionLink.Create', [ @_argSelf,
                  @_argAClient       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAClient := GetObjectOf( _argAClient ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyMenuActionLink.Create( _objAClient );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TMenuActionLink_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMenuActionLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuActionLink) then begin
      ErrorWrongExpectedType( argSelf, 'TMenuActionLink' );
      Exit;
    end;
    realObj := TMenuActionLink(obj);
    // Check attribute
    Result := TMenuActionLink_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TMenuActionLink_ReadAttribute( Self : TMenuActionLink; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTMenuActionLink.MethodCount > 0 then 
      Result := Py_FindMethod( gTMenuActionLink.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TActionLink_ReadAttribute( Self, argSelf, key );
  end;
end;

function TMenuActionLink_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMenuActionLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuActionLink) then begin
      ErrorWrongExpectedType( argSelf, 'TMenuActionLink' );
      Exit;
    end;
    realObj := TMenuActionLink(obj);
    // Check attribute
    Result := TMenuActionLink_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TMenuActionLink_WriteAttribute( Self : TMenuActionLink; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TActionLink_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TMenuItem //////////////////

function TMenuItem_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyMenuItem;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TMenuItem.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyMenuItem.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TMenuItem_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMenuItem;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuItem) then begin
      ErrorWrongExpectedType( argSelf, 'TMenuItem' );
      Exit;
    end;
    realObj := TMenuItem(obj);
    // Check attribute
    Result := TMenuItem_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TMenuItem_ReadAttribute( Self : TMenuItem; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTMenuItem.MethodCount > 0 then 
      Result := Py_FindMethod( gTMenuItem.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Command' ) = 0 then Result := VariantAsPyObject( Self.Command )
    else if CompareText( key, 'Handle' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'HMENU' ); Result := nil; end
    else if CompareText( key, 'Count' ) = 0 then Result := VariantAsPyObject( Self.Count )
    else if CompareText( key, 'MenuIndex' ) = 0 then Result := VariantAsPyObject( Self.MenuIndex )
    else if CompareText( key, 'Parent' ) = 0 then Result := GetPythonObject( Self.Parent, 'Menus', 'TMenuItem' )
    else if CompareText( key, 'Action' ) = 0 then Result := GetPythonObject( Self.Action, 'Menus', 'TBasicAction' )
    else if CompareText( key, 'Bitmap' ) = 0 then Result := GetPythonObject( Self.Bitmap, 'Menus', 'TBitmap' )
    else if CompareText( key, 'Break' ) = 0 then Result := VariantAsPyObject( Integer( Self.Break ) )
    else if CompareText( key, 'Caption' ) = 0 then Result := VariantAsPyObject( Self.Caption )
    else if CompareText( key, 'Checked' ) = 0 then Result := VariantAsPyObject( Self.Checked )
    else if CompareText( key, 'Default' ) = 0 then Result := VariantAsPyObject( Self.Default )
    else if CompareText( key, 'Enabled' ) = 0 then Result := VariantAsPyObject( Self.Enabled )
    else if CompareText( key, 'GroupIndex' ) = 0 then Result := VariantAsPyObject( Self.GroupIndex )
    else if CompareText( key, 'HelpContext' ) = 0 then Result := VariantAsPyObject( Integer( Self.HelpContext ) )
    else if CompareText( key, 'Hint' ) = 0 then Result := VariantAsPyObject( Self.Hint )
    else if CompareText( key, 'ImageIndex' ) = 0 then Result := VariantAsPyObject( Self.ImageIndex )
    else if CompareText( key, 'RadioItem' ) = 0 then Result := VariantAsPyObject( Self.RadioItem )
    else if CompareText( key, 'ShortCut' ) = 0 then Result := VariantAsPyObject( Integer( Self.ShortCut ) )
    else if CompareText( key, 'Visible' ) = 0 then Result := VariantAsPyObject( Self.Visible )
    else if CompareText( key, 'OnClick' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnDrawItem' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMenuDrawItemEvent' ); Result := nil; end
    else if CompareText( key, 'OnMeasureItem' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMenuMeasureItemEvent' ); Result := nil; end
    else Result := TComponent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TMenuItem_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMenuItem;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuItem) then begin
      ErrorWrongExpectedType( argSelf, 'TMenuItem' );
      Exit;
    end;
    realObj := TMenuItem(obj);
    // Check attribute
    Result := TMenuItem_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TMenuItem_WriteAttribute( Self : TMenuItem; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Command' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Handle' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Count' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'MenuIndex' ) = 0 then begin
      Self.MenuIndex := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Parent' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Action' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TBasicAction then begin
        Self.Action := TBasicAction( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Action', 'TBasicAction' );
    end else if CompareText( key, 'Bitmap' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TBitmap then begin
        Self.Bitmap := TBitmap( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Bitmap', 'TBitmap' );
    end else if CompareText( key, 'Break' ) = 0 then begin
      Self.Break := TMenuBreak(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Caption' ) = 0 then begin
      Self.Caption := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Checked' ) = 0 then begin
      Self.Checked := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Default' ) = 0 then begin
      Self.Default := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Enabled' ) = 0 then begin
      Self.Enabled := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'GroupIndex' ) = 0 then begin
      Self.GroupIndex := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HelpContext' ) = 0 then begin
      Self.HelpContext := THelpContext(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Hint' ) = 0 then begin
      Self.Hint := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ImageIndex' ) = 0 then begin
      Self.ImageIndex := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'RadioItem' ) = 0 then begin
      Self.RadioItem := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ShortCut' ) = 0 then begin
      Self.ShortCut := TShortCut(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Visible' ) = 0 then begin
      Self.Visible := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnClick' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnClick := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyMenuItem then
          with TPyMenuItem(Self) do
            OnClick := EventOnClick;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDrawItem' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDrawItem := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyMenuItem then
          with TPyMenuItem(Self) do
            OnDrawItem := EventOnDrawItem;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMeasureItem' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMeasureItem := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyMenuItem then
          with TPyMenuItem(Self) do
            OnMeasureItem := EventOnMeasureItem;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TComponent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TMenuItem_InitiateAction( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenuItem;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuItem) then begin
      ErrorWrongExpectedType( Self, 'TMenuItem' );
      Exit;
    end;
    realObj := TMenuItem(obj);
    realObj.InitiateAction;
    Result := ReturnNone;
  end;
end;

function TMenuItem_Insert( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenuItem;
  _argIndex : Integer;
  _argItem : PPyObject;
  _objItem : TMenuItem;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iO:TMenuItem.Insert', [ 
                  @_argIndex,
                  @_argItem       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objItem := GetObjectOf( _argItem ) as TMenuItem;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuItem) then begin
      ErrorWrongExpectedType( Self, 'TMenuItem' );
      Exit;
    end;
    realObj := TMenuItem(obj);
    realObj.Insert( Integer(_argIndex), _objItem );
    Result := ReturnNone;
  end;
end;

function TMenuItem_Delete( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenuItem;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TMenuItem.Delete', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuItem) then begin
      ErrorWrongExpectedType( Self, 'TMenuItem' );
      Exit;
    end;
    realObj := TMenuItem(obj);
    realObj.Delete( Integer(_argIndex) );
    Result := ReturnNone;
  end;
end;

function TMenuItem_Click( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenuItem;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuItem) then begin
      ErrorWrongExpectedType( Self, 'TMenuItem' );
      Exit;
    end;
    realObj := TMenuItem(obj);
    realObj.Click;
    Result := ReturnNone;
  end;
end;

function TMenuItem_IndexOf( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenuItem;
  rslt : Integer;
  _argItem : PPyObject;
  _objItem : TMenuItem;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TMenuItem.IndexOf', [ 
                  @_argItem       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objItem := GetObjectOf( _argItem ) as TMenuItem;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuItem) then begin
      ErrorWrongExpectedType( Self, 'TMenuItem' );
      Exit;
    end;
    realObj := TMenuItem(obj);
    rslt := realObj.IndexOf( _objItem );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TMenuItem_GetParentComponent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenuItem;
  rslt : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuItem) then begin
      ErrorWrongExpectedType( Self, 'TMenuItem' );
      Exit;
    end;
    realObj := TMenuItem(obj);
    rslt := realObj.GetParentComponent;
    Result := GetPythonObject( rslt, 'Menus', 'TComponent' );
  end;
end;

function TMenuItem_GetParentMenu( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenuItem;
  rslt : TMenu;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuItem) then begin
      ErrorWrongExpectedType( Self, 'TMenuItem' );
      Exit;
    end;
    realObj := TMenuItem(obj);
    rslt := realObj.GetParentMenu;
    Result := GetPythonObject( rslt, 'Menus', 'TMenu' );
  end;
end;

function TMenuItem_HasParent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenuItem;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuItem) then begin
      ErrorWrongExpectedType( Self, 'TMenuItem' );
      Exit;
    end;
    realObj := TMenuItem(obj);
    rslt := realObj.HasParent;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TMenuItem_Add( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenuItem;
  _argItem : PPyObject;
  _objItem : TMenuItem;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TMenuItem.Add', [ 
                  @_argItem       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objItem := GetObjectOf( _argItem ) as TMenuItem;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuItem) then begin
      ErrorWrongExpectedType( Self, 'TMenuItem' );
      Exit;
    end;
    realObj := TMenuItem(obj);
    realObj.Add( _objItem );
    Result := ReturnNone;
  end;
end;

function TMenuItem_Remove( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenuItem;
  _argItem : PPyObject;
  _objItem : TMenuItem;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TMenuItem.Remove', [ 
                  @_argItem       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objItem := GetObjectOf( _argItem ) as TMenuItem;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuItem) then begin
      ErrorWrongExpectedType( Self, 'TMenuItem' );
      Exit;
    end;
    realObj := TMenuItem(obj);
    realObj.Remove( _objItem );
    Result := ReturnNone;
  end;
end;

function TMenuItem_Items( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenuItem;
  rslt : TMenuItem;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TMenuItem.Items', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenuItem) then begin
      ErrorWrongExpectedType( Self, 'TMenuItem' );
      Exit;
    end;
    realObj := TMenuItem(obj);
    rslt := realObj.Items[ Integer(_argIndex) ];
    Result := GetPythonObject( rslt, 'Menus', 'TMenuItem' );
  end;
end;

///////////// Functions for class TMenu //////////////////

function TMenu_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyMenu;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TMenu.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyMenu.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TMenu_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMenu;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMenu) then begin
      ErrorWrongExpectedType( argSelf, 'TMenu' );
      Exit;
    end;
    realObj := TMenu(obj);
    // Check attribute
    Result := TMenu_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TMenu_ReadAttribute( Self : TMenu; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTMenu.MethodCount > 0 then 
      Result := Py_FindMethod( gTMenu.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Images' ) = 0 then Result := GetPythonObject( Self.Images, 'Menus', 'TCustomImageList' )
    else if CompareText( key, 'BiDiMode' ) = 0 then Result := VariantAsPyObject( Integer( Self.BiDiMode ) )
    else if CompareText( key, 'Handle' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'HMENU' ); Result := nil; end
    else if CompareText( key, 'OwnerDraw' ) = 0 then Result := VariantAsPyObject( Self.OwnerDraw )
    else if CompareText( key, 'ParentBiDiMode' ) = 0 then Result := VariantAsPyObject( Self.ParentBiDiMode )
    else if CompareText( key, 'WindowHandle' ) = 0 then Result := VariantAsPyObject( Self.WindowHandle )
    else if CompareText( key, 'Items' ) = 0 then Result := GetPythonObject( Self.Items, 'Menus', 'TMenuItem' )
    else Result := TComponent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TMenu_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMenu;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMenu) then begin
      ErrorWrongExpectedType( argSelf, 'TMenu' );
      Exit;
    end;
    realObj := TMenu(obj);
    // Check attribute
    Result := TMenu_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TMenu_WriteAttribute( Self : TMenu; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Images' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TCustomImageList then begin
        Self.Images := TCustomImageList( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Images', 'TCustomImageList' );
    end else if CompareText( key, 'BiDiMode' ) = 0 then begin
      Self.BiDiMode := TBiDiMode(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Handle' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'OwnerDraw' ) = 0 then begin
      Self.OwnerDraw := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ParentBiDiMode' ) = 0 then begin
      Self.ParentBiDiMode := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'WindowHandle' ) = 0 then begin
      Self.WindowHandle := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Items' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TComponent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TMenu_DispatchCommand( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenu;
  rslt : Boolean;
  _argACommand : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TMenu.DispatchCommand', [ 
                  @_argACommand       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenu) then begin
      ErrorWrongExpectedType( Self, 'TMenu' );
      Exit;
    end;
    realObj := TMenu(obj);
    rslt := realObj.DispatchCommand( Word(_argACommand) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TMenu_DispatchPopup( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TMenu_FindItem( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenu;
  rslt : TMenuItem;
  _argValue : Integer;
  _argKind : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TMenu.FindItem', [ 
                  @_argValue,
                  @_argKind       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenu) then begin
      ErrorWrongExpectedType( Self, 'TMenu' );
      Exit;
    end;
    realObj := TMenu(obj);
    rslt := realObj.FindItem( Integer(_argValue), TFindItemKind(_argKind) );
    Result := GetPythonObject( rslt, 'Menus', 'TMenuItem' );
  end;
end;

function TMenu_GetHelpContext( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenu;
  rslt : THelpContext;
  _argValue : Integer;
  _argByCommand : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TMenu.GetHelpContext', [ 
                  @_argValue,
                  @_argByCommand       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenu) then begin
      ErrorWrongExpectedType( Self, 'TMenu' );
      Exit;
    end;
    realObj := TMenu(obj);
    rslt := realObj.GetHelpContext( Integer(_argValue), Boolean(_argByCommand) );
    Result := VariantAsPyObject( Integer( rslt ) );
  end;
end;

function TMenu_IsRightToLeft( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenu;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenu) then begin
      ErrorWrongExpectedType( Self, 'TMenu' );
      Exit;
    end;
    realObj := TMenu(obj);
    rslt := realObj.IsRightToLeft;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TMenu_IsShortCut( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TMenu_ParentBiDiModeChanged( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenu;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenu) then begin
      ErrorWrongExpectedType( Self, 'TMenu' );
      Exit;
    end;
    realObj := TMenu(obj);
    realObj.ParentBiDiModeChanged;
    Result := ReturnNone;
  end;
end;

function TMenu_ParentBiDiModeChanged1( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMenu;
  _argAControl : PPyObject;
  _objAControl : TObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TMenu.ParentBiDiModeChanged1', [ 
                  @_argAControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAControl := GetObjectOf( _argAControl ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMenu) then begin
      ErrorWrongExpectedType( Self, 'TMenu' );
      Exit;
    end;
    realObj := TMenu(obj);
    realObj.ParentBiDiModeChanged( _objAControl );
    Result := ReturnNone;
  end;
end;

function TMenu_ProcessMenuChar( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TMainMenu //////////////////

function TMainMenu_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyMainMenu;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TMainMenu.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyMainMenu.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TMainMenu_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMainMenu;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMainMenu) then begin
      ErrorWrongExpectedType( argSelf, 'TMainMenu' );
      Exit;
    end;
    realObj := TMainMenu(obj);
    // Check attribute
    Result := TMainMenu_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TMainMenu_ReadAttribute( Self : TMainMenu; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTMainMenu.MethodCount > 0 then 
      Result := Py_FindMethod( gTMainMenu.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'AutoMerge' ) = 0 then Result := VariantAsPyObject( Self.AutoMerge )
    else if CompareText( key, 'BiDiMode' ) = 0 then Result := VariantAsPyObject( Integer( Self.BiDiMode ) )
    else if CompareText( key, 'Images' ) = 0 then Result := GetPythonObject( Self.Images, 'Menus', 'TCustomImageList' )
    else if CompareText( key, 'OwnerDraw' ) = 0 then Result := VariantAsPyObject( Self.OwnerDraw )
    else if CompareText( key, 'ParentBiDiMode' ) = 0 then Result := VariantAsPyObject( Self.ParentBiDiMode )
    else if CompareText( key, 'OnChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMenuChangeEvent' ); Result := nil; end
    else Result := TMenu_ReadAttribute( Self, argSelf, key );
  end;
end;

function TMainMenu_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMainMenu;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMainMenu) then begin
      ErrorWrongExpectedType( argSelf, 'TMainMenu' );
      Exit;
    end;
    realObj := TMainMenu(obj);
    // Check attribute
    Result := TMainMenu_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TMainMenu_WriteAttribute( Self : TMainMenu; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'AutoMerge' ) = 0 then begin
      Self.AutoMerge := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'BiDiMode' ) = 0 then begin
      Self.BiDiMode := TBiDiMode(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Images' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TCustomImageList then begin
        Self.Images := TCustomImageList( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Images', 'TCustomImageList' );
    end else if CompareText( key, 'OwnerDraw' ) = 0 then begin
      Self.OwnerDraw := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ParentBiDiMode' ) = 0 then begin
      Self.ParentBiDiMode := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyMainMenu then
          with TPyMainMenu(Self) do
            OnChange := EventOnChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TMenu_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TMainMenu_Merge( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMainMenu;
  _argMenu : PPyObject;
  _objMenu : TMainMenu;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TMainMenu.Merge', [ 
                  @_argMenu       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objMenu := GetObjectOf( _argMenu ) as TMainMenu;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMainMenu) then begin
      ErrorWrongExpectedType( Self, 'TMainMenu' );
      Exit;
    end;
    realObj := TMainMenu(obj);
    realObj.Merge( _objMenu );
    Result := ReturnNone;
  end;
end;

function TMainMenu_Unmerge( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMainMenu;
  _argMenu : PPyObject;
  _objMenu : TMainMenu;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TMainMenu.Unmerge', [ 
                  @_argMenu       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objMenu := GetObjectOf( _argMenu ) as TMainMenu;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMainMenu) then begin
      ErrorWrongExpectedType( Self, 'TMainMenu' );
      Exit;
    end;
    realObj := TMainMenu(obj);
    realObj.Unmerge( _objMenu );
    Result := ReturnNone;
  end;
end;

function TMainMenu_PopulateOle2Menu( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TMainMenu_GetOle2AcceleratorTable( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TMainMenu_SetOle2MenuHandle( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TPopupMenu //////////////////

function TPopupMenu_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyPopupMenu;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TPopupMenu.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyPopupMenu.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TPopupMenu_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TPopupMenu;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TPopupMenu) then begin
      ErrorWrongExpectedType( argSelf, 'TPopupMenu' );
      Exit;
    end;
    realObj := TPopupMenu(obj);
    // Check attribute
    Result := TPopupMenu_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TPopupMenu_ReadAttribute( Self : TPopupMenu; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTPopupMenu.MethodCount > 0 then 
      Result := Py_FindMethod( gTPopupMenu.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'PopupComponent' ) = 0 then Result := GetPythonObject( Self.PopupComponent, 'Menus', 'TComponent' )
    else if CompareText( key, 'TrackButton' ) = 0 then Result := VariantAsPyObject( Integer( Self.TrackButton ) )
    else if CompareText( key, 'Alignment' ) = 0 then Result := VariantAsPyObject( Integer( Self.Alignment ) )
    else if CompareText( key, 'AutoPopup' ) = 0 then Result := VariantAsPyObject( Self.AutoPopup )
    else if CompareText( key, 'BiDiMode' ) = 0 then Result := VariantAsPyObject( Integer( Self.BiDiMode ) )
    else if CompareText( key, 'HelpContext' ) = 0 then Result := VariantAsPyObject( Integer( Self.HelpContext ) )
    else if CompareText( key, 'Images' ) = 0 then Result := GetPythonObject( Self.Images, 'Menus', 'TCustomImageList' )
    else if CompareText( key, 'OwnerDraw' ) = 0 then Result := VariantAsPyObject( Self.OwnerDraw )
    else if CompareText( key, 'ParentBiDiMode' ) = 0 then Result := VariantAsPyObject( Self.ParentBiDiMode )
    else if CompareText( key, 'OnChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMenuChangeEvent' ); Result := nil; end
    else if CompareText( key, 'OnPopup' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else Result := TMenu_ReadAttribute( Self, argSelf, key );
  end;
end;

function TPopupMenu_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TPopupMenu;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TPopupMenu) then begin
      ErrorWrongExpectedType( argSelf, 'TPopupMenu' );
      Exit;
    end;
    realObj := TPopupMenu(obj);
    // Check attribute
    Result := TPopupMenu_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TPopupMenu_WriteAttribute( Self : TPopupMenu; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'PopupComponent' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TComponent then begin
        Self.PopupComponent := TComponent( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'PopupComponent', 'TComponent' );
    end else if CompareText( key, 'TrackButton' ) = 0 then begin
      Self.TrackButton := TTrackButton(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Alignment' ) = 0 then begin
      Self.Alignment := TPopupAlignment(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'AutoPopup' ) = 0 then begin
      Self.AutoPopup := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'BiDiMode' ) = 0 then begin
      Self.BiDiMode := TBiDiMode(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HelpContext' ) = 0 then begin
      Self.HelpContext := THelpContext(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Images' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TCustomImageList then begin
        Self.Images := TCustomImageList( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Images', 'TCustomImageList' );
    end else if CompareText( key, 'OwnerDraw' ) = 0 then begin
      Self.OwnerDraw := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ParentBiDiMode' ) = 0 then begin
      Self.ParentBiDiMode := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyPopupMenu then
          with TPyPopupMenu(Self) do
            OnChange := EventOnChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnPopup' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnPopup := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyPopupMenu then
          with TPyPopupMenu(Self) do
            OnPopup := EventOnPopup;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TMenu_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TPopupMenu_Popup( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TPopupMenu;
  _argX : Integer;
  _argY : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TPopupMenu.Popup', [ 
                  @_argX,
                  @_argY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TPopupMenu) then begin
      ErrorWrongExpectedType( Self, 'TPopupMenu' );
      Exit;
    end;
    realObj := TPopupMenu(obj);
    realObj.Popup( Integer(_argX), Integer(_argY) );
    Result := ReturnNone;
  end;
end;

///////////// Initialization of the module ///////////

procedure TModule_Menus.Initialize;
begin
  // class TMenuActionLink
  AddMethod( 'CreateMenuActionLink', TMenuActionLink_Create, '' );
  AddMethod( 'MenuActionLink_GetAttr', TMenuActionLink_GetAttr, '' );
  AddMethod( 'MenuActionLink_SetAttr', TMenuActionLink_SetAttr, '' );
  // class TMenuItem
  AddMethod( 'CreateMenuItem', TMenuItem_Create, '' );
  AddMethod( 'MenuItem_GetAttr', TMenuItem_GetAttr, '' );
  AddMethod( 'MenuItem_SetAttr', TMenuItem_SetAttr, '' );
  gTMenuItem.AddMethod( 'Create', TMenuItem_Create, '' );
  gTMenuItem.AddMethod( 'InitiateAction', TMenuItem_InitiateAction, '' );
  gTMenuItem.AddMethod( 'Insert', TMenuItem_Insert, '' );
  gTMenuItem.AddMethod( 'Delete', TMenuItem_Delete, '' );
  gTMenuItem.AddMethod( 'Click', TMenuItem_Click, '' );
  gTMenuItem.AddMethod( 'IndexOf', TMenuItem_IndexOf, '' );
  gTMenuItem.AddMethod( 'GetParentComponent', TMenuItem_GetParentComponent, '' );
  gTMenuItem.AddMethod( 'GetParentMenu', TMenuItem_GetParentMenu, '' );
  gTMenuItem.AddMethod( 'HasParent', TMenuItem_HasParent, '' );
  gTMenuItem.AddMethod( 'Add', TMenuItem_Add, '' );
  gTMenuItem.AddMethod( 'Remove', TMenuItem_Remove, '' );
  gTMenuItem.AddMethod( 'Items', TMenuItem_Items, '' );
  // class TMenu
  AddMethod( 'CreateMenu', TMenu_Create, '' );
  AddMethod( 'Menu_GetAttr', TMenu_GetAttr, '' );
  AddMethod( 'Menu_SetAttr', TMenu_SetAttr, '' );
  gTMenu.AddMethod( 'Create', TMenu_Create, '' );
  gTMenu.AddMethod( 'DispatchCommand', TMenu_DispatchCommand, '' );
  gTMenu.AddMethod( 'DispatchPopup', TMenu_DispatchPopup, '' );
  gTMenu.AddMethod( 'FindItem', TMenu_FindItem, '' );
  gTMenu.AddMethod( 'GetHelpContext', TMenu_GetHelpContext, '' );
  gTMenu.AddMethod( 'IsRightToLeft', TMenu_IsRightToLeft, '' );
  gTMenu.AddMethod( 'IsShortCut', TMenu_IsShortCut, '' );
  gTMenu.AddMethod( 'ParentBiDiModeChanged', TMenu_ParentBiDiModeChanged, '' );
  gTMenu.AddMethod( 'ParentBiDiModeChanged1', TMenu_ParentBiDiModeChanged, '' );
  gTMenu.AddMethod( 'ProcessMenuChar', TMenu_ProcessMenuChar, '' );
  // class TMainMenu
  AddMethod( 'CreateMainMenu', TMainMenu_Create, '' );
  AddMethod( 'MainMenu_GetAttr', TMainMenu_GetAttr, '' );
  AddMethod( 'MainMenu_SetAttr', TMainMenu_SetAttr, '' );
  gTMainMenu.AddMethod( 'Merge', TMainMenu_Merge, '' );
  gTMainMenu.AddMethod( 'Unmerge', TMainMenu_Unmerge, '' );
  gTMainMenu.AddMethod( 'PopulateOle2Menu', TMainMenu_PopulateOle2Menu, '' );
  gTMainMenu.AddMethod( 'GetOle2AcceleratorTable', TMainMenu_GetOle2AcceleratorTable, '' );
  gTMainMenu.AddMethod( 'SetOle2MenuHandle', TMainMenu_SetOle2MenuHandle, '' );
  // class TPopupMenu
  AddMethod( 'CreatePopupMenu', TPopupMenu_Create, '' );
  AddMethod( 'PopupMenu_GetAttr', TPopupMenu_GetAttr, '' );
  AddMethod( 'PopupMenu_SetAttr', TPopupMenu_SetAttr, '' );
  gTPopupMenu.AddMethod( 'Create', TPopupMenu_Create, '' );
  gTPopupMenu.AddMethod( 'Popup', TPopupMenu_Popup, '' );
  inherited;
end;

end.
