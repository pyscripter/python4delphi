////
//  This file was generated by VCL Generator
//  Copyright 1998 - Morgan Martinet
//  06/07/1999 07:59:02
//  it declares the content of the module _ActnList
////

unit Python_ActnList;

interface

uses
   Windows,
   ImgList,
   ActnList,
   Messages,
   Classes,
   SysUtils,
   PythonEngine;

type
  TModule_ActnList = class( TPythonModule )
  public
    procedure Initialize; override;
  end;

  function TContainedAction_ReadAttribute( Self : TContainedAction; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TContainedAction_WriteAttribute( Self : TContainedAction; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TCustomActionList_ReadAttribute( Self : TCustomActionList; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TCustomActionList_WriteAttribute( Self : TCustomActionList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TActionList_ReadAttribute( Self : TActionList; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TActionList_WriteAttribute( Self : TActionList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TCustomAction_ReadAttribute( Self : TCustomAction; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TCustomAction_WriteAttribute( Self : TCustomAction; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TAction_ReadAttribute( Self : TAction; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TAction_WriteAttribute( Self : TAction; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TActionLink_ReadAttribute( Self : TActionLink; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TActionLink_WriteAttribute( Self : TActionLink; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;

  procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 

implementation

uses
   Delphi_Classes,
   Python_Classes,
   Delphi_ImgList,
   Python_ImgList,
   Delphi_System,
   Delphi_ActnList,
   Python_System,
   Py_Misc,
   PyRecords,
   PyDelphiAssoc;

var
  IsInitialized : Boolean;
  gActnList : TModule_ActnList;
  gTContainedAction : TMethodsContainer;
  gTCustomActionList : TMethodsContainer;
  gTActionList : TMethodsContainer;
  gTCustomAction : TMethodsContainer;
  gTAction : TMethodsContainer;
  gTActionLink : TMethodsContainer;

procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 
begin
  if IsInitialized then
    Exit;
  IsInitialized := True;
  gActnList := TModule_ActnList.Create( AOwner );
  with gActnList do
    begin
      Engine := AEngine;
      ModuleName := '_ActnList';
    end;
  gTContainedAction := TMethodsContainer.Create( AOwner );
  gTCustomActionList := TMethodsContainer.Create( AOwner );
  gTActionList := TMethodsContainer.Create( AOwner );
  gTCustomAction := TMethodsContainer.Create( AOwner );
  gTAction := TMethodsContainer.Create( AOwner );
  gTActionLink := TMethodsContainer.Create( AOwner );
end;

///////////// Functions for class TContainedAction //////////////////

function TContainedAction_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyContainedAction;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TContainedAction.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyContainedAction.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TContainedAction_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TContainedAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TContainedAction) then begin
      ErrorWrongExpectedType( argSelf, 'TContainedAction' );
      Exit;
    end;
    realObj := TContainedAction(obj);
    // Check attribute
    Result := TContainedAction_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TContainedAction_ReadAttribute( Self : TContainedAction; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTContainedAction.MethodCount > 0 then 
      Result := Py_FindMethod( gTContainedAction.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'ActionList' ) = 0 then Result := GetPythonObject( Self.ActionList, 'ActnList', 'TCustomActionList' )
    else if CompareText( key, 'Index' ) = 0 then Result := VariantAsPyObject( Self.Index )
    else if CompareText( key, 'Category' ) = 0 then Result := VariantAsPyObject( Self.Category )
    else Result := TBasicAction_ReadAttribute( Self, argSelf, key );
  end;
end;

function TContainedAction_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TContainedAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TContainedAction) then begin
      ErrorWrongExpectedType( argSelf, 'TContainedAction' );
      Exit;
    end;
    realObj := TContainedAction(obj);
    // Check attribute
    Result := TContainedAction_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TContainedAction_WriteAttribute( Self : TContainedAction; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'ActionList' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TCustomActionList then begin
        Self.ActionList := TCustomActionList( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'ActionList', 'TCustomActionList' );
    end else if CompareText( key, 'Index' ) = 0 then begin
      Self.Index := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Category' ) = 0 then begin
      Self.Category := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TBasicAction_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TContainedAction_Execute( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TContainedAction;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TContainedAction) then begin
      ErrorWrongExpectedType( Self, 'TContainedAction' );
      Exit;
    end;
    realObj := TContainedAction(obj);
    rslt := realObj.Execute;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TContainedAction_GetParentComponent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TContainedAction;
  rslt : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TContainedAction) then begin
      ErrorWrongExpectedType( Self, 'TContainedAction' );
      Exit;
    end;
    realObj := TContainedAction(obj);
    rslt := realObj.GetParentComponent;
    Result := GetPythonObject( rslt, 'ActnList', 'TComponent' );
  end;
end;

function TContainedAction_HasParent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TContainedAction;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TContainedAction) then begin
      ErrorWrongExpectedType( Self, 'TContainedAction' );
      Exit;
    end;
    realObj := TContainedAction(obj);
    rslt := realObj.HasParent;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TContainedAction_Update( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TContainedAction;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TContainedAction) then begin
      ErrorWrongExpectedType( Self, 'TContainedAction' );
      Exit;
    end;
    realObj := TContainedAction(obj);
    rslt := realObj.Update;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TCustomActionList //////////////////

function TCustomActionList_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomActionList;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TCustomActionList.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomActionList.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomActionList_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomActionList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomActionList) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomActionList' );
      Exit;
    end;
    realObj := TCustomActionList(obj);
    // Check attribute
    Result := TCustomActionList_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TCustomActionList_ReadAttribute( Self : TCustomActionList; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTCustomActionList.MethodCount > 0 then 
      Result := Py_FindMethod( gTCustomActionList.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'ActionCount' ) = 0 then Result := VariantAsPyObject( Self.ActionCount )
    else if CompareText( key, 'Images' ) = 0 then Result := GetPythonObject( Self.Images, 'ActnList', 'TCustomImageList' )
    else Result := TComponent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TCustomActionList_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomActionList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomActionList) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomActionList' );
      Exit;
    end;
    realObj := TCustomActionList(obj);
    // Check attribute
    Result := TCustomActionList_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TCustomActionList_WriteAttribute( Self : TCustomActionList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'ActionCount' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Images' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TCustomImageList then begin
        Self.Images := TCustomImageList( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Images', 'TCustomImageList' );
    end else Result := TComponent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TCustomActionList_ExecuteAction( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomActionList;
  rslt : Boolean;
  _argAction : PPyObject;
  _objAction : TBasicAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCustomActionList.ExecuteAction', [ 
                  @_argAction       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAction := GetObjectOf( _argAction ) as TBasicAction;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomActionList) then begin
      ErrorWrongExpectedType( Self, 'TCustomActionList' );
      Exit;
    end;
    realObj := TCustomActionList(obj);
    rslt := realObj.ExecuteAction( _objAction );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomActionList_IsShortCut( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TCustomActionList_UpdateAction( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomActionList;
  rslt : Boolean;
  _argAction : PPyObject;
  _objAction : TBasicAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCustomActionList.UpdateAction', [ 
                  @_argAction       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAction := GetObjectOf( _argAction ) as TBasicAction;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomActionList) then begin
      ErrorWrongExpectedType( Self, 'TCustomActionList' );
      Exit;
    end;
    realObj := TCustomActionList(obj);
    rslt := realObj.UpdateAction( _objAction );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomActionList_Actions( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomActionList;
  rslt : TContainedAction;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TCustomActionList.Actions', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomActionList) then begin
      ErrorWrongExpectedType( Self, 'TCustomActionList' );
      Exit;
    end;
    realObj := TCustomActionList(obj);
    rslt := realObj.Actions[ Integer(_argIndex) ];
    Result := GetPythonObject( rslt, 'ActnList', 'TContainedAction' );
  end;
end;

///////////// Functions for class TActionList //////////////////

function TActionList_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyActionList;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TActionList.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyActionList.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TActionList_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TActionList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TActionList) then begin
      ErrorWrongExpectedType( argSelf, 'TActionList' );
      Exit;
    end;
    realObj := TActionList(obj);
    // Check attribute
    Result := TActionList_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TActionList_ReadAttribute( Self : TActionList; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTActionList.MethodCount > 0 then 
      Result := Py_FindMethod( gTActionList.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Images' ) = 0 then Result := GetPythonObject( Self.Images, 'ActnList', 'TCustomImageList' )
    else if CompareText( key, 'OnChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnExecute' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TActionEvent' ); Result := nil; end
    else if CompareText( key, 'OnUpdate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TActionEvent' ); Result := nil; end
    else Result := TCustomActionList_ReadAttribute( Self, argSelf, key );
  end;
end;

function TActionList_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TActionList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TActionList) then begin
      ErrorWrongExpectedType( argSelf, 'TActionList' );
      Exit;
    end;
    realObj := TActionList(obj);
    // Check attribute
    Result := TActionList_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TActionList_WriteAttribute( Self : TActionList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Images' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TCustomImageList then begin
        Self.Images := TCustomImageList( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Images', 'TCustomImageList' );
    end else if CompareText( key, 'OnChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyActionList then
          with TPyActionList(Self) do
            OnChange := EventOnChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnExecute' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnExecute := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyActionList then
          with TPyActionList(Self) do
            OnExecute := EventOnExecute;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnUpdate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnUpdate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyActionList then
          with TPyActionList(Self) do
            OnUpdate := EventOnUpdate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TCustomActionList_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TCustomAction //////////////////

function TCustomAction_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomAction;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TCustomAction.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomAction.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomAction_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomAction) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomAction' );
      Exit;
    end;
    realObj := TCustomAction(obj);
    // Check attribute
    Result := TCustomAction_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TCustomAction_ReadAttribute( Self : TCustomAction; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTCustomAction.MethodCount > 0 then 
      Result := Py_FindMethod( gTCustomAction.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Caption' ) = 0 then Result := VariantAsPyObject( Self.Caption )
    else if CompareText( key, 'Checked' ) = 0 then Result := VariantAsPyObject( Self.Checked )
    else if CompareText( key, 'DisableIfNoHandler' ) = 0 then Result := VariantAsPyObject( Self.DisableIfNoHandler )
    else if CompareText( key, 'Enabled' ) = 0 then Result := VariantAsPyObject( Self.Enabled )
    else if CompareText( key, 'HelpContext' ) = 0 then Result := VariantAsPyObject( Integer( Self.HelpContext ) )
    else if CompareText( key, 'Hint' ) = 0 then Result := VariantAsPyObject( Self.Hint )
    else if CompareText( key, 'ImageIndex' ) = 0 then Result := VariantAsPyObject( Self.ImageIndex )
    else if CompareText( key, 'ShortCut' ) = 0 then Result := VariantAsPyObject( Integer( Self.ShortCut ) )
    else if CompareText( key, 'Visible' ) = 0 then Result := VariantAsPyObject( Self.Visible )
    else if CompareText( key, 'OnHint' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'THintEvent' ); Result := nil; end
    else Result := TContainedAction_ReadAttribute( Self, argSelf, key );
  end;
end;

function TCustomAction_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomAction) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomAction' );
      Exit;
    end;
    realObj := TCustomAction(obj);
    // Check attribute
    Result := TCustomAction_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TCustomAction_WriteAttribute( Self : TCustomAction; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Caption' ) = 0 then begin
      Self.Caption := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Checked' ) = 0 then begin
      Self.Checked := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DisableIfNoHandler' ) = 0 then begin
      Self.DisableIfNoHandler := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Enabled' ) = 0 then begin
      Self.Enabled := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HelpContext' ) = 0 then begin
      Self.HelpContext := THelpContext(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Hint' ) = 0 then begin
      Self.Hint := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ImageIndex' ) = 0 then begin
      Self.ImageIndex := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ShortCut' ) = 0 then begin
      Self.ShortCut := TShortCut(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Visible' ) = 0 then begin
      Self.Visible := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnHint' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnHint := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomAction then
          with TPyCustomAction(Self) do
            OnHint := EventOnHint;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TContainedAction_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TCustomAction_DoHint( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TCustomAction_Execute( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomAction;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomAction) then begin
      ErrorWrongExpectedType( Self, 'TCustomAction' );
      Exit;
    end;
    realObj := TCustomAction(obj);
    rslt := realObj.Execute;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TAction //////////////////

function TAction_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyAction;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TAction.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyAction.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TAction_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TAction) then begin
      ErrorWrongExpectedType( argSelf, 'TAction' );
      Exit;
    end;
    realObj := TAction(obj);
    // Check attribute
    Result := TAction_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TAction_ReadAttribute( Self : TAction; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTAction.MethodCount > 0 then 
      Result := Py_FindMethod( gTAction.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Caption' ) = 0 then Result := VariantAsPyObject( Self.Caption )
    else if CompareText( key, 'Checked' ) = 0 then Result := VariantAsPyObject( Self.Checked )
    else if CompareText( key, 'Enabled' ) = 0 then Result := VariantAsPyObject( Self.Enabled )
    else if CompareText( key, 'HelpContext' ) = 0 then Result := VariantAsPyObject( Integer( Self.HelpContext ) )
    else if CompareText( key, 'Hint' ) = 0 then Result := VariantAsPyObject( Self.Hint )
    else if CompareText( key, 'ImageIndex' ) = 0 then Result := VariantAsPyObject( Self.ImageIndex )
    else if CompareText( key, 'ShortCut' ) = 0 then Result := VariantAsPyObject( Integer( Self.ShortCut ) )
    else if CompareText( key, 'Visible' ) = 0 then Result := VariantAsPyObject( Self.Visible )
    else if CompareText( key, 'OnExecute' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnHint' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'THintEvent' ); Result := nil; end
    else if CompareText( key, 'OnUpdate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else Result := TCustomAction_ReadAttribute( Self, argSelf, key );
  end;
end;

function TAction_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TAction) then begin
      ErrorWrongExpectedType( argSelf, 'TAction' );
      Exit;
    end;
    realObj := TAction(obj);
    // Check attribute
    Result := TAction_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TAction_WriteAttribute( Self : TAction; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Caption' ) = 0 then begin
      Self.Caption := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Checked' ) = 0 then begin
      Self.Checked := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Enabled' ) = 0 then begin
      Self.Enabled := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HelpContext' ) = 0 then begin
      Self.HelpContext := THelpContext(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Hint' ) = 0 then begin
      Self.Hint := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ImageIndex' ) = 0 then begin
      Self.ImageIndex := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ShortCut' ) = 0 then begin
      Self.ShortCut := TShortCut(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Visible' ) = 0 then begin
      Self.Visible := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnExecute' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnExecute := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyAction then
          with TPyAction(Self) do
            OnExecute := EventOnExecute;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnHint' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnHint := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyAction then
          with TPyAction(Self) do
            OnHint := EventOnHint;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnUpdate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnUpdate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyAction then
          with TPyAction(Self) do
            OnUpdate := EventOnUpdate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TCustomAction_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TActionLink //////////////////

function TActionLink_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyActionLink;
  _argSelf : PPyObject;
  _argAClient : PPyObject;
  _objAClient : TObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TActionLink.Create', [ @_argSelf,
                  @_argAClient       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAClient := GetObjectOf( _argAClient ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyActionLink.Create( _objAClient );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TActionLink_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TActionLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TActionLink) then begin
      ErrorWrongExpectedType( argSelf, 'TActionLink' );
      Exit;
    end;
    realObj := TActionLink(obj);
    // Check attribute
    Result := TActionLink_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TActionLink_ReadAttribute( Self : TActionLink; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTActionLink.MethodCount > 0 then 
      Result := Py_FindMethod( gTActionLink.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TBasicActionLink_ReadAttribute( Self, argSelf, key );
  end;
end;

function TActionLink_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TActionLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TActionLink) then begin
      ErrorWrongExpectedType( argSelf, 'TActionLink' );
      Exit;
    end;
    realObj := TActionLink(obj);
    // Check attribute
    Result := TActionLink_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TActionLink_WriteAttribute( Self : TActionLink; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TBasicActionLink_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Initialization of the module ///////////

procedure TModule_ActnList.Initialize;
begin
  // class TContainedAction
  AddMethod( 'CreateContainedAction', TContainedAction_Create, '' );
  AddMethod( 'ContainedAction_GetAttr', TContainedAction_GetAttr, '' );
  AddMethod( 'ContainedAction_SetAttr', TContainedAction_SetAttr, '' );
  gTContainedAction.AddMethod( 'Execute', TContainedAction_Execute, '' );
  gTContainedAction.AddMethod( 'GetParentComponent', TContainedAction_GetParentComponent, '' );
  gTContainedAction.AddMethod( 'HasParent', TContainedAction_HasParent, '' );
  gTContainedAction.AddMethod( 'Update', TContainedAction_Update, '' );
  // class TCustomActionList
  AddMethod( 'CreateCustomActionList', TCustomActionList_Create, '' );
  AddMethod( 'CustomActionList_GetAttr', TCustomActionList_GetAttr, '' );
  AddMethod( 'CustomActionList_SetAttr', TCustomActionList_SetAttr, '' );
  gTCustomActionList.AddMethod( 'Create', TCustomActionList_Create, '' );
  gTCustomActionList.AddMethod( 'ExecuteAction', TCustomActionList_ExecuteAction, '' );
  gTCustomActionList.AddMethod( 'IsShortCut', TCustomActionList_IsShortCut, '' );
  gTCustomActionList.AddMethod( 'UpdateAction', TCustomActionList_UpdateAction, '' );
  gTCustomActionList.AddMethod( 'Actions', TCustomActionList_Actions, '' );
  // class TActionList
  AddMethod( 'CreateActionList', TActionList_Create, '' );
  AddMethod( 'ActionList_GetAttr', TActionList_GetAttr, '' );
  AddMethod( 'ActionList_SetAttr', TActionList_SetAttr, '' );
  // class TCustomAction
  AddMethod( 'CreateCustomAction', TCustomAction_Create, '' );
  AddMethod( 'CustomAction_GetAttr', TCustomAction_GetAttr, '' );
  AddMethod( 'CustomAction_SetAttr', TCustomAction_SetAttr, '' );
  gTCustomAction.AddMethod( 'Create', TCustomAction_Create, '' );
  gTCustomAction.AddMethod( 'DoHint', TCustomAction_DoHint, '' );
  gTCustomAction.AddMethod( 'Execute', TCustomAction_Execute, '' );
  // class TAction
  AddMethod( 'CreateAction', TAction_Create, '' );
  AddMethod( 'Action_GetAttr', TAction_GetAttr, '' );
  AddMethod( 'Action_SetAttr', TAction_SetAttr, '' );
  // class TActionLink
  AddMethod( 'CreateActionLink', TActionLink_Create, '' );
  AddMethod( 'ActionLink_GetAttr', TActionLink_GetAttr, '' );
  AddMethod( 'ActionLink_SetAttr', TActionLink_SetAttr, '' );
  inherited;
end;

end.
