////
//  This file was generated by VCL Generator
//  Copyright 1998 - Morgan Martinet
//  06/07/1999 07:58:58
//  it declares the content of the module _Classes
////

unit Python_Classes;

interface

uses
   Windows,
   ActiveX,
   Classes,
   SysUtils,
   PythonEngine;

type
  TModule_Classes = class( TPythonModule )
  public
    procedure Initialize; override;
  end;

  function TList_ReadAttribute( Self : TList; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TList_WriteAttribute( Self : TList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TThreadList_ReadAttribute( Self : TThreadList; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TThreadList_WriteAttribute( Self : TThreadList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TBits_ReadAttribute( Self : TBits; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TBits_WriteAttribute( Self : TBits; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TPersistent_ReadAttribute( Self : TPersistent; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TPersistent_WriteAttribute( Self : TPersistent; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TCollectionItem_ReadAttribute( Self : TCollectionItem; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TCollectionItem_WriteAttribute( Self : TCollectionItem; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TCollection_ReadAttribute( Self : TCollection; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TCollection_WriteAttribute( Self : TCollection; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TOwnedCollection_ReadAttribute( Self : TOwnedCollection; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TOwnedCollection_WriteAttribute( Self : TOwnedCollection; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TStrings_ReadAttribute( Self : TStrings; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TStrings_WriteAttribute( Self : TStrings; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TStringList_ReadAttribute( Self : TStringList; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TStringList_WriteAttribute( Self : TStringList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TStream_ReadAttribute( Self : TStream; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TStream_WriteAttribute( Self : TStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function THandleStream_ReadAttribute( Self : THandleStream; argSelf : PPyObject; key : PChar ) : PPyObject;
  function THandleStream_WriteAttribute( Self : THandleStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TFileStream_ReadAttribute( Self : TFileStream; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TFileStream_WriteAttribute( Self : TFileStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TCustomMemoryStream_ReadAttribute( Self : TCustomMemoryStream; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TCustomMemoryStream_WriteAttribute( Self : TCustomMemoryStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TMemoryStream_ReadAttribute( Self : TMemoryStream; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TMemoryStream_WriteAttribute( Self : TMemoryStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TStringStream_ReadAttribute( Self : TStringStream; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TStringStream_WriteAttribute( Self : TStringStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TResourceStream_ReadAttribute( Self : TResourceStream; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TResourceStream_WriteAttribute( Self : TResourceStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TStreamAdapter_ReadAttribute( Self : TStreamAdapter; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TStreamAdapter_WriteAttribute( Self : TStreamAdapter; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TFiler_ReadAttribute( Self : TFiler; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TFiler_WriteAttribute( Self : TFiler; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TReader_ReadAttribute( Self : TReader; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TReader_WriteAttribute( Self : TReader; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TWriter_ReadAttribute( Self : TWriter; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TWriter_WriteAttribute( Self : TWriter; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TParser_ReadAttribute( Self : TParser; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TParser_WriteAttribute( Self : TParser; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TThread_ReadAttribute( Self : TThread; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TThread_WriteAttribute( Self : TThread; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TComponent_ReadAttribute( Self : TComponent; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TComponent_WriteAttribute( Self : TComponent; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TBasicActionLink_ReadAttribute( Self : TBasicActionLink; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TBasicActionLink_WriteAttribute( Self : TBasicActionLink; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TBasicAction_ReadAttribute( Self : TBasicAction; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TBasicAction_WriteAttribute( Self : TBasicAction; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;

  procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 

implementation

uses
   Delphi_System,
   Delphi_Classes,
   Python_System,
   Py_Misc,
   PyRecords,
   PyDelphiAssoc;

var
  IsInitialized : Boolean;
  gClasses : TModule_Classes;
  gEStreamError : TMethodsContainer;
  gEFCreateError : TMethodsContainer;
  gEFOpenError : TMethodsContainer;
  gEFilerError : TMethodsContainer;
  gEReadError : TMethodsContainer;
  gEWriteError : TMethodsContainer;
  gEClassNotFound : TMethodsContainer;
  gEMethodNotFound : TMethodsContainer;
  gEInvalidImage : TMethodsContainer;
  gEResNotFound : TMethodsContainer;
  gEListError : TMethodsContainer;
  gEBitsError : TMethodsContainer;
  gEStringListError : TMethodsContainer;
  gEComponentError : TMethodsContainer;
  gEParserError : TMethodsContainer;
  gEOutOfResources : TMethodsContainer;
  gEInvalidOperation : TMethodsContainer;
  gTList : TMethodsContainer;
  gTThreadList : TMethodsContainer;
  gTBits : TMethodsContainer;
  gTPersistent : TMethodsContainer;
  gTCollectionItem : TMethodsContainer;
  gTCollection : TMethodsContainer;
  gTOwnedCollection : TMethodsContainer;
  gTStrings : TMethodsContainer;
  gTStringList : TMethodsContainer;
  gTStream : TMethodsContainer;
  gTHandleStream : TMethodsContainer;
  gTFileStream : TMethodsContainer;
  gTCustomMemoryStream : TMethodsContainer;
  gTMemoryStream : TMethodsContainer;
  gTStringStream : TMethodsContainer;
  gTResourceStream : TMethodsContainer;
  gTStreamAdapter : TMethodsContainer;
  gTFiler : TMethodsContainer;
  gTReader : TMethodsContainer;
  gTWriter : TMethodsContainer;
  gTParser : TMethodsContainer;
  gEThread : TMethodsContainer;
  gTThread : TMethodsContainer;
  gTComponent : TMethodsContainer;
  gTBasicActionLink : TMethodsContainer;
  gTBasicAction : TMethodsContainer;

procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 
begin
  if IsInitialized then
    Exit;
  IsInitialized := True;
  gClasses := TModule_Classes.Create( AOwner );
  with gClasses do
    begin
      Engine := AEngine;
      ModuleName := '_Classes';
    end;
  gEStreamError := TMethodsContainer.Create( AOwner );
  gEFCreateError := TMethodsContainer.Create( AOwner );
  gEFOpenError := TMethodsContainer.Create( AOwner );
  gEFilerError := TMethodsContainer.Create( AOwner );
  gEReadError := TMethodsContainer.Create( AOwner );
  gEWriteError := TMethodsContainer.Create( AOwner );
  gEClassNotFound := TMethodsContainer.Create( AOwner );
  gEMethodNotFound := TMethodsContainer.Create( AOwner );
  gEInvalidImage := TMethodsContainer.Create( AOwner );
  gEResNotFound := TMethodsContainer.Create( AOwner );
  gEListError := TMethodsContainer.Create( AOwner );
  gEBitsError := TMethodsContainer.Create( AOwner );
  gEStringListError := TMethodsContainer.Create( AOwner );
  gEComponentError := TMethodsContainer.Create( AOwner );
  gEParserError := TMethodsContainer.Create( AOwner );
  gEOutOfResources := TMethodsContainer.Create( AOwner );
  gEInvalidOperation := TMethodsContainer.Create( AOwner );
  gTList := TMethodsContainer.Create( AOwner );
  gTThreadList := TMethodsContainer.Create( AOwner );
  gTBits := TMethodsContainer.Create( AOwner );
  gTPersistent := TMethodsContainer.Create( AOwner );
  gTCollectionItem := TMethodsContainer.Create( AOwner );
  gTCollection := TMethodsContainer.Create( AOwner );
  gTOwnedCollection := TMethodsContainer.Create( AOwner );
  gTStrings := TMethodsContainer.Create( AOwner );
  gTStringList := TMethodsContainer.Create( AOwner );
  gTStream := TMethodsContainer.Create( AOwner );
  gTHandleStream := TMethodsContainer.Create( AOwner );
  gTFileStream := TMethodsContainer.Create( AOwner );
  gTCustomMemoryStream := TMethodsContainer.Create( AOwner );
  gTMemoryStream := TMethodsContainer.Create( AOwner );
  gTStringStream := TMethodsContainer.Create( AOwner );
  gTResourceStream := TMethodsContainer.Create( AOwner );
  gTStreamAdapter := TMethodsContainer.Create( AOwner );
  gTFiler := TMethodsContainer.Create( AOwner );
  gTReader := TMethodsContainer.Create( AOwner );
  gTWriter := TMethodsContainer.Create( AOwner );
  gTParser := TMethodsContainer.Create( AOwner );
  gEThread := TMethodsContainer.Create( AOwner );
  gTThread := TMethodsContainer.Create( AOwner );
  gTComponent := TMethodsContainer.Create( AOwner );
  gTBasicActionLink := TMethodsContainer.Create( AOwner );
  gTBasicAction := TMethodsContainer.Create( AOwner );
end;

///////////// Functions for class TList //////////////////

function TList_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyList;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TList.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyList.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TList_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TList) then begin
      ErrorWrongExpectedType( argSelf, 'TList' );
      Exit;
    end;
    realObj := TList(obj);
    // Check attribute
    Result := TList_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TList_ReadAttribute( Self : TList; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTList.MethodCount > 0 then 
      Result := Py_FindMethod( gTList.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Capacity' ) = 0 then Result := VariantAsPyObject( Self.Capacity )
    else if CompareText( key, 'Count' ) = 0 then Result := VariantAsPyObject( Self.Count )
    else if CompareText( key, 'List' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'PPointerList' ); Result := nil; end
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TList_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TList) then begin
      ErrorWrongExpectedType( argSelf, 'TList' );
      Exit;
    end;
    realObj := TList(obj);
    // Check attribute
    Result := TList_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TList_WriteAttribute( Self : TList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Capacity' ) = 0 then begin
      Self.Capacity := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Count' ) = 0 then begin
      Self.Count := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'List' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TList_Add( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TList_Clear( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TList) then begin
      ErrorWrongExpectedType( Self, 'TList' );
      Exit;
    end;
    realObj := TList(obj);
    realObj.Clear;
    Result := ReturnNone;
  end;
end;

function TList_Delete( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TList;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TList.Delete', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TList) then begin
      ErrorWrongExpectedType( Self, 'TList' );
      Exit;
    end;
    realObj := TList(obj);
    realObj.Delete( Integer(_argIndex) );
    Result := ReturnNone;
  end;
end;

function TList_Error( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TList;
  _argMsg : PChar;
  _argData : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'si:TList.Error', [ 
                  @_argMsg,
                  @_argData       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TList) then begin
      ErrorWrongExpectedType( Self, 'TList' );
      Exit;
    end;
    realObj := TList(obj);
    realObj.Error( string(_argMsg), Integer(_argData) );
    Result := ReturnNone;
  end;
end;

function TList_Exchange( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TList;
  _argIndex1 : Integer;
  _argIndex2 : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TList.Exchange', [ 
                  @_argIndex1,
                  @_argIndex2       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TList) then begin
      ErrorWrongExpectedType( Self, 'TList' );
      Exit;
    end;
    realObj := TList(obj);
    realObj.Exchange( Integer(_argIndex1), Integer(_argIndex2) );
    Result := ReturnNone;
  end;
end;

function TList_Expand( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TList;
  rslt : TList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TList) then begin
      ErrorWrongExpectedType( Self, 'TList' );
      Exit;
    end;
    realObj := TList(obj);
    rslt := realObj.Expand;
    Result := GetPythonObject( rslt, 'Classes', 'TList' );
  end;
end;

function TList_First( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TList;
  rslt : Pointer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TList) then begin
      ErrorWrongExpectedType( Self, 'TList' );
      Exit;
    end;
    realObj := TList(obj);
    rslt := realObj.First;
    Result := ReturnNone;
  end;
end;

function TList_IndexOf( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TList_Insert( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TList_Last( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TList;
  rslt : Pointer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TList) then begin
      ErrorWrongExpectedType( Self, 'TList' );
      Exit;
    end;
    realObj := TList(obj);
    rslt := realObj.Last;
    Result := ReturnNone;
  end;
end;

function TList_Move( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TList;
  _argCurIndex : Integer;
  _argNewIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TList.Move', [ 
                  @_argCurIndex,
                  @_argNewIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TList) then begin
      ErrorWrongExpectedType( Self, 'TList' );
      Exit;
    end;
    realObj := TList(obj);
    realObj.Move( Integer(_argCurIndex), Integer(_argNewIndex) );
    Result := ReturnNone;
  end;
end;

function TList_Remove( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TList_Pack( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TList) then begin
      ErrorWrongExpectedType( Self, 'TList' );
      Exit;
    end;
    realObj := TList(obj);
    realObj.Pack;
    Result := ReturnNone;
  end;
end;

function TList_Sort( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TList_Items( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TList;
  rslt : Pointer;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TList.Items', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TList) then begin
      ErrorWrongExpectedType( Self, 'TList' );
      Exit;
    end;
    realObj := TList(obj);
    rslt := realObj.Items[ Integer(_argIndex) ];
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TThreadList //////////////////

function TThreadList_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyThreadList;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TThreadList.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyThreadList.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TThreadList_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TThreadList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TThreadList) then begin
      ErrorWrongExpectedType( argSelf, 'TThreadList' );
      Exit;
    end;
    realObj := TThreadList(obj);
    // Check attribute
    Result := TThreadList_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TThreadList_ReadAttribute( Self : TThreadList; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTThreadList.MethodCount > 0 then 
      Result := Py_FindMethod( gTThreadList.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TThreadList_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TThreadList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TThreadList) then begin
      ErrorWrongExpectedType( argSelf, 'TThreadList' );
      Exit;
    end;
    realObj := TThreadList(obj);
    // Check attribute
    Result := TThreadList_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TThreadList_WriteAttribute( Self : TThreadList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TThreadList_Add( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TThreadList_Clear( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TThreadList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TThreadList) then begin
      ErrorWrongExpectedType( Self, 'TThreadList' );
      Exit;
    end;
    realObj := TThreadList(obj);
    realObj.Clear;
    Result := ReturnNone;
  end;
end;

function TThreadList_LockList( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TThreadList;
  rslt : TList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TThreadList) then begin
      ErrorWrongExpectedType( Self, 'TThreadList' );
      Exit;
    end;
    realObj := TThreadList(obj);
    rslt := realObj.LockList;
    Result := GetPythonObject( rslt, 'Classes', 'TList' );
  end;
end;

function TThreadList_Remove( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TThreadList_UnlockList( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TThreadList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TThreadList) then begin
      ErrorWrongExpectedType( Self, 'TThreadList' );
      Exit;
    end;
    realObj := TThreadList(obj);
    realObj.UnlockList;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TBits //////////////////

function TBits_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyBits;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TBits.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyBits.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TBits_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBits;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBits) then begin
      ErrorWrongExpectedType( argSelf, 'TBits' );
      Exit;
    end;
    realObj := TBits(obj);
    // Check attribute
    Result := TBits_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TBits_ReadAttribute( Self : TBits; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTBits.MethodCount > 0 then 
      Result := Py_FindMethod( gTBits.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Size' ) = 0 then Result := VariantAsPyObject( Self.Size )
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TBits_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBits;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBits) then begin
      ErrorWrongExpectedType( argSelf, 'TBits' );
      Exit;
    end;
    realObj := TBits(obj);
    // Check attribute
    Result := TBits_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TBits_WriteAttribute( Self : TBits; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Size' ) = 0 then begin
      Self.Size := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TBits_OpenBit( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBits;
  rslt : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBits) then begin
      ErrorWrongExpectedType( Self, 'TBits' );
      Exit;
    end;
    realObj := TBits(obj);
    rslt := realObj.OpenBit;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TBits_Bits( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBits;
  rslt : Boolean;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TBits.Bits', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBits) then begin
      ErrorWrongExpectedType( Self, 'TBits' );
      Exit;
    end;
    realObj := TBits(obj);
    rslt := realObj.Bits[ Integer(_argIndex) ];
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TPersistent //////////////////

function TPersistent_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyPersistent;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TPersistent.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyPersistent.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TPersistent_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TPersistent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TPersistent) then begin
      ErrorWrongExpectedType( argSelf, 'TPersistent' );
      Exit;
    end;
    realObj := TPersistent(obj);
    // Check attribute
    Result := TPersistent_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TPersistent_ReadAttribute( Self : TPersistent; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTPersistent.MethodCount > 0 then 
      Result := Py_FindMethod( gTPersistent.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TPersistent_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TPersistent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TPersistent) then begin
      ErrorWrongExpectedType( argSelf, 'TPersistent' );
      Exit;
    end;
    realObj := TPersistent(obj);
    // Check attribute
    Result := TPersistent_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TPersistent_WriteAttribute( Self : TPersistent; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TPersistent_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TPersistent;
  _argSource : PPyObject;
  _objSource : TPersistent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TPersistent.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TPersistent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TPersistent) then begin
      ErrorWrongExpectedType( Self, 'TPersistent' );
      Exit;
    end;
    realObj := TPersistent(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

function TPersistent_GetNamePath( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TPersistent;
  rslt : string;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TPersistent) then begin
      ErrorWrongExpectedType( Self, 'TPersistent' );
      Exit;
    end;
    realObj := TPersistent(obj);
    rslt := realObj.GetNamePath;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TCollectionItem //////////////////

function TCollectionItem_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCollectionItem;
  _argSelf : PPyObject;
  _argCollection : PPyObject;
  _objCollection : TCollection;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TCollectionItem.Create', [ @_argSelf,
                  @_argCollection       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objCollection := GetObjectOf( _argCollection ) as TCollection;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCollectionItem.Create( _objCollection );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCollectionItem_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCollectionItem;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCollectionItem) then begin
      ErrorWrongExpectedType( argSelf, 'TCollectionItem' );
      Exit;
    end;
    realObj := TCollectionItem(obj);
    // Check attribute
    Result := TCollectionItem_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TCollectionItem_ReadAttribute( Self : TCollectionItem; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTCollectionItem.MethodCount > 0 then 
      Result := Py_FindMethod( gTCollectionItem.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Collection' ) = 0 then Result := GetPythonObject( Self.Collection, 'Classes', 'TCollection' )
    else if CompareText( key, 'ID' ) = 0 then Result := VariantAsPyObject( Self.ID )
    else if CompareText( key, 'Index' ) = 0 then Result := VariantAsPyObject( Self.Index )
    else if CompareText( key, 'DisplayName' ) = 0 then Result := VariantAsPyObject( Self.DisplayName )
    else Result := TPersistent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TCollectionItem_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCollectionItem;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCollectionItem) then begin
      ErrorWrongExpectedType( argSelf, 'TCollectionItem' );
      Exit;
    end;
    realObj := TCollectionItem(obj);
    // Check attribute
    Result := TCollectionItem_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TCollectionItem_WriteAttribute( Self : TCollectionItem; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Collection' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TCollection then begin
        Self.Collection := TCollection( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Collection', 'TCollection' );
    end else if CompareText( key, 'ID' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Index' ) = 0 then begin
      Self.Index := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DisplayName' ) = 0 then begin
      Self.DisplayName := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TPersistent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TCollectionItem_GetNamePath( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCollectionItem;
  rslt : string;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCollectionItem) then begin
      ErrorWrongExpectedType( Self, 'TCollectionItem' );
      Exit;
    end;
    realObj := TCollectionItem(obj);
    rslt := realObj.GetNamePath;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TCollection //////////////////

function TCollection_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCollection;
  _argSelf : PPyObject;
  _argItemClass : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TCollection.Create', [ @_argSelf,
                  @_argItemClass       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    //    newObj := TPyCollection.Create( nil );
    //DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCollection_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCollection;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCollection) then begin
      ErrorWrongExpectedType( argSelf, 'TCollection' );
      Exit;
    end;
    realObj := TCollection(obj);
    // Check attribute
    Result := TCollection_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TCollection_ReadAttribute( Self : TCollection; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTCollection.MethodCount > 0 then 
      Result := Py_FindMethod( gTCollection.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Count' ) = 0 then Result := VariantAsPyObject( Self.Count )
    else if CompareText( key, 'ItemClass' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TCollectionItemClass' ); Result := nil; end
    else Result := TPersistent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TCollection_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCollection;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCollection) then begin
      ErrorWrongExpectedType( argSelf, 'TCollection' );
      Exit;
    end;
    realObj := TCollection(obj);
    // Check attribute
    Result := TCollection_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TCollection_WriteAttribute( Self : TCollection; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Count' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ItemClass' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TPersistent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TCollection_Add( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCollection;
  rslt : TCollectionItem;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCollection) then begin
      ErrorWrongExpectedType( Self, 'TCollection' );
      Exit;
    end;
    realObj := TCollection(obj);
    rslt := realObj.Add;
    Result := GetPythonObject( rslt, 'Classes', 'TCollectionItem' );
  end;
end;

function TCollection_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCollection;
  _argSource : PPyObject;
  _objSource : TPersistent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCollection.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TPersistent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCollection) then begin
      ErrorWrongExpectedType( Self, 'TCollection' );
      Exit;
    end;
    realObj := TCollection(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

function TCollection_BeginUpdate( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCollection;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCollection) then begin
      ErrorWrongExpectedType( Self, 'TCollection' );
      Exit;
    end;
    realObj := TCollection(obj);
    realObj.BeginUpdate;
    Result := ReturnNone;
  end;
end;

function TCollection_Clear( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCollection;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCollection) then begin
      ErrorWrongExpectedType( Self, 'TCollection' );
      Exit;
    end;
    realObj := TCollection(obj);
    realObj.Clear;
    Result := ReturnNone;
  end;
end;

function TCollection_EndUpdate( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCollection;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCollection) then begin
      ErrorWrongExpectedType( Self, 'TCollection' );
      Exit;
    end;
    realObj := TCollection(obj);
    realObj.EndUpdate;
    Result := ReturnNone;
  end;
end;

function TCollection_FindItemID( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCollection;
  rslt : TCollectionItem;
  _argID : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TCollection.FindItemID', [ 
                  @_argID       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCollection) then begin
      ErrorWrongExpectedType( Self, 'TCollection' );
      Exit;
    end;
    realObj := TCollection(obj);
    rslt := realObj.FindItemID( Integer(_argID) );
    Result := GetPythonObject( rslt, 'Classes', 'TCollectionItem' );
  end;
end;

function TCollection_GetNamePath( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCollection;
  rslt : string;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCollection) then begin
      ErrorWrongExpectedType( Self, 'TCollection' );
      Exit;
    end;
    realObj := TCollection(obj);
    rslt := realObj.GetNamePath;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCollection_Insert( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCollection;
  rslt : TCollectionItem;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TCollection.Insert', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCollection) then begin
      ErrorWrongExpectedType( Self, 'TCollection' );
      Exit;
    end;
    realObj := TCollection(obj);
    rslt := realObj.Insert( Integer(_argIndex) );
    Result := GetPythonObject( rslt, 'Classes', 'TCollectionItem' );
  end;
end;

function TCollection_Items( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCollection;
  rslt : TCollectionItem;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TCollection.Items', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCollection) then begin
      ErrorWrongExpectedType( Self, 'TCollection' );
      Exit;
    end;
    realObj := TCollection(obj);
    rslt := realObj.Items[ Integer(_argIndex) ];
    Result := GetPythonObject( rslt, 'Classes', 'TCollectionItem' );
  end;
end;

///////////// Functions for class TOwnedCollection //////////////////

function TOwnedCollection_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyOwnedCollection;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TPersistent;
  _argItemClass : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OOO:TOwnedCollection.Create', [ @_argSelf,
                  @_argAOwner,
                  @_argItemClass       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TPersistent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    //    newObj := TPyOwnedCollection.Create( _objAOwner, nil );
    //DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TOwnedCollection_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TOwnedCollection;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TOwnedCollection) then begin
      ErrorWrongExpectedType( argSelf, 'TOwnedCollection' );
      Exit;
    end;
    realObj := TOwnedCollection(obj);
    // Check attribute
    Result := TOwnedCollection_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TOwnedCollection_ReadAttribute( Self : TOwnedCollection; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTOwnedCollection.MethodCount > 0 then 
      Result := Py_FindMethod( gTOwnedCollection.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TCollection_ReadAttribute( Self, argSelf, key );
  end;
end;

function TOwnedCollection_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TOwnedCollection;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TOwnedCollection) then begin
      ErrorWrongExpectedType( argSelf, 'TOwnedCollection' );
      Exit;
    end;
    realObj := TOwnedCollection(obj);
    // Check attribute
    Result := TOwnedCollection_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TOwnedCollection_WriteAttribute( Self : TOwnedCollection; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TCollection_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TStrings //////////////////

function TStrings_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyStrings;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TStrings.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyStrings.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TStrings_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TStrings;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( argSelf, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    // Check attribute
    Result := TStrings_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TStrings_ReadAttribute( Self : TStrings; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTStrings.MethodCount > 0 then 
      Result := Py_FindMethod( gTStrings.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Capacity' ) = 0 then Result := VariantAsPyObject( Self.Capacity )
    else if CompareText( key, 'CommaText' ) = 0 then Result := VariantAsPyObject( Self.CommaText )
    else if CompareText( key, 'Count' ) = 0 then Result := VariantAsPyObject( Self.Count )
    else if CompareText( key, 'Text' ) = 0 then Result := VariantAsPyObject( Self.Text )
    else if CompareText( key, 'StringsAdapter' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'IStringsAdapter' ); Result := nil; end
    else Result := TPersistent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TStrings_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TStrings;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( argSelf, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    // Check attribute
    Result := TStrings_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TStrings_WriteAttribute( Self : TStrings; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Capacity' ) = 0 then begin
      Self.Capacity := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'CommaText' ) = 0 then begin
      Self.CommaText := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Count' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Text' ) = 0 then begin
      Self.Text := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'StringsAdapter' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'IStringsAdapter' );
    end else Result := TPersistent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TStrings_Add( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  rslt : Integer;
  _argS : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TStrings.Add', [ 
                  @_argS       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    rslt := realObj.Add( string(_argS) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStrings_AddObject( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  rslt : Integer;
  _argS : PChar;
  _argAObject : PPyObject;
  _objAObject : TObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'sO:TStrings.AddObject', [ 
                  @_argS,
                  @_argAObject       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAObject := GetObjectOf( _argAObject ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    rslt := realObj.AddObject( string(_argS), _objAObject );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStrings_Append( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  _argS : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TStrings.Append', [ 
                  @_argS       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.Append( string(_argS) );
    Result := ReturnNone;
  end;
end;

function TStrings_AddStrings( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  _argStrings : PPyObject;
  _objStrings : TStrings;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TStrings.AddStrings', [ 
                  @_argStrings       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStrings := GetObjectOf( _argStrings ) as TStrings;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.AddStrings( _objStrings );
    Result := ReturnNone;
  end;
end;

function TStrings_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  _argSource : PPyObject;
  _objSource : TPersistent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TStrings.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TPersistent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

function TStrings_BeginUpdate( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.BeginUpdate;
    Result := ReturnNone;
  end;
end;

function TStrings_Clear( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.Clear;
    Result := ReturnNone;
  end;
end;

function TStrings_Delete( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TStrings.Delete', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.Delete( Integer(_argIndex) );
    Result := ReturnNone;
  end;
end;

function TStrings_EndUpdate( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.EndUpdate;
    Result := ReturnNone;
  end;
end;

function TStrings_Equals( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  rslt : Boolean;
  _argStrings : PPyObject;
  _objStrings : TStrings;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TStrings.Equals', [ 
                  @_argStrings       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStrings := GetObjectOf( _argStrings ) as TStrings;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    rslt := realObj.Equals( _objStrings );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStrings_Exchange( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  _argIndex1 : Integer;
  _argIndex2 : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TStrings.Exchange', [ 
                  @_argIndex1,
                  @_argIndex2       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.Exchange( Integer(_argIndex1), Integer(_argIndex2) );
    Result := ReturnNone;
  end;
end;

function TStrings_GetText( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  rslt : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    rslt := realObj.GetText;
    Result := PyString_FromString( rslt );
  end;
end;

function TStrings_IndexOf( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  rslt : Integer;
  _argS : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TStrings.IndexOf', [ 
                  @_argS       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    rslt := realObj.IndexOf( string(_argS) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStrings_IndexOfName( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  rslt : Integer;
  _argName : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TStrings.IndexOfName', [ 
                  @_argName       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    rslt := realObj.IndexOfName( string(_argName) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStrings_IndexOfObject( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  rslt : Integer;
  _argAObject : PPyObject;
  _objAObject : TObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TStrings.IndexOfObject', [ 
                  @_argAObject       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAObject := GetObjectOf( _argAObject ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    rslt := realObj.IndexOfObject( _objAObject );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStrings_Insert( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  _argIndex : Integer;
  _argS : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'is:TStrings.Insert', [ 
                  @_argIndex,
                  @_argS       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.Insert( Integer(_argIndex), string(_argS) );
    Result := ReturnNone;
  end;
end;

function TStrings_InsertObject( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  _argIndex : Integer;
  _argS : PChar;
  _argAObject : PPyObject;
  _objAObject : TObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'isO:TStrings.InsertObject', [ 
                  @_argIndex,
                  @_argS,
                  @_argAObject       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAObject := GetObjectOf( _argAObject ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.InsertObject( Integer(_argIndex), string(_argS), _objAObject );
    Result := ReturnNone;
  end;
end;

function TStrings_LoadFromFile( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  _argFileName : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TStrings.LoadFromFile', [ 
                  @_argFileName       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.LoadFromFile( string(_argFileName) );
    Result := ReturnNone;
  end;
end;

function TStrings_LoadFromStream( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TStrings.LoadFromStream', [ 
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.LoadFromStream( _objStream );
    Result := ReturnNone;
  end;
end;

function TStrings_Move( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  _argCurIndex : Integer;
  _argNewIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TStrings.Move', [ 
                  @_argCurIndex,
                  @_argNewIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.Move( Integer(_argCurIndex), Integer(_argNewIndex) );
    Result := ReturnNone;
  end;
end;

function TStrings_SaveToFile( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  _argFileName : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TStrings.SaveToFile', [ 
                  @_argFileName       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.SaveToFile( string(_argFileName) );
    Result := ReturnNone;
  end;
end;

function TStrings_SaveToStream( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TStrings.SaveToStream', [ 
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.SaveToStream( _objStream );
    Result := ReturnNone;
  end;
end;

function TStrings_SetText( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  _argText : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TStrings.SetText', [ 
                  @_argText       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    realObj.SetText( PChar(_argText) );
    Result := ReturnNone;
  end;
end;

function TStrings_Names( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  rslt : string;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TStrings.Names', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    rslt := realObj.Names[ Integer(_argIndex) ];
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStrings_Objects( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  rslt : TObject;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TStrings.Objects', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    rslt := realObj.Objects[ Integer(_argIndex) ];
    Result := GetPythonObject( rslt, 'Classes', 'TObject' );
  end;
end;

function TStrings_Values( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  rslt : string;
  _argName : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TStrings.Values', [ 
                  @_argName       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    rslt := realObj.Values[ string(_argName) ];
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStrings_Strings( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStrings;
  rslt : string;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TStrings.Strings', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStrings) then begin
      ErrorWrongExpectedType( Self, 'TStrings' );
      Exit;
    end;
    realObj := TStrings(obj);
    rslt := realObj.Strings[ Integer(_argIndex) ];
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TStringList //////////////////

function TStringList_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyStringList;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TStringList.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyStringList.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TStringList_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TStringList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TStringList) then begin
      ErrorWrongExpectedType( argSelf, 'TStringList' );
      Exit;
    end;
    realObj := TStringList(obj);
    // Check attribute
    Result := TStringList_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TStringList_ReadAttribute( Self : TStringList; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTStringList.MethodCount > 0 then 
      Result := Py_FindMethod( gTStringList.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Duplicates' ) = 0 then Result := VariantAsPyObject( Integer( Self.Duplicates ) )
    else if CompareText( key, 'Sorted' ) = 0 then Result := VariantAsPyObject( Self.Sorted )
    else if CompareText( key, 'OnChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnChanging' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else Result := TStrings_ReadAttribute( Self, argSelf, key );
  end;
end;

function TStringList_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TStringList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TStringList) then begin
      ErrorWrongExpectedType( argSelf, 'TStringList' );
      Exit;
    end;
    realObj := TStringList(obj);
    // Check attribute
    Result := TStringList_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TStringList_WriteAttribute( Self : TStringList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Duplicates' ) = 0 then begin
      Self.Duplicates := TDuplicates(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Sorted' ) = 0 then begin
      Self.Sorted := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyStringList then
          with TPyStringList(Self) do
            OnChange := EventOnChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnChanging' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChanging := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyStringList then
          with TPyStringList(Self) do
            OnChanging := EventOnChanging;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TStrings_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TStringList_Add( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStringList;
  rslt : Integer;
  _argS : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TStringList.Add', [ 
                  @_argS       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStringList) then begin
      ErrorWrongExpectedType( Self, 'TStringList' );
      Exit;
    end;
    realObj := TStringList(obj);
    rslt := realObj.Add( string(_argS) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStringList_Clear( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStringList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStringList) then begin
      ErrorWrongExpectedType( Self, 'TStringList' );
      Exit;
    end;
    realObj := TStringList(obj);
    realObj.Clear;
    Result := ReturnNone;
  end;
end;

function TStringList_Delete( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStringList;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TStringList.Delete', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStringList) then begin
      ErrorWrongExpectedType( Self, 'TStringList' );
      Exit;
    end;
    realObj := TStringList(obj);
    realObj.Delete( Integer(_argIndex) );
    Result := ReturnNone;
  end;
end;

function TStringList_Exchange( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStringList;
  _argIndex1 : Integer;
  _argIndex2 : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TStringList.Exchange', [ 
                  @_argIndex1,
                  @_argIndex2       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStringList) then begin
      ErrorWrongExpectedType( Self, 'TStringList' );
      Exit;
    end;
    realObj := TStringList(obj);
    realObj.Exchange( Integer(_argIndex1), Integer(_argIndex2) );
    Result := ReturnNone;
  end;
end;

function TStringList_Find( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStringList_IndexOf( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStringList;
  rslt : Integer;
  _argS : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TStringList.IndexOf', [ 
                  @_argS       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStringList) then begin
      ErrorWrongExpectedType( Self, 'TStringList' );
      Exit;
    end;
    realObj := TStringList(obj);
    rslt := realObj.IndexOf( string(_argS) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStringList_Insert( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStringList;
  _argIndex : Integer;
  _argS : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'is:TStringList.Insert', [ 
                  @_argIndex,
                  @_argS       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStringList) then begin
      ErrorWrongExpectedType( Self, 'TStringList' );
      Exit;
    end;
    realObj := TStringList(obj);
    realObj.Insert( Integer(_argIndex), string(_argS) );
    Result := ReturnNone;
  end;
end;

function TStringList_Sort( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStringList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStringList) then begin
      ErrorWrongExpectedType( Self, 'TStringList' );
      Exit;
    end;
    realObj := TStringList(obj);
    realObj.Sort;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TStream //////////////////

function TStream_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyStream;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TStream.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyStream.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TStream_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TStream) then begin
      ErrorWrongExpectedType( argSelf, 'TStream' );
      Exit;
    end;
    realObj := TStream(obj);
    // Check attribute
    Result := TStream_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TStream_ReadAttribute( Self : TStream; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTStream.MethodCount > 0 then 
      Result := Py_FindMethod( gTStream.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Position' ) = 0 then Result := VariantAsPyObject( Self.Position )
    else if CompareText( key, 'Size' ) = 0 then Result := VariantAsPyObject( Self.Size )
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TStream_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TStream) then begin
      ErrorWrongExpectedType( argSelf, 'TStream' );
      Exit;
    end;
    realObj := TStream(obj);
    // Check attribute
    Result := TStream_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TStream_WriteAttribute( Self : TStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Position' ) = 0 then begin
      Self.Position := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Size' ) = 0 then begin
      Self.Size := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TStream_Read( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStream_Write( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStream_Seek( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStream;
  rslt : Longint;
  _argOffset : Integer;
  _argOrigin : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TStream.Seek', [ 
                  @_argOffset,
                  @_argOrigin       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStream) then begin
      ErrorWrongExpectedType( Self, 'TStream' );
      Exit;
    end;
    realObj := TStream(obj);
    rslt := realObj.Seek( Longint(_argOffset), Word(_argOrigin) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStream_ReadBuffer( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStream_WriteBuffer( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStream_CopyFrom( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStream;
  rslt : Longint;
  _argSource : PPyObject;
  _objSource : TStream;
  _argCount : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'Oi:TStream.CopyFrom', [ 
                  @_argSource,
                  @_argCount       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStream) then begin
      ErrorWrongExpectedType( Self, 'TStream' );
      Exit;
    end;
    realObj := TStream(obj);
    rslt := realObj.CopyFrom( _objSource, Longint(_argCount) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStream_ReadComponent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStream;
  rslt : TComponent;
  _argInstance : PPyObject;
  _objInstance : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TStream.ReadComponent', [ 
                  @_argInstance       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objInstance := GetObjectOf( _argInstance ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStream) then begin
      ErrorWrongExpectedType( Self, 'TStream' );
      Exit;
    end;
    realObj := TStream(obj);
    rslt := realObj.ReadComponent( _objInstance );
    Result := GetPythonObject( rslt, 'Classes', 'TComponent' );
  end;
end;

function TStream_ReadComponentRes( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStream;
  rslt : TComponent;
  _argInstance : PPyObject;
  _objInstance : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TStream.ReadComponentRes', [ 
                  @_argInstance       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objInstance := GetObjectOf( _argInstance ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStream) then begin
      ErrorWrongExpectedType( Self, 'TStream' );
      Exit;
    end;
    realObj := TStream(obj);
    rslt := realObj.ReadComponentRes( _objInstance );
    Result := GetPythonObject( rslt, 'Classes', 'TComponent' );
  end;
end;

function TStream_WriteComponent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStream;
  _argInstance : PPyObject;
  _objInstance : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TStream.WriteComponent', [ 
                  @_argInstance       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objInstance := GetObjectOf( _argInstance ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStream) then begin
      ErrorWrongExpectedType( Self, 'TStream' );
      Exit;
    end;
    realObj := TStream(obj);
    realObj.WriteComponent( _objInstance );
    Result := ReturnNone;
  end;
end;

function TStream_WriteComponentRes( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStream;
  _argResName : PChar;
  _argInstance : PPyObject;
  _objInstance : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'sO:TStream.WriteComponentRes', [ 
                  @_argResName,
                  @_argInstance       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objInstance := GetObjectOf( _argInstance ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStream) then begin
      ErrorWrongExpectedType( Self, 'TStream' );
      Exit;
    end;
    realObj := TStream(obj);
    realObj.WriteComponentRes( string(_argResName), _objInstance );
    Result := ReturnNone;
  end;
end;

function TStream_WriteDescendent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStream;
  _argInstance : PPyObject;
  _objInstance : TComponent;
  _argAncestor : PPyObject;
  _objAncestor : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'OO:TStream.WriteDescendent', [ 
                  @_argInstance,
                  @_argAncestor       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objInstance := GetObjectOf( _argInstance ) as TComponent;
    _objAncestor := GetObjectOf( _argAncestor ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStream) then begin
      ErrorWrongExpectedType( Self, 'TStream' );
      Exit;
    end;
    realObj := TStream(obj);
    realObj.WriteDescendent( _objInstance, _objAncestor );
    Result := ReturnNone;
  end;
end;

function TStream_WriteDescendentRes( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStream;
  _argResName : PChar;
  _argInstance : PPyObject;
  _objInstance : TComponent;
  _argAncestor : PPyObject;
  _objAncestor : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'sOO:TStream.WriteDescendentRes', [ 
                  @_argResName,
                  @_argInstance,
                  @_argAncestor       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objInstance := GetObjectOf( _argInstance ) as TComponent;
    _objAncestor := GetObjectOf( _argAncestor ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStream) then begin
      ErrorWrongExpectedType( Self, 'TStream' );
      Exit;
    end;
    realObj := TStream(obj);
    realObj.WriteDescendentRes( string(_argResName), _objInstance, _objAncestor );
    Result := ReturnNone;
  end;
end;

function TStream_ReadResHeader( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStream) then begin
      ErrorWrongExpectedType( Self, 'TStream' );
      Exit;
    end;
    realObj := TStream(obj);
    realObj.ReadResHeader;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class THandleStream //////////////////

function THandleStream_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyHandleStream;
  _argSelf : PPyObject;
  _argAHandle : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:THandleStream.Create', [ @_argSelf,
                  @_argAHandle       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyHandleStream.Create( Integer(_argAHandle) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function THandleStream_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : THandleStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is THandleStream) then begin
      ErrorWrongExpectedType( argSelf, 'THandleStream' );
      Exit;
    end;
    realObj := THandleStream(obj);
    // Check attribute
    Result := THandleStream_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function THandleStream_ReadAttribute( Self : THandleStream; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTHandleStream.MethodCount > 0 then 
      Result := Py_FindMethod( gTHandleStream.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Handle' ) = 0 then Result := VariantAsPyObject( Self.Handle )
    else Result := TStream_ReadAttribute( Self, argSelf, key );
  end;
end;

function THandleStream_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : THandleStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is THandleStream) then begin
      ErrorWrongExpectedType( argSelf, 'THandleStream' );
      Exit;
    end;
    realObj := THandleStream(obj);
    // Check attribute
    Result := THandleStream_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function THandleStream_WriteAttribute( Self : THandleStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Handle' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TStream_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function THandleStream_Read( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function THandleStream_Write( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function THandleStream_Seek( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : THandleStream;
  rslt : Longint;
  _argOffset : Integer;
  _argOrigin : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:THandleStream.Seek', [ 
                  @_argOffset,
                  @_argOrigin       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is THandleStream) then begin
      ErrorWrongExpectedType( Self, 'THandleStream' );
      Exit;
    end;
    realObj := THandleStream(obj);
    rslt := realObj.Seek( Longint(_argOffset), Word(_argOrigin) );
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TFileStream //////////////////

function TFileStream_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyFileStream;
  _argSelf : PPyObject;
  _argFileName : PChar;
  _argMode : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Osi:TFileStream.Create', [ @_argSelf,
                  @_argFileName,
                  @_argMode       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyFileStream.Create( string(_argFileName), Word(_argMode) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TFileStream_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TFileStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TFileStream) then begin
      ErrorWrongExpectedType( argSelf, 'TFileStream' );
      Exit;
    end;
    realObj := TFileStream(obj);
    // Check attribute
    Result := TFileStream_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TFileStream_ReadAttribute( Self : TFileStream; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTFileStream.MethodCount > 0 then 
      Result := Py_FindMethod( gTFileStream.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := THandleStream_ReadAttribute( Self, argSelf, key );
  end;
end;

function TFileStream_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TFileStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TFileStream) then begin
      ErrorWrongExpectedType( argSelf, 'TFileStream' );
      Exit;
    end;
    realObj := TFileStream(obj);
    // Check attribute
    Result := TFileStream_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TFileStream_WriteAttribute( Self : TFileStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := THandleStream_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TCustomMemoryStream //////////////////

function TCustomMemoryStream_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomMemoryStream;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TCustomMemoryStream.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomMemoryStream.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomMemoryStream_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomMemoryStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomMemoryStream) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomMemoryStream' );
      Exit;
    end;
    realObj := TCustomMemoryStream(obj);
    // Check attribute
    Result := TCustomMemoryStream_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TCustomMemoryStream_ReadAttribute( Self : TCustomMemoryStream; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTCustomMemoryStream.MethodCount > 0 then 
      Result := Py_FindMethod( gTCustomMemoryStream.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Memory' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'Pointer' ); Result := nil; end
    else Result := TStream_ReadAttribute( Self, argSelf, key );
  end;
end;

function TCustomMemoryStream_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomMemoryStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomMemoryStream) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomMemoryStream' );
      Exit;
    end;
    realObj := TCustomMemoryStream(obj);
    // Check attribute
    Result := TCustomMemoryStream_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TCustomMemoryStream_WriteAttribute( Self : TCustomMemoryStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Memory' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TStream_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TCustomMemoryStream_Read( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TCustomMemoryStream_Seek( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomMemoryStream;
  rslt : Longint;
  _argOffset : Integer;
  _argOrigin : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TCustomMemoryStream.Seek', [ 
                  @_argOffset,
                  @_argOrigin       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomMemoryStream) then begin
      ErrorWrongExpectedType( Self, 'TCustomMemoryStream' );
      Exit;
    end;
    realObj := TCustomMemoryStream(obj);
    rslt := realObj.Seek( Longint(_argOffset), Word(_argOrigin) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomMemoryStream_SaveToStream( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomMemoryStream;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCustomMemoryStream.SaveToStream', [ 
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomMemoryStream) then begin
      ErrorWrongExpectedType( Self, 'TCustomMemoryStream' );
      Exit;
    end;
    realObj := TCustomMemoryStream(obj);
    realObj.SaveToStream( _objStream );
    Result := ReturnNone;
  end;
end;

function TCustomMemoryStream_SaveToFile( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomMemoryStream;
  _argFileName : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TCustomMemoryStream.SaveToFile', [ 
                  @_argFileName       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomMemoryStream) then begin
      ErrorWrongExpectedType( Self, 'TCustomMemoryStream' );
      Exit;
    end;
    realObj := TCustomMemoryStream(obj);
    realObj.SaveToFile( string(_argFileName) );
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TMemoryStream //////////////////

function TMemoryStream_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyMemoryStream;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TMemoryStream.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyMemoryStream.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TMemoryStream_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMemoryStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMemoryStream) then begin
      ErrorWrongExpectedType( argSelf, 'TMemoryStream' );
      Exit;
    end;
    realObj := TMemoryStream(obj);
    // Check attribute
    Result := TMemoryStream_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TMemoryStream_ReadAttribute( Self : TMemoryStream; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTMemoryStream.MethodCount > 0 then 
      Result := Py_FindMethod( gTMemoryStream.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TCustomMemoryStream_ReadAttribute( Self, argSelf, key );
  end;
end;

function TMemoryStream_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMemoryStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMemoryStream) then begin
      ErrorWrongExpectedType( argSelf, 'TMemoryStream' );
      Exit;
    end;
    realObj := TMemoryStream(obj);
    // Check attribute
    Result := TMemoryStream_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TMemoryStream_WriteAttribute( Self : TMemoryStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TCustomMemoryStream_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TMemoryStream_Clear( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMemoryStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMemoryStream) then begin
      ErrorWrongExpectedType( Self, 'TMemoryStream' );
      Exit;
    end;
    realObj := TMemoryStream(obj);
    realObj.Clear;
    Result := ReturnNone;
  end;
end;

function TMemoryStream_LoadFromStream( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMemoryStream;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TMemoryStream.LoadFromStream', [ 
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMemoryStream) then begin
      ErrorWrongExpectedType( Self, 'TMemoryStream' );
      Exit;
    end;
    realObj := TMemoryStream(obj);
    realObj.LoadFromStream( _objStream );
    Result := ReturnNone;
  end;
end;

function TMemoryStream_LoadFromFile( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMemoryStream;
  _argFileName : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TMemoryStream.LoadFromFile', [ 
                  @_argFileName       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMemoryStream) then begin
      ErrorWrongExpectedType( Self, 'TMemoryStream' );
      Exit;
    end;
    realObj := TMemoryStream(obj);
    realObj.LoadFromFile( string(_argFileName) );
    Result := ReturnNone;
  end;
end;

function TMemoryStream_SetSize( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMemoryStream;
  _argNewSize : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TMemoryStream.SetSize', [ 
                  @_argNewSize       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMemoryStream) then begin
      ErrorWrongExpectedType( Self, 'TMemoryStream' );
      Exit;
    end;
    realObj := TMemoryStream(obj);
    realObj.SetSize( Longint(_argNewSize) );
    Result := ReturnNone;
  end;
end;

function TMemoryStream_Write( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TStringStream //////////////////

function TStringStream_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyStringStream;
  _argSelf : PPyObject;
  _argAString : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Os:TStringStream.Create', [ @_argSelf,
                  @_argAString       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyStringStream.Create( string(_argAString) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TStringStream_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TStringStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TStringStream) then begin
      ErrorWrongExpectedType( argSelf, 'TStringStream' );
      Exit;
    end;
    realObj := TStringStream(obj);
    // Check attribute
    Result := TStringStream_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TStringStream_ReadAttribute( Self : TStringStream; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTStringStream.MethodCount > 0 then 
      Result := Py_FindMethod( gTStringStream.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'DataString' ) = 0 then Result := VariantAsPyObject( Self.DataString )
    else Result := TStream_ReadAttribute( Self, argSelf, key );
  end;
end;

function TStringStream_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TStringStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TStringStream) then begin
      ErrorWrongExpectedType( argSelf, 'TStringStream' );
      Exit;
    end;
    realObj := TStringStream(obj);
    // Check attribute
    Result := TStringStream_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TStringStream_WriteAttribute( Self : TStringStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'DataString' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TStream_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TStringStream_Read( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStringStream_ReadString( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStringStream;
  rslt : string;
  _argCount : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TStringStream.ReadString', [ 
                  @_argCount       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStringStream) then begin
      ErrorWrongExpectedType( Self, 'TStringStream' );
      Exit;
    end;
    realObj := TStringStream(obj);
    rslt := realObj.ReadString( Longint(_argCount) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStringStream_Seek( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStringStream;
  rslt : Longint;
  _argOffset : Integer;
  _argOrigin : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TStringStream.Seek', [ 
                  @_argOffset,
                  @_argOrigin       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStringStream) then begin
      ErrorWrongExpectedType( Self, 'TStringStream' );
      Exit;
    end;
    realObj := TStringStream(obj);
    rslt := realObj.Seek( Longint(_argOffset), Word(_argOrigin) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStringStream_Write( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStringStream_WriteString( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStringStream;
  _argAString : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TStringStream.WriteString', [ 
                  @_argAString       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStringStream) then begin
      ErrorWrongExpectedType( Self, 'TStringStream' );
      Exit;
    end;
    realObj := TStringStream(obj);
    realObj.WriteString( string(_argAString) );
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TResourceStream //////////////////

function TResourceStream_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyResourceStream;
  _argSelf : PPyObject;
  _argInstance : Integer;
  _argResName : PChar;
  _argResType : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oiss:TResourceStream.Create', [ @_argSelf,
                  @_argInstance,
                  @_argResName,
                  @_argResType       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyResourceStream.Create( THandle(_argInstance), string(_argResName), PChar(_argResType) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TResourceStream_CreateFromID( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyResourceStream;
  _argSelf : PPyObject;
  _argInstance : Integer;
  _argResID : Integer;
  _argResType : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oiis:TResourceStream.CreateFromID', [ @_argSelf,
                  @_argInstance,
                  @_argResID,
                  @_argResType       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyResourceStream.CreateFromID( THandle(_argInstance), Integer(_argResID), PChar(_argResType) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TResourceStream_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TResourceStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TResourceStream) then begin
      ErrorWrongExpectedType( argSelf, 'TResourceStream' );
      Exit;
    end;
    realObj := TResourceStream(obj);
    // Check attribute
    Result := TResourceStream_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TResourceStream_ReadAttribute( Self : TResourceStream; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTResourceStream.MethodCount > 0 then 
      Result := Py_FindMethod( gTResourceStream.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TCustomMemoryStream_ReadAttribute( Self, argSelf, key );
  end;
end;

function TResourceStream_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TResourceStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TResourceStream) then begin
      ErrorWrongExpectedType( argSelf, 'TResourceStream' );
      Exit;
    end;
    realObj := TResourceStream(obj);
    // Check attribute
    Result := TResourceStream_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TResourceStream_WriteAttribute( Self : TResourceStream; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TCustomMemoryStream_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TResourceStream_Write( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TStreamAdapter //////////////////

function TStreamAdapter_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyStreamAdapter;
  _argSelf : PPyObject;
  _argStream : PPyObject;
  _objStream : TStream;
  _argOwnership : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OOi:TStreamAdapter.Create', [ @_argSelf,
                  @_argStream,
                  @_argOwnership       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyStreamAdapter.Create( _objStream, TStreamOwnership(_argOwnership) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TStreamAdapter_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TStreamAdapter;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TStreamAdapter) then begin
      ErrorWrongExpectedType( argSelf, 'TStreamAdapter' );
      Exit;
    end;
    realObj := TStreamAdapter(obj);
    // Check attribute
    Result := TStreamAdapter_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TStreamAdapter_ReadAttribute( Self : TStreamAdapter; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTStreamAdapter.MethodCount > 0 then 
      Result := Py_FindMethod( gTStreamAdapter.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Stream' ) = 0 then Result := GetPythonObject( Self.Stream, 'Classes', 'TStream' )
    else if CompareText( key, 'StreamOwnership' ) = 0 then Result := VariantAsPyObject( Integer( Self.StreamOwnership ) )
    else Result := TInterfacedObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TStreamAdapter_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TStreamAdapter;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TStreamAdapter) then begin
      ErrorWrongExpectedType( argSelf, 'TStreamAdapter' );
      Exit;
    end;
    realObj := TStreamAdapter(obj);
    // Check attribute
    Result := TStreamAdapter_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TStreamAdapter_WriteAttribute( Self : TStreamAdapter; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Stream' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'StreamOwnership' ) = 0 then begin
      Self.StreamOwnership := TStreamOwnership(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else Result := TInterfacedObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TStreamAdapter_Read( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStreamAdapter_Write( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStreamAdapter_Seek( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStreamAdapter_SetSize( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStreamAdapter_CopyTo( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStreamAdapter_Commit( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStreamAdapter;
  rslt : HResult;
  _arggrfCommitFlags : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TStreamAdapter.Commit', [ 
                  @_arggrfCommitFlags       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStreamAdapter) then begin
      ErrorWrongExpectedType( Self, 'TStreamAdapter' );
      Exit;
    end;
    realObj := TStreamAdapter(obj);
    rslt := realObj.Commit( Longint(_arggrfCommitFlags) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStreamAdapter_Revert( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TStreamAdapter;
  rslt : HResult;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TStreamAdapter) then begin
      ErrorWrongExpectedType( Self, 'TStreamAdapter' );
      Exit;
    end;
    realObj := TStreamAdapter(obj);
    rslt := realObj.Revert;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TStreamAdapter_LockRegion( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStreamAdapter_UnlockRegion( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStreamAdapter_Stat( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TStreamAdapter_Clone( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TFiler //////////////////

function TFiler_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyFiler;
  _argSelf : PPyObject;
  _argStream : PPyObject;
  _objStream : TStream;
  _argBufSize : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OOi:TFiler.Create', [ @_argSelf,
                  @_argStream,
                  @_argBufSize       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyFiler.Create( _objStream, Integer(_argBufSize) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TFiler_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TFiler;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TFiler) then begin
      ErrorWrongExpectedType( argSelf, 'TFiler' );
      Exit;
    end;
    realObj := TFiler(obj);
    // Check attribute
    Result := TFiler_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TFiler_ReadAttribute( Self : TFiler; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTFiler.MethodCount > 0 then 
      Result := Py_FindMethod( gTFiler.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Root' ) = 0 then Result := GetPythonObject( Self.Root, 'Classes', 'TComponent' )
    else if CompareText( key, 'Ancestor' ) = 0 then Result := GetPythonObject( Self.Ancestor, 'Classes', 'TPersistent' )
    else if CompareText( key, 'IgnoreChildren' ) = 0 then Result := VariantAsPyObject( Self.IgnoreChildren )
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TFiler_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TFiler;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TFiler) then begin
      ErrorWrongExpectedType( argSelf, 'TFiler' );
      Exit;
    end;
    realObj := TFiler(obj);
    // Check attribute
    Result := TFiler_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TFiler_WriteAttribute( Self : TFiler; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Root' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TComponent then begin
        Self.Root := TComponent( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Root', 'TComponent' );
    end else if CompareText( key, 'Ancestor' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TPersistent then begin
        Self.Ancestor := TPersistent( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Ancestor', 'TPersistent' );
    end else if CompareText( key, 'IgnoreChildren' ) = 0 then begin
      Self.IgnoreChildren := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TFiler_DefineProperty( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TFiler_DefineBinaryProperty( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TFiler_FlushBuffer( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TFiler;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TFiler) then begin
      ErrorWrongExpectedType( Self, 'TFiler' );
      Exit;
    end;
    realObj := TFiler(obj);
    realObj.FlushBuffer;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TReader //////////////////

function TReader_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyReader;
  _argSelf : PPyObject;
  _argStream : PPyObject;
  _objStream : TStream;
  _argBufSize : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OOi:TReader.Create', [ @_argSelf,
                  @_argStream,
                  @_argBufSize       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyReader.Create( _objStream, Integer(_argBufSize) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TReader_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TReader;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( argSelf, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    // Check attribute
    Result := TReader_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TReader_ReadAttribute( Self : TReader; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTReader.MethodCount > 0 then 
      Result := Py_FindMethod( gTReader.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Owner' ) = 0 then Result := GetPythonObject( Self.Owner, 'Classes', 'TComponent' )
    else if CompareText( key, 'Parent' ) = 0 then Result := GetPythonObject( Self.Parent, 'Classes', 'TComponent' )
    else if CompareText( key, 'Position' ) = 0 then Result := VariantAsPyObject( Self.Position )
    else if CompareText( key, 'OnError' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TReaderError' ); Result := nil; end
    else if CompareText( key, 'OnFindMethod' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TFindMethodEvent' ); Result := nil; end
    else if CompareText( key, 'OnSetName' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TSetNameEvent' ); Result := nil; end
    else if CompareText( key, 'OnReferenceName' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TReferenceNameEvent' ); Result := nil; end
    else if CompareText( key, 'OnAncestorNotFound' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TAncestorNotFoundEvent' ); Result := nil; end
    else Result := TFiler_ReadAttribute( Self, argSelf, key );
  end;
end;

function TReader_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TReader;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( argSelf, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    // Check attribute
    Result := TReader_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TReader_WriteAttribute( Self : TReader; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Owner' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TComponent then begin
        Self.Owner := TComponent( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Owner', 'TComponent' );
    end else if CompareText( key, 'Parent' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TComponent then begin
        Self.Parent := TComponent( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Parent', 'TComponent' );
    end else if CompareText( key, 'Position' ) = 0 then begin
      Self.Position := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnError' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnError := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyReader then
          with TPyReader(Self) do
            OnError := EventOnError;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnFindMethod' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnFindMethod := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyReader then
          with TPyReader(Self) do
            OnFindMethod := EventOnFindMethod;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnSetName' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnSetName := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyReader then
          with TPyReader(Self) do
            OnSetName := EventOnSetName;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnReferenceName' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnReferenceName := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyReader then
          with TPyReader(Self) do
            OnReferenceName := EventOnReferenceName;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnAncestorNotFound' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnAncestorNotFound := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyReader then
          with TPyReader(Self) do
            OnAncestorNotFound := EventOnAncestorNotFound;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TFiler_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TReader_BeginReferences( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    realObj.BeginReferences;
    Result := ReturnNone;
  end;
end;

function TReader_DefineProperty( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TReader_DefineBinaryProperty( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TReader_EndOfList( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.EndOfList;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TReader_EndReferences( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    realObj.EndReferences;
    Result := ReturnNone;
  end;
end;

function TReader_FixupReferences( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    realObj.FixupReferences;
    Result := ReturnNone;
  end;
end;

function TReader_FlushBuffer( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    realObj.FlushBuffer;
    Result := ReturnNone;
  end;
end;

function TReader_NextValue( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : TValueType;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.NextValue;
    Result := VariantAsPyObject( Integer( rslt ) );
  end;
end;

function TReader_Read( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TReader_ReadBoolean( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadBoolean;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TReader_ReadChar( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : Char;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadChar;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TReader_ReadCollection( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  _argCollection : PPyObject;
  _objCollection : TCollection;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TReader.ReadCollection', [ 
                  @_argCollection       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objCollection := GetObjectOf( _argCollection ) as TCollection;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    realObj.ReadCollection( _objCollection );
    Result := ReturnNone;
  end;
end;

function TReader_ReadComponent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : TComponent;
  _argComponent : PPyObject;
  _objComponent : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TReader.ReadComponent', [ 
                  @_argComponent       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objComponent := GetObjectOf( _argComponent ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadComponent( _objComponent );
    Result := GetPythonObject( rslt, 'Classes', 'TComponent' );
  end;
end;

function TReader_ReadComponents( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TReader_ReadFloat( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : Extended;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadFloat;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TReader_ReadSingle( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : Single;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadSingle;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TReader_ReadCurrency( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : Currency;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadCurrency;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TReader_ReadDate( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : TDateTime;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadDate;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TReader_ReadIdent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : string;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadIdent;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TReader_ReadInteger( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : Longint;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadInteger;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TReader_ReadListBegin( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    realObj.ReadListBegin;
    Result := ReturnNone;
  end;
end;

function TReader_ReadListEnd( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    realObj.ReadListEnd;
    Result := ReturnNone;
  end;
end;

function TReader_ReadPrefix( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TReader_ReadRootComponent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : TComponent;
  _argRoot : PPyObject;
  _objRoot : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TReader.ReadRootComponent', [ 
                  @_argRoot       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objRoot := GetObjectOf( _argRoot ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadRootComponent( _objRoot );
    Result := GetPythonObject( rslt, 'Classes', 'TComponent' );
  end;
end;

function TReader_ReadSignature( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    realObj.ReadSignature;
    Result := ReturnNone;
  end;
end;

function TReader_ReadStr( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : string;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadStr;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TReader_ReadString( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : string;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadString;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TReader_ReadWideString( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : WideString;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadWideString;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TReader_ReadValue( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  rslt : TValueType;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    rslt := realObj.ReadValue;
    Result := VariantAsPyObject( Integer( rslt ) );
  end;
end;

function TReader_CopyValue( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TReader;
  _argWriter : PPyObject;
  _objWriter : TWriter;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TReader.CopyValue', [ 
                  @_argWriter       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objWriter := GetObjectOf( _argWriter ) as TWriter;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TReader) then begin
      ErrorWrongExpectedType( Self, 'TReader' );
      Exit;
    end;
    realObj := TReader(obj);
    realObj.CopyValue( _objWriter );
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TWriter //////////////////

function TWriter_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyWriter;
  _argSelf : PPyObject;
  _argStream : PPyObject;
  _objStream : TStream;
  _argBufSize : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OOi:TWriter.Create', [ @_argSelf,
                  @_argStream,
                  @_argBufSize       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyWriter.Create( _objStream, Integer(_argBufSize) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TWriter_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TWriter;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( argSelf, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    // Check attribute
    Result := TWriter_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TWriter_ReadAttribute( Self : TWriter; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTWriter.MethodCount > 0 then 
      Result := Py_FindMethod( gTWriter.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Position' ) = 0 then Result := VariantAsPyObject( Self.Position )
    else if CompareText( key, 'RootAncestor' ) = 0 then Result := GetPythonObject( Self.RootAncestor, 'Classes', 'TComponent' )
    else Result := TFiler_ReadAttribute( Self, argSelf, key );
  end;
end;

function TWriter_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TWriter;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( argSelf, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    // Check attribute
    Result := TWriter_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TWriter_WriteAttribute( Self : TWriter; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Position' ) = 0 then begin
      Self.Position := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'RootAncestor' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TComponent then begin
        Self.RootAncestor := TComponent( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'RootAncestor', 'TComponent' );
    end else Result := TFiler_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TWriter_DefineProperty( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TWriter_DefineBinaryProperty( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TWriter_FlushBuffer( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.FlushBuffer;
    Result := ReturnNone;
  end;
end;

function TWriter_Write( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TWriter_WriteBoolean( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argValue : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TWriter.WriteBoolean', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteBoolean( Boolean(_argValue) );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteCollection( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argValue : PPyObject;
  _objValue : TCollection;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TWriter.WriteCollection', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objValue := GetObjectOf( _argValue ) as TCollection;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteCollection( _objValue );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteComponent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argComponent : PPyObject;
  _objComponent : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TWriter.WriteComponent', [ 
                  @_argComponent       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objComponent := GetObjectOf( _argComponent ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteComponent( _objComponent );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteChar( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argValue : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TWriter.WriteChar', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteChar( PyObjectAsChar(_argValue) );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteDescendent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argRoot : PPyObject;
  _objRoot : TComponent;
  _argAAncestor : PPyObject;
  _objAAncestor : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'OO:TWriter.WriteDescendent', [ 
                  @_argRoot,
                  @_argAAncestor       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objRoot := GetObjectOf( _argRoot ) as TComponent;
    _objAAncestor := GetObjectOf( _argAAncestor ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteDescendent( _objRoot, _objAAncestor );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteFloat( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argValue : Double;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'f:TWriter.WriteFloat', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteFloat( _argValue );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteSingle( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argValue : Double;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'f:TWriter.WriteSingle', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteSingle( _argValue );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteCurrency( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argValue : Double;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'f:TWriter.WriteCurrency', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteCurrency( _argValue );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteDate( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argValue : Double;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'f:TWriter.WriteDate', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteDate( _argValue );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteIdent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argIdent : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TWriter.WriteIdent', [ 
                  @_argIdent       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteIdent( string(_argIdent) );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteInteger( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argValue : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TWriter.WriteInteger', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteInteger( Longint(_argValue) );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteListBegin( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteListBegin;
    Result := ReturnNone;
  end;
end;

function TWriter_WriteListEnd( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteListEnd;
    Result := ReturnNone;
  end;
end;

function TWriter_WriteRootComponent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argRoot : PPyObject;
  _objRoot : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TWriter.WriteRootComponent', [ 
                  @_argRoot       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objRoot := GetObjectOf( _argRoot ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteRootComponent( _objRoot );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteSignature( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteSignature;
    Result := ReturnNone;
  end;
end;

function TWriter_WriteStr( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argValue : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TWriter.WriteStr', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteStr( string(_argValue) );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteString( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argValue : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TWriter.WriteString', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteString( string(_argValue) );
    Result := ReturnNone;
  end;
end;

function TWriter_WriteWideString( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWriter;
  _argValue : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TWriter.WriteWideString', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWriter) then begin
      ErrorWrongExpectedType( Self, 'TWriter' );
      Exit;
    end;
    realObj := TWriter(obj);
    realObj.WriteWideString( WideString(_argValue) );
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TParser //////////////////

function TParser_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyParser;
  _argSelf : PPyObject;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TParser.Create', [ @_argSelf,
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyParser.Create( _objStream );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TParser_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TParser;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( argSelf, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    // Check attribute
    Result := TParser_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TParser_ReadAttribute( Self : TParser; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTParser.MethodCount > 0 then 
      Result := Py_FindMethod( gTParser.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'FloatType' ) = 0 then Result := VariantAsPyObject( Self.FloatType )
    else if CompareText( key, 'SourceLine' ) = 0 then Result := VariantAsPyObject( Self.SourceLine )
    else if CompareText( key, 'Token' ) = 0 then Result := VariantAsPyObject( Self.Token )
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TParser_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TParser;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( argSelf, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    // Check attribute
    Result := TParser_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TParser_WriteAttribute( Self : TParser; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'FloatType' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'SourceLine' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Token' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TParser_CheckToken( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TParser;
  _argT : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TParser.CheckToken', [ 
                  @_argT       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( Self, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    realObj.CheckToken( PyObjectAsChar(_argT) );
    Result := ReturnNone;
  end;
end;

function TParser_CheckTokenSymbol( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TParser;
  _argS : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TParser.CheckTokenSymbol', [ 
                  @_argS       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( Self, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    realObj.CheckTokenSymbol( string(_argS) );
    Result := ReturnNone;
  end;
end;

function TParser_Error( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TParser;
  _argIdent : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TParser.Error', [ 
                  @_argIdent       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( Self, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    realObj.Error( string(_argIdent) );
    Result := ReturnNone;
  end;
end;

function TParser_ErrorFmt( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TParser_ErrorStr( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TParser;
  _argMessage : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TParser.ErrorStr', [ 
                  @_argMessage       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( Self, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    realObj.ErrorStr( string(_argMessage) );
    Result := ReturnNone;
  end;
end;

function TParser_HexToBinary( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TParser;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TParser.HexToBinary', [ 
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( Self, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    realObj.HexToBinary( _objStream );
    Result := ReturnNone;
  end;
end;

function TParser_NextToken( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TParser;
  rslt : Char;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( Self, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    rslt := realObj.NextToken;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TParser_SourcePos( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TParser;
  rslt : Longint;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( Self, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    rslt := realObj.SourcePos;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TParser_TokenComponentIdent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TParser;
  rslt : String;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( Self, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    rslt := realObj.TokenComponentIdent;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TParser_TokenFloat( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TParser;
  rslt : Extended;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( Self, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    rslt := realObj.TokenFloat;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TParser_TokenInt( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TParser;
  rslt : Longint;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( Self, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    rslt := realObj.TokenInt;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TParser_TokenString( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TParser;
  rslt : string;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( Self, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    rslt := realObj.TokenString;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TParser_TokenWideString( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TParser;
  rslt : WideString;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( Self, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    rslt := realObj.TokenWideString;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TParser_TokenSymbolIs( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TParser;
  rslt : Boolean;
  _argS : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TParser.TokenSymbolIs', [ 
                  @_argS       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TParser) then begin
      ErrorWrongExpectedType( Self, 'TParser' );
      Exit;
    end;
    realObj := TParser(obj);
    rslt := realObj.TokenSymbolIs( string(_argS) );
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TThread //////////////////

function TThread_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyThread;
  _argSelf : PPyObject;
  _argCreateSuspended : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:TThread.Create', [ @_argSelf,
                  @_argCreateSuspended       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyThread.Create( Boolean(_argCreateSuspended) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TThread_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TThread;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TThread) then begin
      ErrorWrongExpectedType( argSelf, 'TThread' );
      Exit;
    end;
    realObj := TThread(obj);
    // Check attribute
    Result := TThread_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TThread_ReadAttribute( Self : TThread; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTThread.MethodCount > 0 then 
      Result := Py_FindMethod( gTThread.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'FreeOnTerminate' ) = 0 then Result := VariantAsPyObject( Self.FreeOnTerminate )
    else if CompareText( key, 'Handle' ) = 0 then Result := VariantAsPyObject( Self.Handle )
    else if CompareText( key, 'Priority' ) = 0 then Result := VariantAsPyObject( Integer( Self.Priority ) )
    else if CompareText( key, 'Suspended' ) = 0 then Result := VariantAsPyObject( Self.Suspended )
    else if CompareText( key, 'ThreadID' ) = 0 then Result := VariantAsPyObject( Self.ThreadID )
    else if CompareText( key, 'OnTerminate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TThread_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TThread;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TThread) then begin
      ErrorWrongExpectedType( argSelf, 'TThread' );
      Exit;
    end;
    realObj := TThread(obj);
    // Check attribute
    Result := TThread_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TThread_WriteAttribute( Self : TThread; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'FreeOnTerminate' ) = 0 then begin
      Self.FreeOnTerminate := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Handle' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Priority' ) = 0 then begin
      Self.Priority := TThreadPriority(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Suspended' ) = 0 then begin
      Self.Suspended := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ThreadID' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'OnTerminate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnTerminate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyThread then
          with TPyThread(Self) do
            OnTerminate := EventOnTerminate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TThread_Resume( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TThread;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TThread) then begin
      ErrorWrongExpectedType( Self, 'TThread' );
      Exit;
    end;
    realObj := TThread(obj);
    realObj.Resume;
    Result := ReturnNone;
  end;
end;

function TThread_Suspend( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TThread;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TThread) then begin
      ErrorWrongExpectedType( Self, 'TThread' );
      Exit;
    end;
    realObj := TThread(obj);
    realObj.Suspend;
    Result := ReturnNone;
  end;
end;

function TThread_Terminate( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TThread;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TThread) then begin
      ErrorWrongExpectedType( Self, 'TThread' );
      Exit;
    end;
    realObj := TThread(obj);
    realObj.Terminate;
    Result := ReturnNone;
  end;
end;

function TThread_WaitFor( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TThread;
  rslt : LongWord;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TThread) then begin
      ErrorWrongExpectedType( Self, 'TThread' );
      Exit;
    end;
    realObj := TThread(obj);
    rslt := realObj.WaitFor;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TComponent //////////////////

function TComponent_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyComponent;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TComponent.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyComponent.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TComponent_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( argSelf, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    // Check attribute
    Result := TComponent_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TComponent_ReadAttribute( Self : TComponent; argSelf : PPyObject; key : PChar ) : PPyObject;
var
  tmpComponentState : TComponentState;
  tmpComponentStyle : TComponentStyle;
begin
  with GetPythonEngine do begin
    if gTComponent.MethodCount > 0 then 
      Result := Py_FindMethod( gTComponent.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'ComObject' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'IUnknown' ); Result := nil; end
    else if CompareText( key, 'ComponentCount' ) = 0 then Result := VariantAsPyObject( Self.ComponentCount )
    else if CompareText( key, 'ComponentIndex' ) = 0 then Result := VariantAsPyObject( Self.ComponentIndex )
    else if CompareText( key, 'ComponentState' ) = 0 then begin
      tmpComponentState := Self.ComponentState;
      Result := SetToList( @tmpComponentState, sizeof(tmpComponentState) )
    end
    else if CompareText( key, 'ComponentStyle' ) = 0 then begin
      tmpComponentStyle := Self.ComponentStyle;
      Result := SetToList( @tmpComponentStyle, sizeof(tmpComponentStyle) )
    end
    else if CompareText( key, 'DesignInfo' ) = 0 then Result := VariantAsPyObject( Self.DesignInfo )
    else if CompareText( key, 'Owner' ) = 0 then Result := GetPythonObject( Self.Owner, 'Classes', 'TComponent' )
    else if CompareText( key, 'VCLComObject' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'Pointer' ); Result := nil; end
    else if CompareText( key, 'Name' ) = 0 then Result := VariantAsPyObject( Self.Name )
    else if CompareText( key, 'Tag' ) = 0 then Result := VariantAsPyObject( Self.Tag )
    else Result := TPersistent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TComponent_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( argSelf, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    // Check attribute
    Result := TComponent_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TComponent_WriteAttribute( Self : TComponent; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
  tmpComponentState : TComponentState;
  tmpComponentStyle : TComponentStyle;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'ComObject' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ComponentCount' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ComponentIndex' ) = 0 then begin
      Self.ComponentIndex := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ComponentState' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ComponentStyle' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'DesignInfo' ) = 0 then begin
      Self.DesignInfo := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Owner' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'VCLComObject' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'Pointer' );
    end else if CompareText( key, 'Name' ) = 0 then begin
      Self.Name := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Tag' ) = 0 then begin
      Self.Tag := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TPersistent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TComponent_DestroyComponents( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( Self, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    realObj.DestroyComponents;
    Result := ReturnNone;
  end;
end;

function TComponent_Destroying( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( Self, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    realObj.Destroying;
    Result := ReturnNone;
  end;
end;

function TComponent_ExecuteAction( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TComponent;
  rslt : Boolean;
  _argAction : PPyObject;
  _objAction : TBasicAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TComponent.ExecuteAction', [ 
                  @_argAction       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAction := GetObjectOf( _argAction ) as TBasicAction;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( Self, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    rslt := realObj.ExecuteAction( _objAction );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TComponent_FindComponent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TComponent;
  rslt : TComponent;
  _argAName : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TComponent.FindComponent', [ 
                  @_argAName       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( Self, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    rslt := realObj.FindComponent( string(_argAName) );
    Result := GetPythonObject( rslt, 'Classes', 'TComponent' );
  end;
end;

function TComponent_FreeNotification( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TComponent;
  _argAComponent : PPyObject;
  _objAComponent : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TComponent.FreeNotification', [ 
                  @_argAComponent       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAComponent := GetObjectOf( _argAComponent ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( Self, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    realObj.FreeNotification( _objAComponent );
    Result := ReturnNone;
  end;
end;

function TComponent_FreeOnRelease( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( Self, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    realObj.FreeOnRelease;
    Result := ReturnNone;
  end;
end;

function TComponent_GetParentComponent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TComponent;
  rslt : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( Self, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    rslt := realObj.GetParentComponent;
    Result := GetPythonObject( rslt, 'Classes', 'TComponent' );
  end;
end;

function TComponent_GetNamePath( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TComponent;
  rslt : string;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( Self, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    rslt := realObj.GetNamePath;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TComponent_HasParent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TComponent;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( Self, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    rslt := realObj.HasParent;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TComponent_InsertComponent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TComponent;
  _argAComponent : PPyObject;
  _objAComponent : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TComponent.InsertComponent', [ 
                  @_argAComponent       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAComponent := GetObjectOf( _argAComponent ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( Self, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    realObj.InsertComponent( _objAComponent );
    Result := ReturnNone;
  end;
end;

function TComponent_RemoveComponent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TComponent;
  _argAComponent : PPyObject;
  _objAComponent : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TComponent.RemoveComponent', [ 
                  @_argAComponent       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAComponent := GetObjectOf( _argAComponent ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( Self, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    realObj.RemoveComponent( _objAComponent );
    Result := ReturnNone;
  end;
end;

function TComponent_SafeCallException( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TComponent_UpdateAction( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TComponent;
  rslt : Boolean;
  _argAction : PPyObject;
  _objAction : TBasicAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TComponent.UpdateAction', [ 
                  @_argAction       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAction := GetObjectOf( _argAction ) as TBasicAction;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( Self, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    rslt := realObj.UpdateAction( _objAction );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TComponent_Components( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TComponent;
  rslt : TComponent;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TComponent.Components', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TComponent) then begin
      ErrorWrongExpectedType( Self, 'TComponent' );
      Exit;
    end;
    realObj := TComponent(obj);
    rslt := realObj.Components[ Integer(_argIndex) ];
    Result := GetPythonObject( rslt, 'Classes', 'TComponent' );
  end;
end;

///////////// Functions for class TBasicActionLink //////////////////

function TBasicActionLink_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyBasicActionLink;
  _argSelf : PPyObject;
  _argAClient : PPyObject;
  _objAClient : TObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TBasicActionLink.Create', [ @_argSelf,
                  @_argAClient       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAClient := GetObjectOf( _argAClient ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyBasicActionLink.Create( _objAClient );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TBasicActionLink_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBasicActionLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBasicActionLink) then begin
      ErrorWrongExpectedType( argSelf, 'TBasicActionLink' );
      Exit;
    end;
    realObj := TBasicActionLink(obj);
    // Check attribute
    Result := TBasicActionLink_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TBasicActionLink_ReadAttribute( Self : TBasicActionLink; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTBasicActionLink.MethodCount > 0 then 
      Result := Py_FindMethod( gTBasicActionLink.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Action' ) = 0 then Result := GetPythonObject( Self.Action, 'Classes', 'TBasicAction' )
    else if CompareText( key, 'OnChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TBasicActionLink_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBasicActionLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBasicActionLink) then begin
      ErrorWrongExpectedType( argSelf, 'TBasicActionLink' );
      Exit;
    end;
    realObj := TBasicActionLink(obj);
    // Check attribute
    Result := TBasicActionLink_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TBasicActionLink_WriteAttribute( Self : TBasicActionLink; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Action' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TBasicAction then begin
        Self.Action := TBasicAction( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Action', 'TBasicAction' );
    end else if CompareText( key, 'OnChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyBasicActionLink then
          with TPyBasicActionLink(Self) do
            OnChange := EventOnChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TBasicActionLink_Execute( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBasicActionLink;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBasicActionLink) then begin
      ErrorWrongExpectedType( Self, 'TBasicActionLink' );
      Exit;
    end;
    realObj := TBasicActionLink(obj);
    rslt := realObj.Execute;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TBasicActionLink_Update( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBasicActionLink;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBasicActionLink) then begin
      ErrorWrongExpectedType( Self, 'TBasicActionLink' );
      Exit;
    end;
    realObj := TBasicActionLink(obj);
    rslt := realObj.Update;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TBasicAction //////////////////

function TBasicAction_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyBasicAction;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TBasicAction.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyBasicAction.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TBasicAction_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBasicAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBasicAction) then begin
      ErrorWrongExpectedType( argSelf, 'TBasicAction' );
      Exit;
    end;
    realObj := TBasicAction(obj);
    // Check attribute
    Result := TBasicAction_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TBasicAction_ReadAttribute( Self : TBasicAction; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTBasicAction.MethodCount > 0 then 
      Result := Py_FindMethod( gTBasicAction.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'OnExecute' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnUpdate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else Result := TComponent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TBasicAction_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBasicAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBasicAction) then begin
      ErrorWrongExpectedType( argSelf, 'TBasicAction' );
      Exit;
    end;
    realObj := TBasicAction(obj);
    // Check attribute
    Result := TBasicAction_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TBasicAction_WriteAttribute( Self : TBasicAction; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'OnExecute' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnExecute := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyBasicAction then
          with TPyBasicAction(Self) do
            OnExecute := EventOnExecute;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnUpdate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnUpdate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyBasicAction then
          with TPyBasicAction(Self) do
            OnUpdate := EventOnUpdate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TComponent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TBasicAction_HandlesTarget( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBasicAction;
  rslt : Boolean;
  _argTarget : PPyObject;
  _objTarget : TObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TBasicAction.HandlesTarget', [ 
                  @_argTarget       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objTarget := GetObjectOf( _argTarget ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBasicAction) then begin
      ErrorWrongExpectedType( Self, 'TBasicAction' );
      Exit;
    end;
    realObj := TBasicAction(obj);
    rslt := realObj.HandlesTarget( _objTarget );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TBasicAction_UpdateTarget( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBasicAction;
  _argTarget : PPyObject;
  _objTarget : TObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TBasicAction.UpdateTarget', [ 
                  @_argTarget       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objTarget := GetObjectOf( _argTarget ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBasicAction) then begin
      ErrorWrongExpectedType( Self, 'TBasicAction' );
      Exit;
    end;
    realObj := TBasicAction(obj);
    realObj.UpdateTarget( _objTarget );
    Result := ReturnNone;
  end;
end;

function TBasicAction_ExecuteTarget( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBasicAction;
  _argTarget : PPyObject;
  _objTarget : TObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TBasicAction.ExecuteTarget', [ 
                  @_argTarget       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objTarget := GetObjectOf( _argTarget ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBasicAction) then begin
      ErrorWrongExpectedType( Self, 'TBasicAction' );
      Exit;
    end;
    realObj := TBasicAction(obj);
    realObj.ExecuteTarget( _objTarget );
    Result := ReturnNone;
  end;
end;

function TBasicAction_Execute( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBasicAction;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBasicAction) then begin
      ErrorWrongExpectedType( Self, 'TBasicAction' );
      Exit;
    end;
    realObj := TBasicAction(obj);
    rslt := realObj.Execute;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TBasicAction_RegisterChanges( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBasicAction;
  _argValue : PPyObject;
  _objValue : TBasicActionLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TBasicAction.RegisterChanges', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objValue := GetObjectOf( _argValue ) as TBasicActionLink;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBasicAction) then begin
      ErrorWrongExpectedType( Self, 'TBasicAction' );
      Exit;
    end;
    realObj := TBasicAction(obj);
    realObj.RegisterChanges( _objValue );
    Result := ReturnNone;
  end;
end;

function TBasicAction_UnRegisterChanges( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBasicAction;
  _argValue : PPyObject;
  _objValue : TBasicActionLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TBasicAction.UnRegisterChanges', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objValue := GetObjectOf( _argValue ) as TBasicActionLink;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBasicAction) then begin
      ErrorWrongExpectedType( Self, 'TBasicAction' );
      Exit;
    end;
    realObj := TBasicAction(obj);
    realObj.UnRegisterChanges( _objValue );
    Result := ReturnNone;
  end;
end;

function TBasicAction_Update( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBasicAction;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBasicAction) then begin
      ErrorWrongExpectedType( Self, 'TBasicAction' );
      Exit;
    end;
    realObj := TBasicAction(obj);
    rslt := realObj.Update;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Initialization of the module ///////////

procedure TModule_Classes.Initialize;
begin
  // class TList
  AddMethod( 'CreateList', TList_Create, '' );
  AddMethod( 'List_GetAttr', TList_GetAttr, '' );
  AddMethod( 'List_SetAttr', TList_SetAttr, '' );
  gTList.AddMethod( 'Add', TList_Add, '' );
  gTList.AddMethod( 'Clear', TList_Clear, '' );
  gTList.AddMethod( 'Delete', TList_Delete, '' );
  gTList.AddMethod( 'Error', TList_Error, '' );
  gTList.AddMethod( 'Exchange', TList_Exchange, '' );
  gTList.AddMethod( 'Expand', TList_Expand, '' );
  gTList.AddMethod( 'First', TList_First, '' );
  gTList.AddMethod( 'IndexOf', TList_IndexOf, '' );
  gTList.AddMethod( 'Insert', TList_Insert, '' );
  gTList.AddMethod( 'Last', TList_Last, '' );
  gTList.AddMethod( 'Move', TList_Move, '' );
  gTList.AddMethod( 'Remove', TList_Remove, '' );
  gTList.AddMethod( 'Pack', TList_Pack, '' );
  gTList.AddMethod( 'Sort', TList_Sort, '' );
  gTList.AddMethod( 'Items', TList_Items, '' );
  // class TThreadList
  AddMethod( 'CreateThreadList', TThreadList_Create, '' );
  AddMethod( 'ThreadList_GetAttr', TThreadList_GetAttr, '' );
  AddMethod( 'ThreadList_SetAttr', TThreadList_SetAttr, '' );
  gTThreadList.AddMethod( 'Create', TThreadList_Create, '' );
  gTThreadList.AddMethod( 'Add', TThreadList_Add, '' );
  gTThreadList.AddMethod( 'Clear', TThreadList_Clear, '' );
  gTThreadList.AddMethod( 'LockList', TThreadList_LockList, '' );
  gTThreadList.AddMethod( 'Remove', TThreadList_Remove, '' );
  gTThreadList.AddMethod( 'UnlockList', TThreadList_UnlockList, '' );
  // class TBits
  AddMethod( 'CreateBits', TBits_Create, '' );
  AddMethod( 'Bits_GetAttr', TBits_GetAttr, '' );
  AddMethod( 'Bits_SetAttr', TBits_SetAttr, '' );
  gTBits.AddMethod( 'OpenBit', TBits_OpenBit, '' );
  gTBits.AddMethod( 'Bits', TBits_Bits, '' );
  // class TPersistent
  AddMethod( 'CreatePersistent', TPersistent_Create, '' );
  AddMethod( 'Persistent_GetAttr', TPersistent_GetAttr, '' );
  AddMethod( 'Persistent_SetAttr', TPersistent_SetAttr, '' );
  gTPersistent.AddMethod( 'Assign', TPersistent_Assign, '' );
  gTPersistent.AddMethod( 'GetNamePath', TPersistent_GetNamePath, '' );
  // class TCollectionItem
  AddMethod( 'CreateCollectionItem', TCollectionItem_Create, '' );
  AddMethod( 'CollectionItem_GetAttr', TCollectionItem_GetAttr, '' );
  AddMethod( 'CollectionItem_SetAttr', TCollectionItem_SetAttr, '' );
  gTCollectionItem.AddMethod( 'Create', TCollectionItem_Create, '' );
  gTCollectionItem.AddMethod( 'GetNamePath', TCollectionItem_GetNamePath, '' );
  // class TCollection
  AddMethod( 'CreateCollection', TCollection_Create, '' );
  AddMethod( 'Collection_GetAttr', TCollection_GetAttr, '' );
  AddMethod( 'Collection_SetAttr', TCollection_SetAttr, '' );
  gTCollection.AddMethod( 'Create', TCollection_Create, '' );
  gTCollection.AddMethod( 'Add', TCollection_Add, '' );
  gTCollection.AddMethod( 'Assign', TCollection_Assign, '' );
  gTCollection.AddMethod( 'BeginUpdate', TCollection_BeginUpdate, '' );
  gTCollection.AddMethod( 'Clear', TCollection_Clear, '' );
  gTCollection.AddMethod( 'EndUpdate', TCollection_EndUpdate, '' );
  gTCollection.AddMethod( 'FindItemID', TCollection_FindItemID, '' );
  gTCollection.AddMethod( 'GetNamePath', TCollection_GetNamePath, '' );
  gTCollection.AddMethod( 'Insert', TCollection_Insert, '' );
  gTCollection.AddMethod( 'Items', TCollection_Items, '' );
  // class TOwnedCollection
  AddMethod( 'CreateOwnedCollection', TOwnedCollection_Create, '' );
  AddMethod( 'OwnedCollection_GetAttr', TOwnedCollection_GetAttr, '' );
  AddMethod( 'OwnedCollection_SetAttr', TOwnedCollection_SetAttr, '' );
  gTOwnedCollection.AddMethod( 'Create', TOwnedCollection_Create, '' );
  // class TStrings
  AddMethod( 'CreateStrings', TStrings_Create, '' );
  AddMethod( 'Strings_GetAttr', TStrings_GetAttr, '' );
  AddMethod( 'Strings_SetAttr', TStrings_SetAttr, '' );
  gTStrings.AddMethod( 'Add', TStrings_Add, '' );
  gTStrings.AddMethod( 'AddObject', TStrings_AddObject, '' );
  gTStrings.AddMethod( 'Append', TStrings_Append, '' );
  gTStrings.AddMethod( 'AddStrings', TStrings_AddStrings, '' );
  gTStrings.AddMethod( 'Assign', TStrings_Assign, '' );
  gTStrings.AddMethod( 'BeginUpdate', TStrings_BeginUpdate, '' );
  gTStrings.AddMethod( 'Clear', TStrings_Clear, '' );
  gTStrings.AddMethod( 'Delete', TStrings_Delete, '' );
  gTStrings.AddMethod( 'EndUpdate', TStrings_EndUpdate, '' );
  gTStrings.AddMethod( 'Equals', TStrings_Equals, '' );
  gTStrings.AddMethod( 'Exchange', TStrings_Exchange, '' );
  gTStrings.AddMethod( 'GetText', TStrings_GetText, '' );
  gTStrings.AddMethod( 'IndexOf', TStrings_IndexOf, '' );
  gTStrings.AddMethod( 'IndexOfName', TStrings_IndexOfName, '' );
  gTStrings.AddMethod( 'IndexOfObject', TStrings_IndexOfObject, '' );
  gTStrings.AddMethod( 'Insert', TStrings_Insert, '' );
  gTStrings.AddMethod( 'InsertObject', TStrings_InsertObject, '' );
  gTStrings.AddMethod( 'LoadFromFile', TStrings_LoadFromFile, '' );
  gTStrings.AddMethod( 'LoadFromStream', TStrings_LoadFromStream, '' );
  gTStrings.AddMethod( 'Move', TStrings_Move, '' );
  gTStrings.AddMethod( 'SaveToFile', TStrings_SaveToFile, '' );
  gTStrings.AddMethod( 'SaveToStream', TStrings_SaveToStream, '' );
  gTStrings.AddMethod( 'SetText', TStrings_SetText, '' );
  gTStrings.AddMethod( 'Names', TStrings_Names, '' );
  gTStrings.AddMethod( 'Objects', TStrings_Objects, '' );
  gTStrings.AddMethod( 'Values', TStrings_Values, '' );
  gTStrings.AddMethod( 'Strings', TStrings_Strings, '' );
  // class TStringList
  AddMethod( 'CreateStringList', TStringList_Create, '' );
  AddMethod( 'StringList_GetAttr', TStringList_GetAttr, '' );
  AddMethod( 'StringList_SetAttr', TStringList_SetAttr, '' );
  gTStringList.AddMethod( 'Add', TStringList_Add, '' );
  gTStringList.AddMethod( 'Clear', TStringList_Clear, '' );
  gTStringList.AddMethod( 'Delete', TStringList_Delete, '' );
  gTStringList.AddMethod( 'Exchange', TStringList_Exchange, '' );
  gTStringList.AddMethod( 'Find', TStringList_Find, '' );
  gTStringList.AddMethod( 'IndexOf', TStringList_IndexOf, '' );
  gTStringList.AddMethod( 'Insert', TStringList_Insert, '' );
  gTStringList.AddMethod( 'Sort', TStringList_Sort, '' );
  // class TStream
  AddMethod( 'CreateStream', TStream_Create, '' );
  AddMethod( 'Stream_GetAttr', TStream_GetAttr, '' );
  AddMethod( 'Stream_SetAttr', TStream_SetAttr, '' );
  gTStream.AddMethod( 'Read', TStream_Read, '' );
  gTStream.AddMethod( 'Write', TStream_Write, '' );
  gTStream.AddMethod( 'Seek', TStream_Seek, '' );
  gTStream.AddMethod( 'ReadBuffer', TStream_ReadBuffer, '' );
  gTStream.AddMethod( 'WriteBuffer', TStream_WriteBuffer, '' );
  gTStream.AddMethod( 'CopyFrom', TStream_CopyFrom, '' );
  gTStream.AddMethod( 'ReadComponent', TStream_ReadComponent, '' );
  gTStream.AddMethod( 'ReadComponentRes', TStream_ReadComponentRes, '' );
  gTStream.AddMethod( 'WriteComponent', TStream_WriteComponent, '' );
  gTStream.AddMethod( 'WriteComponentRes', TStream_WriteComponentRes, '' );
  gTStream.AddMethod( 'WriteDescendent', TStream_WriteDescendent, '' );
  gTStream.AddMethod( 'WriteDescendentRes', TStream_WriteDescendentRes, '' );
  gTStream.AddMethod( 'ReadResHeader', TStream_ReadResHeader, '' );
  // class THandleStream
  AddMethod( 'CreateHandleStream', THandleStream_Create, '' );
  AddMethod( 'HandleStream_GetAttr', THandleStream_GetAttr, '' );
  AddMethod( 'HandleStream_SetAttr', THandleStream_SetAttr, '' );
  gTHandleStream.AddMethod( 'Create', THandleStream_Create, '' );
  gTHandleStream.AddMethod( 'Read', THandleStream_Read, '' );
  gTHandleStream.AddMethod( 'Write', THandleStream_Write, '' );
  gTHandleStream.AddMethod( 'Seek', THandleStream_Seek, '' );
  // class TFileStream
  AddMethod( 'CreateFileStream', TFileStream_Create, '' );
  AddMethod( 'FileStream_GetAttr', TFileStream_GetAttr, '' );
  AddMethod( 'FileStream_SetAttr', TFileStream_SetAttr, '' );
  gTFileStream.AddMethod( 'Create', TFileStream_Create, '' );
  // class TCustomMemoryStream
  AddMethod( 'CreateCustomMemoryStream', TCustomMemoryStream_Create, '' );
  AddMethod( 'CustomMemoryStream_GetAttr', TCustomMemoryStream_GetAttr, '' );
  AddMethod( 'CustomMemoryStream_SetAttr', TCustomMemoryStream_SetAttr, '' );
  gTCustomMemoryStream.AddMethod( 'Read', TCustomMemoryStream_Read, '' );
  gTCustomMemoryStream.AddMethod( 'Seek', TCustomMemoryStream_Seek, '' );
  gTCustomMemoryStream.AddMethod( 'SaveToStream', TCustomMemoryStream_SaveToStream, '' );
  gTCustomMemoryStream.AddMethod( 'SaveToFile', TCustomMemoryStream_SaveToFile, '' );
  // class TMemoryStream
  AddMethod( 'CreateMemoryStream', TMemoryStream_Create, '' );
  AddMethod( 'MemoryStream_GetAttr', TMemoryStream_GetAttr, '' );
  AddMethod( 'MemoryStream_SetAttr', TMemoryStream_SetAttr, '' );
  gTMemoryStream.AddMethod( 'Clear', TMemoryStream_Clear, '' );
  gTMemoryStream.AddMethod( 'LoadFromStream', TMemoryStream_LoadFromStream, '' );
  gTMemoryStream.AddMethod( 'LoadFromFile', TMemoryStream_LoadFromFile, '' );
  gTMemoryStream.AddMethod( 'SetSize', TMemoryStream_SetSize, '' );
  gTMemoryStream.AddMethod( 'Write', TMemoryStream_Write, '' );
  // class TStringStream
  AddMethod( 'CreateStringStream', TStringStream_Create, '' );
  AddMethod( 'StringStream_GetAttr', TStringStream_GetAttr, '' );
  AddMethod( 'StringStream_SetAttr', TStringStream_SetAttr, '' );
  gTStringStream.AddMethod( 'Create', TStringStream_Create, '' );
  gTStringStream.AddMethod( 'Read', TStringStream_Read, '' );
  gTStringStream.AddMethod( 'ReadString', TStringStream_ReadString, '' );
  gTStringStream.AddMethod( 'Seek', TStringStream_Seek, '' );
  gTStringStream.AddMethod( 'Write', TStringStream_Write, '' );
  gTStringStream.AddMethod( 'WriteString', TStringStream_WriteString, '' );
  // class TResourceStream
  AddMethod( 'CreateResourceStream', TResourceStream_Create, '' );
  AddMethod( 'CreateFromIDResourceStream', TResourceStream_CreateFromID, '' );
  AddMethod( 'ResourceStream_GetAttr', TResourceStream_GetAttr, '' );
  AddMethod( 'ResourceStream_SetAttr', TResourceStream_SetAttr, '' );
  gTResourceStream.AddMethod( 'Create', TResourceStream_Create, '' );
  gTResourceStream.AddMethod( 'CreateFromID', TResourceStream_CreateFromID, '' );
  gTResourceStream.AddMethod( 'Write', TResourceStream_Write, '' );
  // class TStreamAdapter
  AddMethod( 'CreateStreamAdapter', TStreamAdapter_Create, '' );
  AddMethod( 'StreamAdapter_GetAttr', TStreamAdapter_GetAttr, '' );
  AddMethod( 'StreamAdapter_SetAttr', TStreamAdapter_SetAttr, '' );
  gTStreamAdapter.AddMethod( 'Create', TStreamAdapter_Create, '' );
  gTStreamAdapter.AddMethod( 'Read', TStreamAdapter_Read, '' );
  gTStreamAdapter.AddMethod( 'Write', TStreamAdapter_Write, '' );
  gTStreamAdapter.AddMethod( 'Seek', TStreamAdapter_Seek, '' );
  gTStreamAdapter.AddMethod( 'SetSize', TStreamAdapter_SetSize, '' );
  gTStreamAdapter.AddMethod( 'CopyTo', TStreamAdapter_CopyTo, '' );
  gTStreamAdapter.AddMethod( 'Commit', TStreamAdapter_Commit, '' );
  gTStreamAdapter.AddMethod( 'Revert', TStreamAdapter_Revert, '' );
  gTStreamAdapter.AddMethod( 'LockRegion', TStreamAdapter_LockRegion, '' );
  gTStreamAdapter.AddMethod( 'UnlockRegion', TStreamAdapter_UnlockRegion, '' );
  gTStreamAdapter.AddMethod( 'Stat', TStreamAdapter_Stat, '' );
  gTStreamAdapter.AddMethod( 'Clone', TStreamAdapter_Clone, '' );
  // class TFiler
  AddMethod( 'CreateFiler', TFiler_Create, '' );
  AddMethod( 'Filer_GetAttr', TFiler_GetAttr, '' );
  AddMethod( 'Filer_SetAttr', TFiler_SetAttr, '' );
  gTFiler.AddMethod( 'Create', TFiler_Create, '' );
  gTFiler.AddMethod( 'DefineProperty', TFiler_DefineProperty, '' );
  gTFiler.AddMethod( 'DefineBinaryProperty', TFiler_DefineBinaryProperty, '' );
  gTFiler.AddMethod( 'FlushBuffer', TFiler_FlushBuffer, '' );
  // class TReader
  AddMethod( 'CreateReader', TReader_Create, '' );
  AddMethod( 'Reader_GetAttr', TReader_GetAttr, '' );
  AddMethod( 'Reader_SetAttr', TReader_SetAttr, '' );
  gTReader.AddMethod( 'BeginReferences', TReader_BeginReferences, '' );
  gTReader.AddMethod( 'DefineProperty', TReader_DefineProperty, '' );
  gTReader.AddMethod( 'DefineBinaryProperty', TReader_DefineBinaryProperty, '' );
  gTReader.AddMethod( 'EndOfList', TReader_EndOfList, '' );
  gTReader.AddMethod( 'EndReferences', TReader_EndReferences, '' );
  gTReader.AddMethod( 'FixupReferences', TReader_FixupReferences, '' );
  gTReader.AddMethod( 'FlushBuffer', TReader_FlushBuffer, '' );
  gTReader.AddMethod( 'NextValue', TReader_NextValue, '' );
  gTReader.AddMethod( 'Read', TReader_Read, '' );
  gTReader.AddMethod( 'ReadBoolean', TReader_ReadBoolean, '' );
  gTReader.AddMethod( 'ReadChar', TReader_ReadChar, '' );
  gTReader.AddMethod( 'ReadCollection', TReader_ReadCollection, '' );
  gTReader.AddMethod( 'ReadComponent', TReader_ReadComponent, '' );
  gTReader.AddMethod( 'ReadComponents', TReader_ReadComponents, '' );
  gTReader.AddMethod( 'ReadFloat', TReader_ReadFloat, '' );
  gTReader.AddMethod( 'ReadSingle', TReader_ReadSingle, '' );
  gTReader.AddMethod( 'ReadCurrency', TReader_ReadCurrency, '' );
  gTReader.AddMethod( 'ReadDate', TReader_ReadDate, '' );
  gTReader.AddMethod( 'ReadIdent', TReader_ReadIdent, '' );
  gTReader.AddMethod( 'ReadInteger', TReader_ReadInteger, '' );
  gTReader.AddMethod( 'ReadListBegin', TReader_ReadListBegin, '' );
  gTReader.AddMethod( 'ReadListEnd', TReader_ReadListEnd, '' );
  gTReader.AddMethod( 'ReadPrefix', TReader_ReadPrefix, '' );
  gTReader.AddMethod( 'ReadRootComponent', TReader_ReadRootComponent, '' );
  gTReader.AddMethod( 'ReadSignature', TReader_ReadSignature, '' );
  gTReader.AddMethod( 'ReadStr', TReader_ReadStr, '' );
  gTReader.AddMethod( 'ReadString', TReader_ReadString, '' );
  gTReader.AddMethod( 'ReadWideString', TReader_ReadWideString, '' );
  gTReader.AddMethod( 'ReadValue', TReader_ReadValue, '' );
  gTReader.AddMethod( 'CopyValue', TReader_CopyValue, '' );
  // class TWriter
  AddMethod( 'CreateWriter', TWriter_Create, '' );
  AddMethod( 'Writer_GetAttr', TWriter_GetAttr, '' );
  AddMethod( 'Writer_SetAttr', TWriter_SetAttr, '' );
  gTWriter.AddMethod( 'DefineProperty', TWriter_DefineProperty, '' );
  gTWriter.AddMethod( 'DefineBinaryProperty', TWriter_DefineBinaryProperty, '' );
  gTWriter.AddMethod( 'FlushBuffer', TWriter_FlushBuffer, '' );
  gTWriter.AddMethod( 'Write', TWriter_Write, '' );
  gTWriter.AddMethod( 'WriteBoolean', TWriter_WriteBoolean, '' );
  gTWriter.AddMethod( 'WriteCollection', TWriter_WriteCollection, '' );
  gTWriter.AddMethod( 'WriteComponent', TWriter_WriteComponent, '' );
  gTWriter.AddMethod( 'WriteChar', TWriter_WriteChar, '' );
  gTWriter.AddMethod( 'WriteDescendent', TWriter_WriteDescendent, '' );
  gTWriter.AddMethod( 'WriteFloat', TWriter_WriteFloat, '' );
  gTWriter.AddMethod( 'WriteSingle', TWriter_WriteSingle, '' );
  gTWriter.AddMethod( 'WriteCurrency', TWriter_WriteCurrency, '' );
  gTWriter.AddMethod( 'WriteDate', TWriter_WriteDate, '' );
  gTWriter.AddMethod( 'WriteIdent', TWriter_WriteIdent, '' );
  gTWriter.AddMethod( 'WriteInteger', TWriter_WriteInteger, '' );
  gTWriter.AddMethod( 'WriteListBegin', TWriter_WriteListBegin, '' );
  gTWriter.AddMethod( 'WriteListEnd', TWriter_WriteListEnd, '' );
  gTWriter.AddMethod( 'WriteRootComponent', TWriter_WriteRootComponent, '' );
  gTWriter.AddMethod( 'WriteSignature', TWriter_WriteSignature, '' );
  gTWriter.AddMethod( 'WriteStr', TWriter_WriteStr, '' );
  gTWriter.AddMethod( 'WriteString', TWriter_WriteString, '' );
  gTWriter.AddMethod( 'WriteWideString', TWriter_WriteWideString, '' );
  // class TParser
  AddMethod( 'CreateParser', TParser_Create, '' );
  AddMethod( 'Parser_GetAttr', TParser_GetAttr, '' );
  AddMethod( 'Parser_SetAttr', TParser_SetAttr, '' );
  gTParser.AddMethod( 'Create', TParser_Create, '' );
  gTParser.AddMethod( 'CheckToken', TParser_CheckToken, '' );
  gTParser.AddMethod( 'CheckTokenSymbol', TParser_CheckTokenSymbol, '' );
  gTParser.AddMethod( 'Error', TParser_Error, '' );
  gTParser.AddMethod( 'ErrorFmt', TParser_ErrorFmt, '' );
  gTParser.AddMethod( 'ErrorStr', TParser_ErrorStr, '' );
  gTParser.AddMethod( 'HexToBinary', TParser_HexToBinary, '' );
  gTParser.AddMethod( 'NextToken', TParser_NextToken, '' );
  gTParser.AddMethod( 'SourcePos', TParser_SourcePos, '' );
  gTParser.AddMethod( 'TokenComponentIdent', TParser_TokenComponentIdent, '' );
  gTParser.AddMethod( 'TokenFloat', TParser_TokenFloat, '' );
  gTParser.AddMethod( 'TokenInt', TParser_TokenInt, '' );
  gTParser.AddMethod( 'TokenString', TParser_TokenString, '' );
  gTParser.AddMethod( 'TokenWideString', TParser_TokenWideString, '' );
  gTParser.AddMethod( 'TokenSymbolIs', TParser_TokenSymbolIs, '' );
  // class TThread
  AddMethod( 'CreateThread', TThread_Create, '' );
  AddMethod( 'Thread_GetAttr', TThread_GetAttr, '' );
  AddMethod( 'Thread_SetAttr', TThread_SetAttr, '' );
  gTThread.AddMethod( 'Create', TThread_Create, '' );
  gTThread.AddMethod( 'Resume', TThread_Resume, '' );
  gTThread.AddMethod( 'Suspend', TThread_Suspend, '' );
  gTThread.AddMethod( 'Terminate', TThread_Terminate, '' );
  gTThread.AddMethod( 'WaitFor', TThread_WaitFor, '' );
  // class TComponent
  AddMethod( 'CreateComponent', TComponent_Create, '' );
  AddMethod( 'Component_GetAttr', TComponent_GetAttr, '' );
  AddMethod( 'Component_SetAttr', TComponent_SetAttr, '' );
  gTComponent.AddMethod( 'Create', TComponent_Create, '' );
  gTComponent.AddMethod( 'DestroyComponents', TComponent_DestroyComponents, '' );
  gTComponent.AddMethod( 'Destroying', TComponent_Destroying, '' );
  gTComponent.AddMethod( 'ExecuteAction', TComponent_ExecuteAction, '' );
  gTComponent.AddMethod( 'FindComponent', TComponent_FindComponent, '' );
  gTComponent.AddMethod( 'FreeNotification', TComponent_FreeNotification, '' );
  gTComponent.AddMethod( 'FreeOnRelease', TComponent_FreeOnRelease, '' );
  gTComponent.AddMethod( 'GetParentComponent', TComponent_GetParentComponent, '' );
  gTComponent.AddMethod( 'GetNamePath', TComponent_GetNamePath, '' );
  gTComponent.AddMethod( 'HasParent', TComponent_HasParent, '' );
  gTComponent.AddMethod( 'InsertComponent', TComponent_InsertComponent, '' );
  gTComponent.AddMethod( 'RemoveComponent', TComponent_RemoveComponent, '' );
  gTComponent.AddMethod( 'SafeCallException', TComponent_SafeCallException, '' );
  gTComponent.AddMethod( 'UpdateAction', TComponent_UpdateAction, '' );
  gTComponent.AddMethod( 'Components', TComponent_Components, '' );
  // class TBasicActionLink
  AddMethod( 'CreateBasicActionLink', TBasicActionLink_Create, '' );
  AddMethod( 'BasicActionLink_GetAttr', TBasicActionLink_GetAttr, '' );
  AddMethod( 'BasicActionLink_SetAttr', TBasicActionLink_SetAttr, '' );
  gTBasicActionLink.AddMethod( 'Create', TBasicActionLink_Create, '' );
  gTBasicActionLink.AddMethod( 'Execute', TBasicActionLink_Execute, '' );
  gTBasicActionLink.AddMethod( 'Update', TBasicActionLink_Update, '' );
  // class TBasicAction
  AddMethod( 'CreateBasicAction', TBasicAction_Create, '' );
  AddMethod( 'BasicAction_GetAttr', TBasicAction_GetAttr, '' );
  AddMethod( 'BasicAction_SetAttr', TBasicAction_SetAttr, '' );
  gTBasicAction.AddMethod( 'Create', TBasicAction_Create, '' );
  gTBasicAction.AddMethod( 'HandlesTarget', TBasicAction_HandlesTarget, '' );
  gTBasicAction.AddMethod( 'UpdateTarget', TBasicAction_UpdateTarget, '' );
  gTBasicAction.AddMethod( 'ExecuteTarget', TBasicAction_ExecuteTarget, '' );
  gTBasicAction.AddMethod( 'Execute', TBasicAction_Execute, '' );
  gTBasicAction.AddMethod( 'RegisterChanges', TBasicAction_RegisterChanges, '' );
  gTBasicAction.AddMethod( 'UnRegisterChanges', TBasicAction_UnRegisterChanges, '' );
  gTBasicAction.AddMethod( 'Update', TBasicAction_Update, '' );
  inherited;
end;

end.
