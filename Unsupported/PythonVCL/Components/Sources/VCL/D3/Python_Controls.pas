////
//  This file was generated by VCL Generator
//  Copyright 1998 - Morgan Martinet
//  29/06/1999 12:59:46
//  it declares the content of the module _Controls
////

unit Python_Controls;

interface

uses
   Windows,
   Graphics,
   Menus,
   Controls,
   Messages,
   Classes,
   SysUtils,
   PythonEngine;

type
  TModule_Controls = class( TPythonModule )
  public
    procedure Initialize; override;
  end;

  function TDragObject_ReadAttribute( Self : TDragObject; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TDragObject_WriteAttribute( Self : TDragObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TDragControlObject_ReadAttribute( Self : TDragControlObject; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TDragControlObject_WriteAttribute( Self : TDragControlObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TControlCanvas_ReadAttribute( Self : TControlCanvas; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TControlCanvas_WriteAttribute( Self : TControlCanvas; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TControl_ReadAttribute( Self : TControl; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TControl_WriteAttribute( Self : TControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TWinControl_ReadAttribute( Self : TWinControl; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TWinControl_WriteAttribute( Self : TWinControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TGraphicControl_ReadAttribute( Self : TGraphicControl; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TGraphicControl_WriteAttribute( Self : TGraphicControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TCustomControl_ReadAttribute( Self : TCustomControl; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TCustomControl_WriteAttribute( Self : TCustomControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function THintWindow_ReadAttribute( Self : THintWindow; argSelf : PPyObject; key : PChar ) : PPyObject;
  function THintWindow_WriteAttribute( Self : THintWindow; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TChangeLink_ReadAttribute( Self : TChangeLink; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TChangeLink_WriteAttribute( Self : TChangeLink; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TCustomImageList_ReadAttribute( Self : TCustomImageList; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TCustomImageList_WriteAttribute( Self : TCustomImageList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TImageList_ReadAttribute( Self : TImageList; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TImageList_WriteAttribute( Self : TImageList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;

  procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 

implementation

uses
   Delphi_Classes,
   Python_Classes,
   Delphi_Graphics,
   Python_Graphics,
   Delphi_Menus,
   Python_Menus,
   Delphi_System,
   Delphi_Controls,
   Python_System,
   Py_Misc,
   PyRecords,
   PyDelphiAssoc;

var
  IsInitialized : Boolean;
  gControls : TModule_Controls;
  gTDragObject : TMethodsContainer;
  gTDragControlObject : TMethodsContainer;
  gTControlCanvas : TMethodsContainer;
  gTControl : TMethodsContainer;
  gTWinControl : TMethodsContainer;
  gTGraphicControl : TMethodsContainer;
  gTCustomControl : TMethodsContainer;
  gTHintWindow : TMethodsContainer;
  gTChangeLink : TMethodsContainer;
  gTCustomImageList : TMethodsContainer;
  gTImageList : TMethodsContainer;

procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 
begin
  if IsInitialized then
    Exit;
  IsInitialized := True;
  gControls := TModule_Controls.Create( AOwner );
  with gControls do
    begin
      Engine := AEngine;
      ModuleName := '_Controls';
    end;
  gTDragObject := TMethodsContainer.Create( AOwner );
  gTDragControlObject := TMethodsContainer.Create( AOwner );
  gTControlCanvas := TMethodsContainer.Create( AOwner );
  gTControl := TMethodsContainer.Create( AOwner );
  gTWinControl := TMethodsContainer.Create( AOwner );
  gTGraphicControl := TMethodsContainer.Create( AOwner );
  gTCustomControl := TMethodsContainer.Create( AOwner );
  gTHintWindow := TMethodsContainer.Create( AOwner );
  gTChangeLink := TMethodsContainer.Create( AOwner );
  gTCustomImageList := TMethodsContainer.Create( AOwner );
  gTImageList := TMethodsContainer.Create( AOwner );
end;

///////////// Functions for class TDragObject //////////////////

function TDragObject_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyDragObject;
  _argSelf : PPyObject;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TDragObject.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyDragObject.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TDragObject_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDragObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDragObject) then begin
      ErrorWrongExpectedType( argSelf, 'TDragObject' );
      Exit;
    end;
    realObj := TDragObject(obj);
    // Check attribute
    Result := TDragObject_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TDragObject_ReadAttribute( Self : TDragObject; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTDragObject.MethodCount > 0 then 
      Result := Py_FindMethod( gTDragObject.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TDragObject_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDragObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDragObject) then begin
      ErrorWrongExpectedType( argSelf, 'TDragObject' );
      Exit;
    end;
    realObj := TDragObject(obj);
    // Check attribute
    Result := TDragObject_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TDragObject_WriteAttribute( Self : TDragObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TDragObject_Instance( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragObject;
  rslt : THandle;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragObject) then begin
      ErrorWrongExpectedType( Self, 'TDragObject' );
      Exit;
    end;
    realObj := TDragObject(obj);
    rslt := realObj.Instance;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TDragObject_GetName( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragObject;
  rslt : string;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragObject) then begin
      ErrorWrongExpectedType( Self, 'TDragObject' );
      Exit;
    end;
    realObj := TDragObject(obj);
    rslt := realObj.GetName;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TDragObject_HideDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragObject;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragObject) then begin
      ErrorWrongExpectedType( Self, 'TDragObject' );
      Exit;
    end;
    realObj := TDragObject(obj);
    realObj.HideDragImage;
    Result := ReturnNone;
  end;
end;

function TDragObject_ShowDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragObject;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragObject) then begin
      ErrorWrongExpectedType( Self, 'TDragObject' );
      Exit;
    end;
    realObj := TDragObject(obj);
    realObj.ShowDragImage;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TDragControlObject //////////////////

function TDragControlObject_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyDragControlObject;
  _argSelf : PPyObject;
  _argAControl : PPyObject;
  _objAControl : TControl;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TDragControlObject.Create', [ @_argSelf,
                  @_argAControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAControl := GetObjectOf( _argAControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyDragControlObject.Create( _objAControl );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TDragControlObject_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDragControlObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDragControlObject) then begin
      ErrorWrongExpectedType( argSelf, 'TDragControlObject' );
      Exit;
    end;
    realObj := TDragControlObject(obj);
    // Check attribute
    Result := TDragControlObject_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TDragControlObject_ReadAttribute( Self : TDragControlObject; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTDragControlObject.MethodCount > 0 then 
      Result := Py_FindMethod( gTDragControlObject.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Control' ) = 0 then Result := GetPythonObject( Self.Control, 'Controls', 'TControl' )
    else Result := TDragObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TDragControlObject_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDragControlObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDragControlObject) then begin
      ErrorWrongExpectedType( argSelf, 'TDragControlObject' );
      Exit;
    end;
    realObj := TDragControlObject(obj);
    // Check attribute
    Result := TDragControlObject_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TDragControlObject_WriteAttribute( Self : TDragControlObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Control' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TDragObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TDragControlObject_HideDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragControlObject;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragControlObject) then begin
      ErrorWrongExpectedType( Self, 'TDragControlObject' );
      Exit;
    end;
    realObj := TDragControlObject(obj);
    realObj.HideDragImage;
    Result := ReturnNone;
  end;
end;

function TDragControlObject_ShowDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragControlObject;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragControlObject) then begin
      ErrorWrongExpectedType( Self, 'TDragControlObject' );
      Exit;
    end;
    realObj := TDragControlObject(obj);
    realObj.ShowDragImage;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TControlCanvas //////////////////

function TControlCanvas_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyControlCanvas;
  _argSelf : PPyObject;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TControlCanvas.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyControlCanvas.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TControlCanvas_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TControlCanvas;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TControlCanvas) then begin
      ErrorWrongExpectedType( argSelf, 'TControlCanvas' );
      Exit;
    end;
    realObj := TControlCanvas(obj);
    // Check attribute
    Result := TControlCanvas_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TControlCanvas_ReadAttribute( Self : TControlCanvas; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTControlCanvas.MethodCount > 0 then 
      Result := Py_FindMethod( gTControlCanvas.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Control' ) = 0 then Result := GetPythonObject( Self.Control, 'Controls', 'TControl' )
    else Result := TCanvas_ReadAttribute( Self, argSelf, key );
  end;
end;

function TControlCanvas_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TControlCanvas;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TControlCanvas) then begin
      ErrorWrongExpectedType( argSelf, 'TControlCanvas' );
      Exit;
    end;
    realObj := TControlCanvas(obj);
    // Check attribute
    Result := TControlCanvas_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TControlCanvas_WriteAttribute( Self : TControlCanvas; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Control' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TControl then begin
        Self.Control := TControl( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Control', 'TControl' );
    end else Result := TCanvas_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TControlCanvas_FreeHandle( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControlCanvas;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControlCanvas) then begin
      ErrorWrongExpectedType( Self, 'TControlCanvas' );
      Exit;
    end;
    realObj := TControlCanvas(obj);
    realObj.FreeHandle;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TControl //////////////////

function TControl_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyControl;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TControl.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyControl.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TControl_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( argSelf, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    // Check attribute
    Result := TControl_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TControl_ReadAttribute( Self : TControl; argSelf : PPyObject; key : PChar ) : PPyObject;
var
  tmpControlState : TControlState;
  tmpControlStyle : TControlStyle;
begin
  with GetPythonEngine do begin
    if gTControl.MethodCount > 0 then 
      Result := Py_FindMethod( gTControl.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Align' ) = 0 then Result := VariantAsPyObject( Integer( Self.Align ) )
    else if CompareText( key, 'BoundsRect' ) = 0 then Result := CreateRect( Self.BoundsRect ).GetSelf
    else if CompareText( key, 'ClientHeight' ) = 0 then Result := VariantAsPyObject( Self.ClientHeight )
    else if CompareText( key, 'ClientOrigin' ) = 0 then Result := CreatePoint( Self.ClientOrigin ).GetSelf
    else if CompareText( key, 'ClientRect' ) = 0 then Result := CreateRect( Self.ClientRect ).GetSelf
    else if CompareText( key, 'ClientWidth' ) = 0 then Result := VariantAsPyObject( Self.ClientWidth )
    else if CompareText( key, 'ControlState' ) = 0 then begin
      tmpControlState := Self.ControlState;
      Result := SetToList( @tmpControlState, sizeof(tmpControlState) )
    end
    else if CompareText( key, 'ControlStyle' ) = 0 then begin
      tmpControlStyle := Self.ControlStyle;
      Result := SetToList( @tmpControlStyle, sizeof(tmpControlStyle) )
    end
    else if CompareText( key, 'Parent' ) = 0 then Result := GetPythonObject( Self.Parent, 'Controls', 'TWinControl' )
    else if CompareText( key, 'ShowHint' ) = 0 then Result := VariantAsPyObject( Self.ShowHint )
    else if CompareText( key, 'Visible' ) = 0 then Result := VariantAsPyObject( Self.Visible )
    else if CompareText( key, 'Enabled' ) = 0 then Result := VariantAsPyObject( Self.Enabled )
    else if CompareText( key, 'WindowProc' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TWndMethod' ); Result := nil; end
    else if CompareText( key, 'Left' ) = 0 then Result := VariantAsPyObject( Self.Left )
    else if CompareText( key, 'Top' ) = 0 then Result := VariantAsPyObject( Self.Top )
    else if CompareText( key, 'Width' ) = 0 then Result := VariantAsPyObject( Self.Width )
    else if CompareText( key, 'Height' ) = 0 then Result := VariantAsPyObject( Self.Height )
    else if CompareText( key, 'Cursor' ) = 0 then Result := VariantAsPyObject( Integer( Self.Cursor ) )
    else if CompareText( key, 'Hint' ) = 0 then Result := VariantAsPyObject( Self.Hint )
    else Result := TComponent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TControl_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( argSelf, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    // Check attribute
    Result := TControl_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TControl_WriteAttribute( Self : TControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
  tmpControlState : TControlState;
  tmpControlStyle : TControlStyle;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Align' ) = 0 then begin
      Self.Align := TAlign(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'BoundsRect' ) = 0 then begin
      Self.BoundsRect := PyObjectAsRect( Value );      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ClientHeight' ) = 0 then begin
      Self.ClientHeight := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ClientOrigin' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ClientRect' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ClientWidth' ) = 0 then begin
      Self.ClientWidth := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ControlState' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpControlState, sizeof(tmpControlState) );
        Self.ControlState := tmpControlState;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'ControlState', 'TControlState' );
    end else if CompareText( key, 'ControlStyle' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpControlStyle, sizeof(tmpControlStyle) );
        Self.ControlStyle := tmpControlStyle;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'ControlStyle', 'TControlStyle' );
    end else if CompareText( key, 'Parent' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TWinControl then begin
        Self.Parent := TWinControl( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Parent', 'TWinControl' );
    end else if CompareText( key, 'ShowHint' ) = 0 then begin
      Self.ShowHint := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Visible' ) = 0 then begin
      Self.Visible := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Enabled' ) = 0 then begin
      Self.Enabled := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'WindowProc' ) = 0 then begin
      if Value = Py_None then begin
        Self.WindowProc := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyControl then
          with TPyControl(Self) do
            WindowProc := EventWindowProc;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'Left' ) = 0 then begin
      Self.Left := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Top' ) = 0 then begin
      Self.Top := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Width' ) = 0 then begin
      Self.Width := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Height' ) = 0 then begin
      Self.Height := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Cursor' ) = 0 then begin
      Self.Cursor := TCursor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Hint' ) = 0 then begin
      Self.Hint := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TComponent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TControl_BeginDrag( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  _argImmediate : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TControl.BeginDrag', [ 
                  @_argImmediate       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.BeginDrag( Boolean(_argImmediate) );
    Result := ReturnNone;
  end;
end;

function TControl_BringToFront( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.BringToFront;
    Result := ReturnNone;
  end;
end;

function TControl_ClientToScreen( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : TPoint;
  _argPoint : PPyObject;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TControl.ClientToScreen', [ 
                  @_argPoint       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.ClientToScreen( PyObjectAsPoint( _argPoint ) );
    Result := CreatePoint( rslt ).GetSelf;
  end;
end;

function TControl_Dragging( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Boolean;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.Dragging;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_DragDrop( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  _argSource : PPyObject;
  _objSource : TObject;
  _argX : Integer;
  _argY : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'Oii:TControl.DragDrop', [ 
                  @_argSource,
                  @_argX,
                  @_argY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.DragDrop( _objSource, Integer(_argX), Integer(_argY) );
    Result := ReturnNone;
  end;
end;

function TControl_EndDrag( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  _argDrop : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TControl.EndDrag', [ 
                  @_argDrop       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.EndDrag( Boolean(_argDrop) );
    Result := ReturnNone;
  end;
end;

function TControl_GetTextBuf( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Integer;
  _argBuffer : PChar;
  _argBufSize : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'si:TControl.GetTextBuf', [ 
                  @_argBuffer,
                  @_argBufSize       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.GetTextBuf( PChar(_argBuffer), Integer(_argBufSize) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_GetTextLen( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.GetTextLen;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_Hide( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.Hide;
    Result := ReturnNone;
  end;
end;

function TControl_Invalidate( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.Invalidate;
    Result := ReturnNone;
  end;
end;

function TControl_Perform( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Longint;
  _argMsg : Integer;
  _argWParam : Integer;
  _argLParam : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TControl.Perform', [ 
                  @_argMsg,
                  @_argWParam,
                  @_argLParam       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.Perform( Cardinal(_argMsg), Longint(_argWParam), Longint(_argLParam) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_Refresh( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.Refresh;
    Result := ReturnNone;
  end;
end;

function TControl_Repaint( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.Repaint;
    Result := ReturnNone;
  end;
end;

function TControl_ScreenToClient( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : TPoint;
  _argPoint : PPyObject;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TControl.ScreenToClient', [ 
                  @_argPoint       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.ScreenToClient( PyObjectAsPoint( _argPoint ) );
    Result := CreatePoint( rslt ).GetSelf;
  end;
end;

function TControl_SendToBack( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.SendToBack;
    Result := ReturnNone;
  end;
end;

function TControl_SetBounds( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  _argALeft : Integer;
  _argATop : Integer;
  _argAWidth : Integer;
  _argAHeight : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iiii:TControl.SetBounds', [ 
                  @_argALeft,
                  @_argATop,
                  @_argAWidth,
                  @_argAHeight       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.SetBounds( Integer(_argALeft), Integer(_argATop), Integer(_argAWidth), Integer(_argAHeight) );
    Result := ReturnNone;
  end;
end;

function TControl_SetTextBuf( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  _argBuffer : PChar;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TControl.SetTextBuf', [ 
                  @_argBuffer       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.SetTextBuf( PChar(_argBuffer) );
    Result := ReturnNone;
  end;
end;

function TControl_Show( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.Show;
    Result := ReturnNone;
  end;
end;

function TControl_Update( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.Update;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TWinControl //////////////////

function TWinControl_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyWinControl;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TWinControl.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyWinControl.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TWinControl_CreateParented( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyWinControl;
  _argSelf : PPyObject;
  _argParentWindow : Integer;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:TWinControl.CreateParented', [ @_argSelf,
                  @_argParentWindow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyWinControl.CreateParented( HWnd(_argParentWindow) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TWinControl_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( argSelf, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    // Check attribute
    Result := TWinControl_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TWinControl_ReadAttribute( Self : TWinControl; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTWinControl.MethodCount > 0 then 
      Result := Py_FindMethod( gTWinControl.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Brush' ) = 0 then Result := GetPythonObject( Self.Brush, 'Controls', 'TBrush' )
    else if CompareText( key, 'ControlCount' ) = 0 then Result := VariantAsPyObject( Self.ControlCount )
    else if CompareText( key, 'Handle' ) = 0 then Result := VariantAsPyObject( Self.Handle )
    else if CompareText( key, 'ParentWindow' ) = 0 then Result := VariantAsPyObject( Self.ParentWindow )
    else if CompareText( key, 'Showing' ) = 0 then Result := VariantAsPyObject( Self.Showing )
    else if CompareText( key, 'TabOrder' ) = 0 then Result := VariantAsPyObject( Integer( Self.TabOrder ) )
    else if CompareText( key, 'TabStop' ) = 0 then Result := VariantAsPyObject( Self.TabStop )
    else if CompareText( key, 'HelpContext' ) = 0 then Result := VariantAsPyObject( Integer( Self.HelpContext ) )
    else Result := TControl_ReadAttribute( Self, argSelf, key );
  end;
end;

function TWinControl_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( argSelf, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    // Check attribute
    Result := TWinControl_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TWinControl_WriteAttribute( Self : TWinControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Brush' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ControlCount' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Handle' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ParentWindow' ) = 0 then begin
      Self.ParentWindow := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Showing' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'TabOrder' ) = 0 then begin
      Self.TabOrder := TTabOrder(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'TabStop' ) = 0 then begin
      Self.TabStop := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HelpContext' ) = 0 then begin
      Self.HelpContext := THelpContext(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else Result := TControl_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TWinControl_Broadcast( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TWinControl_CanFocus( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : Boolean;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.CanFocus;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TWinControl_ContainsControl( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : Boolean;
  _argControl : PPyObject;
  _objControl : TControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TWinControl.ContainsControl', [ 
                  @_argControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objControl := GetObjectOf( _argControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.ContainsControl( _objControl );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TWinControl_ControlAtPos( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : TControl;
  _argPos : PPyObject;
  _argAllowDisabled : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'Oi:TWinControl.ControlAtPos', [ 
                  @_argPos,
                  @_argAllowDisabled       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.ControlAtPos( PyObjectAsPoint( _argPos ), Boolean(_argAllowDisabled) );
    Result := GetPythonObject( rslt, 'Controls', 'TControl' );
  end;
end;

function TWinControl_DisableAlign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.DisableAlign;
    Result := ReturnNone;
  end;
end;

function TWinControl_EnableAlign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.EnableAlign;
    Result := ReturnNone;
  end;
end;

function TWinControl_Focused( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : Boolean;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.Focused;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TWinControl_GetTabOrderList( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argList : PPyObject;
  _objList : TList;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TWinControl.GetTabOrderList', [ 
                  @_argList       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objList := GetObjectOf( _argList ) as TList;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.GetTabOrderList( _objList );
    Result := ReturnNone;
  end;
end;

function TWinControl_HandleAllocated( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : Boolean;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.HandleAllocated;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TWinControl_HandleNeeded( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.HandleNeeded;
    Result := ReturnNone;
  end;
end;

function TWinControl_InsertControl( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argAControl : PPyObject;
  _objAControl : TControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TWinControl.InsertControl', [ 
                  @_argAControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAControl := GetObjectOf( _argAControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.InsertControl( _objAControl );
    Result := ReturnNone;
  end;
end;

function TWinControl_Invalidate( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.Invalidate;
    Result := ReturnNone;
  end;
end;

function TWinControl_PaintTo( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argDC : Integer;
  _argX : Integer;
  _argY : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TWinControl.PaintTo', [ 
                  @_argDC,
                  @_argX,
                  @_argY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.PaintTo( HDC(_argDC), Integer(_argX), Integer(_argY) );
    Result := ReturnNone;
  end;
end;

function TWinControl_RemoveControl( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argAControl : PPyObject;
  _objAControl : TControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TWinControl.RemoveControl', [ 
                  @_argAControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAControl := GetObjectOf( _argAControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.RemoveControl( _objAControl );
    Result := ReturnNone;
  end;
end;

function TWinControl_Realign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.Realign;
    Result := ReturnNone;
  end;
end;

function TWinControl_Repaint( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.Repaint;
    Result := ReturnNone;
  end;
end;

function TWinControl_ScaleBy( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argM : Integer;
  _argD : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TWinControl.ScaleBy', [ 
                  @_argM,
                  @_argD       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.ScaleBy( Integer(_argM), Integer(_argD) );
    Result := ReturnNone;
  end;
end;

function TWinControl_ScrollBy( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argDeltaX : Integer;
  _argDeltaY : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TWinControl.ScrollBy', [ 
                  @_argDeltaX,
                  @_argDeltaY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.ScrollBy( Integer(_argDeltaX), Integer(_argDeltaY) );
    Result := ReturnNone;
  end;
end;

function TWinControl_SetBounds( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argALeft : Integer;
  _argATop : Integer;
  _argAWidth : Integer;
  _argAHeight : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iiii:TWinControl.SetBounds', [ 
                  @_argALeft,
                  @_argATop,
                  @_argAWidth,
                  @_argAHeight       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.SetBounds( Integer(_argALeft), Integer(_argATop), Integer(_argAWidth), Integer(_argAHeight) );
    Result := ReturnNone;
  end;
end;

function TWinControl_SetFocus( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.SetFocus;
    Result := ReturnNone;
  end;
end;

function TWinControl_Update( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.Update;
    Result := ReturnNone;
  end;
end;

function TWinControl_UpdateControlState( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.UpdateControlState;
    Result := ReturnNone;
  end;
end;

function TWinControl_Controls( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : TControl;
  _argIndex : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TWinControl.Controls', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.Controls[ Integer(_argIndex) ];
    Result := GetPythonObject( rslt, 'Controls', 'TControl' );
  end;
end;

///////////// Functions for class TGraphicControl //////////////////

function TGraphicControl_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyGraphicControl;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TGraphicControl.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyGraphicControl.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TGraphicControl_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TGraphicControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TGraphicControl) then begin
      ErrorWrongExpectedType( argSelf, 'TGraphicControl' );
      Exit;
    end;
    realObj := TGraphicControl(obj);
    // Check attribute
    Result := TGraphicControl_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TGraphicControl_ReadAttribute( Self : TGraphicControl; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTGraphicControl.MethodCount > 0 then 
      Result := Py_FindMethod( gTGraphicControl.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TControl_ReadAttribute( Self, argSelf, key );
  end;
end;

function TGraphicControl_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TGraphicControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TGraphicControl) then begin
      ErrorWrongExpectedType( argSelf, 'TGraphicControl' );
      Exit;
    end;
    realObj := TGraphicControl(obj);
    // Check attribute
    Result := TGraphicControl_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TGraphicControl_WriteAttribute( Self : TGraphicControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TControl_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TCustomControl //////////////////

function TCustomControl_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomControl;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TCustomControl.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomControl.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomControl_CreateParented( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomControl;
  _argSelf : PPyObject;
  _argParentWindow : Integer;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:TCustomControl.CreateParented', [ @_argSelf,
                  @_argParentWindow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomControl.CreateParented( HWnd(_argParentWindow) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomControl_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomControl) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomControl' );
      Exit;
    end;
    realObj := TCustomControl(obj);
    // Check attribute
    Result := TCustomControl_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TCustomControl_ReadAttribute( Self : TCustomControl; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTCustomControl.MethodCount > 0 then 
      Result := Py_FindMethod( gTCustomControl.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TWinControl_ReadAttribute( Self, argSelf, key );
  end;
end;

function TCustomControl_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomControl) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomControl' );
      Exit;
    end;
    realObj := TCustomControl(obj);
    // Check attribute
    Result := TCustomControl_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TCustomControl_WriteAttribute( Self : TCustomControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TWinControl_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class THintWindow //////////////////

function THintWindow_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyHintWindow;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:THintWindow.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyHintWindow.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function THintWindow_CreateParented( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyHintWindow;
  _argSelf : PPyObject;
  _argParentWindow : Integer;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:THintWindow.CreateParented', [ @_argSelf,
                  @_argParentWindow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyHintWindow.CreateParented( HWnd(_argParentWindow) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function THintWindow_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : THintWindow;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is THintWindow) then begin
      ErrorWrongExpectedType( argSelf, 'THintWindow' );
      Exit;
    end;
    realObj := THintWindow(obj);
    // Check attribute
    Result := THintWindow_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function THintWindow_ReadAttribute( Self : THintWindow; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTHintWindow.MethodCount > 0 then 
      Result := Py_FindMethod( gTHintWindow.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Caption' ) = 0 then Result := VariantAsPyObject( Self.Caption )
    else if CompareText( key, 'Color' ) = 0 then Result := VariantAsPyObject( Integer( Self.Color ) )
    else if CompareText( key, 'Canvas' ) = 0 then Result := GetPythonObject( Self.Canvas, 'Controls', 'TCanvas' )
    else Result := TCustomControl_ReadAttribute( Self, argSelf, key );
  end;
end;

function THintWindow_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : THintWindow;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is THintWindow) then begin
      ErrorWrongExpectedType( argSelf, 'THintWindow' );
      Exit;
    end;
    realObj := THintWindow(obj);
    // Check attribute
    Result := THintWindow_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function THintWindow_WriteAttribute( Self : THintWindow; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Caption' ) = 0 then begin
      Self.Caption := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Color' ) = 0 then begin
      Self.Color := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Canvas' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TCustomControl_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function THintWindow_ActivateHint( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : THintWindow;
  _argRect : PPyObject;
  _argAHint : PChar;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'Os:THintWindow.ActivateHint', [ 
                  @_argRect,
                  @_argAHint       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is THintWindow) then begin
      ErrorWrongExpectedType( Self, 'THintWindow' );
      Exit;
    end;
    realObj := THintWindow(obj);
    realObj.ActivateHint( PyObjectAsRect( _argRect ), string(_argAHint) );
    Result := ReturnNone;
  end;
end;

function THintWindow_ActivateHintData( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function THintWindow_CalcHintRect( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function THintWindow_IsHintMsg( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function THintWindow_ReleaseHandle( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : THintWindow;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is THintWindow) then begin
      ErrorWrongExpectedType( Self, 'THintWindow' );
      Exit;
    end;
    realObj := THintWindow(obj);
    realObj.ReleaseHandle;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TChangeLink //////////////////

function TChangeLink_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyChangeLink;
  _argSelf : PPyObject;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TChangeLink.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyChangeLink.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TChangeLink_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TChangeLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TChangeLink) then begin
      ErrorWrongExpectedType( argSelf, 'TChangeLink' );
      Exit;
    end;
    realObj := TChangeLink(obj);
    // Check attribute
    Result := TChangeLink_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TChangeLink_ReadAttribute( Self : TChangeLink; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTChangeLink.MethodCount > 0 then 
      Result := Py_FindMethod( gTChangeLink.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'OnChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'Sender' ) = 0 then Result := GetPythonObject( Self.Sender, 'Controls', 'TCustomImageList' )
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TChangeLink_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TChangeLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TChangeLink) then begin
      ErrorWrongExpectedType( argSelf, 'TChangeLink' );
      Exit;
    end;
    realObj := TChangeLink(obj);
    // Check attribute
    Result := TChangeLink_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TChangeLink_WriteAttribute( Self : TChangeLink; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'OnChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyChangeLink then
          with TPyChangeLink(Self) do
            OnChange := EventOnChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'Sender' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TCustomImageList then begin
        Self.Sender := TCustomImageList( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Sender', 'TCustomImageList' );
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TChangeLink_Change( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TChangeLink;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TChangeLink) then begin
      ErrorWrongExpectedType( Self, 'TChangeLink' );
      Exit;
    end;
    realObj := TChangeLink(obj);
    realObj.Change;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TCustomImageList //////////////////

function TCustomImageList_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomImageList;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TCustomImageList.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomImageList.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomImageList_CreateSize( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomImageList;
  _argSelf : PPyObject;
  _argAWidth : Integer;
  _argAHeight : Integer;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oii:TCustomImageList.CreateSize', [ @_argSelf,
                  @_argAWidth,
                  @_argAHeight       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomImageList.CreateSize( Integer(_argAWidth), Integer(_argAHeight) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomImageList_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomImageList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    // Check attribute
    Result := TCustomImageList_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TCustomImageList_ReadAttribute( Self : TCustomImageList; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTCustomImageList.MethodCount > 0 then 
      Result := Py_FindMethod( gTCustomImageList.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Count' ) = 0 then Result := VariantAsPyObject( Self.Count )
    else if CompareText( key, 'DragCursor' ) = 0 then Result := VariantAsPyObject( Integer( Self.DragCursor ) )
    else if CompareText( key, 'Dragging' ) = 0 then Result := VariantAsPyObject( Self.Dragging )
    else if CompareText( key, 'Handle' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'HImageList' ); Result := nil; end
    else Result := TComponent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TCustomImageList_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomImageList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    // Check attribute
    Result := TCustomImageList_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TCustomImageList_WriteAttribute( Self : TCustomImageList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Count' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'DragCursor' ) = 0 then begin
      Self.DragCursor := TCursor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Dragging' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Handle' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'HImageList' );
    end else Result := TComponent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TCustomImageList_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argSource : PPyObject;
  _objSource : TPersistent;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCustomImageList.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TPersistent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_Add( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Integer;
  _argImage : PPyObject;
  _objImage : TBitmap;
  _argMask : PPyObject;
  _objMask : TBitmap;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'OO:TCustomImageList.Add', [ 
                  @_argImage,
                  @_argMask       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objImage := GetObjectOf( _argImage ) as TBitmap;
    _objMask := GetObjectOf( _argMask ) as TBitmap;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.Add( _objImage, _objMask );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_AddIcon( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Integer;
  _argImage : PPyObject;
  _objImage : TIcon;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCustomImageList.AddIcon', [ 
                  @_argImage       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objImage := GetObjectOf( _argImage ) as TIcon;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.AddIcon( _objImage );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_AddImages( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argValue : PPyObject;
  _objValue : TCustomImageList;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCustomImageList.AddImages', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objValue := GetObjectOf( _argValue ) as TCustomImageList;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.AddImages( _objValue );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_AddMasked( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Integer;
  _argImage : PPyObject;
  _objImage : TBitmap;
  _argMaskColor : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'Oi:TCustomImageList.AddMasked', [ 
                  @_argImage,
                  @_argMaskColor       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objImage := GetObjectOf( _argImage ) as TBitmap;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.AddMasked( _objImage, TColor(_argMaskColor) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_BeginDrag( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Boolean;
  _argWindow : Integer;
  _argX : Integer;
  _argY : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TCustomImageList.BeginDrag', [ 
                  @_argWindow,
                  @_argX,
                  @_argY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.BeginDrag( HWND(_argWindow), Integer(_argX), Integer(_argY) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_Clear( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.Clear;
    Result := ReturnNone;
  end;
end;

function TCustomImageList_Delete( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argIndex : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TCustomImageList.Delete', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.Delete( Integer(_argIndex) );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_DragLock( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Boolean;
  _argWindow : Integer;
  _argXPos : Integer;
  _argYPos : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TCustomImageList.DragLock', [ 
                  @_argWindow,
                  @_argXPos,
                  @_argYPos       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.DragLock( HWND(_argWindow), Integer(_argXPos), Integer(_argYPos) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_DragMove( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Boolean;
  _argX : Integer;
  _argY : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TCustomImageList.DragMove', [ 
                  @_argX,
                  @_argY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.DragMove( Integer(_argX), Integer(_argY) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_DragUnlock( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.DragUnlock;
    Result := ReturnNone;
  end;
end;

function TCustomImageList_Draw( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argCanvas : PPyObject;
  _objCanvas : TCanvas;
  _argX : Integer;
  _argY : Integer;
  _argIndex : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'Oiii:TCustomImageList.Draw', [ 
                  @_argCanvas,
                  @_argX,
                  @_argY,
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objCanvas := GetObjectOf( _argCanvas ) as TCanvas;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.Draw( _objCanvas, Integer(_argX), Integer(_argY), Integer(_argIndex) );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_DrawOverlay( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argCanvas : PPyObject;
  _objCanvas : TCanvas;
  _argX : Integer;
  _argY : Integer;
  _argImageIndex : Integer;
  _argOverlay : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'Oiiii:TCustomImageList.DrawOverlay', [ 
                  @_argCanvas,
                  @_argX,
                  @_argY,
                  @_argImageIndex,
                  @_argOverlay       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objCanvas := GetObjectOf( _argCanvas ) as TCanvas;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.DrawOverlay( _objCanvas, Integer(_argX), Integer(_argY), Integer(_argImageIndex), TOverlay(_argOverlay) );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_EndDrag( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Boolean;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.EndDrag;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_FileLoad( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Boolean;
  _argResType : Integer;
  _argName : PChar;
  _argMaskColor : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'isi:TCustomImageList.FileLoad', [ 
                  @_argResType,
                  @_argName,
                  @_argMaskColor       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.FileLoad( TResType(_argResType), string(_argName), TColor(_argMaskColor) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_GetBitmap( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argIndex : Integer;
  _argImage : PPyObject;
  _objImage : TBitmap;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iO:TCustomImageList.GetBitmap', [ 
                  @_argIndex,
                  @_argImage       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objImage := GetObjectOf( _argImage ) as TBitmap;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.GetBitmap( Integer(_argIndex), _objImage );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_GetHotSpot( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : TPoint;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.GetHotSpot;
    Result := CreatePoint( rslt ).GetSelf;
  end;
end;

function TCustomImageList_GetIcon( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argIndex : Integer;
  _argImage : PPyObject;
  _objImage : TIcon;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iO:TCustomImageList.GetIcon', [ 
                  @_argIndex,
                  @_argImage       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objImage := GetObjectOf( _argImage ) as TIcon;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.GetIcon( Integer(_argIndex), _objImage );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_GetImageBitmap( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : HBITMAP;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.GetImageBitmap;
    Result := ReturnNone;
  end;
end;

function TCustomImageList_GetMaskBitmap( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : HBITMAP;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.GetMaskBitmap;
    Result := ReturnNone;
  end;
end;

function TCustomImageList_GetResource( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Boolean;
  _argResType : Integer;
  _argName : PChar;
  _argWidth : Integer;
  _argLoadFlags : PPyObject;
  _tmpLoadFlags : TLoadResources;
  _argMaskColor : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'isiOi:TCustomImageList.GetResource', [ 
                  @_argResType,
                  @_argName,
                  @_argWidth,
                  @_argLoadFlags,
                  @_argMaskColor       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyList_Check( _argLoadFlags ) then
      ListToSet( _argLoadFlags, @_tmpLoadFlags, sizeof(_tmpLoadFlags) )
    else
      ErrorWrongSetPropertyType( Self, 'LoadFlags', 'TLoadResources' );
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.GetResource( TResType(_argResType), string(_argName), Integer(_argWidth), _tmpLoadFlags, TColor(_argMaskColor) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_GetInstRes( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Boolean;
  _argInstance : Integer;
  _argResType : Integer;
  _argName : PChar;
  _argWidth : Integer;
  _argLoadFlags : PPyObject;
  _tmpLoadFlags : TLoadResources;
  _argMaskColor : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iisiOi:TCustomImageList.GetInstRes', [ 
                  @_argInstance,
                  @_argResType,
                  @_argName,
                  @_argWidth,
                  @_argLoadFlags,
                  @_argMaskColor       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyList_Check( _argLoadFlags ) then
      ListToSet( _argLoadFlags, @_tmpLoadFlags, sizeof(_tmpLoadFlags) )
    else
      ErrorWrongSetPropertyType( Self, 'LoadFlags', 'TLoadResources' );
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.GetInstRes( THandle(_argInstance), TResType(_argResType), string(_argName), Integer(_argWidth), _tmpLoadFlags, TColor(_argMaskColor) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_HandleAllocated( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Boolean;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.HandleAllocated;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_HideDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.HideDragImage;
    Result := ReturnNone;
  end;
end;

function TCustomImageList_Insert( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argIndex : Integer;
  _argImage : PPyObject;
  _objImage : TBitmap;
  _argMask : PPyObject;
  _objMask : TBitmap;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iOO:TCustomImageList.Insert', [ 
                  @_argIndex,
                  @_argImage,
                  @_argMask       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objImage := GetObjectOf( _argImage ) as TBitmap;
    _objMask := GetObjectOf( _argMask ) as TBitmap;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.Insert( Integer(_argIndex), _objImage, _objMask );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_InsertIcon( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argIndex : Integer;
  _argImage : PPyObject;
  _objImage : TIcon;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iO:TCustomImageList.InsertIcon', [ 
                  @_argIndex,
                  @_argImage       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objImage := GetObjectOf( _argImage ) as TIcon;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.InsertIcon( Integer(_argIndex), _objImage );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_InsertMasked( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argIndex : Integer;
  _argImage : PPyObject;
  _objImage : TBitmap;
  _argMaskColor : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iOi:TCustomImageList.InsertMasked', [ 
                  @_argIndex,
                  @_argImage,
                  @_argMaskColor       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objImage := GetObjectOf( _argImage ) as TBitmap;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.InsertMasked( Integer(_argIndex), _objImage, TColor(_argMaskColor) );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_Move( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argCurIndex : Integer;
  _argNewIndex : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TCustomImageList.Move', [ 
                  @_argCurIndex,
                  @_argNewIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.Move( Integer(_argCurIndex), Integer(_argNewIndex) );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_Overlay( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Boolean;
  _argImageIndex : Integer;
  _argOverlay : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TCustomImageList.Overlay', [ 
                  @_argImageIndex,
                  @_argOverlay       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.Overlay( Integer(_argImageIndex), TOverlay(_argOverlay) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_RegisterChanges( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argValue : PPyObject;
  _objValue : TChangeLink;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCustomImageList.RegisterChanges', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objValue := GetObjectOf( _argValue ) as TChangeLink;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.RegisterChanges( _objValue );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_ResourceLoad( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Boolean;
  _argResType : Integer;
  _argName : PChar;
  _argMaskColor : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'isi:TCustomImageList.ResourceLoad', [ 
                  @_argResType,
                  @_argName,
                  @_argMaskColor       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.ResourceLoad( TResType(_argResType), string(_argName), TColor(_argMaskColor) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_ResInstLoad( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Boolean;
  _argInstance : Integer;
  _argResType : Integer;
  _argName : PChar;
  _argMaskColor : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iisi:TCustomImageList.ResInstLoad', [ 
                  @_argInstance,
                  @_argResType,
                  @_argName,
                  @_argMaskColor       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.ResInstLoad( THandle(_argInstance), TResType(_argResType), string(_argName), TColor(_argMaskColor) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_Replace( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argIndex : Integer;
  _argImage : PPyObject;
  _objImage : TBitmap;
  _argMask : PPyObject;
  _objMask : TBitmap;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iOO:TCustomImageList.Replace', [ 
                  @_argIndex,
                  @_argImage,
                  @_argMask       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objImage := GetObjectOf( _argImage ) as TBitmap;
    _objMask := GetObjectOf( _argMask ) as TBitmap;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.Replace( Integer(_argIndex), _objImage, _objMask );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_ReplaceIcon( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argIndex : Integer;
  _argImage : PPyObject;
  _objImage : TIcon;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iO:TCustomImageList.ReplaceIcon', [ 
                  @_argIndex,
                  @_argImage       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objImage := GetObjectOf( _argImage ) as TIcon;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.ReplaceIcon( Integer(_argIndex), _objImage );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_ReplaceMasked( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argIndex : Integer;
  _argNewImage : PPyObject;
  _objNewImage : TBitmap;
  _argMaskColor : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iOi:TCustomImageList.ReplaceMasked', [ 
                  @_argIndex,
                  @_argNewImage,
                  @_argMaskColor       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objNewImage := GetObjectOf( _argNewImage ) as TBitmap;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.ReplaceMasked( Integer(_argIndex), _objNewImage, TColor(_argMaskColor) );
    Result := ReturnNone;
  end;
end;

function TCustomImageList_SetDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  rslt : Boolean;
  _argIndex : Integer;
  _argHotSpotX : Integer;
  _argHotSpotY : Integer;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TCustomImageList.SetDragImage', [ 
                  @_argIndex,
                  @_argHotSpotX,
                  @_argHotSpotY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    rslt := realObj.SetDragImage( Integer(_argIndex), Integer(_argHotSpotX), Integer(_argHotSpotY) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomImageList_ShowDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.ShowDragImage;
    Result := ReturnNone;
  end;
end;

function TCustomImageList_UnRegisterChanges( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomImageList;
  _argValue : PPyObject;
  _objValue : TChangeLink;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCustomImageList.UnRegisterChanges', [ 
                  @_argValue       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objValue := GetObjectOf( _argValue ) as TChangeLink;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomImageList) then begin
      ErrorWrongExpectedType( Self, 'TCustomImageList' );
      Exit;
    end;
    realObj := TCustomImageList(obj);
    realObj.UnRegisterChanges( _objValue );
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TImageList //////////////////

function TImageList_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyImageList;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TImageList.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyImageList.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TImageList_CreateSize( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyImageList;
  _argSelf : PPyObject;
  _argAWidth : Integer;
  _argAHeight : Integer;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oii:TImageList.CreateSize', [ @_argSelf,
                  @_argAWidth,
                  @_argAHeight       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyImageList.CreateSize( Integer(_argAWidth), Integer(_argAHeight) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TImageList_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TImageList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TImageList) then begin
      ErrorWrongExpectedType( argSelf, 'TImageList' );
      Exit;
    end;
    realObj := TImageList(obj);
    // Check attribute
    Result := TImageList_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TImageList_ReadAttribute( Self : TImageList; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTImageList.MethodCount > 0 then 
      Result := Py_FindMethod( gTImageList.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'BlendColor' ) = 0 then Result := VariantAsPyObject( Integer( Self.BlendColor ) )
    else if CompareText( key, 'BkColor' ) = 0 then Result := VariantAsPyObject( Integer( Self.BkColor ) )
    else if CompareText( key, 'AllocBy' ) = 0 then Result := VariantAsPyObject( Self.AllocBy )
    else if CompareText( key, 'DrawingStyle' ) = 0 then Result := VariantAsPyObject( Integer( Self.DrawingStyle ) )
    else if CompareText( key, 'Height' ) = 0 then Result := VariantAsPyObject( Self.Height )
    else if CompareText( key, 'ImageType' ) = 0 then Result := VariantAsPyObject( Integer( Self.ImageType ) )
    else if CompareText( key, 'Masked' ) = 0 then Result := VariantAsPyObject( Self.Masked )
    else if CompareText( key, 'OnChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'ShareImages' ) = 0 then Result := VariantAsPyObject( Self.ShareImages )
    else if CompareText( key, 'Width' ) = 0 then Result := VariantAsPyObject( Self.Width )
    else Result := TCustomImageList_ReadAttribute( Self, argSelf, key );
  end;
end;

function TImageList_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TImageList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TImageList) then begin
      ErrorWrongExpectedType( argSelf, 'TImageList' );
      Exit;
    end;
    realObj := TImageList(obj);
    // Check attribute
    Result := TImageList_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TImageList_WriteAttribute( Self : TImageList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'BlendColor' ) = 0 then begin
      Self.BlendColor := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'BkColor' ) = 0 then begin
      Self.BkColor := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'AllocBy' ) = 0 then begin
      Self.AllocBy := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DrawingStyle' ) = 0 then begin
      Self.DrawingStyle := TDrawingStyle(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Height' ) = 0 then begin
      Self.Height := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ImageType' ) = 0 then begin
      Self.ImageType := TImageType(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Masked' ) = 0 then begin
      Self.Masked := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyImageList then
          with TPyImageList(Self) do
            OnChange := EventOnChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'ShareImages' ) = 0 then begin
      Self.ShareImages := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Width' ) = 0 then begin
      Self.Width := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TCustomImageList_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Initialization of the module ///////////

procedure TModule_Controls.Initialize;
begin
  // class TDragObject
  AddMethod( 'CreateDragObject', TDragObject_Create, '' );
  AddMethod( 'DragObject_GetAttr', TDragObject_GetAttr, '' );
  AddMethod( 'DragObject_SetAttr', TDragObject_SetAttr, '' );
  gTDragObject.AddMethod( 'Instance', TDragObject_Instance, '' );
  gTDragObject.AddMethod( 'GetName', TDragObject_GetName, '' );
  gTDragObject.AddMethod( 'HideDragImage', TDragObject_HideDragImage, '' );
  gTDragObject.AddMethod( 'ShowDragImage', TDragObject_ShowDragImage, '' );
  // class TDragControlObject
  AddMethod( 'CreateDragControlObject', TDragControlObject_Create, '' );
  AddMethod( 'DragControlObject_GetAttr', TDragControlObject_GetAttr, '' );
  AddMethod( 'DragControlObject_SetAttr', TDragControlObject_SetAttr, '' );
  gTDragControlObject.AddMethod( 'Create', TDragControlObject_Create, '' );
  gTDragControlObject.AddMethod( 'HideDragImage', TDragControlObject_HideDragImage, '' );
  gTDragControlObject.AddMethod( 'ShowDragImage', TDragControlObject_ShowDragImage, '' );
  // class TControlCanvas
  AddMethod( 'CreateControlCanvas', TControlCanvas_Create, '' );
  AddMethod( 'ControlCanvas_GetAttr', TControlCanvas_GetAttr, '' );
  AddMethod( 'ControlCanvas_SetAttr', TControlCanvas_SetAttr, '' );
  gTControlCanvas.AddMethod( 'FreeHandle', TControlCanvas_FreeHandle, '' );
  // class TControl
  AddMethod( 'CreateControl', TControl_Create, '' );
  AddMethod( 'Control_GetAttr', TControl_GetAttr, '' );
  AddMethod( 'Control_SetAttr', TControl_SetAttr, '' );
  gTControl.AddMethod( 'Create', TControl_Create, '' );
  gTControl.AddMethod( 'BeginDrag', TControl_BeginDrag, '' );
  gTControl.AddMethod( 'BringToFront', TControl_BringToFront, '' );
  gTControl.AddMethod( 'ClientToScreen', TControl_ClientToScreen, '' );
  gTControl.AddMethod( 'Dragging', TControl_Dragging, '' );
  gTControl.AddMethod( 'DragDrop', TControl_DragDrop, '' );
  gTControl.AddMethod( 'EndDrag', TControl_EndDrag, '' );
  gTControl.AddMethod( 'GetTextBuf', TControl_GetTextBuf, '' );
  gTControl.AddMethod( 'GetTextLen', TControl_GetTextLen, '' );
  gTControl.AddMethod( 'Hide', TControl_Hide, '' );
  gTControl.AddMethod( 'Invalidate', TControl_Invalidate, '' );
  gTControl.AddMethod( 'Perform', TControl_Perform, '' );
  gTControl.AddMethod( 'Refresh', TControl_Refresh, '' );
  gTControl.AddMethod( 'Repaint', TControl_Repaint, '' );
  gTControl.AddMethod( 'ScreenToClient', TControl_ScreenToClient, '' );
  gTControl.AddMethod( 'SendToBack', TControl_SendToBack, '' );
  gTControl.AddMethod( 'SetBounds', TControl_SetBounds, '' );
  gTControl.AddMethod( 'SetTextBuf', TControl_SetTextBuf, '' );
  gTControl.AddMethod( 'Show', TControl_Show, '' );
  gTControl.AddMethod( 'Update', TControl_Update, '' );
  // class TWinControl
  AddMethod( 'CreateWinControl', TWinControl_Create, '' );
  AddMethod( 'CreateParentedWinControl', TWinControl_CreateParented, '' );
  AddMethod( 'WinControl_GetAttr', TWinControl_GetAttr, '' );
  AddMethod( 'WinControl_SetAttr', TWinControl_SetAttr, '' );
  gTWinControl.AddMethod( 'Create', TWinControl_Create, '' );
  gTWinControl.AddMethod( 'CreateParented', TWinControl_CreateParented, '' );
  gTWinControl.AddMethod( 'Broadcast', TWinControl_Broadcast, '' );
  gTWinControl.AddMethod( 'CanFocus', TWinControl_CanFocus, '' );
  gTWinControl.AddMethod( 'ContainsControl', TWinControl_ContainsControl, '' );
  gTWinControl.AddMethod( 'ControlAtPos', TWinControl_ControlAtPos, '' );
  gTWinControl.AddMethod( 'DisableAlign', TWinControl_DisableAlign, '' );
  gTWinControl.AddMethod( 'EnableAlign', TWinControl_EnableAlign, '' );
  gTWinControl.AddMethod( 'Focused', TWinControl_Focused, '' );
  gTWinControl.AddMethod( 'GetTabOrderList', TWinControl_GetTabOrderList, '' );
  gTWinControl.AddMethod( 'HandleAllocated', TWinControl_HandleAllocated, '' );
  gTWinControl.AddMethod( 'HandleNeeded', TWinControl_HandleNeeded, '' );
  gTWinControl.AddMethod( 'InsertControl', TWinControl_InsertControl, '' );
  gTWinControl.AddMethod( 'Invalidate', TWinControl_Invalidate, '' );
  gTWinControl.AddMethod( 'PaintTo', TWinControl_PaintTo, '' );
  gTWinControl.AddMethod( 'RemoveControl', TWinControl_RemoveControl, '' );
  gTWinControl.AddMethod( 'Realign', TWinControl_Realign, '' );
  gTWinControl.AddMethod( 'Repaint', TWinControl_Repaint, '' );
  gTWinControl.AddMethod( 'ScaleBy', TWinControl_ScaleBy, '' );
  gTWinControl.AddMethod( 'ScrollBy', TWinControl_ScrollBy, '' );
  gTWinControl.AddMethod( 'SetBounds', TWinControl_SetBounds, '' );
  gTWinControl.AddMethod( 'SetFocus', TWinControl_SetFocus, '' );
  gTWinControl.AddMethod( 'Update', TWinControl_Update, '' );
  gTWinControl.AddMethod( 'UpdateControlState', TWinControl_UpdateControlState, '' );
  gTWinControl.AddMethod( 'Controls', TWinControl_Controls, '' );
  // class TGraphicControl
  AddMethod( 'CreateGraphicControl', TGraphicControl_Create, '' );
  AddMethod( 'GraphicControl_GetAttr', TGraphicControl_GetAttr, '' );
  AddMethod( 'GraphicControl_SetAttr', TGraphicControl_SetAttr, '' );
  gTGraphicControl.AddMethod( 'Create', TGraphicControl_Create, '' );
  // class TCustomControl
  AddMethod( 'CreateCustomControl', TCustomControl_Create, '' );
  AddMethod( 'CreateParentedCustomControl', TCustomControl_CreateParented, '' );
  AddMethod( 'CustomControl_GetAttr', TCustomControl_GetAttr, '' );
  AddMethod( 'CustomControl_SetAttr', TCustomControl_SetAttr, '' );
  gTCustomControl.AddMethod( 'Create', TCustomControl_Create, '' );
  // class THintWindow
  AddMethod( 'CreateHintWindow', THintWindow_Create, '' );
  AddMethod( 'CreateParentedHintWindow', THintWindow_CreateParented, '' );
  AddMethod( 'HintWindow_GetAttr', THintWindow_GetAttr, '' );
  AddMethod( 'HintWindow_SetAttr', THintWindow_SetAttr, '' );
  gTHintWindow.AddMethod( 'Create', THintWindow_Create, '' );
  gTHintWindow.AddMethod( 'ActivateHint', THintWindow_ActivateHint, '' );
  gTHintWindow.AddMethod( 'ActivateHintData', THintWindow_ActivateHintData, '' );
  gTHintWindow.AddMethod( 'CalcHintRect', THintWindow_CalcHintRect, '' );
  gTHintWindow.AddMethod( 'IsHintMsg', THintWindow_IsHintMsg, '' );
  gTHintWindow.AddMethod( 'ReleaseHandle', THintWindow_ReleaseHandle, '' );
  // class TChangeLink
  AddMethod( 'CreateChangeLink', TChangeLink_Create, '' );
  AddMethod( 'ChangeLink_GetAttr', TChangeLink_GetAttr, '' );
  AddMethod( 'ChangeLink_SetAttr', TChangeLink_SetAttr, '' );
  gTChangeLink.AddMethod( 'Change', TChangeLink_Change, '' );
  // class TCustomImageList
  AddMethod( 'CreateCustomImageList', TCustomImageList_Create, '' );
  AddMethod( 'CreateSizeCustomImageList', TCustomImageList_CreateSize, '' );
  AddMethod( 'CustomImageList_GetAttr', TCustomImageList_GetAttr, '' );
  AddMethod( 'CustomImageList_SetAttr', TCustomImageList_SetAttr, '' );
  gTCustomImageList.AddMethod( 'Create', TCustomImageList_Create, '' );
  gTCustomImageList.AddMethod( 'CreateSize', TCustomImageList_CreateSize, '' );
  gTCustomImageList.AddMethod( 'Assign', TCustomImageList_Assign, '' );
  gTCustomImageList.AddMethod( 'Add', TCustomImageList_Add, '' );
  gTCustomImageList.AddMethod( 'AddIcon', TCustomImageList_AddIcon, '' );
  gTCustomImageList.AddMethod( 'AddImages', TCustomImageList_AddImages, '' );
  gTCustomImageList.AddMethod( 'AddMasked', TCustomImageList_AddMasked, '' );
  gTCustomImageList.AddMethod( 'BeginDrag', TCustomImageList_BeginDrag, '' );
  gTCustomImageList.AddMethod( 'Clear', TCustomImageList_Clear, '' );
  gTCustomImageList.AddMethod( 'Delete', TCustomImageList_Delete, '' );
  gTCustomImageList.AddMethod( 'DragLock', TCustomImageList_DragLock, '' );
  gTCustomImageList.AddMethod( 'DragMove', TCustomImageList_DragMove, '' );
  gTCustomImageList.AddMethod( 'DragUnlock', TCustomImageList_DragUnlock, '' );
  gTCustomImageList.AddMethod( 'Draw', TCustomImageList_Draw, '' );
  gTCustomImageList.AddMethod( 'DrawOverlay', TCustomImageList_DrawOverlay, '' );
  gTCustomImageList.AddMethod( 'EndDrag', TCustomImageList_EndDrag, '' );
  gTCustomImageList.AddMethod( 'FileLoad', TCustomImageList_FileLoad, '' );
  gTCustomImageList.AddMethod( 'GetBitmap', TCustomImageList_GetBitmap, '' );
  gTCustomImageList.AddMethod( 'GetHotSpot', TCustomImageList_GetHotSpot, '' );
  gTCustomImageList.AddMethod( 'GetIcon', TCustomImageList_GetIcon, '' );
  gTCustomImageList.AddMethod( 'GetImageBitmap', TCustomImageList_GetImageBitmap, '' );
  gTCustomImageList.AddMethod( 'GetMaskBitmap', TCustomImageList_GetMaskBitmap, '' );
  gTCustomImageList.AddMethod( 'GetResource', TCustomImageList_GetResource, '' );
  gTCustomImageList.AddMethod( 'GetInstRes', TCustomImageList_GetInstRes, '' );
  gTCustomImageList.AddMethod( 'HandleAllocated', TCustomImageList_HandleAllocated, '' );
  gTCustomImageList.AddMethod( 'HideDragImage', TCustomImageList_HideDragImage, '' );
  gTCustomImageList.AddMethod( 'Insert', TCustomImageList_Insert, '' );
  gTCustomImageList.AddMethod( 'InsertIcon', TCustomImageList_InsertIcon, '' );
  gTCustomImageList.AddMethod( 'InsertMasked', TCustomImageList_InsertMasked, '' );
  gTCustomImageList.AddMethod( 'Move', TCustomImageList_Move, '' );
  gTCustomImageList.AddMethod( 'Overlay', TCustomImageList_Overlay, '' );
  gTCustomImageList.AddMethod( 'RegisterChanges', TCustomImageList_RegisterChanges, '' );
  gTCustomImageList.AddMethod( 'ResourceLoad', TCustomImageList_ResourceLoad, '' );
  gTCustomImageList.AddMethod( 'ResInstLoad', TCustomImageList_ResInstLoad, '' );
  gTCustomImageList.AddMethod( 'Replace', TCustomImageList_Replace, '' );
  gTCustomImageList.AddMethod( 'ReplaceIcon', TCustomImageList_ReplaceIcon, '' );
  gTCustomImageList.AddMethod( 'ReplaceMasked', TCustomImageList_ReplaceMasked, '' );
  gTCustomImageList.AddMethod( 'SetDragImage', TCustomImageList_SetDragImage, '' );
  gTCustomImageList.AddMethod( 'ShowDragImage', TCustomImageList_ShowDragImage, '' );
  gTCustomImageList.AddMethod( 'UnRegisterChanges', TCustomImageList_UnRegisterChanges, '' );
  // class TImageList
  AddMethod( 'CreateImageList', TImageList_Create, '' );
  AddMethod( 'CreateSizeImageList', TImageList_CreateSize, '' );
  AddMethod( 'ImageList_GetAttr', TImageList_GetAttr, '' );
  AddMethod( 'ImageList_SetAttr', TImageList_SetAttr, '' );
  inherited;
end;

end.
